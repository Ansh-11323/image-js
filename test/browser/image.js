(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.IJS = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
"use strict";

module.exports = function _atob(str) {
  return atob(str);
};

},{}],2:[function(require,module,exports){
"use strict";

},{}],3:[function(require,module,exports){
'use strict';

var hasOwn = Object.prototype.hasOwnProperty;
var toStr = Object.prototype.toString;

var isArray = function isArray(arr) {
	if (typeof Array.isArray === 'function') {
		return Array.isArray(arr);
	}

	return toStr.call(arr) === '[object Array]';
};

var isPlainObject = function isPlainObject(obj) {
	if (!obj || toStr.call(obj) !== '[object Object]') {
		return false;
	}

	var hasOwnConstructor = hasOwn.call(obj, 'constructor');
	var hasIsPrototypeOf = obj.constructor && obj.constructor.prototype && hasOwn.call(obj.constructor.prototype, 'isPrototypeOf');
	// Not own constructor property must be Object
	if (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {
		return false;
	}

	// Own properties are enumerated firstly, so to speed up,
	// if last one is own, then all properties are own.
	var key;
	for (key in obj) {/**/}

	return typeof key === 'undefined' || hasOwn.call(obj, key);
};

module.exports = function extend() {
	var options,
	    name,
	    src,
	    copy,
	    copyIsArray,
	    clone,
	    target = arguments[0],
	    i = 1,
	    length = arguments.length,
	    deep = false;

	// Handle a deep copy situation
	if (typeof target === 'boolean') {
		deep = target;
		target = arguments[1] || {};
		// skip the boolean and the target
		i = 2;
	} else if (typeof target !== 'object' && typeof target !== 'function' || target == null) {
		target = {};
	}

	for (; i < length; ++i) {
		options = arguments[i];
		// Only deal with non-null/undefined values
		if (options != null) {
			// Extend the base object
			for (name in options) {
				src = target[name];
				copy = options[name];

				// Prevent never-ending loop
				if (target !== copy) {
					// Recurse if we're merging plain objects or arrays
					if (deep && copy && (isPlainObject(copy) || (copyIsArray = isArray(copy)))) {
						if (copyIsArray) {
							copyIsArray = false;
							clone = src && isArray(src) ? src : [];
						} else {
							clone = src && isPlainObject(src) ? src : {};
						}

						// Never move original objects, clone them
						target[name] = extend(deep, clone, copy);

						// Don't bring in undefined values
					} else if (typeof copy !== 'undefined') {
						target[name] = copy;
					}
				}
			}
		}
	}

	// Return the modified object
	return target;
};

},{}],4:[function(require,module,exports){
'use strict';

var IOBuffer = require('iobuffer');
var Inflator = require('pako').Inflate;

var empty = new Uint8Array(0);
var NULL = '\0';
var pngSignature = [137, 80, 78, 71, 13, 10, 26, 10];

class PNGDecoder extends IOBuffer {
    constructor(data) {
        super(data);
        this._decoded = false;
        this._inflator = new Inflator();
        this._png = null;
        this._end = false;
        // PNG is always big endian
        // http://www.w3.org/TR/PNG/#7Integers-and-byte-order
        this.setBigEndian();
    }

    decode() {
        if (this._decoded) return this._png;
        this._png = {
            tEXt: {}
        };
        this.decodeSignature();
        while (!this._end) {
            this.decodeChunk();
        }
        this.decodeImage();
        return this._png;
    }

    // http://www.w3.org/TR/PNG/#5PNG-file-signature
    decodeSignature() {
        for (var i = 0; i < 8; i++) {
            if (this.readUint8() !== pngSignature[i]) {
                throw new Error(`Wrong PNG signature. Byte at ${ i } should be ${ pngSignature[i] }.`);
            }
        }
    }

    // http://www.w3.org/TR/PNG/#5Chunk-layout
    decodeChunk() {
        var length = this.readUint32();
        var type = this.readChars(4);
        var offset = this.offset;
        switch (type) {
            case 'IHDR':
                this.decodeIHDR();
                break;
            case 'PLTE':
                this.decodePLTE(length);
                break;
            case 'IDAT':
                this.decodeIDAT(length);
                break;
            case 'tEXt':
                this.decodetEXt(length);
                break;
            case 'IEND':
                this._end = true;
                break;
            default:
                this.skip(length);
                break;
        }
        if (this.offset - offset !== length) {
            throw new Error('Length mismatch while decoding chunk ' + type);
        }
        // TODO compute and validate CRC ?
        // http://www.w3.org/TR/PNG/#5CRC-algorithm
        var crc = this.readUint32();
    }

    // http://www.w3.org/TR/PNG/#11IHDR
    decodeIHDR() {
        var image = this._png;
        image.width = this.readUint32();
        image.height = this.readUint32();
        image.bitDepth = this.readUint8();
        image.colourType = this.readUint8();
        image.compressionMethod = this.readUint8();
        image.filterMethod = this.readUint8();
        image.interlaceMethod = this.readUint8();
        if (this._png.compressionMethod !== 0) {
            throw new Error('Unsupported compression method: ' + image.compressionMethod);
        }
    }

    // https://www.w3.org/TR/PNG/#11PLTE
    decodePLTE(length) {
        if (length % 3 !== 0) {
            throw new RangeError('PLTE field length must be a multiple of 3. Got ' + length);
        }
        var l = length / 3;
        this._hasPalette = true;
        var palette = this._palette = new Array(l);
        for (var i = 0; i < l; i++) {
            palette[i] = [this.readUint8(), this.readUint8(), this.readUint8()];
        }
    }

    // http://www.w3.org/TR/PNG/#11IDAT
    decodeIDAT(length) {
        this._inflator.push(new Uint8Array(this.buffer, this.offset, length));
        this.skip(length);
    }

    // http://www.w3.org/TR/PNG/#11tEXt
    decodetEXt(length) {
        var keyword = '';
        var char;
        while ((char = this.readChar()) !== NULL) {
            keyword += char;
        }
        this._png.tEXt[keyword] = this.readChars(length - keyword.length - 1);
    }

    decodeImage() {
        this._inflator.push(empty, true);
        if (this._inflator.err) {
            throw new Error('Error while decompressing the data');
        }
        var data = this._inflator.result;
        this._inflator = null;

        if (this._png.filterMethod !== 0) {
            throw new Error('Filter method ' + this._png.filterMethod + ' not supported');
        }

        if (this._png.interlaceMethod === 0) {
            this.decodeInterlaceNull(data);
        } else {
            throw new Error('Interlace method ' + this._png.interlaceMethod + ' not supported');
        }
    }

    decodeInterlaceNull(data) {

        var channels;
        switch (this._png.colourType) {
            case 0:
                channels = 1;break;
            case 2:
                channels = 3;break;
            case 3:
                if (!this._hasPalette) throw new Error('Missing palette');
                channels = 1;
                break;
            case 4:
                channels = 2;break;
            case 6:
                channels = 4;break;
            default:
                throw new Error('Unknown colour type: ' + this._png.colourType);
        }

        var height = this._png.height;
        var bytesPerPixel = channels * this._png.bitDepth / 8;
        var bytesPerLine = this._png.width * bytesPerPixel;
        var newData = new Uint8Array(this._png.height * bytesPerLine);

        var prevLine = empty;
        var offset = 0;
        var currentLine, newLine;

        for (var i = 0; i < height; i++) {
            currentLine = data.subarray(offset + 1, offset + 1 + bytesPerLine);
            newLine = newData.subarray(i * bytesPerLine, (i + 1) * bytesPerLine);
            switch (data[offset]) {
                case 0:
                    unfilterNone(currentLine, newLine, bytesPerLine);
                    break;
                case 1:
                    unfilterSub(currentLine, newLine, bytesPerLine, bytesPerPixel);
                    break;
                case 2:
                    unfilterUp(currentLine, newLine, prevLine, bytesPerLine);
                    break;
                case 3:
                    unfilterAverage(currentLine, newLine, prevLine, bytesPerLine, bytesPerPixel);
                    break;
                case 4:
                    unfilterPaeth(currentLine, newLine, prevLine, bytesPerLine, bytesPerPixel);
                    break;
                default:
                    throw new Error('Unsupported filter: ' + data[offset]);
            }
            prevLine = newLine;
            offset += bytesPerLine + 1;
        }

        if (this._hasPalette) {
            this._png.palette = this._palette;
        }
        this._png.data = newData;
    }

}

module.exports = PNGDecoder;

function unfilterNone(currentLine, newLine, bytesPerLine) {
    for (var i = 0; i < bytesPerLine; i++) {
        newLine[i] = currentLine[i];
    }
}

function unfilterSub(currentLine, newLine, bytesPerLine, bytesPerPixel) {
    var i = 0;
    for (; i < bytesPerPixel; i++) {
        // just copy first bytes
        newLine[i] = currentLine[i];
    }
    for (; i < bytesPerLine; i++) {
        newLine[i] = currentLine[i] + newLine[i - bytesPerPixel] & 0xFF;
    }
}

function unfilterUp(currentLine, newLine, prevLine, bytesPerLine) {
    var i = 0;
    if (prevLine.length === 0) {
        // just copy bytes for first line
        for (; i < bytesPerLine; i++) {
            newLine[i] = currentLine[i];
        }
    } else {
        for (; i < bytesPerLine; i++) {
            newLine[i] = currentLine[i] + prevLine[i] & 0xFF;
        }
    }
}

function unfilterAverage(currentLine, newLine, prevLine, bytesPerLine, bytesPerPixel) {
    var i = 0;
    if (prevLine.length === 0) {
        for (; i < bytesPerPixel; i++) {
            newLine[i] = currentLine[i];
        }
        for (; i < bytesPerLine; i++) {
            newLine[i] = currentLine[i] + (newLine[i - bytesPerPixel] >> 1) & 0xFF;
        }
    } else {
        for (; i < bytesPerPixel; i++) {
            newLine[i] = currentLine[i] + (prevLine[i] >> 1) & 0xFF;
        }
        for (; i < bytesPerLine; i++) {
            newLine[i] = currentLine[i] + (newLine[i - bytesPerPixel] + prevLine[i] >> 1) & 0xFF;
        }
    }
}

function unfilterPaeth(currentLine, newLine, prevLine, bytesPerLine, bytesPerPixel) {
    var i = 0;
    if (prevLine.length === 0) {
        for (; i < bytesPerPixel; i++) {
            newLine[i] = currentLine[i];
        }
        for (; i < bytesPerLine; i++) {
            newLine[i] = currentLine[i] + newLine[i - bytesPerPixel] & 0xFF;
        }
    } else {
        for (; i < bytesPerPixel; i++) {
            newLine[i] = currentLine[i] + prevLine[i] & 0xFF;
        }
        for (; i < bytesPerLine; i++) {
            newLine[i] = currentLine[i] + paethPredictor(newLine[i - bytesPerPixel], prevLine[i], prevLine[i - bytesPerPixel]) & 0xFF;
        }
    }
}

function paethPredictor(a, b, c) {
    var p = a + b - c;
    var pa = Math.abs(p - a);
    var pb = Math.abs(p - b);
    var pc = Math.abs(p - c);
    if (pa <= pb && pa <= pc) return a;else if (pb <= pc) return b;else return c;
}

},{"iobuffer":7,"pako":37}],5:[function(require,module,exports){
'use strict';

exports.PNGDecoder = require('./PNGDecoder');

},{"./PNGDecoder":4}],6:[function(require,module,exports){
'use strict';

if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor;
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor;
    var TempCtor = function TempCtor() {};
    TempCtor.prototype = superCtor.prototype;
    ctor.prototype = new TempCtor();
    ctor.prototype.constructor = ctor;
  };
}

},{}],7:[function(require,module,exports){
'use strict';

var defaultByteLength = 1024 * 8;
var charArray = [];

class IOBuffer {
    constructor(data) {
        var length = 0;
        if (data === undefined) {
            data = defaultByteLength;
        }
        if (typeof data === 'number') {
            length = data;
            data = new ArrayBuffer(data);
        }
        length = data.byteLength;
        if (data.buffer) {
            length = data.byteLength;
            if (data.byteLength !== data.buffer.byteLength) {
                // Node.js buffer from pool
                data = data.buffer.slice(data.byteOffset, data.byteOffset + data.byteLength);
            } else {
                data = data.buffer;
            }
        }
        this.buffer = data;
        this.length = length;
        this.offset = 0;
        this.littleEndian = true;
        this._data = new DataView(this.buffer);
        this._increment = length || defaultByteLength;
        this._mark = 0;
    }

    available(byteLength) {
        if (byteLength === undefined) byteLength = 1;
        return this.offset + byteLength <= this.length;
    }

    isLittleEndian() {
        return this.littleEndian;
    }

    setLittleEndian() {
        this.littleEndian = true;
    }

    isBigEndian() {
        return !this.littleEndian;
    }

    setBigEndian() {
        this.littleEndian = false;
    }

    skip(n) {
        if (n === undefined) n = 1;
        this.offset += n;
    }

    seek(offset) {
        this.offset = offset;
    }

    mark() {
        this._mark = this.offset;
    }

    reset() {
        this.offset = this._mark;
    }

    rewind() {
        this.offset = 0;
    }

    ensureAvailable(byteLength) {
        if (byteLength === undefined) byteLength = 1;
        if (!this.available(byteLength)) {
            var newIncrement = this._increment + this._increment;
            this._increment = newIncrement;
            var newLength = this.length + newIncrement;
            var newArray = new Uint8Array(newLength);
            newArray.set(new Uint8Array(this.buffer));
            this.buffer = newArray.buffer;
            this.length = newLength;
            this._data = new DataView(this.buffer);
        }
    }

    readBoolean() {
        return this.readUint8() !== 0;
    }

    readInt8() {
        return this._data.getInt8(this.offset++);
    }

    readUint8() {
        return this._data.getUint8(this.offset++);
    }

    readByte() {
        return this.readUint8();
    }

    readBytes(n) {
        if (n === undefined) n = 1;
        var bytes = new Uint8Array(n);
        for (var i = 0; i < n; i++) {
            bytes[i] = this.readByte();
        }
        return bytes;
    }

    readInt16() {
        var value = this._data.getInt16(this.offset, this.littleEndian);
        this.offset += 2;
        return value;
    }

    readUint16() {
        var value = this._data.getUint16(this.offset, this.littleEndian);
        this.offset += 2;
        return value;
    }

    readInt32() {
        var value = this._data.getInt32(this.offset, this.littleEndian);
        this.offset += 4;
        return value;
    }

    readUint32() {
        var value = this._data.getUint32(this.offset, this.littleEndian);
        this.offset += 4;
        return value;
    }

    readFloat32() {
        var value = this._data.getFloat32(this.offset, this.littleEndian);
        this.offset += 4;
        return value;
    }

    readFloat64() {
        var value = this._data.getFloat64(this.offset, this.littleEndian);
        this.offset += 8;
        return value;
    }

    readChar() {
        return String.fromCharCode(this.readInt8());
    }

    readChars(n) {
        if (n === undefined) n = 1;
        charArray.length = n;
        for (var i = 0; i < n; i++) {
            charArray[i] = this.readChar();
        }
        return charArray.join('');
    }

    writeBoolean(bool) {
        this.writeUint8(bool ? 0xff : 0x00);
    }

    writeInt8(value) {
        this.ensureAvailable(1);
        this._data.setInt8(this.offset++, value);
    }

    writeUint8(value) {
        this.ensureAvailable(1);
        this._data.setUint8(this.offset++, value);
    }

    writeByte(value) {
        this.writeUint8(value);
    }

    writeBytes(bytes) {
        this.ensureAvailable(bytes.length);
        for (var i = 0; i < bytes.length; i++) {
            this._data.setUint8(this.offset++, bytes[i]);
        }
    }

    writeInt16(value) {
        this.ensureAvailable(2);
        this._data.setInt16(this.offset, value, this.littleEndian);
        this.offset += 2;
    }

    writeUint16(value) {
        this.ensureAvailable(2);
        this._data.setUint16(this.offset, value, this.littleEndian);
        this.offset += 2;
    }

    writeInt32(value) {
        this.ensureAvailable(4);
        this._data.setInt32(this.offset, value, this.littleEndian);
        this.offset += 4;
    }

    writeUint32(value) {
        this.ensureAvailable(4);
        this._data.setUint32(this.offset, value, this.littleEndian);
        this.offset += 4;
    }

    writeFloat32(value) {
        this.ensureAvailable(4);
        this._data.setFloat32(this.offset, value, this.littleEndian);
        this.offset += 4;
    }

    writeFloat64(value) {
        this.ensureAvailable(8);
        this._data.setFloat64(this.offset, value, this.littleEndian);
        this.offset += 8;
    }

    writeChar(str) {
        this.writeUint8(str.charCodeAt(0));
    }

    writeChars(str) {
        for (var i = 0; i < str.length; i++) {
            this.writeUint8(str.charCodeAt(i));
        }
    }

    toArray() {
        return new Uint8Array(this.buffer, 0, this.offset);
    }
}

module.exports = IOBuffer;

},{}],8:[function(require,module,exports){
'use strict';

var toString = Object.prototype.toString;

module.exports = function isArrayType(value) {
    return toString.call(value).substr(-6, 5) === 'Array';
};

},{}],9:[function(require,module,exports){
'use strict';

var numberIsNan = require('number-is-nan');

module.exports = Number.isFinite || function (val) {
	return !(typeof val !== 'number' || numberIsNan(val) || val === Infinity || val === -Infinity);
};

},{"number-is-nan":36}],10:[function(require,module,exports){
"use strict";

// https://github.com/paulmillr/es6-shim
// http://people.mozilla.org/~jorendorff/es6-draft.html#sec-number.isinteger
var isFinite = require("is-finite");
module.exports = Number.isInteger || function (val) {
  return typeof val === "number" && isFinite(val) && Math.floor(val) === val;
};

},{"is-finite":9}],11:[function(require,module,exports){
'use strict';

function squaredEuclidean(p, q) {
    var d = 0;
    for (var i = 0; i < p.length; i++) {
        d += (p[i] - q[i]) * (p[i] - q[i]);
    }
    return d;
}

function euclidean(p, q) {
    return Math.sqrt(squaredEuclidean(p, q));
}

module.exports = euclidean;
euclidean.squared = squaredEuclidean;

},{}],12:[function(require,module,exports){
'use strict';

var squaredEuclidean = require('ml-euclidean-distance').squared;

var defaultOptions = {
    sigma: 1
};

class GaussianKernel {
    constructor(options) {
        options = Object.assign({}, defaultOptions, options);
        this.sigma = options.sigma;
        this.divisor = 2 * options.sigma * options.sigma;
    }

    compute(x, y) {
        var distance = squaredEuclidean(x, y);
        return Math.exp(-distance / this.divisor);
    }
}

module.exports = GaussianKernel;

},{"ml-euclidean-distance":11}],13:[function(require,module,exports){
'use strict';

var Matrix = require('ml-matrix');

var GaussianKernel = require('ml-gaussian-kernel');
var PolynomialKernel = require('ml-polynomial-kernel');
var ANOVAKernel = require('./kernels/anova-kernel');
var CauchyKernel = require('./kernels/cauchy-kernel');
var ExponentialKernel = require('./kernels/exponential-kernel');
var HistogramKernel = require('./kernels/histogram-intersection-kernel');
var LaplacianKernel = require('./kernels/laplacian-kernel');
var MultiquadraticKernel = require('./kernels/multiquadratic-kernel');
var RationalKernel = require('./kernels/rational-quadratic-kernel');

var kernelType = {
    gaussian: GaussianKernel,
    rbf: GaussianKernel,
    polynomial: PolynomialKernel,
    poly: PolynomialKernel,
    anova: ANOVAKernel,
    cauchy: CauchyKernel,
    exponential: ExponentialKernel,
    histogram: HistogramKernel,
    min: HistogramKernel,
    laplacian: LaplacianKernel,
    multiquadratic: MultiquadraticKernel,
    rational: RationalKernel
};

class Kernel {
    constructor(type, options) {
        if (typeof type === 'string') {
            type = type.toLowerCase();

            var KernelConstructor = kernelType[type];
            if (KernelConstructor) {
                this.kernelFunction = new KernelConstructor(options);
            } else {
                throw new Error('unsupported kernel type: ' + type);
            }
        } else if (typeof type === 'object' && typeof type.compute === 'function') {
            this.kernelFunction = type;
        } else {
            throw new TypeError('first argument must be a valid kernel type or instance');
        }
    }

    compute(inputs, landmarks) {
        if (landmarks === undefined) {
            landmarks = inputs;
        }
        var kernelMatrix = new Matrix(inputs.length, landmarks.length);
        var i, j;
        if (inputs === landmarks) {
            // fast path, matrix is symmetric
            for (i = 0; i < inputs.length; i++) {
                for (j = i; j < inputs.length; j++) {
                    kernelMatrix[i][j] = kernelMatrix[j][i] = this.kernelFunction.compute(inputs[i], inputs[j]);
                }
            }
        } else {
            for (i = 0; i < inputs.length; i++) {
                for (j = 0; j < landmarks.length; j++) {
                    kernelMatrix[i][j] = this.kernelFunction.compute(inputs[i], landmarks[j]);
                }
            }
        }
        return kernelMatrix;
    }
}

module.exports = Kernel;

},{"./kernels/anova-kernel":14,"./kernels/cauchy-kernel":15,"./kernels/exponential-kernel":16,"./kernels/histogram-intersection-kernel":17,"./kernels/laplacian-kernel":18,"./kernels/multiquadratic-kernel":19,"./kernels/rational-quadratic-kernel":20,"ml-gaussian-kernel":12,"ml-matrix":28,"ml-polynomial-kernel":30}],14:[function(require,module,exports){
'use strict';

var defaultOptions = {
    sigma: 1,
    degree: 1
};

class ANOVAKernel {
    constructor(options) {
        options = Object.assign({}, defaultOptions, options);
        this.sigma = options.sigma;
        this.degree = options.degree;
    }

    compute(x, y) {
        var sum = 0;
        var len = Math.min(x.length, y.length);
        for (var i = 1; i <= len; ++i) {
            sum += Math.pow(Math.exp(-this.sigma * Math.pow(Math.pow(x[i - 1], i) - Math.pow(y[i - 1], i), 2)), this.degree);
        }
        return sum;
    }
}

module.exports = ANOVAKernel;

},{}],15:[function(require,module,exports){
'use strict';

var squaredEuclidean = require('ml-euclidean-distance').squared;

var defaultOptions = {
    sigma: 1
};

class CauchyKernel {
    constructor(options) {
        options = Object.assign({}, defaultOptions, options);
        this.sigma = options.sigma;
    }

    compute(x, y) {
        return 1 / (1 + squaredEuclidean(x, y) / (this.sigma * this.sigma));
    }
}

module.exports = CauchyKernel;

},{"ml-euclidean-distance":11}],16:[function(require,module,exports){
'use strict';

var euclidean = require('ml-euclidean-distance');

var defaultOptions = {
    sigma: 1
};

class ExponentialKernel {
    constructor(options) {
        options = Object.assign({}, defaultOptions, options);
        this.sigma = options.sigma;
        this.divisor = 2 * options.sigma * options.sigma;
    }

    compute(x, y) {
        var distance = euclidean(x, y);
        return Math.exp(-distance / this.divisor);
    }
}

module.exports = ExponentialKernel;

},{"ml-euclidean-distance":11}],17:[function(require,module,exports){
'use strict';

class HistogramIntersectionKernel {
    compute(x, y) {
        var min = Math.min(x.length, y.length);
        var sum = 0;
        for (var i = 0; i < min; ++i) {
            sum += Math.min(x[i], y[i]);
        }return sum;
    }
}

module.exports = HistogramIntersectionKernel;

},{}],18:[function(require,module,exports){
'use strict';

var euclidean = require('ml-euclidean-distance');

var defaultOptions = {
    sigma: 1
};

class LaplacianKernel {
    constructor(options) {
        options = Object.assign({}, defaultOptions, options);
        this.sigma = options.sigma;
    }

    compute(x, y) {
        var distance = euclidean(x, y);
        return Math.exp(-distance / this.sigma);
    }
}

module.exports = LaplacianKernel;

},{"ml-euclidean-distance":11}],19:[function(require,module,exports){
'use strict';

var squaredEuclidean = require('ml-euclidean-distance').squared;

var defaultOptions = {
    constant: 1
};

class MultiquadraticKernel {
    constructor(options) {
        options = Object.assign({}, defaultOptions, options);
        this.constant = options.constant;
    }

    compute(x, y) {
        return Math.sqrt(squaredEuclidean(x, y) + this.constant * this.constant);
    }
}

module.exports = MultiquadraticKernel;

},{"ml-euclidean-distance":11}],20:[function(require,module,exports){
'use strict';

var squaredEuclidean = require('ml-euclidean-distance').squared;

var defaultOptions = {
    constant: 1
};

class RationalQuadraticKernel {
    constructor(options) {
        options = Object.assign({}, defaultOptions, options);
        this.constant = options.constant;
    }

    compute(x, y) {
        return 1 - squaredEuclidean(x, y) / (squaredEuclidean(x, y) + this.constant);
    }
}

module.exports = RationalQuadraticKernel;

},{"ml-euclidean-distance":11}],21:[function(require,module,exports){
'use strict';

var Matrix = require('../matrix');

// https://github.com/lutzroeder/Mapack/blob/master/Source/CholeskyDecomposition.cs
function CholeskyDecomposition(value) {
    if (!(this instanceof CholeskyDecomposition)) {
        return new CholeskyDecomposition(value);
    }
    value = Matrix.checkMatrix(value);
    if (!value.isSymmetric()) throw new Error('Matrix is not symmetric');

    var a = value,
        dimension = a.rows,
        l = new Matrix(dimension, dimension),
        positiveDefinite = true,
        i,
        j,
        k;

    for (j = 0; j < dimension; j++) {
        var Lrowj = l[j];
        var d = 0;
        for (k = 0; k < j; k++) {
            var Lrowk = l[k];
            var s = 0;
            for (i = 0; i < k; i++) {
                s += Lrowk[i] * Lrowj[i];
            }
            Lrowj[k] = s = (a[j][k] - s) / l[k][k];
            d = d + s * s;
        }

        d = a[j][j] - d;

        positiveDefinite &= d > 0;
        l[j][j] = Math.sqrt(Math.max(d, 0));
        for (k = j + 1; k < dimension; k++) {
            l[j][k] = 0;
        }
    }

    if (!positiveDefinite) {
        throw new Error('Matrix is not positive definite');
    }

    this.L = l;
}

CholeskyDecomposition.prototype = {
    get lowerTriangularMatrix() {
        return this.L;
    },
    solve: function solve(value) {
        value = Matrix.checkMatrix(value);

        var l = this.L,
            dimension = l.rows;

        if (value.rows !== dimension) {
            throw new Error('Matrix dimensions do not match');
        }

        var count = value.columns,
            B = value.clone(),
            i,
            j,
            k;

        for (k = 0; k < dimension; k++) {
            for (j = 0; j < count; j++) {
                for (i = 0; i < k; i++) {
                    B[k][j] -= B[i][j] * l[k][i];
                }
                B[k][j] /= l[k][k];
            }
        }

        for (k = dimension - 1; k >= 0; k--) {
            for (j = 0; j < count; j++) {
                for (i = k + 1; i < dimension; i++) {
                    B[k][j] -= B[i][j] * l[i][k];
                }
                B[k][j] /= l[k][k];
            }
        }

        return B;
    }
};

module.exports = CholeskyDecomposition;

},{"../matrix":29}],22:[function(require,module,exports){
'use strict';

var Matrix = require('../matrix');
var util = require('./util');
var hypotenuse = util.hypotenuse;
var getFilled2DArray = util.getFilled2DArray;

var defaultOptions = {
    assumeSymmetric: false
};

// https://github.com/lutzroeder/Mapack/blob/master/Source/EigenvalueDecomposition.cs
function EigenvalueDecomposition(matrix, options) {
    options = Object.assign({}, defaultOptions, options);
    if (!(this instanceof EigenvalueDecomposition)) {
        return new EigenvalueDecomposition(matrix, options);
    }
    matrix = Matrix.checkMatrix(matrix);
    if (!matrix.isSquare()) {
        throw new Error('Matrix is not a square matrix');
    }

    var n = matrix.columns,
        V = getFilled2DArray(n, n, 0),
        d = new Array(n),
        e = new Array(n),
        value = matrix,
        i,
        j;

    var isSymmetric = false;
    if (options.assumeSymmetric) {
        isSymmetric = true;
    } else {
        isSymmetric = matrix.isSymmetric();
    }

    if (isSymmetric) {
        for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
                V[i][j] = value.get(i, j);
            }
        }
        tred2(n, e, d, V);
        tql2(n, e, d, V);
    } else {
        var H = getFilled2DArray(n, n, 0),
            ort = new Array(n);
        for (j = 0; j < n; j++) {
            for (i = 0; i < n; i++) {
                H[i][j] = value.get(i, j);
            }
        }
        orthes(n, H, ort, V);
        hqr2(n, e, d, V, H);
    }

    this.n = n;
    this.e = e;
    this.d = d;
    this.V = V;
}

EigenvalueDecomposition.prototype = {
    get realEigenvalues() {
        return this.d;
    },
    get imaginaryEigenvalues() {
        return this.e;
    },
    get eigenvectorMatrix() {
        if (!Matrix.isMatrix(this.V)) {
            this.V = new Matrix(this.V);
        }
        return this.V;
    },
    get diagonalMatrix() {
        var n = this.n,
            e = this.e,
            d = this.d,
            X = new Matrix(n, n),
            i,
            j;
        for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
                X[i][j] = 0;
            }
            X[i][i] = d[i];
            if (e[i] > 0) {
                X[i][i + 1] = e[i];
            } else if (e[i] < 0) {
                X[i][i - 1] = e[i];
            }
        }
        return X;
    }
};

function tred2(n, e, d, V) {

    var f, g, h, i, j, k, hh, scale;

    for (j = 0; j < n; j++) {
        d[j] = V[n - 1][j];
    }

    for (i = n - 1; i > 0; i--) {
        scale = 0;
        h = 0;
        for (k = 0; k < i; k++) {
            scale = scale + Math.abs(d[k]);
        }

        if (scale === 0) {
            e[i] = d[i - 1];
            for (j = 0; j < i; j++) {
                d[j] = V[i - 1][j];
                V[i][j] = 0;
                V[j][i] = 0;
            }
        } else {
            for (k = 0; k < i; k++) {
                d[k] /= scale;
                h += d[k] * d[k];
            }

            f = d[i - 1];
            g = Math.sqrt(h);
            if (f > 0) {
                g = -g;
            }

            e[i] = scale * g;
            h = h - f * g;
            d[i - 1] = f - g;
            for (j = 0; j < i; j++) {
                e[j] = 0;
            }

            for (j = 0; j < i; j++) {
                f = d[j];
                V[j][i] = f;
                g = e[j] + V[j][j] * f;
                for (k = j + 1; k <= i - 1; k++) {
                    g += V[k][j] * d[k];
                    e[k] += V[k][j] * f;
                }
                e[j] = g;
            }

            f = 0;
            for (j = 0; j < i; j++) {
                e[j] /= h;
                f += e[j] * d[j];
            }

            hh = f / (h + h);
            for (j = 0; j < i; j++) {
                e[j] -= hh * d[j];
            }

            for (j = 0; j < i; j++) {
                f = d[j];
                g = e[j];
                for (k = j; k <= i - 1; k++) {
                    V[k][j] -= f * e[k] + g * d[k];
                }
                d[j] = V[i - 1][j];
                V[i][j] = 0;
            }
        }
        d[i] = h;
    }

    for (i = 0; i < n - 1; i++) {
        V[n - 1][i] = V[i][i];
        V[i][i] = 1;
        h = d[i + 1];
        if (h !== 0) {
            for (k = 0; k <= i; k++) {
                d[k] = V[k][i + 1] / h;
            }

            for (j = 0; j <= i; j++) {
                g = 0;
                for (k = 0; k <= i; k++) {
                    g += V[k][i + 1] * V[k][j];
                }
                for (k = 0; k <= i; k++) {
                    V[k][j] -= g * d[k];
                }
            }
        }

        for (k = 0; k <= i; k++) {
            V[k][i + 1] = 0;
        }
    }

    for (j = 0; j < n; j++) {
        d[j] = V[n - 1][j];
        V[n - 1][j] = 0;
    }

    V[n - 1][n - 1] = 1;
    e[0] = 0;
}

function tql2(n, e, d, V) {

    var g, h, i, j, k, l, m, p, r, dl1, c, c2, c3, el1, s, s2, iter;

    for (i = 1; i < n; i++) {
        e[i - 1] = e[i];
    }

    e[n - 1] = 0;

    var f = 0,
        tst1 = 0,
        eps = Math.pow(2, -52);

    for (l = 0; l < n; l++) {
        tst1 = Math.max(tst1, Math.abs(d[l]) + Math.abs(e[l]));
        m = l;
        while (m < n) {
            if (Math.abs(e[m]) <= eps * tst1) {
                break;
            }
            m++;
        }

        if (m > l) {
            iter = 0;
            do {
                iter = iter + 1;

                g = d[l];
                p = (d[l + 1] - g) / (2 * e[l]);
                r = hypotenuse(p, 1);
                if (p < 0) {
                    r = -r;
                }

                d[l] = e[l] / (p + r);
                d[l + 1] = e[l] * (p + r);
                dl1 = d[l + 1];
                h = g - d[l];
                for (i = l + 2; i < n; i++) {
                    d[i] -= h;
                }

                f = f + h;

                p = d[m];
                c = 1;
                c2 = c;
                c3 = c;
                el1 = e[l + 1];
                s = 0;
                s2 = 0;
                for (i = m - 1; i >= l; i--) {
                    c3 = c2;
                    c2 = c;
                    s2 = s;
                    g = c * e[i];
                    h = c * p;
                    r = hypotenuse(p, e[i]);
                    e[i + 1] = s * r;
                    s = e[i] / r;
                    c = p / r;
                    p = c * d[i] - s * g;
                    d[i + 1] = h + s * (c * g + s * d[i]);

                    for (k = 0; k < n; k++) {
                        h = V[k][i + 1];
                        V[k][i + 1] = s * V[k][i] + c * h;
                        V[k][i] = c * V[k][i] - s * h;
                    }
                }

                p = -s * s2 * c3 * el1 * e[l] / dl1;
                e[l] = s * p;
                d[l] = c * p;
            } while (Math.abs(e[l]) > eps * tst1);
        }
        d[l] = d[l] + f;
        e[l] = 0;
    }

    for (i = 0; i < n - 1; i++) {
        k = i;
        p = d[i];
        for (j = i + 1; j < n; j++) {
            if (d[j] < p) {
                k = j;
                p = d[j];
            }
        }

        if (k !== i) {
            d[k] = d[i];
            d[i] = p;
            for (j = 0; j < n; j++) {
                p = V[j][i];
                V[j][i] = V[j][k];
                V[j][k] = p;
            }
        }
    }
}

function orthes(n, H, ort, V) {

    var low = 0,
        high = n - 1,
        f,
        g,
        h,
        i,
        j,
        m,
        scale;

    for (m = low + 1; m <= high - 1; m++) {
        scale = 0;
        for (i = m; i <= high; i++) {
            scale = scale + Math.abs(H[i][m - 1]);
        }

        if (scale !== 0) {
            h = 0;
            for (i = high; i >= m; i--) {
                ort[i] = H[i][m - 1] / scale;
                h += ort[i] * ort[i];
            }

            g = Math.sqrt(h);
            if (ort[m] > 0) {
                g = -g;
            }

            h = h - ort[m] * g;
            ort[m] = ort[m] - g;

            for (j = m; j < n; j++) {
                f = 0;
                for (i = high; i >= m; i--) {
                    f += ort[i] * H[i][j];
                }

                f = f / h;
                for (i = m; i <= high; i++) {
                    H[i][j] -= f * ort[i];
                }
            }

            for (i = 0; i <= high; i++) {
                f = 0;
                for (j = high; j >= m; j--) {
                    f += ort[j] * H[i][j];
                }

                f = f / h;
                for (j = m; j <= high; j++) {
                    H[i][j] -= f * ort[j];
                }
            }

            ort[m] = scale * ort[m];
            H[m][m - 1] = scale * g;
        }
    }

    for (i = 0; i < n; i++) {
        for (j = 0; j < n; j++) {
            V[i][j] = i === j ? 1 : 0;
        }
    }

    for (m = high - 1; m >= low + 1; m--) {
        if (H[m][m - 1] !== 0) {
            for (i = m + 1; i <= high; i++) {
                ort[i] = H[i][m - 1];
            }

            for (j = m; j <= high; j++) {
                g = 0;
                for (i = m; i <= high; i++) {
                    g += ort[i] * V[i][j];
                }

                g = g / ort[m] / H[m][m - 1];
                for (i = m; i <= high; i++) {
                    V[i][j] += g * ort[i];
                }
            }
        }
    }
}

function hqr2(nn, e, d, V, H) {
    var n = nn - 1,
        low = 0,
        high = nn - 1,
        eps = Math.pow(2, -52),
        exshift = 0,
        norm = 0,
        p = 0,
        q = 0,
        r = 0,
        s = 0,
        z = 0,
        iter = 0,
        i,
        j,
        k,
        l,
        m,
        t,
        w,
        x,
        y,
        ra,
        sa,
        vr,
        vi,
        notlast,
        cdivres;

    for (i = 0; i < nn; i++) {
        if (i < low || i > high) {
            d[i] = H[i][i];
            e[i] = 0;
        }

        for (j = Math.max(i - 1, 0); j < nn; j++) {
            norm = norm + Math.abs(H[i][j]);
        }
    }

    while (n >= low) {
        l = n;
        while (l > low) {
            s = Math.abs(H[l - 1][l - 1]) + Math.abs(H[l][l]);
            if (s === 0) {
                s = norm;
            }
            if (Math.abs(H[l][l - 1]) < eps * s) {
                break;
            }
            l--;
        }

        if (l === n) {
            H[n][n] = H[n][n] + exshift;
            d[n] = H[n][n];
            e[n] = 0;
            n--;
            iter = 0;
        } else if (l === n - 1) {
            w = H[n][n - 1] * H[n - 1][n];
            p = (H[n - 1][n - 1] - H[n][n]) / 2;
            q = p * p + w;
            z = Math.sqrt(Math.abs(q));
            H[n][n] = H[n][n] + exshift;
            H[n - 1][n - 1] = H[n - 1][n - 1] + exshift;
            x = H[n][n];

            if (q >= 0) {
                z = p >= 0 ? p + z : p - z;
                d[n - 1] = x + z;
                d[n] = d[n - 1];
                if (z !== 0) {
                    d[n] = x - w / z;
                }
                e[n - 1] = 0;
                e[n] = 0;
                x = H[n][n - 1];
                s = Math.abs(x) + Math.abs(z);
                p = x / s;
                q = z / s;
                r = Math.sqrt(p * p + q * q);
                p = p / r;
                q = q / r;

                for (j = n - 1; j < nn; j++) {
                    z = H[n - 1][j];
                    H[n - 1][j] = q * z + p * H[n][j];
                    H[n][j] = q * H[n][j] - p * z;
                }

                for (i = 0; i <= n; i++) {
                    z = H[i][n - 1];
                    H[i][n - 1] = q * z + p * H[i][n];
                    H[i][n] = q * H[i][n] - p * z;
                }

                for (i = low; i <= high; i++) {
                    z = V[i][n - 1];
                    V[i][n - 1] = q * z + p * V[i][n];
                    V[i][n] = q * V[i][n] - p * z;
                }
            } else {
                d[n - 1] = x + p;
                d[n] = x + p;
                e[n - 1] = z;
                e[n] = -z;
            }

            n = n - 2;
            iter = 0;
        } else {
            x = H[n][n];
            y = 0;
            w = 0;
            if (l < n) {
                y = H[n - 1][n - 1];
                w = H[n][n - 1] * H[n - 1][n];
            }

            if (iter === 10) {
                exshift += x;
                for (i = low; i <= n; i++) {
                    H[i][i] -= x;
                }
                s = Math.abs(H[n][n - 1]) + Math.abs(H[n - 1][n - 2]);
                x = y = 0.75 * s;
                w = -0.4375 * s * s;
            }

            if (iter === 30) {
                s = (y - x) / 2;
                s = s * s + w;
                if (s > 0) {
                    s = Math.sqrt(s);
                    if (y < x) {
                        s = -s;
                    }
                    s = x - w / ((y - x) / 2 + s);
                    for (i = low; i <= n; i++) {
                        H[i][i] -= s;
                    }
                    exshift += s;
                    x = y = w = 0.964;
                }
            }

            iter = iter + 1;

            m = n - 2;
            while (m >= l) {
                z = H[m][m];
                r = x - z;
                s = y - z;
                p = (r * s - w) / H[m + 1][m] + H[m][m + 1];
                q = H[m + 1][m + 1] - z - r - s;
                r = H[m + 2][m + 1];
                s = Math.abs(p) + Math.abs(q) + Math.abs(r);
                p = p / s;
                q = q / s;
                r = r / s;
                if (m === l) {
                    break;
                }
                if (Math.abs(H[m][m - 1]) * (Math.abs(q) + Math.abs(r)) < eps * (Math.abs(p) * (Math.abs(H[m - 1][m - 1]) + Math.abs(z) + Math.abs(H[m + 1][m + 1])))) {
                    break;
                }
                m--;
            }

            for (i = m + 2; i <= n; i++) {
                H[i][i - 2] = 0;
                if (i > m + 2) {
                    H[i][i - 3] = 0;
                }
            }

            for (k = m; k <= n - 1; k++) {
                notlast = k !== n - 1;
                if (k !== m) {
                    p = H[k][k - 1];
                    q = H[k + 1][k - 1];
                    r = notlast ? H[k + 2][k - 1] : 0;
                    x = Math.abs(p) + Math.abs(q) + Math.abs(r);
                    if (x !== 0) {
                        p = p / x;
                        q = q / x;
                        r = r / x;
                    }
                }

                if (x === 0) {
                    break;
                }

                s = Math.sqrt(p * p + q * q + r * r);
                if (p < 0) {
                    s = -s;
                }

                if (s !== 0) {
                    if (k !== m) {
                        H[k][k - 1] = -s * x;
                    } else if (l !== m) {
                        H[k][k - 1] = -H[k][k - 1];
                    }

                    p = p + s;
                    x = p / s;
                    y = q / s;
                    z = r / s;
                    q = q / p;
                    r = r / p;

                    for (j = k; j < nn; j++) {
                        p = H[k][j] + q * H[k + 1][j];
                        if (notlast) {
                            p = p + r * H[k + 2][j];
                            H[k + 2][j] = H[k + 2][j] - p * z;
                        }

                        H[k][j] = H[k][j] - p * x;
                        H[k + 1][j] = H[k + 1][j] - p * y;
                    }

                    for (i = 0; i <= Math.min(n, k + 3); i++) {
                        p = x * H[i][k] + y * H[i][k + 1];
                        if (notlast) {
                            p = p + z * H[i][k + 2];
                            H[i][k + 2] = H[i][k + 2] - p * r;
                        }

                        H[i][k] = H[i][k] - p;
                        H[i][k + 1] = H[i][k + 1] - p * q;
                    }

                    for (i = low; i <= high; i++) {
                        p = x * V[i][k] + y * V[i][k + 1];
                        if (notlast) {
                            p = p + z * V[i][k + 2];
                            V[i][k + 2] = V[i][k + 2] - p * r;
                        }

                        V[i][k] = V[i][k] - p;
                        V[i][k + 1] = V[i][k + 1] - p * q;
                    }
                }
            }
        }
    }

    if (norm === 0) {
        return;
    }

    for (n = nn - 1; n >= 0; n--) {
        p = d[n];
        q = e[n];

        if (q === 0) {
            l = n;
            H[n][n] = 1;
            for (i = n - 1; i >= 0; i--) {
                w = H[i][i] - p;
                r = 0;
                for (j = l; j <= n; j++) {
                    r = r + H[i][j] * H[j][n];
                }

                if (e[i] < 0) {
                    z = w;
                    s = r;
                } else {
                    l = i;
                    if (e[i] === 0) {
                        H[i][n] = w !== 0 ? -r / w : -r / (eps * norm);
                    } else {
                        x = H[i][i + 1];
                        y = H[i + 1][i];
                        q = (d[i] - p) * (d[i] - p) + e[i] * e[i];
                        t = (x * s - z * r) / q;
                        H[i][n] = t;
                        H[i + 1][n] = Math.abs(x) > Math.abs(z) ? (-r - w * t) / x : (-s - y * t) / z;
                    }

                    t = Math.abs(H[i][n]);
                    if (eps * t * t > 1) {
                        for (j = i; j <= n; j++) {
                            H[j][n] = H[j][n] / t;
                        }
                    }
                }
            }
        } else if (q < 0) {
            l = n - 1;

            if (Math.abs(H[n][n - 1]) > Math.abs(H[n - 1][n])) {
                H[n - 1][n - 1] = q / H[n][n - 1];
                H[n - 1][n] = -(H[n][n] - p) / H[n][n - 1];
            } else {
                cdivres = cdiv(0, -H[n - 1][n], H[n - 1][n - 1] - p, q);
                H[n - 1][n - 1] = cdivres[0];
                H[n - 1][n] = cdivres[1];
            }

            H[n][n - 1] = 0;
            H[n][n] = 1;
            for (i = n - 2; i >= 0; i--) {
                ra = 0;
                sa = 0;
                for (j = l; j <= n; j++) {
                    ra = ra + H[i][j] * H[j][n - 1];
                    sa = sa + H[i][j] * H[j][n];
                }

                w = H[i][i] - p;

                if (e[i] < 0) {
                    z = w;
                    r = ra;
                    s = sa;
                } else {
                    l = i;
                    if (e[i] === 0) {
                        cdivres = cdiv(-ra, -sa, w, q);
                        H[i][n - 1] = cdivres[0];
                        H[i][n] = cdivres[1];
                    } else {
                        x = H[i][i + 1];
                        y = H[i + 1][i];
                        vr = (d[i] - p) * (d[i] - p) + e[i] * e[i] - q * q;
                        vi = (d[i] - p) * 2 * q;
                        if (vr === 0 && vi === 0) {
                            vr = eps * norm * (Math.abs(w) + Math.abs(q) + Math.abs(x) + Math.abs(y) + Math.abs(z));
                        }
                        cdivres = cdiv(x * r - z * ra + q * sa, x * s - z * sa - q * ra, vr, vi);
                        H[i][n - 1] = cdivres[0];
                        H[i][n] = cdivres[1];
                        if (Math.abs(x) > Math.abs(z) + Math.abs(q)) {
                            H[i + 1][n - 1] = (-ra - w * H[i][n - 1] + q * H[i][n]) / x;
                            H[i + 1][n] = (-sa - w * H[i][n] - q * H[i][n - 1]) / x;
                        } else {
                            cdivres = cdiv(-r - y * H[i][n - 1], -s - y * H[i][n], z, q);
                            H[i + 1][n - 1] = cdivres[0];
                            H[i + 1][n] = cdivres[1];
                        }
                    }

                    t = Math.max(Math.abs(H[i][n - 1]), Math.abs(H[i][n]));
                    if (eps * t * t > 1) {
                        for (j = i; j <= n; j++) {
                            H[j][n - 1] = H[j][n - 1] / t;
                            H[j][n] = H[j][n] / t;
                        }
                    }
                }
            }
        }
    }

    for (i = 0; i < nn; i++) {
        if (i < low || i > high) {
            for (j = i; j < nn; j++) {
                V[i][j] = H[i][j];
            }
        }
    }

    for (j = nn - 1; j >= low; j--) {
        for (i = low; i <= high; i++) {
            z = 0;
            for (k = low; k <= Math.min(j, high); k++) {
                z = z + V[i][k] * H[k][j];
            }
            V[i][j] = z;
        }
    }
}

function cdiv(xr, xi, yr, yi) {
    var r, d;
    if (Math.abs(yr) > Math.abs(yi)) {
        r = yi / yr;
        d = yr + r * yi;
        return [(xr + r * xi) / d, (xi - r * xr) / d];
    } else {
        r = yr / yi;
        d = yi + r * yr;
        return [(r * xr + xi) / d, (r * xi - xr) / d];
    }
}

module.exports = EigenvalueDecomposition;

},{"../matrix":29,"./util":26}],23:[function(require,module,exports){
'use strict';

var Matrix = require('../matrix');

// https://github.com/lutzroeder/Mapack/blob/master/Source/LuDecomposition.cs
function LuDecomposition(matrix) {
    if (!(this instanceof LuDecomposition)) {
        return new LuDecomposition(matrix);
    }
    matrix = Matrix.checkMatrix(matrix);

    var lu = matrix.clone(),
        rows = lu.rows,
        columns = lu.columns,
        pivotVector = new Array(rows),
        pivotSign = 1,
        i,
        j,
        k,
        p,
        s,
        t,
        v,
        LUrowi,
        LUcolj,
        kmax;

    for (i = 0; i < rows; i++) {
        pivotVector[i] = i;
    }

    LUcolj = new Array(rows);

    for (j = 0; j < columns; j++) {

        for (i = 0; i < rows; i++) {
            LUcolj[i] = lu[i][j];
        }

        for (i = 0; i < rows; i++) {
            LUrowi = lu[i];
            kmax = Math.min(i, j);
            s = 0;
            for (k = 0; k < kmax; k++) {
                s += LUrowi[k] * LUcolj[k];
            }
            LUrowi[j] = LUcolj[i] -= s;
        }

        p = j;
        for (i = j + 1; i < rows; i++) {
            if (Math.abs(LUcolj[i]) > Math.abs(LUcolj[p])) {
                p = i;
            }
        }

        if (p !== j) {
            for (k = 0; k < columns; k++) {
                t = lu[p][k];
                lu[p][k] = lu[j][k];
                lu[j][k] = t;
            }

            v = pivotVector[p];
            pivotVector[p] = pivotVector[j];
            pivotVector[j] = v;

            pivotSign = -pivotSign;
        }

        if (j < rows && lu[j][j] !== 0) {
            for (i = j + 1; i < rows; i++) {
                lu[i][j] /= lu[j][j];
            }
        }
    }

    this.LU = lu;
    this.pivotVector = pivotVector;
    this.pivotSign = pivotSign;
}

LuDecomposition.prototype = {
    isSingular: function isSingular() {
        var data = this.LU,
            col = data.columns;
        for (var j = 0; j < col; j++) {
            if (data[j][j] === 0) {
                return true;
            }
        }
        return false;
    },
    get determinant() {
        var data = this.LU;
        if (!data.isSquare()) throw new Error('Matrix must be square');
        var determinant = this.pivotSign,
            col = data.columns;
        for (var j = 0; j < col; j++) {
            determinant *= data[j][j];
        }return determinant;
    },
    get lowerTriangularMatrix() {
        var data = this.LU,
            rows = data.rows,
            columns = data.columns,
            X = new Matrix(rows, columns);
        for (var i = 0; i < rows; i++) {
            for (var j = 0; j < columns; j++) {
                if (i > j) {
                    X[i][j] = data[i][j];
                } else if (i === j) {
                    X[i][j] = 1;
                } else {
                    X[i][j] = 0;
                }
            }
        }
        return X;
    },
    get upperTriangularMatrix() {
        var data = this.LU,
            rows = data.rows,
            columns = data.columns,
            X = new Matrix(rows, columns);
        for (var i = 0; i < rows; i++) {
            for (var j = 0; j < columns; j++) {
                if (i <= j) {
                    X[i][j] = data[i][j];
                } else {
                    X[i][j] = 0;
                }
            }
        }
        return X;
    },
    get pivotPermutationVector() {
        return this.pivotVector.slice();
    },
    solve: function solve(value) {
        value = Matrix.checkMatrix(value);

        var lu = this.LU,
            rows = lu.rows;

        if (rows !== value.rows) throw new Error('Invalid matrix dimensions');
        if (this.isSingular()) throw new Error('LU matrix is singular');

        var count = value.columns,
            X = value.subMatrixRow(this.pivotVector, 0, count - 1),
            columns = lu.columns,
            i,
            j,
            k;

        for (k = 0; k < columns; k++) {
            for (i = k + 1; i < columns; i++) {
                for (j = 0; j < count; j++) {
                    X[i][j] -= X[k][j] * lu[i][k];
                }
            }
        }
        for (k = columns - 1; k >= 0; k--) {
            for (j = 0; j < count; j++) {
                X[k][j] /= lu[k][k];
            }
            for (i = 0; i < k; i++) {
                for (j = 0; j < count; j++) {
                    X[i][j] -= X[k][j] * lu[i][k];
                }
            }
        }
        return X;
    }
};

module.exports = LuDecomposition;

},{"../matrix":29}],24:[function(require,module,exports){
'use strict';

var Matrix = require('../matrix');
var hypotenuse = require('./util').hypotenuse;

//https://github.com/lutzroeder/Mapack/blob/master/Source/QrDecomposition.cs
function QrDecomposition(value) {
    if (!(this instanceof QrDecomposition)) {
        return new QrDecomposition(value);
    }
    value = Matrix.checkMatrix(value);

    var qr = value.clone(),
        m = value.rows,
        n = value.columns,
        rdiag = new Array(n),
        i,
        j,
        k,
        s;

    for (k = 0; k < n; k++) {
        var nrm = 0;
        for (i = k; i < m; i++) {
            nrm = hypotenuse(nrm, qr[i][k]);
        }
        if (nrm !== 0) {
            if (qr[k][k] < 0) {
                nrm = -nrm;
            }
            for (i = k; i < m; i++) {
                qr[i][k] /= nrm;
            }
            qr[k][k] += 1;
            for (j = k + 1; j < n; j++) {
                s = 0;
                for (i = k; i < m; i++) {
                    s += qr[i][k] * qr[i][j];
                }
                s = -s / qr[k][k];
                for (i = k; i < m; i++) {
                    qr[i][j] += s * qr[i][k];
                }
            }
        }
        rdiag[k] = -nrm;
    }

    this.QR = qr;
    this.Rdiag = rdiag;
}

QrDecomposition.prototype = {
    solve: function solve(value) {
        value = Matrix.checkMatrix(value);

        var qr = this.QR,
            m = qr.rows;

        if (value.rows !== m) throw new Error('Matrix row dimensions must agree');
        if (!this.isFullRank()) throw new Error('Matrix is rank deficient');

        var count = value.columns,
            X = value.clone(),
            n = qr.columns,
            i,
            j,
            k,
            s;

        for (k = 0; k < n; k++) {
            for (j = 0; j < count; j++) {
                s = 0;
                for (i = k; i < m; i++) {
                    s += qr[i][k] * X[i][j];
                }
                s = -s / qr[k][k];
                for (i = k; i < m; i++) {
                    X[i][j] += s * qr[i][k];
                }
            }
        }
        for (k = n - 1; k >= 0; k--) {
            for (j = 0; j < count; j++) {
                X[k][j] /= this.Rdiag[k];
            }
            for (i = 0; i < k; i++) {
                for (j = 0; j < count; j++) {
                    X[i][j] -= X[k][j] * qr[i][k];
                }
            }
        }

        return X.subMatrix(0, n - 1, 0, count - 1);
    },
    isFullRank: function isFullRank() {
        var columns = this.QR.columns;
        for (var i = 0; i < columns; i++) {
            if (this.Rdiag[i] === 0) {
                return false;
            }
        }
        return true;
    },
    get upperTriangularMatrix() {
        var qr = this.QR,
            n = qr.columns,
            X = new Matrix(n, n),
            i,
            j;
        for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
                if (i < j) {
                    X[i][j] = qr[i][j];
                } else if (i === j) {
                    X[i][j] = this.Rdiag[i];
                } else {
                    X[i][j] = 0;
                }
            }
        }
        return X;
    },
    get orthogonalMatrix() {
        var qr = this.QR,
            rows = qr.rows,
            columns = qr.columns,
            X = new Matrix(rows, columns),
            i,
            j,
            k,
            s;

        for (k = columns - 1; k >= 0; k--) {
            for (i = 0; i < rows; i++) {
                X[i][k] = 0;
            }
            X[k][k] = 1;
            for (j = k; j < columns; j++) {
                if (qr[k][k] !== 0) {
                    s = 0;
                    for (i = k; i < rows; i++) {
                        s += qr[i][k] * X[i][j];
                    }

                    s = -s / qr[k][k];

                    for (i = k; i < rows; i++) {
                        X[i][j] += s * qr[i][k];
                    }
                }
            }
        }
        return X;
    }
};

module.exports = QrDecomposition;

},{"../matrix":29,"./util":26}],25:[function(require,module,exports){
'use strict';

var Matrix = require('../matrix');
var util = require('./util');
var hypotenuse = util.hypotenuse;
var getFilled2DArray = util.getFilled2DArray;

// https://github.com/lutzroeder/Mapack/blob/master/Source/SingularValueDecomposition.cs
function SingularValueDecomposition(value, options) {
    if (!(this instanceof SingularValueDecomposition)) {
        return new SingularValueDecomposition(value, options);
    }
    value = Matrix.checkMatrix(value);

    options = options || {};

    var m = value.rows,
        n = value.columns,
        nu = Math.min(m, n);

    var wantu = true,
        wantv = true;
    if (options.computeLeftSingularVectors === false) wantu = false;
    if (options.computeRightSingularVectors === false) wantv = false;
    var autoTranspose = options.autoTranspose === true;

    var swapped = false;
    var a;
    if (m < n) {
        if (!autoTranspose) {
            a = value.clone();
            console.warn('Computing SVD on a matrix with more columns than rows. Consider enabling autoTranspose');
        } else {
            a = value.transpose();
            m = a.rows;
            n = a.columns;
            swapped = true;
            var aux = wantu;
            wantu = wantv;
            wantv = aux;
        }
    } else {
        a = value.clone();
    }

    var s = new Array(Math.min(m + 1, n)),
        U = getFilled2DArray(m, nu, 0),
        V = getFilled2DArray(n, n, 0),
        e = new Array(n),
        work = new Array(m);

    var nct = Math.min(m - 1, n);
    var nrt = Math.max(0, Math.min(n - 2, m));

    var i, j, k, p, t, ks, f, cs, sn, max, kase, scale, sp, spm1, epm1, sk, ek, b, c, shift, g;

    for (k = 0, max = Math.max(nct, nrt); k < max; k++) {
        if (k < nct) {
            s[k] = 0;
            for (i = k; i < m; i++) {
                s[k] = hypotenuse(s[k], a[i][k]);
            }
            if (s[k] !== 0) {
                if (a[k][k] < 0) {
                    s[k] = -s[k];
                }
                for (i = k; i < m; i++) {
                    a[i][k] /= s[k];
                }
                a[k][k] += 1;
            }
            s[k] = -s[k];
        }

        for (j = k + 1; j < n; j++) {
            if (k < nct && s[k] !== 0) {
                t = 0;
                for (i = k; i < m; i++) {
                    t += a[i][k] * a[i][j];
                }
                t = -t / a[k][k];
                for (i = k; i < m; i++) {
                    a[i][j] += t * a[i][k];
                }
            }
            e[j] = a[k][j];
        }

        if (wantu && k < nct) {
            for (i = k; i < m; i++) {
                U[i][k] = a[i][k];
            }
        }

        if (k < nrt) {
            e[k] = 0;
            for (i = k + 1; i < n; i++) {
                e[k] = hypotenuse(e[k], e[i]);
            }
            if (e[k] !== 0) {
                if (e[k + 1] < 0) e[k] = -e[k];
                for (i = k + 1; i < n; i++) {
                    e[i] /= e[k];
                }
                e[k + 1] += 1;
            }
            e[k] = -e[k];
            if (k + 1 < m && e[k] !== 0) {
                for (i = k + 1; i < m; i++) {
                    work[i] = 0;
                }
                for (j = k + 1; j < n; j++) {
                    for (i = k + 1; i < m; i++) {
                        work[i] += e[j] * a[i][j];
                    }
                }
                for (j = k + 1; j < n; j++) {
                    t = -e[j] / e[k + 1];
                    for (i = k + 1; i < m; i++) {
                        a[i][j] += t * work[i];
                    }
                }
            }
            if (wantv) {
                for (i = k + 1; i < n; i++) {
                    V[i][k] = e[i];
                }
            }
        }
    }

    p = Math.min(n, m + 1);
    if (nct < n) {
        s[nct] = a[nct][nct];
    }
    if (m < p) {
        s[p - 1] = 0;
    }
    if (nrt + 1 < p) {
        e[nrt] = a[nrt][p - 1];
    }
    e[p - 1] = 0;

    if (wantu) {
        for (j = nct; j < nu; j++) {
            for (i = 0; i < m; i++) {
                U[i][j] = 0;
            }
            U[j][j] = 1;
        }
        for (k = nct - 1; k >= 0; k--) {
            if (s[k] !== 0) {
                for (j = k + 1; j < nu; j++) {
                    t = 0;
                    for (i = k; i < m; i++) {
                        t += U[i][k] * U[i][j];
                    }
                    t = -t / U[k][k];
                    for (i = k; i < m; i++) {
                        U[i][j] += t * U[i][k];
                    }
                }
                for (i = k; i < m; i++) {
                    U[i][k] = -U[i][k];
                }
                U[k][k] = 1 + U[k][k];
                for (i = 0; i < k - 1; i++) {
                    U[i][k] = 0;
                }
            } else {
                for (i = 0; i < m; i++) {
                    U[i][k] = 0;
                }
                U[k][k] = 1;
            }
        }
    }

    if (wantv) {
        for (k = n - 1; k >= 0; k--) {
            if (k < nrt && e[k] !== 0) {
                for (j = k + 1; j < n; j++) {
                    t = 0;
                    for (i = k + 1; i < n; i++) {
                        t += V[i][k] * V[i][j];
                    }
                    t = -t / V[k + 1][k];
                    for (i = k + 1; i < n; i++) {
                        V[i][j] += t * V[i][k];
                    }
                }
            }
            for (i = 0; i < n; i++) {
                V[i][k] = 0;
            }
            V[k][k] = 1;
        }
    }

    var pp = p - 1,
        iter = 0,
        eps = Math.pow(2, -52);
    while (p > 0) {
        for (k = p - 2; k >= -1; k--) {
            if (k === -1) {
                break;
            }
            if (Math.abs(e[k]) <= eps * (Math.abs(s[k]) + Math.abs(s[k + 1]))) {
                e[k] = 0;
                break;
            }
        }
        if (k === p - 2) {
            kase = 4;
        } else {
            for (ks = p - 1; ks >= k; ks--) {
                if (ks === k) {
                    break;
                }
                t = (ks !== p ? Math.abs(e[ks]) : 0) + (ks !== k + 1 ? Math.abs(e[ks - 1]) : 0);
                if (Math.abs(s[ks]) <= eps * t) {
                    s[ks] = 0;
                    break;
                }
            }
            if (ks === k) {
                kase = 3;
            } else if (ks === p - 1) {
                kase = 1;
            } else {
                kase = 2;
                k = ks;
            }
        }

        k++;

        switch (kase) {
            case 1:
                {
                    f = e[p - 2];
                    e[p - 2] = 0;
                    for (j = p - 2; j >= k; j--) {
                        t = hypotenuse(s[j], f);
                        cs = s[j] / t;
                        sn = f / t;
                        s[j] = t;
                        if (j !== k) {
                            f = -sn * e[j - 1];
                            e[j - 1] = cs * e[j - 1];
                        }
                        if (wantv) {
                            for (i = 0; i < n; i++) {
                                t = cs * V[i][j] + sn * V[i][p - 1];
                                V[i][p - 1] = -sn * V[i][j] + cs * V[i][p - 1];
                                V[i][j] = t;
                            }
                        }
                    }
                    break;
                }
            case 2:
                {
                    f = e[k - 1];
                    e[k - 1] = 0;
                    for (j = k; j < p; j++) {
                        t = hypotenuse(s[j], f);
                        cs = s[j] / t;
                        sn = f / t;
                        s[j] = t;
                        f = -sn * e[j];
                        e[j] = cs * e[j];
                        if (wantu) {
                            for (i = 0; i < m; i++) {
                                t = cs * U[i][j] + sn * U[i][k - 1];
                                U[i][k - 1] = -sn * U[i][j] + cs * U[i][k - 1];
                                U[i][j] = t;
                            }
                        }
                    }
                    break;
                }
            case 3:
                {
                    scale = Math.max(Math.max(Math.max(Math.max(Math.abs(s[p - 1]), Math.abs(s[p - 2])), Math.abs(e[p - 2])), Math.abs(s[k])), Math.abs(e[k]));
                    sp = s[p - 1] / scale;
                    spm1 = s[p - 2] / scale;
                    epm1 = e[p - 2] / scale;
                    sk = s[k] / scale;
                    ek = e[k] / scale;
                    b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2;
                    c = sp * epm1 * (sp * epm1);
                    shift = 0;
                    if (b !== 0 || c !== 0) {
                        shift = Math.sqrt(b * b + c);
                        if (b < 0) {
                            shift = -shift;
                        }
                        shift = c / (b + shift);
                    }
                    f = (sk + sp) * (sk - sp) + shift;
                    g = sk * ek;
                    for (j = k; j < p - 1; j++) {
                        t = hypotenuse(f, g);
                        cs = f / t;
                        sn = g / t;
                        if (j !== k) {
                            e[j - 1] = t;
                        }
                        f = cs * s[j] + sn * e[j];
                        e[j] = cs * e[j] - sn * s[j];
                        g = sn * s[j + 1];
                        s[j + 1] = cs * s[j + 1];
                        if (wantv) {
                            for (i = 0; i < n; i++) {
                                t = cs * V[i][j] + sn * V[i][j + 1];
                                V[i][j + 1] = -sn * V[i][j] + cs * V[i][j + 1];
                                V[i][j] = t;
                            }
                        }
                        t = hypotenuse(f, g);
                        cs = f / t;
                        sn = g / t;
                        s[j] = t;
                        f = cs * e[j] + sn * s[j + 1];
                        s[j + 1] = -sn * e[j] + cs * s[j + 1];
                        g = sn * e[j + 1];
                        e[j + 1] = cs * e[j + 1];
                        if (wantu && j < m - 1) {
                            for (i = 0; i < m; i++) {
                                t = cs * U[i][j] + sn * U[i][j + 1];
                                U[i][j + 1] = -sn * U[i][j] + cs * U[i][j + 1];
                                U[i][j] = t;
                            }
                        }
                    }
                    e[p - 2] = f;
                    iter = iter + 1;
                    break;
                }
            case 4:
                {
                    if (s[k] <= 0) {
                        s[k] = s[k] < 0 ? -s[k] : 0;
                        if (wantv) {
                            for (i = 0; i <= pp; i++) {
                                V[i][k] = -V[i][k];
                            }
                        }
                    }
                    while (k < pp) {
                        if (s[k] >= s[k + 1]) {
                            break;
                        }
                        t = s[k];
                        s[k] = s[k + 1];
                        s[k + 1] = t;
                        if (wantv && k < n - 1) {
                            for (i = 0; i < n; i++) {
                                t = V[i][k + 1];
                                V[i][k + 1] = V[i][k];
                                V[i][k] = t;
                            }
                        }
                        if (wantu && k < m - 1) {
                            for (i = 0; i < m; i++) {
                                t = U[i][k + 1];
                                U[i][k + 1] = U[i][k];
                                U[i][k] = t;
                            }
                        }
                        k++;
                    }
                    iter = 0;
                    p--;
                    break;
                }
        }
    }

    if (swapped) {
        var tmp = V;
        V = U;
        U = tmp;
    }

    this.m = m;
    this.n = n;
    this.s = s;
    this.U = U;
    this.V = V;
}

SingularValueDecomposition.prototype = {
    get condition() {
        return this.s[0] / this.s[Math.min(this.m, this.n) - 1];
    },
    get norm2() {
        return this.s[0];
    },
    get rank() {
        var eps = Math.pow(2, -52),
            tol = Math.max(this.m, this.n) * this.s[0] * eps,
            r = 0,
            s = this.s;
        for (var i = 0, ii = s.length; i < ii; i++) {
            if (s[i] > tol) {
                r++;
            }
        }
        return r;
    },
    get diagonal() {
        return this.s;
    },
    // https://github.com/accord-net/framework/blob/development/Sources/Accord.Math/Decompositions/SingularValueDecomposition.cs
    get threshold() {
        return Math.pow(2, -52) / 2 * Math.max(this.m, this.n) * this.s[0];
    },
    get leftSingularVectors() {
        if (!Matrix.isMatrix(this.U)) {
            this.U = new Matrix(this.U);
        }
        return this.U;
    },
    get rightSingularVectors() {
        if (!Matrix.isMatrix(this.V)) {
            this.V = new Matrix(this.V);
        }
        return this.V;
    },
    get diagonalMatrix() {
        return Matrix.diag(this.s);
    },
    solve: function solve(value) {

        var Y = value,
            e = this.threshold,
            scols = this.s.length,
            Ls = Matrix.zeros(scols, scols),
            i;

        for (i = 0; i < scols; i++) {
            if (Math.abs(this.s[i]) <= e) {
                Ls[i][i] = 0;
            } else {
                Ls[i][i] = 1 / this.s[i];
            }
        }

        var U = this.U;
        var V = this.rightSingularVectors;

        var VL = V.mmul(Ls),
            vrows = V.rows,
            urows = U.length,
            VLU = Matrix.zeros(vrows, urows),
            j,
            k,
            sum;

        for (i = 0; i < vrows; i++) {
            for (j = 0; j < urows; j++) {
                sum = 0;
                for (k = 0; k < scols; k++) {
                    sum += VL[i][k] * U[j][k];
                }
                VLU[i][j] = sum;
            }
        }

        return VLU.mmul(Y);
    },
    solveForDiagonal: function solveForDiagonal(value) {
        return this.solve(Matrix.diag(value));
    },
    inverse: function inverse() {
        var V = this.V;
        var e = this.threshold,
            vrows = V.length,
            vcols = V[0].length,
            X = new Matrix(vrows, this.s.length),
            i,
            j;

        for (i = 0; i < vrows; i++) {
            for (j = 0; j < vcols; j++) {
                if (Math.abs(this.s[j]) > e) {
                    X[i][j] = V[i][j] / this.s[j];
                } else {
                    X[i][j] = 0;
                }
            }
        }

        var U = this.U;

        var urows = U.length,
            ucols = U[0].length,
            Y = new Matrix(vrows, urows),
            k,
            sum;

        for (i = 0; i < vrows; i++) {
            for (j = 0; j < urows; j++) {
                sum = 0;
                for (k = 0; k < ucols; k++) {
                    sum += X[i][k] * U[j][k];
                }
                Y[i][j] = sum;
            }
        }

        return Y;
    }
};

module.exports = SingularValueDecomposition;

},{"../matrix":29,"./util":26}],26:[function(require,module,exports){
'use strict';

exports.hypotenuse = function hypotenuse(a, b) {
    if (Math.abs(a) > Math.abs(b)) {
        var r = b / a;
        return Math.abs(a) * Math.sqrt(1 + r * r);
    }
    if (b !== 0) {
        var r = a / b;
        return Math.abs(b) * Math.sqrt(1 + r * r);
    }
    return 0;
};

// For use in the decomposition names. With big matrices, access time is
// too long on elements from array subclass
// todo check when it is fixed in v8
// http://jsperf.com/access-and-write-array-subclass
exports.getEmpty2DArray = function (rows, columns) {
    var array = new Array(rows);
    for (var i = 0; i < rows; i++) {
        array[i] = new Array(columns);
    }
    return array;
};

exports.getFilled2DArray = function (rows, columns, value) {
    var array = new Array(rows);
    for (var i = 0; i < rows; i++) {
        array[i] = new Array(columns);
        for (var j = 0; j < columns; j++) {
            array[i][j] = value;
        }
    }
    return array;
};

},{}],27:[function(require,module,exports){
'use strict';

var Matrix = require('./matrix');

var SingularValueDecomposition = require('./dc/svd');
var EigenvalueDecomposition = require('./dc/evd');
var LuDecomposition = require('./dc/lu');
var QrDecomposition = require('./dc/qr');
var CholeskyDecomposition = require('./dc/cholesky');

function inverse(matrix) {
    matrix = Matrix.checkMatrix(matrix);
    return solve(matrix, Matrix.eye(matrix.rows));
}

Matrix.inverse = Matrix.inv = inverse;
Matrix.prototype.inverse = Matrix.prototype.inv = function () {
    return inverse(this);
};

function solve(leftHandSide, rightHandSide) {
    leftHandSide = Matrix.checkMatrix(leftHandSide);
    rightHandSide = Matrix.checkMatrix(rightHandSide);
    return leftHandSide.isSquare() ? new LuDecomposition(leftHandSide).solve(rightHandSide) : new QrDecomposition(leftHandSide).solve(rightHandSide);
}

Matrix.solve = solve;
Matrix.prototype.solve = function (other) {
    return solve(this, other);
};

module.exports = {
    SingularValueDecomposition: SingularValueDecomposition,
    SVD: SingularValueDecomposition,
    EigenvalueDecomposition: EigenvalueDecomposition,
    EVD: EigenvalueDecomposition,
    LuDecomposition: LuDecomposition,
    LU: LuDecomposition,
    QrDecomposition: QrDecomposition,
    QR: QrDecomposition,
    CholeskyDecomposition: CholeskyDecomposition,
    CHO: CholeskyDecomposition,
    inverse: inverse,
    solve: solve
};

},{"./dc/cholesky":21,"./dc/evd":22,"./dc/lu":23,"./dc/qr":24,"./dc/svd":25,"./matrix":29}],28:[function(require,module,exports){
'use strict';

module.exports = require('./matrix');
module.exports.Decompositions = module.exports.DC = require('./decompositions');

},{"./decompositions":27,"./matrix":29}],29:[function(require,module,exports){
'use strict';

/**
 * Real matrix
 */

class Matrix extends Array {
    /**
     * @constructor
     * @param {number|Array|Matrix} nRows - Number of rows of the new matrix,
     * 2D array containing the data or Matrix instance to clone
     * @param {number} [nColumns] - Number of columns of the new matrix
     */
    constructor(nRows, nColumns) {
        if (Matrix.isMatrix(nRows)) {
            return nRows.clone();
        } else if (Number.isInteger(nRows) && nRows > 0) {
            // Create an empty matrix
            super(nRows);
            if (Number.isInteger(nColumns) && nColumns > 0) {
                for (var i = 0; i < nRows; i++) {
                    this[i] = new Array(nColumns);
                }
            } else {
                throw new TypeError('nColumns must be a positive integer');
            }
        } else if (Array.isArray(nRows)) {
            // Copy the values from the 2D array
            var matrix = nRows;
            nRows = matrix.length;
            nColumns = matrix[0].length;
            if (typeof nColumns !== 'number' || nColumns === 0) {
                throw new TypeError('Data must be a 2D array with at least one element');
            }
            super(nRows);
            for (var i = 0; i < nRows; i++) {
                if (matrix[i].length !== nColumns) {
                    throw new RangeError('Inconsistent array dimensions');
                }
                this[i] = [].concat(matrix[i]);
            }
        } else {
            throw new TypeError('First argument must be a positive number or an array');
        }
        this.rows = nRows;
        this.columns = nColumns;
    }

    // Native array methods should return instances of Array, not Matrix
    static get [Symbol.species]() {
        return Array;
    }

    /**
     * Constructs a Matrix with the chosen dimensions from a 1D array
     * @param {number} newRows - Number of rows
     * @param {number} newColumns - Number of columns
     * @param {Array} newData - A 1D array containing data for the matrix
     * @returns {Matrix} - The new matrix
     */
    static from1DArray(newRows, newColumns, newData) {
        var length = newRows * newColumns;
        if (length !== newData.length) {
            throw new RangeError('Data length does not match given dimensions');
        }
        var newMatrix = new Matrix(newRows, newColumns);
        for (var row = 0; row < newRows; row++) {
            for (var column = 0; column < newColumns; column++) {
                newMatrix[row][column] = newData[row * newColumns + column];
            }
        }
        return newMatrix;
    }

    /**
     * Creates a row vector, a matrix with only one row.
     * @param {Array} newData - A 1D array containing data for the vector
     * @returns {Matrix} - The new matrix
     */
    static rowVector(newData) {
        var vector = new Matrix(1, newData.length);
        for (var i = 0; i < newData.length; i++) {
            vector[0][i] = newData[i];
        }
        return vector;
    }

    /**
     * Creates a column vector, a matrix with only one column.
     * @param {Array} newData - A 1D array containing data for the vector
     * @returns {Matrix} - The new matrix
     */
    static columnVector(newData) {
        var vector = new Matrix(newData.length, 1);
        for (var i = 0; i < newData.length; i++) {
            vector[i][0] = newData[i];
        }
        return vector;
    }

    /**
     * Creates an empty matrix with the given dimensions. Values will be undefined. Same as using new Matrix(rows, columns).
     * @param {number} rows - Number of rows
     * @param {number} columns - Number of columns
     * @returns {Matrix} - The new matrix
     */
    static empty(rows, columns) {
        return new Matrix(rows, columns);
    }

    /**
     * Creates a matrix with the given dimensions. Values will be set to zero.
     * @param {number} rows - Number of rows
     * @param {number} columns - Number of columns
     * @returns {Matrix} - The new matrix
     */
    static zeros(rows, columns) {
        return Matrix.empty(rows, columns).fill(0);
    }

    /**
     * Creates a matrix with the given dimensions. Values will be set to one.
     * @param {number} rows - Number of rows
     * @param {number} columns - Number of columns
     * @returns {Matrix} - The new matrix
     */
    static ones(rows, columns) {
        return Matrix.empty(rows, columns).fill(1);
    }

    /**
     * Creates a matrix with the given dimensions. Values will be randomly set.
     * @param {number} rows - Number of rows
     * @param {number} columns - Number of columns
     * @param {function} [rng] - Random number generator (default: Math.random)
     * @returns {Matrix} The new matrix
     */
    static rand(rows, columns, rng) {
        if (rng === undefined) rng = Math.random;
        var matrix = Matrix.empty(rows, columns);
        for (var i = 0; i < rows; i++) {
            for (var j = 0; j < columns; j++) {
                matrix[i][j] = rng();
            }
        }
        return matrix;
    }

    /**
     * Creates an identity matrix with the given dimension. Values of the diagonal will be 1 and others will be 0.
     * @param {number} rows - Number of rows
     * @param {number} [columns] - Number of columns (Default: rows)
     * @returns {Matrix} - The new identity matrix
     */
    static eye(rows, columns) {
        if (columns === undefined) columns = rows;
        var min = Math.min(rows, columns);
        var matrix = Matrix.zeros(rows, columns);
        for (var i = 0; i < min; i++) {
            matrix[i][i] = 1;
        }
        return matrix;
    }

    /**
     * Creates a diagonal matrix based on the given array.
     * @param {Array} data - Array containing the data for the diagonal
     * @param {number} [rows] - Number of rows (Default: data.length)
     * @param {number} [columns] - Number of columns (Default: rows)
     * @returns {Matrix} - The new diagonal matrix
     */
    static diag(data, rows, columns) {
        var l = data.length;
        if (rows === undefined) rows = l;
        if (columns === undefined) columns = rows;
        var min = Math.min(l, rows, columns);
        var matrix = Matrix.zeros(rows, columns);
        for (var i = 0; i < min; i++) {
            matrix[i][i] = data[i];
        }
        return matrix;
    }

    /**
     * Returns a matrix whose elements are the minimum between matrix1 and matrix2
     * @param matrix1
     * @param matrix2
     * @returns {Matrix}
     */
    static min(matrix1, matrix2) {
        var rows = matrix1.length;
        var columns = matrix1[0].length;
        var result = new Matrix(rows, columns);
        for (var i = 0; i < rows; i++) {
            for (var j = 0; j < columns; j++) {
                result[i][j] = Math.min(matrix1[i][j], matrix2[i][j]);
            }
        }
        return result;
    }

    /**
     * Returns a matrix whose elements are the maximum between matrix1 and matrix2
     * @param matrix1
     * @param matrix2
     * @returns {Matrix}
     */
    static max(matrix1, matrix2) {
        var rows = matrix1.length;
        var columns = matrix1[0].length;
        var result = new Matrix(rows, columns);
        for (var i = 0; i < rows; i++) {
            for (var j = 0; j < columns; j++) {
                result[i][j] = Math.max(matrix1[i][j], matrix2[i][j]);
            }
        }
        return result;
    }

    /**
     * Check that the provided value is a Matrix and tries to instantiate one if not
     * @param value - The value to check
     * @returns {Matrix}
     */
    static checkMatrix(value) {
        return Matrix.isMatrix(value) ? value : new Matrix(value);
    }

    /**
     * Returns true if the argument is a Matrix, false otherwise
     * @param value - The value to check
     * @return {boolean}
     */
    static isMatrix(value) {
        return value != null && value.klass === 'Matrix';
    }

    /**
     * @property {number} - The number of elements in the matrix.
     */
    get size() {
        return this.rows * this.columns;
    }

    /**
     * Applies a callback for each element of the matrix. The function is called in the matrix (this) context.
     * @param {function} callback - Function that will be called with two parameters : i (row) and j (column)
     * @returns {Matrix} this
     */
    apply(callback) {
        if (typeof callback !== 'function') {
            throw new TypeError('callback must be a function');
        }
        var ii = this.rows;
        var jj = this.columns;
        for (var i = 0; i < ii; i++) {
            for (var j = 0; j < jj; j++) {
                callback.call(this, i, j);
            }
        }
        return this;
    }

    /**
     * Creates an exact and independent copy of the matrix
     * @returns {Matrix}
     */
    clone() {
        var newMatrix = new Matrix(this.rows, this.columns);
        for (var row = 0; row < this.rows; row++) {
            for (var column = 0; column < this.columns; column++) {
                newMatrix[row][column] = this[row][column];
            }
        }
        return newMatrix;
    }

    /**
     * Returns a new 1D array filled row by row with the matrix values
     * @returns {Array}
     */
    to1DArray() {
        var array = new Array(this.size);
        for (var i = 0; i < this.rows; i++) {
            for (var j = 0; j < this.columns; j++) {
                array[i * this.columns + j] = this[i][j];
            }
        }
        return array;
    }

    /**
     * Returns a 2D array containing a copy of the data
     * @returns {Array}
     */
    to2DArray() {
        var copy = new Array(this.rows);
        for (var i = 0; i < this.rows; i++) {
            copy[i] = [].concat(this[i]);
        }
        return copy;
    }

    /**
     * @returns {boolean} true if the matrix has one row
     */
    isRowVector() {
        return this.rows === 1;
    }

    /**
     * @returns {boolean} true if the matrix has one column
     */
    isColumnVector() {
        return this.columns === 1;
    }

    /**
     * @returns {boolean} true if the matrix has one row or one column
     */
    isVector() {
        return this.rows === 1 || this.columns === 1;
    }

    /**
     * @returns {boolean} true if the matrix has the same number of rows and columns
     */
    isSquare() {
        return this.rows === this.columns;
    }

    /**
     * @returns {boolean} true if the matrix is square and has the same values on both sides of the diagonal
     */
    isSymmetric() {
        if (this.isSquare()) {
            for (var i = 0; i < this.rows; i++) {
                for (var j = 0; j <= i; j++) {
                    if (this[i][j] !== this[j][i]) {
                        return false;
                    }
                }
            }
            return true;
        }
        return false;
    }

    /**
     * Sets a given element of the matrix. mat.set(3,4,1) is equivalent to mat[3][4]=1
     * @param {number} rowIndex - Index of the row
     * @param {number} columnIndex - Index of the column
     * @param {number} value - The new value for the element
     * @returns {Matrix} this
     */
    set(rowIndex, columnIndex, value) {
        this[rowIndex][columnIndex] = value;
        return this;
    }

    /**
     * Returns the given element of the matrix. mat.get(3,4) is equivalent to matrix[3][4]
     * @param {number} rowIndex - Index of the row
     * @param {number} columnIndex - Index of the column
     * @returns {number}
     */
    get(rowIndex, columnIndex) {
        return this[rowIndex][columnIndex];
    }

    /**
     * Fills the matrix with a given value. All elements will be set to this value.
     * @param {number} value - New value
     * @returns {Matrix} this
     */
    fill(value) {
        for (var i = 0; i < this.rows; i++) {
            for (var j = 0; j < this.columns; j++) {
                this[i][j] = value;
            }
        }
        return this;
    }

    /**
     * Negates the matrix. All elements will be multiplied by (-1)
     * @returns {Matrix} this
     */
    neg() {
        return this.mulS(-1);
    }

    /**
     * Returns a new array from the given row index
     * @param {number} index - Row index
     * @returns {Array}
     */
    getRow(index) {
        checkRowIndex(this, index);
        return [].concat(this[index]);
    }

    /**
     * Returns a new row vector from the given row index
     * @param {number} index - Row index
     * @returns {Matrix}
     */
    getRowVector(index) {
        return Matrix.rowVector(this.getRow(index));
    }

    /**
     * Sets a row at the given index
     * @param {number} index - Row index
     * @param {Array|Matrix} array - Array or vector
     * @returns {Matrix} this
     */
    setRow(index, array) {
        checkRowIndex(this, index);
        array = checkRowVector(this, array, true);
        this[index] = array;
        return this;
    }

    /**
     * Removes a row from the given index
     * @param {number} index - Row index
     * @returns {Matrix} this
     */
    removeRow(index) {
        checkRowIndex(this, index);
        if (this.rows === 1) throw new RangeError('A matrix cannot have less than one row');
        this.splice(index, 1);
        this.rows -= 1;
        return this;
    }

    /**
     * Adds a row at the given index
     * @param {number} [index = this.rows] - Row index
     * @param {Array|Matrix} array - Array or vector
     * @returns {Matrix} this
     */
    addRow(index, array) {
        if (array === undefined) {
            array = index;
            index = this.rows;
        }
        checkRowIndex(this, index, true);
        array = checkRowVector(this, array, true);
        this.splice(index, 0, array);
        this.rows += 1;
        return this;
    }

    /**
     * Swaps two rows
     * @param {number} row1 - First row index
     * @param {number} row2 - Second row index
     * @returns {Matrix} this
     */
    swapRows(row1, row2) {
        checkRowIndex(this, row1);
        checkRowIndex(this, row2);
        var temp = this[row1];
        this[row1] = this[row2];
        this[row2] = temp;
        return this;
    }

    /**
     * Returns a new array from the given column index
     * @param {number} index - Column index
     * @returns {Array}
     */
    getColumn(index) {
        checkColumnIndex(this, index);
        var column = new Array(this.rows);
        for (var i = 0; i < this.rows; i++) {
            column[i] = this[i][index];
        }
        return column;
    }

    /**
     * Returns a new column vector from the given column index
     * @param {number} index - Column index
     * @returns {Matrix}
     */
    getColumnVector(index) {
        return Matrix.columnVector(this.getColumn(index));
    }

    /**
     * Sets a column at the given index
     * @param {number} index - Column index
     * @param {Array|Matrix} array - Array or vector
     * @returns {Matrix} this
     */
    setColumn(index, array) {
        checkColumnIndex(this, index);
        array = checkColumnVector(this, array);
        for (var i = 0; i < this.rows; i++) {
            this[i][index] = array[i];
        }
        return this;
    }

    /**
     * Removes a column from the given index
     * @param {number} index - Column index
     * @returns {Matrix} this
     */
    removeColumn(index) {
        checkColumnIndex(this, index);
        if (this.columns === 1) throw new RangeError('A matrix cannot have less than one column');
        for (var i = 0; i < this.rows; i++) {
            this[i].splice(index, 1);
        }
        this.columns -= 1;
        return this;
    }

    /**
     * Adds a column at the given index
     * @param {number} [index = this.columns] - Column index
     * @param {Array|Matrix} array - Array or vector
     * @returns {Matrix} this
     */
    addColumn(index, array) {
        if (typeof array === 'undefined') {
            array = index;
            index = this.columns;
        }
        checkColumnIndex(this, index, true);
        array = checkColumnVector(this, array);
        for (var i = 0; i < this.rows; i++) {
            this[i].splice(index, 0, array[i]);
        }
        this.columns += 1;
        return this;
    }

    /**
     * Swaps two columns
     * @param {number} column1 - First column index
     * @param {number} column2 - Second column index
     * @returns {Matrix} this
     */
    swapColumns(column1, column2) {
        checkColumnIndex(this, column1);
        checkColumnIndex(this, column2);
        var temp, row;
        for (var i = 0; i < this.rows; i++) {
            row = this[i];
            temp = row[column1];
            row[column1] = row[column2];
            row[column2] = temp;
        }
        return this;
    }

    /**
     * Adds the values of a vector to each row
     * @param {Array|Matrix} vector - Array or vector
     * @returns {Matrix} this
     */
    addRowVector(vector) {
        vector = checkRowVector(this, vector);
        for (var i = 0; i < this.rows; i++) {
            for (var j = 0; j < this.columns; j++) {
                this[i][j] += vector[j];
            }
        }
        return this;
    }

    /**
     * Subtracts the values of a vector from each row
     * @param {Array|Matrix} vector - Array or vector
     * @returns {Matrix} this
     */
    subRowVector(vector) {
        vector = checkRowVector(this, vector);
        for (var i = 0; i < this.rows; i++) {
            for (var j = 0; j < this.columns; j++) {
                this[i][j] -= vector[j];
            }
        }
        return this;
    }

    /**
     * Multiplies the values of a vector with each row
     * @param {Array|Matrix} vector - Array or vector
     * @returns {Matrix} this
     */
    mulRowVector(vector) {
        vector = checkRowVector(this, vector);
        for (var i = 0; i < this.rows; i++) {
            for (var j = 0; j < this.columns; j++) {
                this[i][j] *= vector[j];
            }
        }
        return this;
    }

    /**
     * Divides the values of each row by those of a vector
     * @param {Array|Matrix} vector - Array or vector
     * @returns {Matrix} this
     */
    divRowVector(vector) {
        vector = checkRowVector(this, vector);
        for (var i = 0; i < this.rows; i++) {
            for (var j = 0; j < this.columns; j++) {
                this[i][j] /= vector[j];
            }
        }
        return this;
    }

    /**
     * Adds the values of a vector to each column
     * @param {Array|Matrix} vector - Array or vector
     * @returns {Matrix} this
     */
    addColumnVector(vector) {
        vector = checkColumnVector(this, vector);
        for (var i = 0; i < this.rows; i++) {
            for (var j = 0; j < this.columns; j++) {
                this[i][j] += vector[i];
            }
        }
        return this;
    }

    /**
     * Subtracts the values of a vector from each column
     * @param {Array|Matrix} vector - Array or vector
     * @returns {Matrix} this
     */
    subColumnVector(vector) {
        vector = checkColumnVector(this, vector);
        for (var i = 0; i < this.rows; i++) {
            for (var j = 0; j < this.columns; j++) {
                this[i][j] -= vector[i];
            }
        }
        return this;
    }

    /**
     * Multiplies the values of a vector with each column
     * @param {Array|Matrix} vector - Array or vector
     * @returns {Matrix} this
     */
    mulColumnVector(vector) {
        vector = checkColumnVector(this, vector);
        for (var i = 0; i < this.rows; i++) {
            for (var j = 0; j < this.columns; j++) {
                this[i][j] *= vector[i];
            }
        }
        return this;
    }

    /**
     * Divides the values of each column by those of a vector
     * @param {Array|Matrix} vector - Array or vector
     * @returns {Matrix} this
     */
    divColumnVector(vector) {
        vector = checkColumnVector(this, vector);
        for (var i = 0; i < this.rows; i++) {
            for (var j = 0; j < this.columns; j++) {
                this[i][j] /= vector[i];
            }
        }
        return this;
    }

    /**
     * Multiplies the values of a row with a scalar
     * @param {number} index - Row index
     * @param {number} value
     * @returns {Matrix} this
     */
    mulRow(index, value) {
        checkRowIndex(this, index);
        for (var i = 0; i < this.columns; i++) {
            this[index][i] *= value;
        }
        return this;
    }

    /**
     * Multiplies the values of a column with a scalar
     * @param {number} index - Column index
     * @param {number} value
     * @returns {Matrix} this
     */
    mulColumn(index, value) {
        checkColumnIndex(this, index);
        for (var i = 0; i < this.rows; i++) {
            this[i][index] *= value;
        }
    }

    /**
     * Returns the maximum value of the matrix
     * @returns {number}
     */
    max() {
        var v = this[0][0];
        for (var i = 0; i < this.rows; i++) {
            for (var j = 0; j < this.columns; j++) {
                if (this[i][j] > v) {
                    v = this[i][j];
                }
            }
        }
        return v;
    }

    /**
     * Returns the index of the maximum value
     * @returns {Array}
     */
    maxIndex() {
        var v = this[0][0];
        var idx = [0, 0];
        for (var i = 0; i < this.rows; i++) {
            for (var j = 0; j < this.columns; j++) {
                if (this[i][j] > v) {
                    v = this[i][j];
                    idx[0] = i;
                    idx[1] = j;
                }
            }
        }
        return idx;
    }

    /**
     * Returns the minimum value of the matrix
     * @returns {number}
     */
    min() {
        var v = this[0][0];
        for (var i = 0; i < this.rows; i++) {
            for (var j = 0; j < this.columns; j++) {
                if (this[i][j] < v) {
                    v = this[i][j];
                }
            }
        }
        return v;
    }

    /**
     * Returns the index of the minimum value
     * @returns {Array}
     */
    minIndex() {
        var v = this[0][0];
        var idx = [0, 0];
        for (var i = 0; i < this.rows; i++) {
            for (var j = 0; j < this.columns; j++) {
                if (this[i][j] < v) {
                    v = this[i][j];
                    idx[0] = i;
                    idx[1] = j;
                }
            }
        }
        return idx;
    }

    /**
     * Returns the maximum value of one row
     * @param {number} row - Row index
     * @returns {number}
     */
    maxRow(row) {
        checkRowIndex(this, row);
        var v = this[row][0];
        for (var i = 1; i < this.columns; i++) {
            if (this[row][i] > v) {
                v = this[row][i];
            }
        }
        return v;
    }

    /**
     * Returns the index of the maximum value of one row
     * @param {number} row - Row index
     * @returns {Array}
     */
    maxRowIndex(row) {
        checkRowIndex(this, row);
        var v = this[row][0];
        var idx = [row, 0];
        for (var i = 1; i < this.columns; i++) {
            if (this[row][i] > v) {
                v = this[row][i];
                idx[1] = i;
            }
        }
        return idx;
    }

    /**
     * Returns the minimum value of one row
     * @param {number} row - Row index
     * @returns {number}
     */
    minRow(row) {
        checkRowIndex(this, row);
        var v = this[row][0];
        for (var i = 1; i < this.columns; i++) {
            if (this[row][i] < v) {
                v = this[row][i];
            }
        }
        return v;
    }

    /**
     * Returns the index of the maximum value of one row
     * @param {number} row - Row index
     * @returns {Array}
     */
    minRowIndex(row) {
        checkRowIndex(this, row);
        var v = this[row][0];
        var idx = [row, 0];
        for (var i = 1; i < this.columns; i++) {
            if (this[row][i] < v) {
                v = this[row][i];
                idx[1] = i;
            }
        }
        return idx;
    }

    /**
     * Returns the maximum value of one column
     * @param {number} column - Column index
     * @returns {number}
     */
    maxColumn(column) {
        checkColumnIndex(this, column);
        var v = this[0][column];
        for (var i = 1; i < this.rows; i++) {
            if (this[i][column] > v) {
                v = this[i][column];
            }
        }
        return v;
    }

    /**
     * Returns the index of the maximum value of one column
     * @param {number} column - Column index
     * @returns {Array}
     */
    maxColumnIndex(column) {
        checkColumnIndex(this, column);
        var v = this[0][column];
        var idx = [0, column];
        for (var i = 1; i < this.rows; i++) {
            if (this[i][column] > v) {
                v = this[i][column];
                idx[0] = i;
            }
        }
        return idx;
    }

    /**
     * Returns the minimum value of one column
     * @param {number} column - Column index
     * @returns {number}
     */
    minColumn(column) {
        checkColumnIndex(this, column);
        var v = this[0][column];
        for (var i = 1; i < this.rows; i++) {
            if (this[i][column] < v) {
                v = this[i][column];
            }
        }
        return v;
    }

    /**
     * Returns the index of the minimum value of one column
     * @param {number} column - Column index
     * @returns {Array}
     */
    minColumnIndex(column) {
        checkColumnIndex(this, column);
        var v = this[0][column];
        var idx = [0, column];
        for (var i = 1; i < this.rows; i++) {
            if (this[i][column] < v) {
                v = this[i][column];
                idx[0] = i;
            }
        }
        return idx;
    }

    /**
     * Returns an array containing the diagonal values of the matrix
     * @returns {Array}
     */
    diag() {
        var min = Math.min(this.rows, this.columns);
        var diag = new Array(min);
        for (var i = 0; i < min; i++) {
            diag[i] = this[i][i];
        }
        return diag;
    }

    /**
     * Returns the sum of all elements of the matrix
     * @returns {number}
     */
    sum() {
        var v = 0;
        for (var i = 0; i < this.rows; i++) {
            for (var j = 0; j < this.columns; j++) {
                v += this[i][j];
            }
        }
        return v;
    }

    /**
     * Returns the mean of all elements of the matrix
     * @returns {number}
     */
    mean() {
        return this.sum() / this.size;
    }

    /**
     * Returns the product of all elements of the matrix
     * @returns {number}
     */
    prod() {
        var prod = 1;
        for (var i = 0; i < this.rows; i++) {
            for (var j = 0; j < this.columns; j++) {
                prod *= this[i][j];
            }
        }
        return prod;
    }

    /**
     * Computes the cumulative sum of the matrix elements (in place, row by row)
     * @returns {Matrix} this
     */
    cumulativeSum() {
        var sum = 0;
        for (var i = 0; i < this.rows; i++) {
            for (var j = 0; j < this.columns; j++) {
                sum += this[i][j];
                this[i][j] = sum;
            }
        }
        return this;
    }

    /**
     * Computes the dot (scalar) product between the matrix and another
     * @param {Matrix} vector2 vector
     * @returns {number}
     */
    dot(vector2) {
        if (Matrix.isMatrix(vector2)) vector2 = vector2.to1DArray();
        var vector1 = this.to1DArray();
        if (vector1.length !== vector2.length) {
            throw new RangeError('vectors do not have the same size');
        }
        var dot = 0;
        for (var i = 0; i < vector1.length; i++) {
            dot += vector1[i] * vector2[i];
        }
        return dot;
    }

    /**
     * Returns the matrix product between this and other
     * @param {Matrix} other
     * @returns {Matrix}
     */
    mmul(other) {
        other = Matrix.checkMatrix(other);
        if (this.columns !== other.rows) console.warn('Number of columns of left matrix are not equal to number of rows of right matrix.');

        var m = this.rows;
        var n = this.columns;
        var p = other.columns;

        var result = new Matrix(m, p);

        var Bcolj = new Array(n);
        for (var j = 0; j < p; j++) {
            for (var k = 0; k < n; k++) {
                Bcolj[k] = other[k][j];
            }for (var i = 0; i < m; i++) {
                var Arowi = this[i];

                var s = 0;
                for (k = 0; k < n; k++) {
                    s += Arowi[k] * Bcolj[k];
                }result[i][j] = s;
            }
        }
        return result;
    }

    /**
     * Returns the Kronecker product (also known as tensor product) between this and other
     * See https://en.wikipedia.org/wiki/Kronecker_product
     * @param {Matrix} other
     * @return {Matrix}
     */
    kroneckerProduct(other) {
        other = Matrix.checkMatrix(other);

        var m = this.rows;
        var n = this.columns;
        var p = other.rows;
        var q = other.columns;

        var result = new Matrix(m * p, n * q);
        for (var i = 0; i < m; i++) {
            for (var j = 0; j < n; j++) {
                for (var k = 0; k < p; k++) {
                    for (var l = 0; l < q; l++) {
                        result[p * i + k][q * j + l] = this[i][j] * other[k][l];
                    }
                }
            }
        }
        return result;
    }

    /**
     * Transposes the matrix and returns a new one containing the result
     * @returns {Matrix}
     */
    transpose() {
        var result = new Matrix(this.columns, this.rows);
        for (var i = 0; i < this.rows; i++) {
            for (var j = 0; j < this.columns; j++) {
                result[j][i] = this[i][j];
            }
        }
        return result;
    }

    /**
     * Sorts the rows (in place)
     * @param {function} compareFunction - usual Array.prototype.sort comparison function
     * @returns {Matrix} this
     */
    sortRows(compareFunction) {
        if (compareFunction === undefined) compareFunction = compareNumbers;
        for (var i = 0; i < this.rows; i++) {
            this[i].sort(compareFunction);
        }
        return this;
    }

    /**
     * Sorts the columns (in place)
     * @param {function} compareFunction - usual Array.prototype.sort comparison function
     * @returns {Matrix} this
     */
    sortColumns(compareFunction) {
        if (compareFunction === undefined) compareFunction = compareNumbers;
        for (var i = 0; i < this.columns; i++) {
            this.setColumn(i, this.getColumn(i).sort(compareFunction));
        }
        return this;
    }

    /**
     * Returns a subset of the matrix
     * @param {number} startRow - First row index
     * @param {number} endRow - Last row index
     * @param {number} startColumn - First column index
     * @param {number} endColumn - Last column index
     * @returns {Matrix}
     */
    subMatrix(startRow, endRow, startColumn, endColumn) {
        if (startRow > endRow || startColumn > endColumn || startRow < 0 || startRow >= this.rows || endRow < 0 || endRow >= this.rows || startColumn < 0 || startColumn >= this.columns || endColumn < 0 || endColumn >= this.columns) {
            throw new RangeError('Argument out of range');
        }
        var newMatrix = new Matrix(endRow - startRow + 1, endColumn - startColumn + 1);
        for (var i = startRow; i <= endRow; i++) {
            for (var j = startColumn; j <= endColumn; j++) {
                newMatrix[i - startRow][j - startColumn] = this[i][j];
            }
        }
        return newMatrix;
    }

    /**
     * Returns a subset of the matrix based on an array of row indices
     * @param {Array} indices - Array containing the row indices
     * @param {number} [startColumn = 0] - First column index
     * @param {number} [endColumn = this.columns-1] - Last column index
     * @returns {Matrix}
     */
    subMatrixRow(indices, startColumn, endColumn) {
        if (startColumn === undefined) startColumn = 0;
        if (endColumn === undefined) endColumn = this.columns - 1;
        if (startColumn > endColumn || startColumn < 0 || startColumn >= this.columns || endColumn < 0 || endColumn >= this.columns) {
            throw new RangeError('Argument out of range');
        }

        var newMatrix = new Matrix(indices.length, endColumn - startColumn + 1);
        for (var i = 0; i < indices.length; i++) {
            for (var j = startColumn; j <= endColumn; j++) {
                if (indices[i] < 0 || indices[i] >= this.rows) {
                    throw new RangeError('Row index out of range: ' + indices[i]);
                }
                newMatrix[i][j - startColumn] = this[indices[i]][j];
            }
        }
        return newMatrix;
    }

    /**
     * Returns a subset of the matrix based on an array of column indices
     * @param {Array} indices - Array containing the column indices
     * @param {number} [startRow = 0] - First row index
     * @param {number} [endRow = this.rows-1] - Last row index
     * @returns {Matrix}
     */
    subMatrixColumn(indices, startRow, endRow) {
        if (startRow === undefined) startRow = 0;
        if (endRow === undefined) endRow = this.rows - 1;
        if (startRow > endRow || startRow < 0 || startRow >= this.rows || endRow < 0 || endRow >= this.rows) {
            throw new RangeError('Argument out of range');
        }

        var newMatrix = new Matrix(endRow - startRow + 1, indices.length);
        for (var i = 0; i < indices.length; i++) {
            for (var j = startRow; j <= endRow; j++) {
                if (indices[i] < 0 || indices[i] >= this.columns) {
                    throw new RangeError('Column index out of range: ' + indices[i]);
                }
                newMatrix[j - startRow][i] = this[j][indices[i]];
            }
        }
        return newMatrix;
    }

    /**
     * Returns the trace of the matrix (sum of the diagonal elements)
     * @returns {number}
     */
    trace() {
        var min = Math.min(this.rows, this.columns);
        var trace = 0;
        for (var i = 0; i < min; i++) {
            trace += this[i][i];
        }
        return trace;
    }
}

Matrix.prototype.klass = 'Matrix';

module.exports = Matrix;

/**
 * @private
 * Check that a row index is not out of bounds
 * @param {Matrix} matrix
 * @param {number} index
 * @param {boolean} [outer]
 */
function checkRowIndex(matrix, index, outer) {
    var max = outer ? matrix.rows : matrix.rows - 1;
    if (index < 0 || index > max) throw new RangeError('Row index out of range');
}

/**
 * @private
 * Check that the provided vector is an array with the right length
 * @param {Matrix} matrix
 * @param {Array|Matrix} vector
 * @param {boolean} copy
 * @returns {Array}
 * @throws {RangeError}
 */
function checkRowVector(matrix, vector, copy) {
    if (Matrix.isMatrix(vector)) {
        vector = vector.to1DArray();
    } else if (copy) {
        vector = [].concat(vector);
    }
    if (vector.length !== matrix.columns) throw new RangeError('vector size must be the same as the number of columns');
    return vector;
}

/**
 * @private
 * Check that the provided vector is an array with the right length
 * @param {Matrix} matrix
 * @param {Array|Matrix} vector
 * @param {boolean} copy
 * @returns {Array}
 * @throws {RangeError}
 */
function checkColumnVector(matrix, vector, copy) {
    if (Matrix.isMatrix(vector)) {
        vector = vector.to1DArray();
    } else if (copy) {
        vector = [].concat(vector);
    }
    if (vector.length !== matrix.rows) throw new RangeError('vector size must be the same as the number of rows');
    return vector;
}

/**
 * @private
 * Check that a column index is not out of bounds
 * @param {Matrix} matrix
 * @param {number} index
 * @param {boolean} [outer]
 */
function checkColumnIndex(matrix, index, outer) {
    var max = outer ? matrix.columns : matrix.columns - 1;
    if (index < 0 || index > max) throw new RangeError('Column index out of range');
}

/**
 * @private
 * Check that two matrices have the same dimensions
 * @param {Matrix} matrix
 * @param {Matrix} otherMatrix
 */
function checkDimensions(matrix, otherMatrix) {
    if (matrix.rows !== otherMatrix.length || matrix.columns !== otherMatrix[0].length) {
        throw new RangeError('Matrices dimensions must be equal');
    }
}

function compareNumbers(a, b) {
    return a - b;
}

/*
Synonyms
 */

Matrix.random = Matrix.rand;
Matrix.diagonal = Matrix.diag;
Matrix.prototype.diagonal = Matrix.prototype.diag;
Matrix.identity = Matrix.eye;
Matrix.prototype.negate = Matrix.prototype.neg;
Matrix.prototype.tensorProduct = Matrix.prototype.kroneckerProduct;

/*
Add dynamically instance and static methods for mathematical operations
 */

var inplaceOperator = `
(function %name%(value) {
    if (typeof value === 'number') return this.%name%S(value);
    return this.%name%M(value);
})
`;

var inplaceOperatorScalar = `
(function %name%S(value) {
    for (var i = 0; i < this.rows; i++) {
        for (var j = 0; j < this.columns; j++) {
            this[i][j] = this[i][j] %op% value;
        }
    }
    return this;
})
`;

var inplaceOperatorMatrix = `
(function %name%M(matrix) {
    checkDimensions(this, matrix);
    for (var i = 0; i < this.rows; i++) {
        for (var j = 0; j < this.columns; j++) {
            this[i][j] = this[i][j] %op% matrix[i][j];
        }
    }
    return this;
})
`;

var staticOperator = `
(function %name%(matrix, value) {
    var newMatrix = new Matrix(matrix);
    return newMatrix.%name%(value);
})
`;

var inplaceMethod = `
(function %name%() {
    for (var i = 0; i < this.rows; i++) {
        for (var j = 0; j < this.columns; j++) {
            this[i][j] = %method%(this[i][j]);
        }
    }
    return this;
})
`;

var staticMethod = `
(function %name%(matrix) {
    var newMatrix = new Matrix(matrix);
    return newMatrix.%name%();
})
`;

var operators = [
// Arithmetic operators
['+', 'add'], ['-', 'sub', 'subtract'], ['*', 'mul', 'multiply'], ['/', 'div', 'divide'], ['%', 'mod', 'modulus'],
// Bitwise operators
['&', 'and'], ['|', 'or'], ['^', 'xor'], ['<<', 'leftShift'], ['>>', 'signPropagatingRightShift'], ['>>>', 'rightShift', 'zeroFillRightShift']];

for (var operator of operators) {
    for (var i = 1; i < operator.length; i++) {
        Matrix.prototype[operator[i]] = eval(fillTemplateFunction(inplaceOperator, { name: operator[i], op: operator[0] }));
        Matrix.prototype[operator[i] + 'S'] = eval(fillTemplateFunction(inplaceOperatorScalar, { name: operator[i] + 'S', op: operator[0] }));
        Matrix.prototype[operator[i] + 'M'] = eval(fillTemplateFunction(inplaceOperatorMatrix, { name: operator[i] + 'M', op: operator[0] }));

        Matrix[operator[i]] = eval(fillTemplateFunction(staticOperator, { name: operator[i] }));
    }
}

var methods = [['~', 'not']];

['abs', 'acos', 'acosh', 'asin', 'asinh', 'atan', 'atanh', 'cbrt', 'ceil', 'clz32', 'cos', 'cosh', 'exp', 'expm1', 'floor', 'fround', 'log', 'log1p', 'log10', 'log2', 'round', 'sign', 'sin', 'sinh', 'sqrt', 'tan', 'tanh', 'trunc'].forEach(function (mathMethod) {
    methods.push(['Math.' + mathMethod, mathMethod]);
});

for (var method of methods) {
    for (var i = 1; i < method.length; i++) {
        Matrix.prototype[method[i]] = eval(fillTemplateFunction(inplaceMethod, { name: method[i], method: method[0] }));
        Matrix[method[i]] = eval(fillTemplateFunction(staticMethod, { name: method[i] }));
    }
}

function fillTemplateFunction(template, values) {
    for (var i in values) {
        template = template.replace(new RegExp('%' + i + '%', 'g'), values[i]);
    }
    return template;
}

},{}],30:[function(require,module,exports){
'use strict';

var defaultOptions = {
    degree: 1,
    constant: 1,
    scale: 1
};

class PolynomialKernel {
    constructor(options) {
        options = Object.assign({}, defaultOptions, options);

        this.degree = options.degree;
        this.constant = options.constant;
        this.scale = options.scale;
    }

    compute(x, y) {
        var sum = 0;
        for (var i = 0; i < x.length; i++) {
            sum += x[i] * y[i];
        }
        return Math.pow(this.scale * sum + this.constant, this.degree);
    }
}

module.exports = PolynomialKernel;

},{}],31:[function(require,module,exports){
'use strict';

exports.SimpleLinearRegression = exports.SLR = require('./regression/simple-linear-regression');
exports.KernelRidgeRegression = exports.KRR = require('./regression/kernel-ridge-regression');
//exports.MultipleLinearRegression = exports.MLR = require('./regression/multiple-linear-regression');
//exports.MultivariateLinearRegression = exports.MVLR = require('./regression/multivariate-linear-regression');

},{"./regression/kernel-ridge-regression":32,"./regression/simple-linear-regression":33}],32:[function(require,module,exports){
'use strict';

var Matrix = require('ml-matrix');
var Kernel = require('ml-kernel');

var defaultOptions = {
    lambda: 0.1,
    kernelType: 'gaussian',
    kernelOptions: {}
};

// Implements the Kernel ridge regression algorithm.
// http://www.ics.uci.edu/~welling/classnotes/papers_class/Kernel-Ridge.pdf
class KernelRidgeRegression {
    constructor(inputs, outputs, options) {
        if (inputs === true) {
            // reloading model
            this.alpha = outputs.alpha;
            this.inputs = outputs.inputs;
            this.kernelType = outputs.kernelType;
            this.kernelOptions = outputs.kernelOptions;
            this.kernel = new Kernel(outputs.kernelType, outputs.kernelOptions);
        } else {
            options = Object.assign({}, defaultOptions, options);

            var kernelFunction = new Kernel(options.kernelType, options.kernelOptions);
            var K = kernelFunction.compute(inputs);
            var n = inputs.length;
            K.add(Matrix.eye(n, n).mul(options.lambda));

            this.alpha = K.solve(outputs);
            this.inputs = inputs;
            this.kernelType = options.kernelType;
            this.kernelOptions = options.kernelOptions;
            this.kernel = kernelFunction;
        }
    }

    predict(newInputs) {
        return this.kernel.compute(newInputs, this.inputs).mmul(this.alpha);
    }

    toJSON() {
        return {
            name: 'kernelRidgeRegression',
            alpha: this.alpha,
            inputs: this.inputs,
            kernelType: this.kernelType,
            kernelOptions: this.kernelOptions
        };
    }

    static load(json) {
        if (json.name !== 'kernelRidgeRegression') {
            throw new TypeError('not a KRR model');
        }
        return new KernelRidgeRegression(true, json);
    }
}

module.exports = KernelRidgeRegression;

},{"ml-kernel":13,"ml-matrix":28}],33:[function(require,module,exports){
'use strict';

var maybeToPrecision = require('./util').maybeToPrecision;

function SimpleLinearRegression(x, y) {
    if (!(this instanceof SimpleLinearRegression)) {
        return new SimpleLinearRegression(x, y);
    }

    var n = x.length;
    if (n !== y.length) {
        throw new RangeError('input and output array have a different length');
    }

    var xSum = 0;
    var ySum = 0;

    var xSquared = 0;
    var ySquared = 0;
    var xY = 0;

    for (var i = 0; i < n; i++) {
        xSum += x[i];
        ySum += y[i];
        xSquared += x[i] * x[i];
        ySquared += y[i] * y[i];
        xY += x[i] * y[i];
    }

    var numerator = n * xY - xSum * ySum;

    this.slope = numerator / (n * xSquared - xSum * xSum);
    this.intercept = 1 / n * ySum - this.slope * (1 / n) * xSum;
    this.coefficients = [this.intercept, this.slope];

    this.r = numerator / Math.sqrt((n * xSquared - xSum * xSum) * (n * ySquared - ySum * ySum));
    this.coefficientOfDetermination = this.r2 = this.r * this.r;
}

SimpleLinearRegression.prototype.compute = function compute(input) {
    return this.slope * input + this.intercept;
};

SimpleLinearRegression.prototype.computeX = function computeX(input) {
    return (input - this.intercept) / this.slope;
};

SimpleLinearRegression.prototype.toString = function toString(precision) {
    var result = 'y = ';
    if (this.slope) {
        var xFactor = maybeToPrecision(this.slope, precision);
        result += (xFactor == 1 ? '' : xFactor) + 'x';
        if (this.intercept) {
            var absIntercept = Math.abs(this.intercept);
            var operator = absIntercept === this.intercept ? '+' : '-';
            result += ' ' + operator + ' ' + maybeToPrecision(absIntercept, precision);
        }
    } else {
        result += maybeToPrecision(this.intercept, precision);
    }
    return result;
};

module.exports = SimpleLinearRegression;

},{"./util":34}],34:[function(require,module,exports){
'use strict';

exports.maybeToPrecision = function maybeToPrecision(value, digits) {
    if (digits) return value.toPrecision(digits);else return value.toString();
};

},{}],35:[function(require,module,exports){
"use strict";

module.exports = newArray;

function newArray(n, value) {
  n = n || 0;
  var array = new Array(n);
  for (var i = 0; i < n; i++) {
    array[i] = value;
  }
  return array;
}

},{}],36:[function(require,module,exports){
'use strict';

module.exports = Number.isNaN || function (x) {
	return x !== x;
};

},{}],37:[function(require,module,exports){
// Top level file is just a mixin of submodules & constants
'use strict';

var assign = require('./lib/utils/common').assign;

var deflate = require('./lib/deflate');
var inflate = require('./lib/inflate');
var constants = require('./lib/zlib/constants');

var pako = {};

assign(pako, deflate, inflate, constants);

module.exports = pako;

},{"./lib/deflate":38,"./lib/inflate":39,"./lib/utils/common":40,"./lib/zlib/constants":43}],38:[function(require,module,exports){
'use strict';

var zlib_deflate = require('./zlib/deflate');
var utils = require('./utils/common');
var strings = require('./utils/strings');
var msg = require('./zlib/messages');
var ZStream = require('./zlib/zstream');

var toString = Object.prototype.toString;

/* Public constants ==========================================================*/
/* ===========================================================================*/

var Z_NO_FLUSH = 0;
var Z_FINISH = 4;

var Z_OK = 0;
var Z_STREAM_END = 1;
var Z_SYNC_FLUSH = 2;

var Z_DEFAULT_COMPRESSION = -1;

var Z_DEFAULT_STRATEGY = 0;

var Z_DEFLATED = 8;

/* ===========================================================================*/

/**
 * class Deflate
 *
 * Generic JS-style wrapper for zlib calls. If you don't need
 * streaming behaviour - use more simple functions: [[deflate]],
 * [[deflateRaw]] and [[gzip]].
 **/

/* internal
 * Deflate.chunks -> Array
 *
 * Chunks of output data, if [[Deflate#onData]] not overriden.
 **/

/**
 * Deflate.result -> Uint8Array|Array
 *
 * Compressed result, generated by default [[Deflate#onData]]
 * and [[Deflate#onEnd]] handlers. Filled after you push last chunk
 * (call [[Deflate#push]] with `Z_FINISH` / `true` param)  or if you
 * push a chunk with explicit flush (call [[Deflate#push]] with
 * `Z_SYNC_FLUSH` param).
 **/

/**
 * Deflate.err -> Number
 *
 * Error code after deflate finished. 0 (Z_OK) on success.
 * You will not need it in real life, because deflate errors
 * are possible only on wrong options or bad `onData` / `onEnd`
 * custom handlers.
 **/

/**
 * Deflate.msg -> String
 *
 * Error message, if [[Deflate.err]] != 0
 **/

/**
 * new Deflate(options)
 * - options (Object): zlib deflate options.
 *
 * Creates new deflator instance with specified params. Throws exception
 * on bad params. Supported options:
 *
 * - `level`
 * - `windowBits`
 * - `memLevel`
 * - `strategy`
 * - `dictionary`
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information on these.
 *
 * Additional options, for internal needs:
 *
 * - `chunkSize` - size of generated data chunks (16K by default)
 * - `raw` (Boolean) - do raw deflate
 * - `gzip` (Boolean) - create gzip wrapper
 * - `to` (String) - if equal to 'string', then result will be "binary string"
 *    (each char code [0..255])
 * - `header` (Object) - custom header for gzip
 *   - `text` (Boolean) - true if compressed data believed to be text
 *   - `time` (Number) - modification time, unix timestamp
 *   - `os` (Number) - operation system code
 *   - `extra` (Array) - array of bytes with extra data (max 65536)
 *   - `name` (String) - file name (binary string)
 *   - `comment` (String) - comment (binary string)
 *   - `hcrc` (Boolean) - true if header crc should be added
 *
 * ##### Example:
 *
 * ```javascript
 * var pako = require('pako')
 *   , chunk1 = Uint8Array([1,2,3,4,5,6,7,8,9])
 *   , chunk2 = Uint8Array([10,11,12,13,14,15,16,17,18,19]);
 *
 * var deflate = new pako.Deflate({ level: 3});
 *
 * deflate.push(chunk1, false);
 * deflate.push(chunk2, true);  // true -> last chunk
 *
 * if (deflate.err) { throw new Error(deflate.err); }
 *
 * console.log(deflate.result);
 * ```
 **/
function Deflate(options) {
  if (!(this instanceof Deflate)) return new Deflate(options);

  this.options = utils.assign({
    level: Z_DEFAULT_COMPRESSION,
    method: Z_DEFLATED,
    chunkSize: 16384,
    windowBits: 15,
    memLevel: 8,
    strategy: Z_DEFAULT_STRATEGY,
    to: ''
  }, options || {});

  var opt = this.options;

  if (opt.raw && opt.windowBits > 0) {
    opt.windowBits = -opt.windowBits;
  } else if (opt.gzip && opt.windowBits > 0 && opt.windowBits < 16) {
    opt.windowBits += 16;
  }

  this.err = 0; // error code, if happens (0 = Z_OK)
  this.msg = ''; // error message
  this.ended = false; // used to avoid multiple onEnd() calls
  this.chunks = []; // chunks of compressed data

  this.strm = new ZStream();
  this.strm.avail_out = 0;

  var status = zlib_deflate.deflateInit2(this.strm, opt.level, opt.method, opt.windowBits, opt.memLevel, opt.strategy);

  if (status !== Z_OK) {
    throw new Error(msg[status]);
  }

  if (opt.header) {
    zlib_deflate.deflateSetHeader(this.strm, opt.header);
  }

  if (opt.dictionary) {
    var dict;
    // Convert data if needed
    if (typeof opt.dictionary === 'string') {
      // If we need to compress text, change encoding to utf8.
      dict = strings.string2buf(opt.dictionary);
    } else if (toString.call(opt.dictionary) === '[object ArrayBuffer]') {
      dict = new Uint8Array(opt.dictionary);
    } else {
      dict = opt.dictionary;
    }

    status = zlib_deflate.deflateSetDictionary(this.strm, dict);

    if (status !== Z_OK) {
      throw new Error(msg[status]);
    }

    this._dict_set = true;
  }
}

/**
 * Deflate#push(data[, mode]) -> Boolean
 * - data (Uint8Array|Array|ArrayBuffer|String): input data. Strings will be
 *   converted to utf8 byte sequence.
 * - mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.
 *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` meansh Z_FINISH.
 *
 * Sends input data to deflate pipe, generating [[Deflate#onData]] calls with
 * new compressed chunks. Returns `true` on success. The last data block must have
 * mode Z_FINISH (or `true`). That will flush internal pending buffers and call
 * [[Deflate#onEnd]]. For interim explicit flushes (without ending the stream) you
 * can use mode Z_SYNC_FLUSH, keeping the compression context.
 *
 * On fail call [[Deflate#onEnd]] with error code and return false.
 *
 * We strongly recommend to use `Uint8Array` on input for best speed (output
 * array format is detected automatically). Also, don't skip last param and always
 * use the same type in your code (boolean or number). That will improve JS speed.
 *
 * For regular `Array`-s make sure all elements are [0..255].
 *
 * ##### Example
 *
 * ```javascript
 * push(chunk, false); // push one of data chunks
 * ...
 * push(chunk, true);  // push last chunk
 * ```
 **/
Deflate.prototype.push = function (data, mode) {
  var strm = this.strm;
  var chunkSize = this.options.chunkSize;
  var status, _mode;

  if (this.ended) {
    return false;
  }

  _mode = mode === ~~mode ? mode : mode === true ? Z_FINISH : Z_NO_FLUSH;

  // Convert data if needed
  if (typeof data === 'string') {
    // If we need to compress text, change encoding to utf8.
    strm.input = strings.string2buf(data);
  } else if (toString.call(data) === '[object ArrayBuffer]') {
    strm.input = new Uint8Array(data);
  } else {
    strm.input = data;
  }

  strm.next_in = 0;
  strm.avail_in = strm.input.length;

  do {
    if (strm.avail_out === 0) {
      strm.output = new utils.Buf8(chunkSize);
      strm.next_out = 0;
      strm.avail_out = chunkSize;
    }
    status = zlib_deflate.deflate(strm, _mode); /* no bad return value */

    if (status !== Z_STREAM_END && status !== Z_OK) {
      this.onEnd(status);
      this.ended = true;
      return false;
    }
    if (strm.avail_out === 0 || strm.avail_in === 0 && (_mode === Z_FINISH || _mode === Z_SYNC_FLUSH)) {
      if (this.options.to === 'string') {
        this.onData(strings.buf2binstring(utils.shrinkBuf(strm.output, strm.next_out)));
      } else {
        this.onData(utils.shrinkBuf(strm.output, strm.next_out));
      }
    }
  } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== Z_STREAM_END);

  // Finalize on the last chunk.
  if (_mode === Z_FINISH) {
    status = zlib_deflate.deflateEnd(this.strm);
    this.onEnd(status);
    this.ended = true;
    return status === Z_OK;
  }

  // callback interim results if Z_SYNC_FLUSH.
  if (_mode === Z_SYNC_FLUSH) {
    this.onEnd(Z_OK);
    strm.avail_out = 0;
    return true;
  }

  return true;
};

/**
 * Deflate#onData(chunk) -> Void
 * - chunk (Uint8Array|Array|String): ouput data. Type of array depends
 *   on js engine support. When string output requested, each chunk
 *   will be string.
 *
 * By default, stores data blocks in `chunks[]` property and glue
 * those in `onEnd`. Override this handler, if you need another behaviour.
 **/
Deflate.prototype.onData = function (chunk) {
  this.chunks.push(chunk);
};

/**
 * Deflate#onEnd(status) -> Void
 * - status (Number): deflate status. 0 (Z_OK) on success,
 *   other if not.
 *
 * Called once after you tell deflate that the input stream is
 * complete (Z_FINISH) or should be flushed (Z_SYNC_FLUSH)
 * or if an error happened. By default - join collected chunks,
 * free memory and fill `results` / `err` properties.
 **/
Deflate.prototype.onEnd = function (status) {
  // On success - join
  if (status === Z_OK) {
    if (this.options.to === 'string') {
      this.result = this.chunks.join('');
    } else {
      this.result = utils.flattenChunks(this.chunks);
    }
  }
  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
};

/**
 * deflate(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to compress.
 * - options (Object): zlib deflate options.
 *
 * Compress `data` with deflate algorithm and `options`.
 *
 * Supported options are:
 *
 * - level
 * - windowBits
 * - memLevel
 * - strategy
 * - dictionary
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information on these.
 *
 * Sugar (options):
 *
 * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify
 *   negative windowBits implicitly.
 * - `to` (String) - if equal to 'string', then result will be "binary string"
 *    (each char code [0..255])
 *
 * ##### Example:
 *
 * ```javascript
 * var pako = require('pako')
 *   , data = Uint8Array([1,2,3,4,5,6,7,8,9]);
 *
 * console.log(pako.deflate(data));
 * ```
 **/
function deflate(input, options) {
  var deflator = new Deflate(options);

  deflator.push(input, true);

  // That will never happens, if you don't cheat with options :)
  if (deflator.err) {
    throw deflator.msg;
  }

  return deflator.result;
}

/**
 * deflateRaw(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to compress.
 * - options (Object): zlib deflate options.
 *
 * The same as [[deflate]], but creates raw data, without wrapper
 * (header and adler32 crc).
 **/
function deflateRaw(input, options) {
  options = options || {};
  options.raw = true;
  return deflate(input, options);
}

/**
 * gzip(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to compress.
 * - options (Object): zlib deflate options.
 *
 * The same as [[deflate]], but create gzip wrapper instead of
 * deflate one.
 **/
function gzip(input, options) {
  options = options || {};
  options.gzip = true;
  return deflate(input, options);
}

exports.Deflate = Deflate;
exports.deflate = deflate;
exports.deflateRaw = deflateRaw;
exports.gzip = gzip;

},{"./utils/common":40,"./utils/strings":41,"./zlib/deflate":45,"./zlib/messages":50,"./zlib/zstream":52}],39:[function(require,module,exports){
'use strict';

var zlib_inflate = require('./zlib/inflate');
var utils = require('./utils/common');
var strings = require('./utils/strings');
var c = require('./zlib/constants');
var msg = require('./zlib/messages');
var ZStream = require('./zlib/zstream');
var GZheader = require('./zlib/gzheader');

var toString = Object.prototype.toString;

/**
 * class Inflate
 *
 * Generic JS-style wrapper for zlib calls. If you don't need
 * streaming behaviour - use more simple functions: [[inflate]]
 * and [[inflateRaw]].
 **/

/* internal
 * inflate.chunks -> Array
 *
 * Chunks of output data, if [[Inflate#onData]] not overriden.
 **/

/**
 * Inflate.result -> Uint8Array|Array|String
 *
 * Uncompressed result, generated by default [[Inflate#onData]]
 * and [[Inflate#onEnd]] handlers. Filled after you push last chunk
 * (call [[Inflate#push]] with `Z_FINISH` / `true` param) or if you
 * push a chunk with explicit flush (call [[Inflate#push]] with
 * `Z_SYNC_FLUSH` param).
 **/

/**
 * Inflate.err -> Number
 *
 * Error code after inflate finished. 0 (Z_OK) on success.
 * Should be checked if broken data possible.
 **/

/**
 * Inflate.msg -> String
 *
 * Error message, if [[Inflate.err]] != 0
 **/

/**
 * new Inflate(options)
 * - options (Object): zlib inflate options.
 *
 * Creates new inflator instance with specified params. Throws exception
 * on bad params. Supported options:
 *
 * - `windowBits`
 * - `dictionary`
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information on these.
 *
 * Additional options, for internal needs:
 *
 * - `chunkSize` - size of generated data chunks (16K by default)
 * - `raw` (Boolean) - do raw inflate
 * - `to` (String) - if equal to 'string', then result will be converted
 *   from utf8 to utf16 (javascript) string. When string output requested,
 *   chunk length can differ from `chunkSize`, depending on content.
 *
 * By default, when no options set, autodetect deflate/gzip data format via
 * wrapper header.
 *
 * ##### Example:
 *
 * ```javascript
 * var pako = require('pako')
 *   , chunk1 = Uint8Array([1,2,3,4,5,6,7,8,9])
 *   , chunk2 = Uint8Array([10,11,12,13,14,15,16,17,18,19]);
 *
 * var inflate = new pako.Inflate({ level: 3});
 *
 * inflate.push(chunk1, false);
 * inflate.push(chunk2, true);  // true -> last chunk
 *
 * if (inflate.err) { throw new Error(inflate.err); }
 *
 * console.log(inflate.result);
 * ```
 **/
function Inflate(options) {
  if (!(this instanceof Inflate)) return new Inflate(options);

  this.options = utils.assign({
    chunkSize: 16384,
    windowBits: 0,
    to: ''
  }, options || {});

  var opt = this.options;

  // Force window size for `raw` data, if not set directly,
  // because we have no header for autodetect.
  if (opt.raw && opt.windowBits >= 0 && opt.windowBits < 16) {
    opt.windowBits = -opt.windowBits;
    if (opt.windowBits === 0) {
      opt.windowBits = -15;
    }
  }

  // If `windowBits` not defined (and mode not raw) - set autodetect flag for gzip/deflate
  if (opt.windowBits >= 0 && opt.windowBits < 16 && !(options && options.windowBits)) {
    opt.windowBits += 32;
  }

  // Gzip header has no info about windows size, we can do autodetect only
  // for deflate. So, if window size not set, force it to max when gzip possible
  if (opt.windowBits > 15 && opt.windowBits < 48) {
    // bit 3 (16) -> gzipped data
    // bit 4 (32) -> autodetect gzip/deflate
    if ((opt.windowBits & 15) === 0) {
      opt.windowBits |= 15;
    }
  }

  this.err = 0; // error code, if happens (0 = Z_OK)
  this.msg = ''; // error message
  this.ended = false; // used to avoid multiple onEnd() calls
  this.chunks = []; // chunks of compressed data

  this.strm = new ZStream();
  this.strm.avail_out = 0;

  var status = zlib_inflate.inflateInit2(this.strm, opt.windowBits);

  if (status !== c.Z_OK) {
    throw new Error(msg[status]);
  }

  this.header = new GZheader();

  zlib_inflate.inflateGetHeader(this.strm, this.header);
}

/**
 * Inflate#push(data[, mode]) -> Boolean
 * - data (Uint8Array|Array|ArrayBuffer|String): input data
 * - mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.
 *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` meansh Z_FINISH.
 *
 * Sends input data to inflate pipe, generating [[Inflate#onData]] calls with
 * new output chunks. Returns `true` on success. The last data block must have
 * mode Z_FINISH (or `true`). That will flush internal pending buffers and call
 * [[Inflate#onEnd]]. For interim explicit flushes (without ending the stream) you
 * can use mode Z_SYNC_FLUSH, keeping the decompression context.
 *
 * On fail call [[Inflate#onEnd]] with error code and return false.
 *
 * We strongly recommend to use `Uint8Array` on input for best speed (output
 * format is detected automatically). Also, don't skip last param and always
 * use the same type in your code (boolean or number). That will improve JS speed.
 *
 * For regular `Array`-s make sure all elements are [0..255].
 *
 * ##### Example
 *
 * ```javascript
 * push(chunk, false); // push one of data chunks
 * ...
 * push(chunk, true);  // push last chunk
 * ```
 **/
Inflate.prototype.push = function (data, mode) {
  var strm = this.strm;
  var chunkSize = this.options.chunkSize;
  var dictionary = this.options.dictionary;
  var status, _mode;
  var next_out_utf8, tail, utf8str;
  var dict;

  // Flag to properly process Z_BUF_ERROR on testing inflate call
  // when we check that all output data was flushed.
  var allowBufError = false;

  if (this.ended) {
    return false;
  }
  _mode = mode === ~~mode ? mode : mode === true ? c.Z_FINISH : c.Z_NO_FLUSH;

  // Convert data if needed
  if (typeof data === 'string') {
    // Only binary strings can be decompressed on practice
    strm.input = strings.binstring2buf(data);
  } else if (toString.call(data) === '[object ArrayBuffer]') {
    strm.input = new Uint8Array(data);
  } else {
    strm.input = data;
  }

  strm.next_in = 0;
  strm.avail_in = strm.input.length;

  do {
    if (strm.avail_out === 0) {
      strm.output = new utils.Buf8(chunkSize);
      strm.next_out = 0;
      strm.avail_out = chunkSize;
    }

    status = zlib_inflate.inflate(strm, c.Z_NO_FLUSH); /* no bad return value */

    if (status === c.Z_NEED_DICT && dictionary) {
      // Convert data if needed
      if (typeof dictionary === 'string') {
        dict = strings.string2buf(dictionary);
      } else if (toString.call(dictionary) === '[object ArrayBuffer]') {
        dict = new Uint8Array(dictionary);
      } else {
        dict = dictionary;
      }

      status = zlib_inflate.inflateSetDictionary(this.strm, dict);
    }

    if (status === c.Z_BUF_ERROR && allowBufError === true) {
      status = c.Z_OK;
      allowBufError = false;
    }

    if (status !== c.Z_STREAM_END && status !== c.Z_OK) {
      this.onEnd(status);
      this.ended = true;
      return false;
    }

    if (strm.next_out) {
      if (strm.avail_out === 0 || status === c.Z_STREAM_END || strm.avail_in === 0 && (_mode === c.Z_FINISH || _mode === c.Z_SYNC_FLUSH)) {

        if (this.options.to === 'string') {

          next_out_utf8 = strings.utf8border(strm.output, strm.next_out);

          tail = strm.next_out - next_out_utf8;
          utf8str = strings.buf2string(strm.output, next_out_utf8);

          // move tail
          strm.next_out = tail;
          strm.avail_out = chunkSize - tail;
          if (tail) {
            utils.arraySet(strm.output, strm.output, next_out_utf8, tail, 0);
          }

          this.onData(utf8str);
        } else {
          this.onData(utils.shrinkBuf(strm.output, strm.next_out));
        }
      }
    }

    // When no more input data, we should check that internal inflate buffers
    // are flushed. The only way to do it when avail_out = 0 - run one more
    // inflate pass. But if output data not exists, inflate return Z_BUF_ERROR.
    // Here we set flag to process this error properly.
    //
    // NOTE. Deflate does not return error in this case and does not needs such
    // logic.
    if (strm.avail_in === 0 && strm.avail_out === 0) {
      allowBufError = true;
    }
  } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== c.Z_STREAM_END);

  if (status === c.Z_STREAM_END) {
    _mode = c.Z_FINISH;
  }

  // Finalize on the last chunk.
  if (_mode === c.Z_FINISH) {
    status = zlib_inflate.inflateEnd(this.strm);
    this.onEnd(status);
    this.ended = true;
    return status === c.Z_OK;
  }

  // callback interim results if Z_SYNC_FLUSH.
  if (_mode === c.Z_SYNC_FLUSH) {
    this.onEnd(c.Z_OK);
    strm.avail_out = 0;
    return true;
  }

  return true;
};

/**
 * Inflate#onData(chunk) -> Void
 * - chunk (Uint8Array|Array|String): ouput data. Type of array depends
 *   on js engine support. When string output requested, each chunk
 *   will be string.
 *
 * By default, stores data blocks in `chunks[]` property and glue
 * those in `onEnd`. Override this handler, if you need another behaviour.
 **/
Inflate.prototype.onData = function (chunk) {
  this.chunks.push(chunk);
};

/**
 * Inflate#onEnd(status) -> Void
 * - status (Number): inflate status. 0 (Z_OK) on success,
 *   other if not.
 *
 * Called either after you tell inflate that the input stream is
 * complete (Z_FINISH) or should be flushed (Z_SYNC_FLUSH)
 * or if an error happened. By default - join collected chunks,
 * free memory and fill `results` / `err` properties.
 **/
Inflate.prototype.onEnd = function (status) {
  // On success - join
  if (status === c.Z_OK) {
    if (this.options.to === 'string') {
      // Glue & convert here, until we teach pako to send
      // utf8 alligned strings to onData
      this.result = this.chunks.join('');
    } else {
      this.result = utils.flattenChunks(this.chunks);
    }
  }
  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
};

/**
 * inflate(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to decompress.
 * - options (Object): zlib inflate options.
 *
 * Decompress `data` with inflate/ungzip and `options`. Autodetect
 * format via wrapper header by default. That's why we don't provide
 * separate `ungzip` method.
 *
 * Supported options are:
 *
 * - windowBits
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information.
 *
 * Sugar (options):
 *
 * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify
 *   negative windowBits implicitly.
 * - `to` (String) - if equal to 'string', then result will be converted
 *   from utf8 to utf16 (javascript) string. When string output requested,
 *   chunk length can differ from `chunkSize`, depending on content.
 *
 *
 * ##### Example:
 *
 * ```javascript
 * var pako = require('pako')
 *   , input = pako.deflate([1,2,3,4,5,6,7,8,9])
 *   , output;
 *
 * try {
 *   output = pako.inflate(input);
 * } catch (err)
 *   console.log(err);
 * }
 * ```
 **/
function inflate(input, options) {
  var inflator = new Inflate(options);

  inflator.push(input, true);

  // That will never happens, if you don't cheat with options :)
  if (inflator.err) {
    throw inflator.msg;
  }

  return inflator.result;
}

/**
 * inflateRaw(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to decompress.
 * - options (Object): zlib inflate options.
 *
 * The same as [[inflate]], but creates raw data, without wrapper
 * (header and adler32 crc).
 **/
function inflateRaw(input, options) {
  options = options || {};
  options.raw = true;
  return inflate(input, options);
}

/**
 * ungzip(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to decompress.
 * - options (Object): zlib inflate options.
 *
 * Just shortcut to [[inflate]], because it autodetects format
 * by header.content. Done for convenience.
 **/

exports.Inflate = Inflate;
exports.inflate = inflate;
exports.inflateRaw = inflateRaw;
exports.ungzip = inflate;

},{"./utils/common":40,"./utils/strings":41,"./zlib/constants":43,"./zlib/gzheader":46,"./zlib/inflate":48,"./zlib/messages":50,"./zlib/zstream":52}],40:[function(require,module,exports){
'use strict';

var TYPED_OK = typeof Uint8Array !== 'undefined' && typeof Uint16Array !== 'undefined' && typeof Int32Array !== 'undefined';

exports.assign = function (obj /*from1, from2, from3, ...*/) {
  var sources = Array.prototype.slice.call(arguments, 1);
  while (sources.length) {
    var source = sources.shift();
    if (!source) {
      continue;
    }

    if (typeof source !== 'object') {
      throw new TypeError(source + 'must be non-object');
    }

    for (var p in source) {
      if (source.hasOwnProperty(p)) {
        obj[p] = source[p];
      }
    }
  }

  return obj;
};

// reduce buffer size, avoiding mem copy
exports.shrinkBuf = function (buf, size) {
  if (buf.length === size) {
    return buf;
  }
  if (buf.subarray) {
    return buf.subarray(0, size);
  }
  buf.length = size;
  return buf;
};

var fnTyped = {
  arraySet: function arraySet(dest, src, src_offs, len, dest_offs) {
    if (src.subarray && dest.subarray) {
      dest.set(src.subarray(src_offs, src_offs + len), dest_offs);
      return;
    }
    // Fallback to ordinary array
    for (var i = 0; i < len; i++) {
      dest[dest_offs + i] = src[src_offs + i];
    }
  },
  // Join array of chunks to single array.
  flattenChunks: function flattenChunks(chunks) {
    var i, l, len, pos, chunk, result;

    // calculate data length
    len = 0;
    for (i = 0, l = chunks.length; i < l; i++) {
      len += chunks[i].length;
    }

    // join chunks
    result = new Uint8Array(len);
    pos = 0;
    for (i = 0, l = chunks.length; i < l; i++) {
      chunk = chunks[i];
      result.set(chunk, pos);
      pos += chunk.length;
    }

    return result;
  }
};

var fnUntyped = {
  arraySet: function arraySet(dest, src, src_offs, len, dest_offs) {
    for (var i = 0; i < len; i++) {
      dest[dest_offs + i] = src[src_offs + i];
    }
  },
  // Join array of chunks to single array.
  flattenChunks: function flattenChunks(chunks) {
    return [].concat.apply([], chunks);
  }
};

// Enable/Disable typed arrays use, for testing
//
exports.setTyped = function (on) {
  if (on) {
    exports.Buf8 = Uint8Array;
    exports.Buf16 = Uint16Array;
    exports.Buf32 = Int32Array;
    exports.assign(exports, fnTyped);
  } else {
    exports.Buf8 = Array;
    exports.Buf16 = Array;
    exports.Buf32 = Array;
    exports.assign(exports, fnUntyped);
  }
};

exports.setTyped(TYPED_OK);

},{}],41:[function(require,module,exports){
// String encode/decode helpers
'use strict';

var utils = require('./common');

// Quick check if we can use fast array to bin string conversion
//
// - apply(Array) can fail on Android 2.2
// - apply(Uint8Array) can fail on iOS 5.1 Safary
//
var STR_APPLY_OK = true;
var STR_APPLY_UIA_OK = true;

try {
  String.fromCharCode.apply(null, [0]);
} catch (__) {
  STR_APPLY_OK = false;
}
try {
  String.fromCharCode.apply(null, new Uint8Array(1));
} catch (__) {
  STR_APPLY_UIA_OK = false;
}

// Table with utf8 lengths (calculated by first byte of sequence)
// Note, that 5 & 6-byte values and some 4-byte values can not be represented in JS,
// because max possible codepoint is 0x10ffff
var _utf8len = new utils.Buf8(256);
for (var q = 0; q < 256; q++) {
  _utf8len[q] = q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1;
}
_utf8len[254] = _utf8len[254] = 1; // Invalid sequence start

// convert string to array (typed, when possible)
exports.string2buf = function (str) {
  var buf,
      c,
      c2,
      m_pos,
      i,
      str_len = str.length,
      buf_len = 0;

  // count binary size
  for (m_pos = 0; m_pos < str_len; m_pos++) {
    c = str.charCodeAt(m_pos);
    if ((c & 0xfc00) === 0xd800 && m_pos + 1 < str_len) {
      c2 = str.charCodeAt(m_pos + 1);
      if ((c2 & 0xfc00) === 0xdc00) {
        c = 0x10000 + (c - 0xd800 << 10) + (c2 - 0xdc00);
        m_pos++;
      }
    }
    buf_len += c < 0x80 ? 1 : c < 0x800 ? 2 : c < 0x10000 ? 3 : 4;
  }

  // allocate buffer
  buf = new utils.Buf8(buf_len);

  // convert
  for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
    c = str.charCodeAt(m_pos);
    if ((c & 0xfc00) === 0xd800 && m_pos + 1 < str_len) {
      c2 = str.charCodeAt(m_pos + 1);
      if ((c2 & 0xfc00) === 0xdc00) {
        c = 0x10000 + (c - 0xd800 << 10) + (c2 - 0xdc00);
        m_pos++;
      }
    }
    if (c < 0x80) {
      /* one byte */
      buf[i++] = c;
    } else if (c < 0x800) {
      /* two bytes */
      buf[i++] = 0xC0 | c >>> 6;
      buf[i++] = 0x80 | c & 0x3f;
    } else if (c < 0x10000) {
      /* three bytes */
      buf[i++] = 0xE0 | c >>> 12;
      buf[i++] = 0x80 | c >>> 6 & 0x3f;
      buf[i++] = 0x80 | c & 0x3f;
    } else {
      /* four bytes */
      buf[i++] = 0xf0 | c >>> 18;
      buf[i++] = 0x80 | c >>> 12 & 0x3f;
      buf[i++] = 0x80 | c >>> 6 & 0x3f;
      buf[i++] = 0x80 | c & 0x3f;
    }
  }

  return buf;
};

// Helper (used in 2 places)
function buf2binstring(buf, len) {
  // use fallback for big arrays to avoid stack overflow
  if (len < 65537) {
    if (buf.subarray && STR_APPLY_UIA_OK || !buf.subarray && STR_APPLY_OK) {
      return String.fromCharCode.apply(null, utils.shrinkBuf(buf, len));
    }
  }

  var result = '';
  for (var i = 0; i < len; i++) {
    result += String.fromCharCode(buf[i]);
  }
  return result;
}

// Convert byte array to binary string
exports.buf2binstring = function (buf) {
  return buf2binstring(buf, buf.length);
};

// Convert binary string (typed, when possible)
exports.binstring2buf = function (str) {
  var buf = new utils.Buf8(str.length);
  for (var i = 0, len = buf.length; i < len; i++) {
    buf[i] = str.charCodeAt(i);
  }
  return buf;
};

// convert array to string
exports.buf2string = function (buf, max) {
  var i, out, c, c_len;
  var len = max || buf.length;

  // Reserve max possible length (2 words per char)
  // NB: by unknown reasons, Array is significantly faster for
  //     String.fromCharCode.apply than Uint16Array.
  var utf16buf = new Array(len * 2);

  for (out = 0, i = 0; i < len;) {
    c = buf[i++];
    // quick process ascii
    if (c < 0x80) {
      utf16buf[out++] = c;continue;
    }

    c_len = _utf8len[c];
    // skip 5 & 6 byte codes
    if (c_len > 4) {
      utf16buf[out++] = 0xfffd;i += c_len - 1;continue;
    }

    // apply mask on first byte
    c &= c_len === 2 ? 0x1f : c_len === 3 ? 0x0f : 0x07;
    // join the rest
    while (c_len > 1 && i < len) {
      c = c << 6 | buf[i++] & 0x3f;
      c_len--;
    }

    // terminated by end of string?
    if (c_len > 1) {
      utf16buf[out++] = 0xfffd;continue;
    }

    if (c < 0x10000) {
      utf16buf[out++] = c;
    } else {
      c -= 0x10000;
      utf16buf[out++] = 0xd800 | c >> 10 & 0x3ff;
      utf16buf[out++] = 0xdc00 | c & 0x3ff;
    }
  }

  return buf2binstring(utf16buf, out);
};

// Calculate max possible position in utf8 buffer,
// that will not break sequence. If that's not possible
// - (very small limits) return max size as is.
//
// buf[] - utf8 bytes array
// max   - length limit (mandatory);
exports.utf8border = function (buf, max) {
  var pos;

  max = max || buf.length;
  if (max > buf.length) {
    max = buf.length;
  }

  // go back from last position, until start of sequence found
  pos = max - 1;
  while (pos >= 0 && (buf[pos] & 0xC0) === 0x80) {
    pos--;
  }

  // Fuckup - very small and broken sequence,
  // return max, because we should return something anyway.
  if (pos < 0) {
    return max;
  }

  // If we came to start of buffer - that means vuffer is too small,
  // return max too.
  if (pos === 0) {
    return max;
  }

  return pos + _utf8len[buf[pos]] > max ? pos : max;
};

},{"./common":40}],42:[function(require,module,exports){
'use strict';

// Note: adler32 takes 12% for level 0 and 2% for level 6.
// It doesn't worth to make additional optimizationa as in original.
// Small size is preferable.

function adler32(adler, buf, len, pos) {
  var s1 = adler & 0xffff | 0,
      s2 = adler >>> 16 & 0xffff | 0,
      n = 0;

  while (len !== 0) {
    // Set limit ~ twice less than 5552, to keep
    // s2 in 31-bits, because we force signed ints.
    // in other case %= will fail.
    n = len > 2000 ? 2000 : len;
    len -= n;

    do {
      s1 = s1 + buf[pos++] | 0;
      s2 = s2 + s1 | 0;
    } while (--n);

    s1 %= 65521;
    s2 %= 65521;
  }

  return s1 | s2 << 16 | 0;
}

module.exports = adler32;

},{}],43:[function(require,module,exports){
'use strict';

module.exports = {

  /* Allowed flush values; see deflate() and inflate() below for details */
  Z_NO_FLUSH: 0,
  Z_PARTIAL_FLUSH: 1,
  Z_SYNC_FLUSH: 2,
  Z_FULL_FLUSH: 3,
  Z_FINISH: 4,
  Z_BLOCK: 5,
  Z_TREES: 6,

  /* Return codes for the compression/decompression functions. Negative values
  * are errors, positive values are used for special but normal events.
  */
  Z_OK: 0,
  Z_STREAM_END: 1,
  Z_NEED_DICT: 2,
  Z_ERRNO: -1,
  Z_STREAM_ERROR: -2,
  Z_DATA_ERROR: -3,
  //Z_MEM_ERROR:     -4,
  Z_BUF_ERROR: -5,
  //Z_VERSION_ERROR: -6,

  /* compression levels */
  Z_NO_COMPRESSION: 0,
  Z_BEST_SPEED: 1,
  Z_BEST_COMPRESSION: 9,
  Z_DEFAULT_COMPRESSION: -1,

  Z_FILTERED: 1,
  Z_HUFFMAN_ONLY: 2,
  Z_RLE: 3,
  Z_FIXED: 4,
  Z_DEFAULT_STRATEGY: 0,

  /* Possible values of the data_type field (though see inflate()) */
  Z_BINARY: 0,
  Z_TEXT: 1,
  //Z_ASCII:                1, // = Z_TEXT (deprecated)
  Z_UNKNOWN: 2,

  /* The deflate compression method */
  Z_DEFLATED: 8
  //Z_NULL:                 null // Use -1 or null inline, depending on var type
};

},{}],44:[function(require,module,exports){
'use strict';

// Note: we can't get significant speed boost here.
// So write code to minimize size - no pregenerated tables
// and array tools dependencies.

// Use ordinary array, since untyped makes no boost here

function makeTable() {
  var c,
      table = [];

  for (var n = 0; n < 256; n++) {
    c = n;
    for (var k = 0; k < 8; k++) {
      c = c & 1 ? 0xEDB88320 ^ c >>> 1 : c >>> 1;
    }
    table[n] = c;
  }

  return table;
}

// Create table on load. Just 255 signed longs. Not a problem.
var crcTable = makeTable();

function crc32(crc, buf, len, pos) {
  var t = crcTable,
      end = pos + len;

  crc ^= -1;

  for (var i = pos; i < end; i++) {
    crc = crc >>> 8 ^ t[(crc ^ buf[i]) & 0xFF];
  }

  return crc ^ -1; // >>> 0;
}

module.exports = crc32;

},{}],45:[function(require,module,exports){
'use strict';

var utils = require('../utils/common');
var trees = require('./trees');
var adler32 = require('./adler32');
var crc32 = require('./crc32');
var msg = require('./messages');

/* Public constants ==========================================================*/
/* ===========================================================================*/

/* Allowed flush values; see deflate() and inflate() below for details */
var Z_NO_FLUSH = 0;
var Z_PARTIAL_FLUSH = 1;
//var Z_SYNC_FLUSH    = 2;
var Z_FULL_FLUSH = 3;
var Z_FINISH = 4;
var Z_BLOCK = 5;
//var Z_TREES         = 6;

/* Return codes for the compression/decompression functions. Negative values
 * are errors, positive values are used for special but normal events.
 */
var Z_OK = 0;
var Z_STREAM_END = 1;
//var Z_NEED_DICT     = 2;
//var Z_ERRNO         = -1;
var Z_STREAM_ERROR = -2;
var Z_DATA_ERROR = -3;
//var Z_MEM_ERROR     = -4;
var Z_BUF_ERROR = -5;
//var Z_VERSION_ERROR = -6;

/* compression levels */
//var Z_NO_COMPRESSION      = 0;
//var Z_BEST_SPEED          = 1;
//var Z_BEST_COMPRESSION    = 9;
var Z_DEFAULT_COMPRESSION = -1;

var Z_FILTERED = 1;
var Z_HUFFMAN_ONLY = 2;
var Z_RLE = 3;
var Z_FIXED = 4;
var Z_DEFAULT_STRATEGY = 0;

/* Possible values of the data_type field (though see inflate()) */
//var Z_BINARY              = 0;
//var Z_TEXT                = 1;
//var Z_ASCII               = 1; // = Z_TEXT
var Z_UNKNOWN = 2;

/* The deflate compression method */
var Z_DEFLATED = 8;

/*============================================================================*/

var MAX_MEM_LEVEL = 9;
/* Maximum value for memLevel in deflateInit2 */
var MAX_WBITS = 15;
/* 32K LZ77 window */
var DEF_MEM_LEVEL = 8;

var LENGTH_CODES = 29;
/* number of length codes, not counting the special END_BLOCK code */
var LITERALS = 256;
/* number of literal bytes 0..255 */
var L_CODES = LITERALS + 1 + LENGTH_CODES;
/* number of Literal or Length codes, including the END_BLOCK code */
var D_CODES = 30;
/* number of distance codes */
var BL_CODES = 19;
/* number of codes used to transfer the bit lengths */
var HEAP_SIZE = 2 * L_CODES + 1;
/* maximum heap size */
var MAX_BITS = 15;
/* All codes must not exceed MAX_BITS bits */

var MIN_MATCH = 3;
var MAX_MATCH = 258;
var MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1;

var PRESET_DICT = 0x20;

var INIT_STATE = 42;
var EXTRA_STATE = 69;
var NAME_STATE = 73;
var COMMENT_STATE = 91;
var HCRC_STATE = 103;
var BUSY_STATE = 113;
var FINISH_STATE = 666;

var BS_NEED_MORE = 1; /* block not completed, need more input or more output */
var BS_BLOCK_DONE = 2; /* block flush performed */
var BS_FINISH_STARTED = 3; /* finish started, need only more output at next deflate */
var BS_FINISH_DONE = 4; /* finish done, accept no more input or output */

var OS_CODE = 0x03; // Unix :) . Don't detect, use this default.

function err(strm, errorCode) {
  strm.msg = msg[errorCode];
  return errorCode;
}

function rank(f) {
  return (f << 1) - (f > 4 ? 9 : 0);
}

function zero(buf) {
  var len = buf.length;while (--len >= 0) {
    buf[len] = 0;
  }
}

/* =========================================================================
 * Flush as much pending output as possible. All deflate() output goes
 * through this function so some applications may wish to modify it
 * to avoid allocating a large strm->output buffer and copying into it.
 * (See also read_buf()).
 */
function flush_pending(strm) {
  var s = strm.state;

  //_tr_flush_bits(s);
  var len = s.pending;
  if (len > strm.avail_out) {
    len = strm.avail_out;
  }
  if (len === 0) {
    return;
  }

  utils.arraySet(strm.output, s.pending_buf, s.pending_out, len, strm.next_out);
  strm.next_out += len;
  s.pending_out += len;
  strm.total_out += len;
  strm.avail_out -= len;
  s.pending -= len;
  if (s.pending === 0) {
    s.pending_out = 0;
  }
}

function flush_block_only(s, last) {
  trees._tr_flush_block(s, s.block_start >= 0 ? s.block_start : -1, s.strstart - s.block_start, last);
  s.block_start = s.strstart;
  flush_pending(s.strm);
}

function put_byte(s, b) {
  s.pending_buf[s.pending++] = b;
}

/* =========================================================================
 * Put a short in the pending buffer. The 16-bit value is put in MSB order.
 * IN assertion: the stream state is correct and there is enough room in
 * pending_buf.
 */
function putShortMSB(s, b) {
  //  put_byte(s, (Byte)(b >> 8));
  //  put_byte(s, (Byte)(b & 0xff));
  s.pending_buf[s.pending++] = b >>> 8 & 0xff;
  s.pending_buf[s.pending++] = b & 0xff;
}

/* ===========================================================================
 * Read a new buffer from the current input stream, update the adler32
 * and total number of bytes read.  All deflate() input goes through
 * this function so some applications may wish to modify it to avoid
 * allocating a large strm->input buffer and copying from it.
 * (See also flush_pending()).
 */
function read_buf(strm, buf, start, size) {
  var len = strm.avail_in;

  if (len > size) {
    len = size;
  }
  if (len === 0) {
    return 0;
  }

  strm.avail_in -= len;

  // zmemcpy(buf, strm->next_in, len);
  utils.arraySet(buf, strm.input, strm.next_in, len, start);
  if (strm.state.wrap === 1) {
    strm.adler = adler32(strm.adler, buf, len, start);
  } else if (strm.state.wrap === 2) {
    strm.adler = crc32(strm.adler, buf, len, start);
  }

  strm.next_in += len;
  strm.total_in += len;

  return len;
}

/* ===========================================================================
 * Set match_start to the longest match starting at the given string and
 * return its length. Matches shorter or equal to prev_length are discarded,
 * in which case the result is equal to prev_length and match_start is
 * garbage.
 * IN assertions: cur_match is the head of the hash chain for the current
 *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1
 * OUT assertion: the match length is not greater than s->lookahead.
 */
function longest_match(s, cur_match) {
  var chain_length = s.max_chain_length; /* max hash chain length */
  var scan = s.strstart; /* current string */
  var match; /* matched string */
  var len; /* length of current match */
  var best_len = s.prev_length; /* best match length so far */
  var nice_match = s.nice_match; /* stop if match long enough */
  var limit = s.strstart > s.w_size - MIN_LOOKAHEAD ? s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0 /*NIL*/;

  var _win = s.window; // shortcut

  var wmask = s.w_mask;
  var prev = s.prev;

  /* Stop when cur_match becomes <= limit. To simplify the code,
   * we prevent matches with the string of window index 0.
   */

  var strend = s.strstart + MAX_MATCH;
  var scan_end1 = _win[scan + best_len - 1];
  var scan_end = _win[scan + best_len];

  /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.
   * It is easy to get rid of this optimization if necessary.
   */
  // Assert(s->hash_bits >= 8 && MAX_MATCH == 258, "Code too clever");

  /* Do not waste too much time if we already have a good match: */
  if (s.prev_length >= s.good_match) {
    chain_length >>= 2;
  }
  /* Do not look for matches beyond the end of the input. This is necessary
   * to make deflate deterministic.
   */
  if (nice_match > s.lookahead) {
    nice_match = s.lookahead;
  }

  // Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, "need lookahead");

  do {
    // Assert(cur_match < s->strstart, "no future");
    match = cur_match;

    /* Skip to next match if the match length cannot increase
     * or if the match length is less than 2.  Note that the checks below
     * for insufficient lookahead only occur occasionally for performance
     * reasons.  Therefore uninitialized memory will be accessed, and
     * conditional jumps will be made that depend on those values.
     * However the length of the match is limited to the lookahead, so
     * the output of deflate is not affected by the uninitialized values.
     */

    if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1]) {
      continue;
    }

    /* The check at best_len-1 can be removed because it will be made
     * again later. (This heuristic is not always a win.)
     * It is not necessary to compare scan[2] and match[2] since they
     * are always equal when the other bytes match, given that
     * the hash keys are equal and that HASH_BITS >= 8.
     */
    scan += 2;
    match++;
    // Assert(*scan == *match, "match[2]?");

    /* We check for insufficient lookahead only every 8th comparison;
     * the 256th check will be made at strstart+258.
     */
    do {
      /*jshint noempty:false*/
    } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend);

    // Assert(scan <= s->window+(unsigned)(s->window_size-1), "wild scan");

    len = MAX_MATCH - (strend - scan);
    scan = strend - MAX_MATCH;

    if (len > best_len) {
      s.match_start = cur_match;
      best_len = len;
      if (len >= nice_match) {
        break;
      }
      scan_end1 = _win[scan + best_len - 1];
      scan_end = _win[scan + best_len];
    }
  } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);

  if (best_len <= s.lookahead) {
    return best_len;
  }
  return s.lookahead;
}

/* ===========================================================================
 * Fill the window when the lookahead becomes insufficient.
 * Updates strstart and lookahead.
 *
 * IN assertion: lookahead < MIN_LOOKAHEAD
 * OUT assertions: strstart <= window_size-MIN_LOOKAHEAD
 *    At least one byte has been read, or avail_in == 0; reads are
 *    performed for at least two bytes (required for the zip translate_eol
 *    option -- not supported here).
 */
function fill_window(s) {
  var _w_size = s.w_size;
  var p, n, m, more, str;

  //Assert(s->lookahead < MIN_LOOKAHEAD, "already enough lookahead");

  do {
    more = s.window_size - s.lookahead - s.strstart;

    // JS ints have 32 bit, block below not needed
    /* Deal with !@#$% 64K limit: */
    //if (sizeof(int) <= 2) {
    //    if (more == 0 && s->strstart == 0 && s->lookahead == 0) {
    //        more = wsize;
    //
    //  } else if (more == (unsigned)(-1)) {
    //        /* Very unlikely, but possible on 16 bit machine if
    //         * strstart == 0 && lookahead == 1 (input done a byte at time)
    //         */
    //        more--;
    //    }
    //}

    /* If the window is almost full and there is insufficient lookahead,
     * move the upper half to the lower one to make room in the upper half.
     */
    if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {

      utils.arraySet(s.window, s.window, _w_size, _w_size, 0);
      s.match_start -= _w_size;
      s.strstart -= _w_size;
      /* we now have strstart >= MAX_DIST */
      s.block_start -= _w_size;

      /* Slide the hash table (could be avoided with 32 bit values
       at the expense of memory usage). We slide even when level == 0
       to keep the hash table consistent if we switch back to level > 0
       later. (Using level 0 permanently is not an optimal usage of
       zlib, so we don't care about this pathological case.)
       */

      n = s.hash_size;
      p = n;
      do {
        m = s.head[--p];
        s.head[p] = m >= _w_size ? m - _w_size : 0;
      } while (--n);

      n = _w_size;
      p = n;
      do {
        m = s.prev[--p];
        s.prev[p] = m >= _w_size ? m - _w_size : 0;
        /* If n is not on any hash chain, prev[n] is garbage but
         * its value will never be used.
         */
      } while (--n);

      more += _w_size;
    }
    if (s.strm.avail_in === 0) {
      break;
    }

    /* If there was no sliding:
     *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&
     *    more == window_size - lookahead - strstart
     * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)
     * => more >= window_size - 2*WSIZE + 2
     * In the BIG_MEM or MMAP case (not yet supported),
     *   window_size == input_size + MIN_LOOKAHEAD  &&
     *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.
     * Otherwise, window_size == 2*WSIZE so more >= 2.
     * If there was sliding, more >= WSIZE. So in all cases, more >= 2.
     */
    //Assert(more >= 2, "more < 2");
    n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
    s.lookahead += n;

    /* Initialize the hash value now that we have some input: */
    if (s.lookahead + s.insert >= MIN_MATCH) {
      str = s.strstart - s.insert;
      s.ins_h = s.window[str];

      /* UPDATE_HASH(s, s->ins_h, s->window[str + 1]); */
      s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + 1]) & s.hash_mask;
      //#if MIN_MATCH != 3
      //        Call update_hash() MIN_MATCH-3 more times
      //#endif
      while (s.insert) {
        /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */
        s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;

        s.prev[str & s.w_mask] = s.head[s.ins_h];
        s.head[s.ins_h] = str;
        str++;
        s.insert--;
        if (s.lookahead + s.insert < MIN_MATCH) {
          break;
        }
      }
    }
    /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,
     * but this is not important since only literal bytes will be emitted.
     */
  } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);

  /* If the WIN_INIT bytes after the end of the current data have never been
   * written, then zero those bytes in order to avoid memory check reports of
   * the use of uninitialized (or uninitialised as Julian writes) bytes by
   * the longest match routines.  Update the high water mark for the next
   * time through here.  WIN_INIT is set to MAX_MATCH since the longest match
   * routines allow scanning to strstart + MAX_MATCH, ignoring lookahead.
   */
  //  if (s.high_water < s.window_size) {
  //    var curr = s.strstart + s.lookahead;
  //    var init = 0;
  //
  //    if (s.high_water < curr) {
  //      /* Previous high water mark below current data -- zero WIN_INIT
  //       * bytes or up to end of window, whichever is less.
  //       */
  //      init = s.window_size - curr;
  //      if (init > WIN_INIT)
  //        init = WIN_INIT;
  //      zmemzero(s->window + curr, (unsigned)init);
  //      s->high_water = curr + init;
  //    }
  //    else if (s->high_water < (ulg)curr + WIN_INIT) {
  //      /* High water mark at or above current data, but below current data
  //       * plus WIN_INIT -- zero out to current data plus WIN_INIT, or up
  //       * to end of window, whichever is less.
  //       */
  //      init = (ulg)curr + WIN_INIT - s->high_water;
  //      if (init > s->window_size - s->high_water)
  //        init = s->window_size - s->high_water;
  //      zmemzero(s->window + s->high_water, (unsigned)init);
  //      s->high_water += init;
  //    }
  //  }
  //
  //  Assert((ulg)s->strstart <= s->window_size - MIN_LOOKAHEAD,
  //    "not enough room for search");
}

/* ===========================================================================
 * Copy without compression as much as possible from the input stream, return
 * the current block state.
 * This function does not insert new strings in the dictionary since
 * uncompressible data is probably not useful. This function is used
 * only for the level=0 compression option.
 * NOTE: this function should be optimized to avoid extra copying from
 * window to pending_buf.
 */
function deflate_stored(s, flush) {
  /* Stored blocks are limited to 0xffff bytes, pending_buf is limited
   * to pending_buf_size, and each stored block has a 5 byte header:
   */
  var max_block_size = 0xffff;

  if (max_block_size > s.pending_buf_size - 5) {
    max_block_size = s.pending_buf_size - 5;
  }

  /* Copy as much as possible from input to output: */
  for (;;) {
    /* Fill the window as much as possible: */
    if (s.lookahead <= 1) {

      //Assert(s->strstart < s->w_size+MAX_DIST(s) ||
      //  s->block_start >= (long)s->w_size, "slide too late");
      //      if (!(s.strstart < s.w_size + (s.w_size - MIN_LOOKAHEAD) ||
      //        s.block_start >= s.w_size)) {
      //        throw  new Error("slide too late");
      //      }

      fill_window(s);
      if (s.lookahead === 0 && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }

      if (s.lookahead === 0) {
        break;
      }
      /* flush the current block */
    }
    //Assert(s->block_start >= 0L, "block gone");
    //    if (s.block_start < 0) throw new Error("block gone");

    s.strstart += s.lookahead;
    s.lookahead = 0;

    /* Emit a stored block if pending_buf will be full: */
    var max_start = s.block_start + max_block_size;

    if (s.strstart === 0 || s.strstart >= max_start) {
      /* strstart == 0 is possible when wraparound on 16-bit machine */
      s.lookahead = s.strstart - max_start;
      s.strstart = max_start;
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
    /* Flush if we may have to slide, otherwise block_start may become
     * negative and the data will be gone:
     */
    if (s.strstart - s.block_start >= s.w_size - MIN_LOOKAHEAD) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }

  s.insert = 0;

  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }

  if (s.strstart > s.block_start) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }

  return BS_NEED_MORE;
}

/* ===========================================================================
 * Compress as much as possible from the input stream, return the current
 * block state.
 * This function does not perform lazy evaluation of matches and inserts
 * new strings in the dictionary only for unmatched strings or for short
 * matches. It is used only for the fast compression options.
 */
function deflate_fast(s, flush) {
  var hash_head; /* head of the hash chain */
  var bflush; /* set if current block must be flushed */

  for (;;) {
    /* Make sure that we always have enough lookahead, except
     * at the end of the input file. We need MAX_MATCH bytes
     * for the next match, plus MIN_MATCH bytes to insert the
     * string following the next match.
     */
    if (s.lookahead < MIN_LOOKAHEAD) {
      fill_window(s);
      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break; /* flush the current block */
      }
    }

    /* Insert the string window[strstart .. strstart+2] in the
     * dictionary, and set hash_head to the head of the hash chain:
     */
    hash_head = 0 /*NIL*/;
    if (s.lookahead >= MIN_MATCH) {
      /*** INSERT_STRING(s, s.strstart, hash_head); ***/
      s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
      /***/
    }

    /* Find the longest match, discarding those <= prev_length.
     * At this point we have always match_length < MIN_MATCH
     */
    if (hash_head !== 0 /*NIL*/ && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
      /* To simplify the code, we prevent matches with the string
       * of window index 0 (in particular we have to avoid a match
       * of the string with itself at the start of the input file).
       */
      s.match_length = longest_match(s, hash_head);
      /* longest_match() sets match_start */
    }
    if (s.match_length >= MIN_MATCH) {
      // check_match(s, s.strstart, s.match_start, s.match_length); // for debug only

      /*** _tr_tally_dist(s, s.strstart - s.match_start,
                     s.match_length - MIN_MATCH, bflush); ***/
      bflush = trees._tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);

      s.lookahead -= s.match_length;

      /* Insert new strings in the hash table only if the match length
       * is not too large. This saves time but degrades compression.
       */
      if (s.match_length <= s.max_lazy_match /*max_insert_length*/ && s.lookahead >= MIN_MATCH) {
        s.match_length--; /* string at strstart already in table */
        do {
          s.strstart++;
          /*** INSERT_STRING(s, s.strstart, hash_head); ***/
          s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
          /***/
          /* strstart never exceeds WSIZE-MAX_MATCH, so there are
           * always MIN_MATCH bytes ahead.
           */
        } while (--s.match_length !== 0);
        s.strstart++;
      } else {
        s.strstart += s.match_length;
        s.match_length = 0;
        s.ins_h = s.window[s.strstart];
        /* UPDATE_HASH(s, s.ins_h, s.window[s.strstart+1]); */
        s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + 1]) & s.hash_mask;

        //#if MIN_MATCH != 3
        //                Call UPDATE_HASH() MIN_MATCH-3 more times
        //#endif
        /* If lookahead < MIN_MATCH, ins_h is garbage, but it does not
         * matter since it will be recomputed at next deflate call.
         */
      }
    } else {
      /* No match, output a literal byte */
      //Tracevv((stderr,"%c", s.window[s.strstart]));
      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
      bflush = trees._tr_tally(s, 0, s.window[s.strstart]);

      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }
  s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }
  return BS_BLOCK_DONE;
}

/* ===========================================================================
 * Same as above, but achieves better compression. We use a lazy
 * evaluation for matches: a match is finally adopted only if there is
 * no better match at the next window position.
 */
function deflate_slow(s, flush) {
  var hash_head; /* head of hash chain */
  var bflush; /* set if current block must be flushed */

  var max_insert;

  /* Process the input block. */
  for (;;) {
    /* Make sure that we always have enough lookahead, except
     * at the end of the input file. We need MAX_MATCH bytes
     * for the next match, plus MIN_MATCH bytes to insert the
     * string following the next match.
     */
    if (s.lookahead < MIN_LOOKAHEAD) {
      fill_window(s);
      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break;
      } /* flush the current block */
    }

    /* Insert the string window[strstart .. strstart+2] in the
     * dictionary, and set hash_head to the head of the hash chain:
     */
    hash_head = 0 /*NIL*/;
    if (s.lookahead >= MIN_MATCH) {
      /*** INSERT_STRING(s, s.strstart, hash_head); ***/
      s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
      /***/
    }

    /* Find the longest match, discarding those <= prev_length.
     */
    s.prev_length = s.match_length;
    s.prev_match = s.match_start;
    s.match_length = MIN_MATCH - 1;

    if (hash_head !== 0 /*NIL*/ && s.prev_length < s.max_lazy_match && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD /*MAX_DIST(s)*/) {
        /* To simplify the code, we prevent matches with the string
         * of window index 0 (in particular we have to avoid a match
         * of the string with itself at the start of the input file).
         */
        s.match_length = longest_match(s, hash_head);
        /* longest_match() sets match_start */

        if (s.match_length <= 5 && (s.strategy === Z_FILTERED || s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096 /*TOO_FAR*/)) {

          /* If prev_match is also MIN_MATCH, match_start is garbage
           * but we will ignore the current match anyway.
           */
          s.match_length = MIN_MATCH - 1;
        }
      }
    /* If there was a match at the previous step and the current
     * match is not better, output the previous match:
     */
    if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {
      max_insert = s.strstart + s.lookahead - MIN_MATCH;
      /* Do not insert strings in hash table beyond this. */

      //check_match(s, s.strstart-1, s.prev_match, s.prev_length);

      /***_tr_tally_dist(s, s.strstart - 1 - s.prev_match,
                     s.prev_length - MIN_MATCH, bflush);***/
      bflush = trees._tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);
      /* Insert in hash table all strings up to the end of the match.
       * strstart-1 and strstart are already inserted. If there is not
       * enough lookahead, the last two strings are not inserted in
       * the hash table.
       */
      s.lookahead -= s.prev_length - 1;
      s.prev_length -= 2;
      do {
        if (++s.strstart <= max_insert) {
          /*** INSERT_STRING(s, s.strstart, hash_head); ***/
          s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
          /***/
        }
      } while (--s.prev_length !== 0);
      s.match_available = 0;
      s.match_length = MIN_MATCH - 1;
      s.strstart++;

      if (bflush) {
        /*** FLUSH_BLOCK(s, 0); ***/
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
        /***/
      }
    } else if (s.match_available) {
      /* If there was no match at the previous position, output a
       * single literal. If there was a match but the current match
       * is longer, truncate the previous match to a single literal.
       */
      //Tracevv((stderr,"%c", s->window[s->strstart-1]));
      /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/
      bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);

      if (bflush) {
        /*** FLUSH_BLOCK_ONLY(s, 0) ***/
        flush_block_only(s, false);
        /***/
      }
      s.strstart++;
      s.lookahead--;
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    } else {
      /* There is no previous match to compare with, wait for
       * the next step to decide.
       */
      s.match_available = 1;
      s.strstart++;
      s.lookahead--;
    }
  }
  //Assert (flush != Z_NO_FLUSH, "no flush?");
  if (s.match_available) {
    //Tracevv((stderr,"%c", s->window[s->strstart-1]));
    /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/
    bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);

    s.match_available = 0;
  }
  s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }

  return BS_BLOCK_DONE;
}

/* ===========================================================================
 * For Z_RLE, simply look for runs of bytes, generate matches only of distance
 * one.  Do not maintain a hash table.  (It will be regenerated if this run of
 * deflate switches away from Z_RLE.)
 */
function deflate_rle(s, flush) {
  var bflush; /* set if current block must be flushed */
  var prev; /* byte at distance one to match */
  var scan, strend; /* scan goes up to strend for length of run */

  var _win = s.window;

  for (;;) {
    /* Make sure that we always have enough lookahead, except
     * at the end of the input file. We need MAX_MATCH bytes
     * for the longest run, plus one for the unrolled loop.
     */
    if (s.lookahead <= MAX_MATCH) {
      fill_window(s);
      if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break;
      } /* flush the current block */
    }

    /* See how many times the previous byte repeats */
    s.match_length = 0;
    if (s.lookahead >= MIN_MATCH && s.strstart > 0) {
      scan = s.strstart - 1;
      prev = _win[scan];
      if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
        strend = s.strstart + MAX_MATCH;
        do {
          /*jshint noempty:false*/
        } while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);
        s.match_length = MAX_MATCH - (strend - scan);
        if (s.match_length > s.lookahead) {
          s.match_length = s.lookahead;
        }
      }
      //Assert(scan <= s->window+(uInt)(s->window_size-1), "wild scan");
    }

    /* Emit match if have run of MIN_MATCH or longer, else emit literal */
    if (s.match_length >= MIN_MATCH) {
      //check_match(s, s.strstart, s.strstart - 1, s.match_length);

      /*** _tr_tally_dist(s, 1, s.match_length - MIN_MATCH, bflush); ***/
      bflush = trees._tr_tally(s, 1, s.match_length - MIN_MATCH);

      s.lookahead -= s.match_length;
      s.strstart += s.match_length;
      s.match_length = 0;
    } else {
      /* No match, output a literal byte */
      //Tracevv((stderr,"%c", s->window[s->strstart]));
      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
      bflush = trees._tr_tally(s, 0, s.window[s.strstart]);

      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }
  s.insert = 0;
  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }
  return BS_BLOCK_DONE;
}

/* ===========================================================================
 * For Z_HUFFMAN_ONLY, do not look for matches.  Do not maintain a hash table.
 * (It will be regenerated if this run of deflate switches away from Huffman.)
 */
function deflate_huff(s, flush) {
  var bflush; /* set if current block must be flushed */

  for (;;) {
    /* Make sure that we have a literal to write. */
    if (s.lookahead === 0) {
      fill_window(s);
      if (s.lookahead === 0) {
        if (flush === Z_NO_FLUSH) {
          return BS_NEED_MORE;
        }
        break; /* flush the current block */
      }
    }

    /* Output a literal byte */
    s.match_length = 0;
    //Tracevv((stderr,"%c", s->window[s->strstart]));
    /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
    bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
    s.lookahead--;
    s.strstart++;
    if (bflush) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }
  s.insert = 0;
  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }
  return BS_BLOCK_DONE;
}

/* Values for max_lazy_match, good_match and max_chain_length, depending on
 * the desired pack level (0..9). The values given below have been tuned to
 * exclude worst case performance for pathological files. Better values may be
 * found for specific files.
 */
function Config(good_length, max_lazy, nice_length, max_chain, func) {
  this.good_length = good_length;
  this.max_lazy = max_lazy;
  this.nice_length = nice_length;
  this.max_chain = max_chain;
  this.func = func;
}

var configuration_table;

configuration_table = [
/*      good lazy nice chain */
new Config(0, 0, 0, 0, deflate_stored), /* 0 store only */
new Config(4, 4, 8, 4, deflate_fast), /* 1 max speed, no lazy matches */
new Config(4, 5, 16, 8, deflate_fast), /* 2 */
new Config(4, 6, 32, 32, deflate_fast), /* 3 */

new Config(4, 4, 16, 16, deflate_slow), /* 4 lazy matches */
new Config(8, 16, 32, 32, deflate_slow), /* 5 */
new Config(8, 16, 128, 128, deflate_slow), /* 6 */
new Config(8, 32, 128, 256, deflate_slow), /* 7 */
new Config(32, 128, 258, 1024, deflate_slow), /* 8 */
new Config(32, 258, 258, 4096, deflate_slow) /* 9 max compression */
];

/* ===========================================================================
 * Initialize the "longest match" routines for a new zlib stream
 */
function lm_init(s) {
  s.window_size = 2 * s.w_size;

  /*** CLEAR_HASH(s); ***/
  zero(s.head); // Fill with NIL (= 0);

  /* Set the default configuration parameters:
   */
  s.max_lazy_match = configuration_table[s.level].max_lazy;
  s.good_match = configuration_table[s.level].good_length;
  s.nice_match = configuration_table[s.level].nice_length;
  s.max_chain_length = configuration_table[s.level].max_chain;

  s.strstart = 0;
  s.block_start = 0;
  s.lookahead = 0;
  s.insert = 0;
  s.match_length = s.prev_length = MIN_MATCH - 1;
  s.match_available = 0;
  s.ins_h = 0;
}

function DeflateState() {
  this.strm = null; /* pointer back to this zlib stream */
  this.status = 0; /* as the name implies */
  this.pending_buf = null; /* output still pending */
  this.pending_buf_size = 0; /* size of pending_buf */
  this.pending_out = 0; /* next pending byte to output to the stream */
  this.pending = 0; /* nb of bytes in the pending buffer */
  this.wrap = 0; /* bit 0 true for zlib, bit 1 true for gzip */
  this.gzhead = null; /* gzip header information to write */
  this.gzindex = 0; /* where in extra, name, or comment */
  this.method = Z_DEFLATED; /* can only be DEFLATED */
  this.last_flush = -1; /* value of flush param for previous deflate call */

  this.w_size = 0; /* LZ77 window size (32K by default) */
  this.w_bits = 0; /* log2(w_size)  (8..16) */
  this.w_mask = 0; /* w_size - 1 */

  this.window = null;
  /* Sliding window. Input bytes are read into the second half of the window,
   * and move to the first half later to keep a dictionary of at least wSize
   * bytes. With this organization, matches are limited to a distance of
   * wSize-MAX_MATCH bytes, but this ensures that IO is always
   * performed with a length multiple of the block size.
   */

  this.window_size = 0;
  /* Actual size of window: 2*wSize, except when the user input buffer
   * is directly used as sliding window.
   */

  this.prev = null;
  /* Link to older string with same hash index. To limit the size of this
   * array to 64K, this link is maintained only for the last 32K strings.
   * An index in this array is thus a window index modulo 32K.
   */

  this.head = null; /* Heads of the hash chains or NIL. */

  this.ins_h = 0; /* hash index of string to be inserted */
  this.hash_size = 0; /* number of elements in hash table */
  this.hash_bits = 0; /* log2(hash_size) */
  this.hash_mask = 0; /* hash_size-1 */

  this.hash_shift = 0;
  /* Number of bits by which ins_h must be shifted at each input
   * step. It must be such that after MIN_MATCH steps, the oldest
   * byte no longer takes part in the hash key, that is:
   *   hash_shift * MIN_MATCH >= hash_bits
   */

  this.block_start = 0;
  /* Window position at the beginning of the current output block. Gets
   * negative when the window is moved backwards.
   */

  this.match_length = 0; /* length of best match */
  this.prev_match = 0; /* previous match */
  this.match_available = 0; /* set if previous match exists */
  this.strstart = 0; /* start of string to insert */
  this.match_start = 0; /* start of matching string */
  this.lookahead = 0; /* number of valid bytes ahead in window */

  this.prev_length = 0;
  /* Length of the best match at previous step. Matches not greater than this
   * are discarded. This is used in the lazy match evaluation.
   */

  this.max_chain_length = 0;
  /* To speed up deflation, hash chains are never searched beyond this
   * length.  A higher limit improves compression ratio but degrades the
   * speed.
   */

  this.max_lazy_match = 0;
  /* Attempt to find a better match only when the current match is strictly
   * smaller than this value. This mechanism is used only for compression
   * levels >= 4.
   */
  // That's alias to max_lazy_match, don't use directly
  //this.max_insert_length = 0;
  /* Insert new strings in the hash table only if the match length is not
   * greater than this length. This saves time but degrades compression.
   * max_insert_length is used only for compression levels <= 3.
   */

  this.level = 0; /* compression level (1..9) */
  this.strategy = 0; /* favor or force Huffman coding*/

  this.good_match = 0;
  /* Use a faster search when the previous match is longer than this */

  this.nice_match = 0; /* Stop searching when current match exceeds this */

  /* used by trees.c: */

  /* Didn't use ct_data typedef below to suppress compiler warning */

  // struct ct_data_s dyn_ltree[HEAP_SIZE];   /* literal and length tree */
  // struct ct_data_s dyn_dtree[2*D_CODES+1]; /* distance tree */
  // struct ct_data_s bl_tree[2*BL_CODES+1];  /* Huffman tree for bit lengths */

  // Use flat array of DOUBLE size, with interleaved fata,
  // because JS does not support effective
  this.dyn_ltree = new utils.Buf16(HEAP_SIZE * 2);
  this.dyn_dtree = new utils.Buf16((2 * D_CODES + 1) * 2);
  this.bl_tree = new utils.Buf16((2 * BL_CODES + 1) * 2);
  zero(this.dyn_ltree);
  zero(this.dyn_dtree);
  zero(this.bl_tree);

  this.l_desc = null; /* desc. for literal tree */
  this.d_desc = null; /* desc. for distance tree */
  this.bl_desc = null; /* desc. for bit length tree */

  //ush bl_count[MAX_BITS+1];
  this.bl_count = new utils.Buf16(MAX_BITS + 1);
  /* number of codes at each bit length for an optimal tree */

  //int heap[2*L_CODES+1];      /* heap used to build the Huffman trees */
  this.heap = new utils.Buf16(2 * L_CODES + 1); /* heap used to build the Huffman trees */
  zero(this.heap);

  this.heap_len = 0; /* number of elements in the heap */
  this.heap_max = 0; /* element of largest frequency */
  /* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.
   * The same heap array is used to build all trees.
   */

  this.depth = new utils.Buf16(2 * L_CODES + 1); //uch depth[2*L_CODES+1];
  zero(this.depth);
  /* Depth of each subtree used as tie breaker for trees of equal frequency
   */

  this.l_buf = 0; /* buffer index for literals or lengths */

  this.lit_bufsize = 0;
  /* Size of match buffer for literals/lengths.  There are 4 reasons for
   * limiting lit_bufsize to 64K:
   *   - frequencies can be kept in 16 bit counters
   *   - if compression is not successful for the first block, all input
   *     data is still in the window so we can still emit a stored block even
   *     when input comes from standard input.  (This can also be done for
   *     all blocks if lit_bufsize is not greater than 32K.)
   *   - if compression is not successful for a file smaller than 64K, we can
   *     even emit a stored file instead of a stored block (saving 5 bytes).
   *     This is applicable only for zip (not gzip or zlib).
   *   - creating new Huffman trees less frequently may not provide fast
   *     adaptation to changes in the input data statistics. (Take for
   *     example a binary file with poorly compressible code followed by
   *     a highly compressible string table.) Smaller buffer sizes give
   *     fast adaptation but have of course the overhead of transmitting
   *     trees more frequently.
   *   - I can't count above 4
   */

  this.last_lit = 0; /* running index in l_buf */

  this.d_buf = 0;
  /* Buffer index for distances. To simplify the code, d_buf and l_buf have
   * the same number of elements. To use different lengths, an extra flag
   * array would be necessary.
   */

  this.opt_len = 0; /* bit length of current block with optimal trees */
  this.static_len = 0; /* bit length of current block with static trees */
  this.matches = 0; /* number of string matches in current block */
  this.insert = 0; /* bytes at end of window left to insert */

  this.bi_buf = 0;
  /* Output buffer. bits are inserted starting at the bottom (least
   * significant bits).
   */
  this.bi_valid = 0;
  /* Number of valid bits in bi_buf.  All bits above the last valid bit
   * are always zero.
   */

  // Used for window memory init. We safely ignore it for JS. That makes
  // sense only for pointers and memory check tools.
  //this.high_water = 0;
  /* High water mark offset in window for initialized bytes -- bytes above
   * this are set to zero in order to avoid memory check warnings when
   * longest match routines access bytes past the input.  This is then
   * updated to the new high water mark.
   */
}

function deflateResetKeep(strm) {
  var s;

  if (!strm || !strm.state) {
    return err(strm, Z_STREAM_ERROR);
  }

  strm.total_in = strm.total_out = 0;
  strm.data_type = Z_UNKNOWN;

  s = strm.state;
  s.pending = 0;
  s.pending_out = 0;

  if (s.wrap < 0) {
    s.wrap = -s.wrap;
    /* was made negative by deflate(..., Z_FINISH); */
  }
  s.status = s.wrap ? INIT_STATE : BUSY_STATE;
  strm.adler = s.wrap === 2 ? 0 // crc32(0, Z_NULL, 0)
  : 1; // adler32(0, Z_NULL, 0)
  s.last_flush = Z_NO_FLUSH;
  trees._tr_init(s);
  return Z_OK;
}

function deflateReset(strm) {
  var ret = deflateResetKeep(strm);
  if (ret === Z_OK) {
    lm_init(strm.state);
  }
  return ret;
}

function deflateSetHeader(strm, head) {
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR;
  }
  if (strm.state.wrap !== 2) {
    return Z_STREAM_ERROR;
  }
  strm.state.gzhead = head;
  return Z_OK;
}

function deflateInit2(strm, level, method, windowBits, memLevel, strategy) {
  if (!strm) {
    // === Z_NULL
    return Z_STREAM_ERROR;
  }
  var wrap = 1;

  if (level === Z_DEFAULT_COMPRESSION) {
    level = 6;
  }

  if (windowBits < 0) {
    /* suppress zlib wrapper */
    wrap = 0;
    windowBits = -windowBits;
  } else if (windowBits > 15) {
    wrap = 2; /* write gzip wrapper instead */
    windowBits -= 16;
  }

  if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED) {
    return err(strm, Z_STREAM_ERROR);
  }

  if (windowBits === 8) {
    windowBits = 9;
  }
  /* until 256-byte window bug fixed */

  var s = new DeflateState();

  strm.state = s;
  s.strm = strm;

  s.wrap = wrap;
  s.gzhead = null;
  s.w_bits = windowBits;
  s.w_size = 1 << s.w_bits;
  s.w_mask = s.w_size - 1;

  s.hash_bits = memLevel + 7;
  s.hash_size = 1 << s.hash_bits;
  s.hash_mask = s.hash_size - 1;
  s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);

  s.window = new utils.Buf8(s.w_size * 2);
  s.head = new utils.Buf16(s.hash_size);
  s.prev = new utils.Buf16(s.w_size);

  // Don't need mem init magic for JS.
  //s.high_water = 0;  /* nothing written to s->window yet */

  s.lit_bufsize = 1 << memLevel + 6; /* 16K elements by default */

  s.pending_buf_size = s.lit_bufsize * 4;
  s.pending_buf = new utils.Buf8(s.pending_buf_size);

  s.d_buf = s.lit_bufsize >> 1;
  s.l_buf = (1 + 2) * s.lit_bufsize;

  s.level = level;
  s.strategy = strategy;
  s.method = method;

  return deflateReset(strm);
}

function deflateInit(strm, level) {
  return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);
}

function deflate(strm, flush) {
  var old_flush, s;
  var beg, val; // for gzip header write only

  if (!strm || !strm.state || flush > Z_BLOCK || flush < 0) {
    return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;
  }

  s = strm.state;

  if (!strm.output || !strm.input && strm.avail_in !== 0 || s.status === FINISH_STATE && flush !== Z_FINISH) {
    return err(strm, strm.avail_out === 0 ? Z_BUF_ERROR : Z_STREAM_ERROR);
  }

  s.strm = strm; /* just in case */
  old_flush = s.last_flush;
  s.last_flush = flush;

  /* Write the header */
  if (s.status === INIT_STATE) {

    if (s.wrap === 2) {
      // GZIP header
      strm.adler = 0; //crc32(0L, Z_NULL, 0);
      put_byte(s, 31);
      put_byte(s, 139);
      put_byte(s, 8);
      if (!s.gzhead) {
        // s->gzhead == Z_NULL
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
        put_byte(s, OS_CODE);
        s.status = BUSY_STATE;
      } else {
        put_byte(s, (s.gzhead.text ? 1 : 0) + (s.gzhead.hcrc ? 2 : 0) + (!s.gzhead.extra ? 0 : 4) + (!s.gzhead.name ? 0 : 8) + (!s.gzhead.comment ? 0 : 16));
        put_byte(s, s.gzhead.time & 0xff);
        put_byte(s, s.gzhead.time >> 8 & 0xff);
        put_byte(s, s.gzhead.time >> 16 & 0xff);
        put_byte(s, s.gzhead.time >> 24 & 0xff);
        put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
        put_byte(s, s.gzhead.os & 0xff);
        if (s.gzhead.extra && s.gzhead.extra.length) {
          put_byte(s, s.gzhead.extra.length & 0xff);
          put_byte(s, s.gzhead.extra.length >> 8 & 0xff);
        }
        if (s.gzhead.hcrc) {
          strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0);
        }
        s.gzindex = 0;
        s.status = EXTRA_STATE;
      }
    } else // DEFLATE header
      {
        var header = Z_DEFLATED + (s.w_bits - 8 << 4) << 8;
        var level_flags = -1;

        if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
          level_flags = 0;
        } else if (s.level < 6) {
          level_flags = 1;
        } else if (s.level === 6) {
          level_flags = 2;
        } else {
          level_flags = 3;
        }
        header |= level_flags << 6;
        if (s.strstart !== 0) {
          header |= PRESET_DICT;
        }
        header += 31 - header % 31;

        s.status = BUSY_STATE;
        putShortMSB(s, header);

        /* Save the adler32 of the preset dictionary: */
        if (s.strstart !== 0) {
          putShortMSB(s, strm.adler >>> 16);
          putShortMSB(s, strm.adler & 0xffff);
        }
        strm.adler = 1; // adler32(0L, Z_NULL, 0);
      }
  }

  //#ifdef GZIP
  if (s.status === EXTRA_STATE) {
    if (s.gzhead.extra /* != Z_NULL*/) {
        beg = s.pending; /* start of bytes to update crc */

        while (s.gzindex < (s.gzhead.extra.length & 0xffff)) {
          if (s.pending === s.pending_buf_size) {
            if (s.gzhead.hcrc && s.pending > beg) {
              strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
            }
            flush_pending(strm);
            beg = s.pending;
            if (s.pending === s.pending_buf_size) {
              break;
            }
          }
          put_byte(s, s.gzhead.extra[s.gzindex] & 0xff);
          s.gzindex++;
        }
        if (s.gzhead.hcrc && s.pending > beg) {
          strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
        }
        if (s.gzindex === s.gzhead.extra.length) {
          s.gzindex = 0;
          s.status = NAME_STATE;
        }
      } else {
      s.status = NAME_STATE;
    }
  }
  if (s.status === NAME_STATE) {
    if (s.gzhead.name /* != Z_NULL*/) {
        beg = s.pending; /* start of bytes to update crc */
        //int val;

        do {
          if (s.pending === s.pending_buf_size) {
            if (s.gzhead.hcrc && s.pending > beg) {
              strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
            }
            flush_pending(strm);
            beg = s.pending;
            if (s.pending === s.pending_buf_size) {
              val = 1;
              break;
            }
          }
          // JS specific: little magic to add zero terminator to end of string
          if (s.gzindex < s.gzhead.name.length) {
            val = s.gzhead.name.charCodeAt(s.gzindex++) & 0xff;
          } else {
            val = 0;
          }
          put_byte(s, val);
        } while (val !== 0);

        if (s.gzhead.hcrc && s.pending > beg) {
          strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
        }
        if (val === 0) {
          s.gzindex = 0;
          s.status = COMMENT_STATE;
        }
      } else {
      s.status = COMMENT_STATE;
    }
  }
  if (s.status === COMMENT_STATE) {
    if (s.gzhead.comment /* != Z_NULL*/) {
        beg = s.pending; /* start of bytes to update crc */
        //int val;

        do {
          if (s.pending === s.pending_buf_size) {
            if (s.gzhead.hcrc && s.pending > beg) {
              strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
            }
            flush_pending(strm);
            beg = s.pending;
            if (s.pending === s.pending_buf_size) {
              val = 1;
              break;
            }
          }
          // JS specific: little magic to add zero terminator to end of string
          if (s.gzindex < s.gzhead.comment.length) {
            val = s.gzhead.comment.charCodeAt(s.gzindex++) & 0xff;
          } else {
            val = 0;
          }
          put_byte(s, val);
        } while (val !== 0);

        if (s.gzhead.hcrc && s.pending > beg) {
          strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
        }
        if (val === 0) {
          s.status = HCRC_STATE;
        }
      } else {
      s.status = HCRC_STATE;
    }
  }
  if (s.status === HCRC_STATE) {
    if (s.gzhead.hcrc) {
      if (s.pending + 2 > s.pending_buf_size) {
        flush_pending(strm);
      }
      if (s.pending + 2 <= s.pending_buf_size) {
        put_byte(s, strm.adler & 0xff);
        put_byte(s, strm.adler >> 8 & 0xff);
        strm.adler = 0; //crc32(0L, Z_NULL, 0);
        s.status = BUSY_STATE;
      }
    } else {
      s.status = BUSY_STATE;
    }
  }
  //#endif

  /* Flush as much pending output as possible */
  if (s.pending !== 0) {
    flush_pending(strm);
    if (strm.avail_out === 0) {
      /* Since avail_out is 0, deflate will be called again with
       * more output space, but possibly with both pending and
       * avail_in equal to zero. There won't be anything to do,
       * but this is not an error situation so make sure we
       * return OK instead of BUF_ERROR at next call of deflate:
       */
      s.last_flush = -1;
      return Z_OK;
    }

    /* Make sure there is something to do and avoid duplicate consecutive
     * flushes. For repeated and useless calls with Z_FINISH, we keep
     * returning Z_STREAM_END instead of Z_BUF_ERROR.
     */
  } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) && flush !== Z_FINISH) {
    return err(strm, Z_BUF_ERROR);
  }

  /* User must not provide more input after the first FINISH: */
  if (s.status === FINISH_STATE && strm.avail_in !== 0) {
    return err(strm, Z_BUF_ERROR);
  }

  /* Start a new block or continue the current one.
   */
  if (strm.avail_in !== 0 || s.lookahead !== 0 || flush !== Z_NO_FLUSH && s.status !== FINISH_STATE) {
    var bstate = s.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s, flush) : s.strategy === Z_RLE ? deflate_rle(s, flush) : configuration_table[s.level].func(s, flush);

    if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
      s.status = FINISH_STATE;
    }
    if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
      if (strm.avail_out === 0) {
        s.last_flush = -1;
        /* avoid BUF_ERROR next call, see above */
      }
      return Z_OK;
      /* If flush != Z_NO_FLUSH && avail_out == 0, the next call
       * of deflate should use the same flush parameter to make sure
       * that the flush is complete. So we don't have to output an
       * empty block here, this will be done at next call. This also
       * ensures that for a very small output buffer, we emit at most
       * one empty block.
       */
    }
    if (bstate === BS_BLOCK_DONE) {
      if (flush === Z_PARTIAL_FLUSH) {
        trees._tr_align(s);
      } else if (flush !== Z_BLOCK) {
        /* FULL_FLUSH or SYNC_FLUSH */

        trees._tr_stored_block(s, 0, 0, false);
        /* For a full flush, this empty block will be recognized
         * as a special marker by inflate_sync().
         */
        if (flush === Z_FULL_FLUSH) {
          /*** CLEAR_HASH(s); ***/ /* forget history */
          zero(s.head); // Fill with NIL (= 0);

          if (s.lookahead === 0) {
            s.strstart = 0;
            s.block_start = 0;
            s.insert = 0;
          }
        }
      }
      flush_pending(strm);
      if (strm.avail_out === 0) {
        s.last_flush = -1; /* avoid BUF_ERROR at next call, see above */
        return Z_OK;
      }
    }
  }
  //Assert(strm->avail_out > 0, "bug2");
  //if (strm.avail_out <= 0) { throw new Error("bug2");}

  if (flush !== Z_FINISH) {
    return Z_OK;
  }
  if (s.wrap <= 0) {
    return Z_STREAM_END;
  }

  /* Write the trailer */
  if (s.wrap === 2) {
    put_byte(s, strm.adler & 0xff);
    put_byte(s, strm.adler >> 8 & 0xff);
    put_byte(s, strm.adler >> 16 & 0xff);
    put_byte(s, strm.adler >> 24 & 0xff);
    put_byte(s, strm.total_in & 0xff);
    put_byte(s, strm.total_in >> 8 & 0xff);
    put_byte(s, strm.total_in >> 16 & 0xff);
    put_byte(s, strm.total_in >> 24 & 0xff);
  } else {
    putShortMSB(s, strm.adler >>> 16);
    putShortMSB(s, strm.adler & 0xffff);
  }

  flush_pending(strm);
  /* If avail_out is zero, the application will call deflate again
   * to flush the rest.
   */
  if (s.wrap > 0) {
    s.wrap = -s.wrap;
  }
  /* write the trailer only once! */
  return s.pending !== 0 ? Z_OK : Z_STREAM_END;
}

function deflateEnd(strm) {
  var status;

  if (!strm /*== Z_NULL*/ || !strm.state /*== Z_NULL*/) {
      return Z_STREAM_ERROR;
    }

  status = strm.state.status;
  if (status !== INIT_STATE && status !== EXTRA_STATE && status !== NAME_STATE && status !== COMMENT_STATE && status !== HCRC_STATE && status !== BUSY_STATE && status !== FINISH_STATE) {
    return err(strm, Z_STREAM_ERROR);
  }

  strm.state = null;

  return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;
}

/* =========================================================================
 * Initializes the compression dictionary from the given byte
 * sequence without producing any compressed output.
 */
function deflateSetDictionary(strm, dictionary) {
  var dictLength = dictionary.length;

  var s;
  var str, n;
  var wrap;
  var avail;
  var next;
  var input;
  var tmpDict;

  if (!strm /*== Z_NULL*/ || !strm.state /*== Z_NULL*/) {
      return Z_STREAM_ERROR;
    }

  s = strm.state;
  wrap = s.wrap;

  if (wrap === 2 || wrap === 1 && s.status !== INIT_STATE || s.lookahead) {
    return Z_STREAM_ERROR;
  }

  /* when using zlib wrappers, compute Adler-32 for provided dictionary */
  if (wrap === 1) {
    /* adler32(strm->adler, dictionary, dictLength); */
    strm.adler = adler32(strm.adler, dictionary, dictLength, 0);
  }

  s.wrap = 0; /* avoid computing Adler-32 in read_buf */

  /* if dictionary would fill window, just replace the history */
  if (dictLength >= s.w_size) {
    if (wrap === 0) {
      /* already empty otherwise */
      /*** CLEAR_HASH(s); ***/
      zero(s.head); // Fill with NIL (= 0);
      s.strstart = 0;
      s.block_start = 0;
      s.insert = 0;
    }
    /* use the tail */
    // dictionary = dictionary.slice(dictLength - s.w_size);
    tmpDict = new utils.Buf8(s.w_size);
    utils.arraySet(tmpDict, dictionary, dictLength - s.w_size, s.w_size, 0);
    dictionary = tmpDict;
    dictLength = s.w_size;
  }
  /* insert dictionary into window and hash */
  avail = strm.avail_in;
  next = strm.next_in;
  input = strm.input;
  strm.avail_in = dictLength;
  strm.next_in = 0;
  strm.input = dictionary;
  fill_window(s);
  while (s.lookahead >= MIN_MATCH) {
    str = s.strstart;
    n = s.lookahead - (MIN_MATCH - 1);
    do {
      /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */
      s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;

      s.prev[str & s.w_mask] = s.head[s.ins_h];

      s.head[s.ins_h] = str;
      str++;
    } while (--n);
    s.strstart = str;
    s.lookahead = MIN_MATCH - 1;
    fill_window(s);
  }
  s.strstart += s.lookahead;
  s.block_start = s.strstart;
  s.insert = s.lookahead;
  s.lookahead = 0;
  s.match_length = s.prev_length = MIN_MATCH - 1;
  s.match_available = 0;
  strm.next_in = next;
  strm.input = input;
  strm.avail_in = avail;
  s.wrap = wrap;
  return Z_OK;
}

exports.deflateInit = deflateInit;
exports.deflateInit2 = deflateInit2;
exports.deflateReset = deflateReset;
exports.deflateResetKeep = deflateResetKeep;
exports.deflateSetHeader = deflateSetHeader;
exports.deflate = deflate;
exports.deflateEnd = deflateEnd;
exports.deflateSetDictionary = deflateSetDictionary;
exports.deflateInfo = 'pako deflate (from Nodeca project)';

/* Not implemented
exports.deflateBound = deflateBound;
exports.deflateCopy = deflateCopy;
exports.deflateParams = deflateParams;
exports.deflatePending = deflatePending;
exports.deflatePrime = deflatePrime;
exports.deflateTune = deflateTune;
*/

},{"../utils/common":40,"./adler32":42,"./crc32":44,"./messages":50,"./trees":51}],46:[function(require,module,exports){
'use strict';

function GZheader() {
  /* true if compressed data believed to be text */
  this.text = 0;
  /* modification time */
  this.time = 0;
  /* extra flags (not used when writing a gzip file) */
  this.xflags = 0;
  /* operating system */
  this.os = 0;
  /* pointer to extra field or Z_NULL if none */
  this.extra = null;
  /* extra field length (valid if extra != Z_NULL) */
  this.extra_len = 0; // Actually, we don't need it in JS,
  // but leave for few code modifications

  //
  // Setup limits is not necessary because in js we should not preallocate memory
  // for inflate use constant limit in 65536 bytes
  //

  /* space at extra (only when reading header) */
  // this.extra_max  = 0;
  /* pointer to zero-terminated file name or Z_NULL */
  this.name = '';
  /* space at name (only when reading header) */
  // this.name_max   = 0;
  /* pointer to zero-terminated comment or Z_NULL */
  this.comment = '';
  /* space at comment (only when reading header) */
  // this.comm_max   = 0;
  /* true if there was or will be a header crc */
  this.hcrc = 0;
  /* true when done reading gzip header (not used when writing a gzip file) */
  this.done = false;
}

module.exports = GZheader;

},{}],47:[function(require,module,exports){
'use strict';

// See state defs from inflate.js

var BAD = 30; /* got a data error -- remain here until reset */
var TYPE = 12; /* i: waiting for type bits, including last-flag bit */

/*
   Decode literal, length, and distance codes and write out the resulting
   literal and match bytes until either not enough input or output is
   available, an end-of-block is encountered, or a data error is encountered.
   When large enough input and output buffers are supplied to inflate(), for
   example, a 16K input buffer and a 64K output buffer, more than 95% of the
   inflate execution time is spent in this routine.

   Entry assumptions:

        state.mode === LEN
        strm.avail_in >= 6
        strm.avail_out >= 258
        start >= strm.avail_out
        state.bits < 8

   On return, state.mode is one of:

        LEN -- ran out of enough output space or enough available input
        TYPE -- reached end of block code, inflate() to interpret next block
        BAD -- error in block data

   Notes:

    - The maximum input bits used by a length/distance pair is 15 bits for the
      length code, 5 bits for the length extra, 15 bits for the distance code,
      and 13 bits for the distance extra.  This totals 48 bits, or six bytes.
      Therefore if strm.avail_in >= 6, then there is enough input to avoid
      checking for available input while decoding.

    - The maximum bytes that a single length/distance pair can output is 258
      bytes, which is the maximum length that can be coded.  inflate_fast()
      requires strm.avail_out >= 258 for each loop to avoid checking for
      output space.
 */
module.exports = function inflate_fast(strm, start) {
  var state;
  var _in; /* local strm.input */
  var last; /* have enough input while in < last */
  var _out; /* local strm.output */
  var beg; /* inflate()'s initial strm.output */
  var end; /* while out < end, enough space available */
  //#ifdef INFLATE_STRICT
  var dmax; /* maximum distance from zlib header */
  //#endif
  var wsize; /* window size or zero if not using window */
  var whave; /* valid bytes in the window */
  var wnext; /* window write index */
  // Use `s_window` instead `window`, avoid conflict with instrumentation tools
  var s_window; /* allocated sliding window, if wsize != 0 */
  var hold; /* local strm.hold */
  var bits; /* local strm.bits */
  var lcode; /* local strm.lencode */
  var dcode; /* local strm.distcode */
  var lmask; /* mask for first level of length codes */
  var dmask; /* mask for first level of distance codes */
  var here; /* retrieved table entry */
  var op; /* code bits, operation, extra bits, or */
  /*  window position, window bytes to copy */
  var len; /* match length, unused bytes */
  var dist; /* match distance */
  var from; /* where to copy match from */
  var from_source;

  var input, output; // JS specific, because we have no pointers

  /* copy state to local variables */
  state = strm.state;
  //here = state.here;
  _in = strm.next_in;
  input = strm.input;
  last = _in + (strm.avail_in - 5);
  _out = strm.next_out;
  output = strm.output;
  beg = _out - (start - strm.avail_out);
  end = _out + (strm.avail_out - 257);
  //#ifdef INFLATE_STRICT
  dmax = state.dmax;
  //#endif
  wsize = state.wsize;
  whave = state.whave;
  wnext = state.wnext;
  s_window = state.window;
  hold = state.hold;
  bits = state.bits;
  lcode = state.lencode;
  dcode = state.distcode;
  lmask = (1 << state.lenbits) - 1;
  dmask = (1 << state.distbits) - 1;

  /* decode literals and length/distances until end-of-block or not enough
     input data or output space */

  top: do {
    if (bits < 15) {
      hold += input[_in++] << bits;
      bits += 8;
      hold += input[_in++] << bits;
      bits += 8;
    }

    here = lcode[hold & lmask];

    dolen: for (;;) {
      // Goto emulation
      op = here >>> 24 /*here.bits*/;
      hold >>>= op;
      bits -= op;
      op = here >>> 16 & 0xff /*here.op*/;
      if (op === 0) {
        /* literal */
        //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
        //        "inflate:         literal '%c'\n" :
        //        "inflate:         literal 0x%02x\n", here.val));
        output[_out++] = here & 0xffff /*here.val*/;
      } else if (op & 16) {
        /* length base */
        len = here & 0xffff /*here.val*/;
        op &= 15; /* number of extra bits */
        if (op) {
          if (bits < op) {
            hold += input[_in++] << bits;
            bits += 8;
          }
          len += hold & (1 << op) - 1;
          hold >>>= op;
          bits -= op;
        }
        //Tracevv((stderr, "inflate:         length %u\n", len));
        if (bits < 15) {
          hold += input[_in++] << bits;
          bits += 8;
          hold += input[_in++] << bits;
          bits += 8;
        }
        here = dcode[hold & dmask];

        dodist: for (;;) {
          // goto emulation
          op = here >>> 24 /*here.bits*/;
          hold >>>= op;
          bits -= op;
          op = here >>> 16 & 0xff /*here.op*/;

          if (op & 16) {
            /* distance base */
            dist = here & 0xffff /*here.val*/;
            op &= 15; /* number of extra bits */
            if (bits < op) {
              hold += input[_in++] << bits;
              bits += 8;
              if (bits < op) {
                hold += input[_in++] << bits;
                bits += 8;
              }
            }
            dist += hold & (1 << op) - 1;
            //#ifdef INFLATE_STRICT
            if (dist > dmax) {
              strm.msg = 'invalid distance too far back';
              state.mode = BAD;
              break top;
            }
            //#endif
            hold >>>= op;
            bits -= op;
            //Tracevv((stderr, "inflate:         distance %u\n", dist));
            op = _out - beg; /* max distance in output */
            if (dist > op) {
              /* see if copy from window */
              op = dist - op; /* distance back in window */
              if (op > whave) {
                if (state.sane) {
                  strm.msg = 'invalid distance too far back';
                  state.mode = BAD;
                  break top;
                }

                // (!) This block is disabled in zlib defailts,
                // don't enable it for binary compatibility
                //#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
                //                if (len <= op - whave) {
                //                  do {
                //                    output[_out++] = 0;
                //                  } while (--len);
                //                  continue top;
                //                }
                //                len -= op - whave;
                //                do {
                //                  output[_out++] = 0;
                //                } while (--op > whave);
                //                if (op === 0) {
                //                  from = _out - dist;
                //                  do {
                //                    output[_out++] = output[from++];
                //                  } while (--len);
                //                  continue top;
                //                }
                //#endif
              }
              from = 0; // window index
              from_source = s_window;
              if (wnext === 0) {
                /* very common case */
                from += wsize - op;
                if (op < len) {
                  /* some from window */
                  len -= op;
                  do {
                    output[_out++] = s_window[from++];
                  } while (--op);
                  from = _out - dist; /* rest from output */
                  from_source = output;
                }
              } else if (wnext < op) {
                /* wrap around window */
                from += wsize + wnext - op;
                op -= wnext;
                if (op < len) {
                  /* some from end of window */
                  len -= op;
                  do {
                    output[_out++] = s_window[from++];
                  } while (--op);
                  from = 0;
                  if (wnext < len) {
                    /* some from start of window */
                    op = wnext;
                    len -= op;
                    do {
                      output[_out++] = s_window[from++];
                    } while (--op);
                    from = _out - dist; /* rest from output */
                    from_source = output;
                  }
                }
              } else {
                /* contiguous in window */
                from += wnext - op;
                if (op < len) {
                  /* some from window */
                  len -= op;
                  do {
                    output[_out++] = s_window[from++];
                  } while (--op);
                  from = _out - dist; /* rest from output */
                  from_source = output;
                }
              }
              while (len > 2) {
                output[_out++] = from_source[from++];
                output[_out++] = from_source[from++];
                output[_out++] = from_source[from++];
                len -= 3;
              }
              if (len) {
                output[_out++] = from_source[from++];
                if (len > 1) {
                  output[_out++] = from_source[from++];
                }
              }
            } else {
              from = _out - dist; /* copy direct from output */
              do {
                /* minimum length is three */
                output[_out++] = output[from++];
                output[_out++] = output[from++];
                output[_out++] = output[from++];
                len -= 3;
              } while (len > 2);
              if (len) {
                output[_out++] = output[from++];
                if (len > 1) {
                  output[_out++] = output[from++];
                }
              }
            }
          } else if ((op & 64) === 0) {
            /* 2nd level distance code */
            here = dcode[(here & 0xffff) + ( /*here.val*/hold & (1 << op) - 1)];
            continue dodist;
          } else {
            strm.msg = 'invalid distance code';
            state.mode = BAD;
            break top;
          }

          break; // need to emulate goto via "continue"
        }
      } else if ((op & 64) === 0) {
        /* 2nd level length code */
        here = lcode[(here & 0xffff) + ( /*here.val*/hold & (1 << op) - 1)];
        continue dolen;
      } else if (op & 32) {
        /* end-of-block */
        //Tracevv((stderr, "inflate:         end of block\n"));
        state.mode = TYPE;
        break top;
      } else {
        strm.msg = 'invalid literal/length code';
        state.mode = BAD;
        break top;
      }

      break; // need to emulate goto via "continue"
    }
  } while (_in < last && _out < end);

  /* return unused bytes (on entry, bits < 8, so in won't go too far back) */
  len = bits >> 3;
  _in -= len;
  bits -= len << 3;
  hold &= (1 << bits) - 1;

  /* update state and return */
  strm.next_in = _in;
  strm.next_out = _out;
  strm.avail_in = _in < last ? 5 + (last - _in) : 5 - (_in - last);
  strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);
  state.hold = hold;
  state.bits = bits;
  return;
};

},{}],48:[function(require,module,exports){
'use strict';

var utils = require('../utils/common');
var adler32 = require('./adler32');
var crc32 = require('./crc32');
var inflate_fast = require('./inffast');
var inflate_table = require('./inftrees');

var CODES = 0;
var LENS = 1;
var DISTS = 2;

/* Public constants ==========================================================*/
/* ===========================================================================*/

/* Allowed flush values; see deflate() and inflate() below for details */
//var Z_NO_FLUSH      = 0;
//var Z_PARTIAL_FLUSH = 1;
//var Z_SYNC_FLUSH    = 2;
//var Z_FULL_FLUSH    = 3;
var Z_FINISH = 4;
var Z_BLOCK = 5;
var Z_TREES = 6;

/* Return codes for the compression/decompression functions. Negative values
 * are errors, positive values are used for special but normal events.
 */
var Z_OK = 0;
var Z_STREAM_END = 1;
var Z_NEED_DICT = 2;
//var Z_ERRNO         = -1;
var Z_STREAM_ERROR = -2;
var Z_DATA_ERROR = -3;
var Z_MEM_ERROR = -4;
var Z_BUF_ERROR = -5;
//var Z_VERSION_ERROR = -6;

/* The deflate compression method */
var Z_DEFLATED = 8;

/* STATES ====================================================================*/
/* ===========================================================================*/

var HEAD = 1; /* i: waiting for magic header */
var FLAGS = 2; /* i: waiting for method and flags (gzip) */
var TIME = 3; /* i: waiting for modification time (gzip) */
var OS = 4; /* i: waiting for extra flags and operating system (gzip) */
var EXLEN = 5; /* i: waiting for extra length (gzip) */
var EXTRA = 6; /* i: waiting for extra bytes (gzip) */
var NAME = 7; /* i: waiting for end of file name (gzip) */
var COMMENT = 8; /* i: waiting for end of comment (gzip) */
var HCRC = 9; /* i: waiting for header crc (gzip) */
var DICTID = 10; /* i: waiting for dictionary check value */
var DICT = 11; /* waiting for inflateSetDictionary() call */
var TYPE = 12; /* i: waiting for type bits, including last-flag bit */
var TYPEDO = 13; /* i: same, but skip check to exit inflate on new block */
var STORED = 14; /* i: waiting for stored size (length and complement) */
var COPY_ = 15; /* i/o: same as COPY below, but only first time in */
var COPY = 16; /* i/o: waiting for input or output to copy stored block */
var TABLE = 17; /* i: waiting for dynamic block table lengths */
var LENLENS = 18; /* i: waiting for code length code lengths */
var CODELENS = 19; /* i: waiting for length/lit and distance code lengths */
var LEN_ = 20; /* i: same as LEN below, but only first time in */
var LEN = 21; /* i: waiting for length/lit/eob code */
var LENEXT = 22; /* i: waiting for length extra bits */
var DIST = 23; /* i: waiting for distance code */
var DISTEXT = 24; /* i: waiting for distance extra bits */
var MATCH = 25; /* o: waiting for output space to copy string */
var LIT = 26; /* o: waiting for output space to write literal */
var CHECK = 27; /* i: waiting for 32-bit check value */
var LENGTH = 28; /* i: waiting for 32-bit length (gzip) */
var DONE = 29; /* finished check, done -- remain here until reset */
var BAD = 30; /* got a data error -- remain here until reset */
var MEM = 31; /* got an inflate() memory error -- remain here until reset */
var SYNC = 32; /* looking for synchronization bytes to restart inflate() */

/* ===========================================================================*/

var ENOUGH_LENS = 852;
var ENOUGH_DISTS = 592;
//var ENOUGH =  (ENOUGH_LENS+ENOUGH_DISTS);

var MAX_WBITS = 15;
/* 32K LZ77 window */
var DEF_WBITS = MAX_WBITS;

function zswap32(q) {
  return (q >>> 24 & 0xff) + (q >>> 8 & 0xff00) + ((q & 0xff00) << 8) + ((q & 0xff) << 24);
}

function InflateState() {
  this.mode = 0; /* current inflate mode */
  this.last = false; /* true if processing last block */
  this.wrap = 0; /* bit 0 true for zlib, bit 1 true for gzip */
  this.havedict = false; /* true if dictionary provided */
  this.flags = 0; /* gzip header method and flags (0 if zlib) */
  this.dmax = 0; /* zlib header max distance (INFLATE_STRICT) */
  this.check = 0; /* protected copy of check value */
  this.total = 0; /* protected copy of output count */
  // TODO: may be {}
  this.head = null; /* where to save gzip header information */

  /* sliding window */
  this.wbits = 0; /* log base 2 of requested window size */
  this.wsize = 0; /* window size or zero if not using window */
  this.whave = 0; /* valid bytes in the window */
  this.wnext = 0; /* window write index */
  this.window = null; /* allocated sliding window, if needed */

  /* bit accumulator */
  this.hold = 0; /* input bit accumulator */
  this.bits = 0; /* number of bits in "in" */

  /* for string and stored block copying */
  this.length = 0; /* literal or length of data to copy */
  this.offset = 0; /* distance back to copy string from */

  /* for table and code decoding */
  this.extra = 0; /* extra bits needed */

  /* fixed and dynamic code tables */
  this.lencode = null; /* starting table for length/literal codes */
  this.distcode = null; /* starting table for distance codes */
  this.lenbits = 0; /* index bits for lencode */
  this.distbits = 0; /* index bits for distcode */

  /* dynamic table building */
  this.ncode = 0; /* number of code length code lengths */
  this.nlen = 0; /* number of length code lengths */
  this.ndist = 0; /* number of distance code lengths */
  this.have = 0; /* number of code lengths in lens[] */
  this.next = null; /* next available space in codes[] */

  this.lens = new utils.Buf16(320); /* temporary storage for code lengths */
  this.work = new utils.Buf16(288); /* work area for code table building */

  /*
   because we don't have pointers in js, we use lencode and distcode directly
   as buffers so we don't need codes
  */
  //this.codes = new utils.Buf32(ENOUGH);       /* space for code tables */
  this.lendyn = null; /* dynamic table for length/literal codes (JS specific) */
  this.distdyn = null; /* dynamic table for distance codes (JS specific) */
  this.sane = 0; /* if false, allow invalid distance too far */
  this.back = 0; /* bits back of last unprocessed length/lit */
  this.was = 0; /* initial length of match */
}

function inflateResetKeep(strm) {
  var state;

  if (!strm || !strm.state) {
    return Z_STREAM_ERROR;
  }
  state = strm.state;
  strm.total_in = strm.total_out = state.total = 0;
  strm.msg = ''; /*Z_NULL*/
  if (state.wrap) {
    /* to support ill-conceived Java test suite */
    strm.adler = state.wrap & 1;
  }
  state.mode = HEAD;
  state.last = 0;
  state.havedict = 0;
  state.dmax = 32768;
  state.head = null /*Z_NULL*/;
  state.hold = 0;
  state.bits = 0;
  //state.lencode = state.distcode = state.next = state.codes;
  state.lencode = state.lendyn = new utils.Buf32(ENOUGH_LENS);
  state.distcode = state.distdyn = new utils.Buf32(ENOUGH_DISTS);

  state.sane = 1;
  state.back = -1;
  //Tracev((stderr, "inflate: reset\n"));
  return Z_OK;
}

function inflateReset(strm) {
  var state;

  if (!strm || !strm.state) {
    return Z_STREAM_ERROR;
  }
  state = strm.state;
  state.wsize = 0;
  state.whave = 0;
  state.wnext = 0;
  return inflateResetKeep(strm);
}

function inflateReset2(strm, windowBits) {
  var wrap;
  var state;

  /* get the state */
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR;
  }
  state = strm.state;

  /* extract wrap request from windowBits parameter */
  if (windowBits < 0) {
    wrap = 0;
    windowBits = -windowBits;
  } else {
    wrap = (windowBits >> 4) + 1;
    if (windowBits < 48) {
      windowBits &= 15;
    }
  }

  /* set number of window bits, free window if different */
  if (windowBits && (windowBits < 8 || windowBits > 15)) {
    return Z_STREAM_ERROR;
  }
  if (state.window !== null && state.wbits !== windowBits) {
    state.window = null;
  }

  /* update state and reset the rest of it */
  state.wrap = wrap;
  state.wbits = windowBits;
  return inflateReset(strm);
}

function inflateInit2(strm, windowBits) {
  var ret;
  var state;

  if (!strm) {
    return Z_STREAM_ERROR;
  }
  //strm.msg = Z_NULL;                 /* in case we return an error */

  state = new InflateState();

  //if (state === Z_NULL) return Z_MEM_ERROR;
  //Tracev((stderr, "inflate: allocated\n"));
  strm.state = state;
  state.window = null /*Z_NULL*/;
  ret = inflateReset2(strm, windowBits);
  if (ret !== Z_OK) {
    strm.state = null /*Z_NULL*/;
  }
  return ret;
}

function inflateInit(strm) {
  return inflateInit2(strm, DEF_WBITS);
}

/*
 Return state with length and distance decoding tables and index sizes set to
 fixed code decoding.  Normally this returns fixed tables from inffixed.h.
 If BUILDFIXED is defined, then instead this routine builds the tables the
 first time it's called, and returns those tables the first time and
 thereafter.  This reduces the size of the code by about 2K bytes, in
 exchange for a little execution time.  However, BUILDFIXED should not be
 used for threaded applications, since the rewriting of the tables and virgin
 may not be thread-safe.
 */
var virgin = true;

var lenfix, distfix; // We have no pointers in JS, so keep tables separate

function fixedtables(state) {
  /* build fixed huffman tables if first call (may not be thread safe) */
  if (virgin) {
    var sym;

    lenfix = new utils.Buf32(512);
    distfix = new utils.Buf32(32);

    /* literal/length table */
    sym = 0;
    while (sym < 144) {
      state.lens[sym++] = 8;
    }
    while (sym < 256) {
      state.lens[sym++] = 9;
    }
    while (sym < 280) {
      state.lens[sym++] = 7;
    }
    while (sym < 288) {
      state.lens[sym++] = 8;
    }

    inflate_table(LENS, state.lens, 0, 288, lenfix, 0, state.work, { bits: 9 });

    /* distance table */
    sym = 0;
    while (sym < 32) {
      state.lens[sym++] = 5;
    }

    inflate_table(DISTS, state.lens, 0, 32, distfix, 0, state.work, { bits: 5 });

    /* do this just once */
    virgin = false;
  }

  state.lencode = lenfix;
  state.lenbits = 9;
  state.distcode = distfix;
  state.distbits = 5;
}

/*
 Update the window with the last wsize (normally 32K) bytes written before
 returning.  If window does not exist yet, create it.  This is only called
 when a window is already in use, or when output has been written during this
 inflate call, but the end of the deflate stream has not been reached yet.
 It is also called to create a window for dictionary data when a dictionary
 is loaded.

 Providing output buffers larger than 32K to inflate() should provide a speed
 advantage, since only the last 32K of output is copied to the sliding window
 upon return from inflate(), and since all distances after the first 32K of
 output will fall in the output data, making match copies simpler and faster.
 The advantage may be dependent on the size of the processor's data caches.
 */
function updatewindow(strm, src, end, copy) {
  var dist;
  var state = strm.state;

  /* if it hasn't been done already, allocate space for the window */
  if (state.window === null) {
    state.wsize = 1 << state.wbits;
    state.wnext = 0;
    state.whave = 0;

    state.window = new utils.Buf8(state.wsize);
  }

  /* copy state->wsize or less output bytes into the circular window */
  if (copy >= state.wsize) {
    utils.arraySet(state.window, src, end - state.wsize, state.wsize, 0);
    state.wnext = 0;
    state.whave = state.wsize;
  } else {
    dist = state.wsize - state.wnext;
    if (dist > copy) {
      dist = copy;
    }
    //zmemcpy(state->window + state->wnext, end - copy, dist);
    utils.arraySet(state.window, src, end - copy, dist, state.wnext);
    copy -= dist;
    if (copy) {
      //zmemcpy(state->window, end - copy, copy);
      utils.arraySet(state.window, src, end - copy, copy, 0);
      state.wnext = copy;
      state.whave = state.wsize;
    } else {
      state.wnext += dist;
      if (state.wnext === state.wsize) {
        state.wnext = 0;
      }
      if (state.whave < state.wsize) {
        state.whave += dist;
      }
    }
  }
  return 0;
}

function inflate(strm, flush) {
  var state;
  var input, output; // input/output buffers
  var next; /* next input INDEX */
  var put; /* next output INDEX */
  var have, left; /* available input and output */
  var hold; /* bit buffer */
  var bits; /* bits in bit buffer */
  var _in, _out; /* save starting available input and output */
  var copy; /* number of stored or match bytes to copy */
  var from; /* where to copy match bytes from */
  var from_source;
  var here = 0; /* current decoding table entry */
  var here_bits, here_op, here_val; // paked "here" denormalized (JS specific)
  //var last;                   /* parent table entry */
  var last_bits, last_op, last_val; // paked "last" denormalized (JS specific)
  var len; /* length to copy for repeats, bits to drop */
  var ret; /* return code */
  var hbuf = new utils.Buf8(4); /* buffer for gzip header crc calculation */
  var opts;

  var n; // temporary var for NEED_BITS

  var order = /* permutation of code lengths */
  [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];

  if (!strm || !strm.state || !strm.output || !strm.input && strm.avail_in !== 0) {
    return Z_STREAM_ERROR;
  }

  state = strm.state;
  if (state.mode === TYPE) {
    state.mode = TYPEDO;
  } /* skip check */

  //--- LOAD() ---
  put = strm.next_out;
  output = strm.output;
  left = strm.avail_out;
  next = strm.next_in;
  input = strm.input;
  have = strm.avail_in;
  hold = state.hold;
  bits = state.bits;
  //---

  _in = have;
  _out = left;
  ret = Z_OK;

  inf_leave: // goto emulation
  for (;;) {
    switch (state.mode) {
      case HEAD:
        if (state.wrap === 0) {
          state.mode = TYPEDO;
          break;
        }
        //=== NEEDBITS(16);
        while (bits < 16) {
          if (have === 0) {
            break inf_leave;
          }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        if (state.wrap & 2 && hold === 0x8b1f) {
          /* gzip header */
          state.check = 0 /*crc32(0L, Z_NULL, 0)*/;
          //=== CRC2(state.check, hold);
          hbuf[0] = hold & 0xff;
          hbuf[1] = hold >>> 8 & 0xff;
          state.check = crc32(state.check, hbuf, 2, 0);
          //===//

          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
          state.mode = FLAGS;
          break;
        }
        state.flags = 0; /* expect zlib header */
        if (state.head) {
          state.head.done = false;
        }
        if (!(state.wrap & 1) || /* check if zlib header allowed */
        (((hold & 0xff) << /*BITS(8)*/8) + (hold >> 8)) % 31) {
          strm.msg = 'incorrect header check';
          state.mode = BAD;
          break;
        }
        if ((hold & 0x0f) !== /*BITS(4)*/Z_DEFLATED) {
          strm.msg = 'unknown compression method';
          state.mode = BAD;
          break;
        }
        //--- DROPBITS(4) ---//
        hold >>>= 4;
        bits -= 4;
        //---//
        len = (hold & 0x0f) + /*BITS(4)*/8;
        if (state.wbits === 0) {
          state.wbits = len;
        } else if (len > state.wbits) {
          strm.msg = 'invalid window size';
          state.mode = BAD;
          break;
        }
        state.dmax = 1 << len;
        //Tracev((stderr, "inflate:   zlib header ok\n"));
        strm.adler = state.check = 1 /*adler32(0L, Z_NULL, 0)*/;
        state.mode = hold & 0x200 ? DICTID : TYPE;
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        break;
      case FLAGS:
        //=== NEEDBITS(16); */
        while (bits < 16) {
          if (have === 0) {
            break inf_leave;
          }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        state.flags = hold;
        if ((state.flags & 0xff) !== Z_DEFLATED) {
          strm.msg = 'unknown compression method';
          state.mode = BAD;
          break;
        }
        if (state.flags & 0xe000) {
          strm.msg = 'unknown header flags set';
          state.mode = BAD;
          break;
        }
        if (state.head) {
          state.head.text = hold >> 8 & 1;
        }
        if (state.flags & 0x0200) {
          //=== CRC2(state.check, hold);
          hbuf[0] = hold & 0xff;
          hbuf[1] = hold >>> 8 & 0xff;
          state.check = crc32(state.check, hbuf, 2, 0);
          //===//
        }
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = TIME;
      /* falls through */
      case TIME:
        //=== NEEDBITS(32); */
        while (bits < 32) {
          if (have === 0) {
            break inf_leave;
          }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        if (state.head) {
          state.head.time = hold;
        }
        if (state.flags & 0x0200) {
          //=== CRC4(state.check, hold)
          hbuf[0] = hold & 0xff;
          hbuf[1] = hold >>> 8 & 0xff;
          hbuf[2] = hold >>> 16 & 0xff;
          hbuf[3] = hold >>> 24 & 0xff;
          state.check = crc32(state.check, hbuf, 4, 0);
          //===
        }
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = OS;
      /* falls through */
      case OS:
        //=== NEEDBITS(16); */
        while (bits < 16) {
          if (have === 0) {
            break inf_leave;
          }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        if (state.head) {
          state.head.xflags = hold & 0xff;
          state.head.os = hold >> 8;
        }
        if (state.flags & 0x0200) {
          //=== CRC2(state.check, hold);
          hbuf[0] = hold & 0xff;
          hbuf[1] = hold >>> 8 & 0xff;
          state.check = crc32(state.check, hbuf, 2, 0);
          //===//
        }
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = EXLEN;
      /* falls through */
      case EXLEN:
        if (state.flags & 0x0400) {
          //=== NEEDBITS(16); */
          while (bits < 16) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          state.length = hold;
          if (state.head) {
            state.head.extra_len = hold;
          }
          if (state.flags & 0x0200) {
            //=== CRC2(state.check, hold);
            hbuf[0] = hold & 0xff;
            hbuf[1] = hold >>> 8 & 0xff;
            state.check = crc32(state.check, hbuf, 2, 0);
            //===//
          }
          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
        } else if (state.head) {
          state.head.extra = null /*Z_NULL*/;
        }
        state.mode = EXTRA;
      /* falls through */
      case EXTRA:
        if (state.flags & 0x0400) {
          copy = state.length;
          if (copy > have) {
            copy = have;
          }
          if (copy) {
            if (state.head) {
              len = state.head.extra_len - state.length;
              if (!state.head.extra) {
                // Use untyped array for more conveniend processing later
                state.head.extra = new Array(state.head.extra_len);
              }
              utils.arraySet(state.head.extra, input, next,
              // extra field is limited to 65536 bytes
              // - no need for additional size check
              copy,
              /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
              len);
              //zmemcpy(state.head.extra + len, next,
              //        len + copy > state.head.extra_max ?
              //        state.head.extra_max - len : copy);
            }
            if (state.flags & 0x0200) {
              state.check = crc32(state.check, input, copy, next);
            }
            have -= copy;
            next += copy;
            state.length -= copy;
          }
          if (state.length) {
            break inf_leave;
          }
        }
        state.length = 0;
        state.mode = NAME;
      /* falls through */
      case NAME:
        if (state.flags & 0x0800) {
          if (have === 0) {
            break inf_leave;
          }
          copy = 0;
          do {
            // TODO: 2 or 1 bytes?
            len = input[next + copy++];
            /* use constant limit because in js we should not preallocate memory */
            if (state.head && len && state.length < 65536 /*state.head.name_max*/) {
              state.head.name += String.fromCharCode(len);
            }
          } while (len && copy < have);

          if (state.flags & 0x0200) {
            state.check = crc32(state.check, input, copy, next);
          }
          have -= copy;
          next += copy;
          if (len) {
            break inf_leave;
          }
        } else if (state.head) {
          state.head.name = null;
        }
        state.length = 0;
        state.mode = COMMENT;
      /* falls through */
      case COMMENT:
        if (state.flags & 0x1000) {
          if (have === 0) {
            break inf_leave;
          }
          copy = 0;
          do {
            len = input[next + copy++];
            /* use constant limit because in js we should not preallocate memory */
            if (state.head && len && state.length < 65536 /*state.head.comm_max*/) {
              state.head.comment += String.fromCharCode(len);
            }
          } while (len && copy < have);
          if (state.flags & 0x0200) {
            state.check = crc32(state.check, input, copy, next);
          }
          have -= copy;
          next += copy;
          if (len) {
            break inf_leave;
          }
        } else if (state.head) {
          state.head.comment = null;
        }
        state.mode = HCRC;
      /* falls through */
      case HCRC:
        if (state.flags & 0x0200) {
          //=== NEEDBITS(16); */
          while (bits < 16) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          if (hold !== (state.check & 0xffff)) {
            strm.msg = 'header crc mismatch';
            state.mode = BAD;
            break;
          }
          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
        }
        if (state.head) {
          state.head.hcrc = state.flags >> 9 & 1;
          state.head.done = true;
        }
        strm.adler = state.check = 0;
        state.mode = TYPE;
        break;
      case DICTID:
        //=== NEEDBITS(32); */
        while (bits < 32) {
          if (have === 0) {
            break inf_leave;
          }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        strm.adler = state.check = zswap32(hold);
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = DICT;
      /* falls through */
      case DICT:
        if (state.havedict === 0) {
          //--- RESTORE() ---
          strm.next_out = put;
          strm.avail_out = left;
          strm.next_in = next;
          strm.avail_in = have;
          state.hold = hold;
          state.bits = bits;
          //---
          return Z_NEED_DICT;
        }
        strm.adler = state.check = 1 /*adler32(0L, Z_NULL, 0)*/;
        state.mode = TYPE;
      /* falls through */
      case TYPE:
        if (flush === Z_BLOCK || flush === Z_TREES) {
          break inf_leave;
        }
      /* falls through */
      case TYPEDO:
        if (state.last) {
          //--- BYTEBITS() ---//
          hold >>>= bits & 7;
          bits -= bits & 7;
          //---//
          state.mode = CHECK;
          break;
        }
        //=== NEEDBITS(3); */
        while (bits < 3) {
          if (have === 0) {
            break inf_leave;
          }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        state.last = hold & 0x01 /*BITS(1)*/;
        //--- DROPBITS(1) ---//
        hold >>>= 1;
        bits -= 1;
        //---//

        switch (hold & 0x03) {/*BITS(2)*/
          case 0:
            /* stored block */
            //Tracev((stderr, "inflate:     stored block%s\n",
            //        state.last ? " (last)" : ""));
            state.mode = STORED;
            break;
          case 1:
            /* fixed block */
            fixedtables(state);
            //Tracev((stderr, "inflate:     fixed codes block%s\n",
            //        state.last ? " (last)" : ""));
            state.mode = LEN_; /* decode codes */
            if (flush === Z_TREES) {
              //--- DROPBITS(2) ---//
              hold >>>= 2;
              bits -= 2;
              //---//
              break inf_leave;
            }
            break;
          case 2:
            /* dynamic block */
            //Tracev((stderr, "inflate:     dynamic codes block%s\n",
            //        state.last ? " (last)" : ""));
            state.mode = TABLE;
            break;
          case 3:
            strm.msg = 'invalid block type';
            state.mode = BAD;
        }
        //--- DROPBITS(2) ---//
        hold >>>= 2;
        bits -= 2;
        //---//
        break;
      case STORED:
        //--- BYTEBITS() ---// /* go to byte boundary */
        hold >>>= bits & 7;
        bits -= bits & 7;
        //---//
        //=== NEEDBITS(32); */
        while (bits < 32) {
          if (have === 0) {
            break inf_leave;
          }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        if ((hold & 0xffff) !== (hold >>> 16 ^ 0xffff)) {
          strm.msg = 'invalid stored block lengths';
          state.mode = BAD;
          break;
        }
        state.length = hold & 0xffff;
        //Tracev((stderr, "inflate:       stored length %u\n",
        //        state.length));
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = COPY_;
        if (flush === Z_TREES) {
          break inf_leave;
        }
      /* falls through */
      case COPY_:
        state.mode = COPY;
      /* falls through */
      case COPY:
        copy = state.length;
        if (copy) {
          if (copy > have) {
            copy = have;
          }
          if (copy > left) {
            copy = left;
          }
          if (copy === 0) {
            break inf_leave;
          }
          //--- zmemcpy(put, next, copy); ---
          utils.arraySet(output, input, next, copy, put);
          //---//
          have -= copy;
          next += copy;
          left -= copy;
          put += copy;
          state.length -= copy;
          break;
        }
        //Tracev((stderr, "inflate:       stored end\n"));
        state.mode = TYPE;
        break;
      case TABLE:
        //=== NEEDBITS(14); */
        while (bits < 14) {
          if (have === 0) {
            break inf_leave;
          }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        state.nlen = (hold & 0x1f) + /*BITS(5)*/257;
        //--- DROPBITS(5) ---//
        hold >>>= 5;
        bits -= 5;
        //---//
        state.ndist = (hold & 0x1f) + /*BITS(5)*/1;
        //--- DROPBITS(5) ---//
        hold >>>= 5;
        bits -= 5;
        //---//
        state.ncode = (hold & 0x0f) + /*BITS(4)*/4;
        //--- DROPBITS(4) ---//
        hold >>>= 4;
        bits -= 4;
        //---//
        //#ifndef PKZIP_BUG_WORKAROUND
        if (state.nlen > 286 || state.ndist > 30) {
          strm.msg = 'too many length or distance symbols';
          state.mode = BAD;
          break;
        }
        //#endif
        //Tracev((stderr, "inflate:       table sizes ok\n"));
        state.have = 0;
        state.mode = LENLENS;
      /* falls through */
      case LENLENS:
        while (state.have < state.ncode) {
          //=== NEEDBITS(3);
          while (bits < 3) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          state.lens[order[state.have++]] = hold & 0x07; //BITS(3);
          //--- DROPBITS(3) ---//
          hold >>>= 3;
          bits -= 3;
          //---//
        }
        while (state.have < 19) {
          state.lens[order[state.have++]] = 0;
        }
        // We have separate tables & no pointers. 2 commented lines below not needed.
        //state.next = state.codes;
        //state.lencode = state.next;
        // Switch to use dynamic table
        state.lencode = state.lendyn;
        state.lenbits = 7;

        opts = { bits: state.lenbits };
        ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
        state.lenbits = opts.bits;

        if (ret) {
          strm.msg = 'invalid code lengths set';
          state.mode = BAD;
          break;
        }
        //Tracev((stderr, "inflate:       code lengths ok\n"));
        state.have = 0;
        state.mode = CODELENS;
      /* falls through */
      case CODELENS:
        while (state.have < state.nlen + state.ndist) {
          for (;;) {
            here = state.lencode[hold & (1 << state.lenbits) - 1]; /*BITS(state.lenbits)*/
            here_bits = here >>> 24;
            here_op = here >>> 16 & 0xff;
            here_val = here & 0xffff;

            if (here_bits <= bits) {
              break;
            }
            //--- PULLBYTE() ---//
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
            //---//
          }
          if (here_val < 16) {
            //--- DROPBITS(here.bits) ---//
            hold >>>= here_bits;
            bits -= here_bits;
            //---//
            state.lens[state.have++] = here_val;
          } else {
            if (here_val === 16) {
              //=== NEEDBITS(here.bits + 2);
              n = here_bits + 2;
              while (bits < n) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              //===//
              //--- DROPBITS(here.bits) ---//
              hold >>>= here_bits;
              bits -= here_bits;
              //---//
              if (state.have === 0) {
                strm.msg = 'invalid bit length repeat';
                state.mode = BAD;
                break;
              }
              len = state.lens[state.have - 1];
              copy = 3 + (hold & 0x03); //BITS(2);
              //--- DROPBITS(2) ---//
              hold >>>= 2;
              bits -= 2;
              //---//
            } else if (here_val === 17) {
              //=== NEEDBITS(here.bits + 3);
              n = here_bits + 3;
              while (bits < n) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              //===//
              //--- DROPBITS(here.bits) ---//
              hold >>>= here_bits;
              bits -= here_bits;
              //---//
              len = 0;
              copy = 3 + (hold & 0x07); //BITS(3);
              //--- DROPBITS(3) ---//
              hold >>>= 3;
              bits -= 3;
              //---//
            } else {
              //=== NEEDBITS(here.bits + 7);
              n = here_bits + 7;
              while (bits < n) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              //===//
              //--- DROPBITS(here.bits) ---//
              hold >>>= here_bits;
              bits -= here_bits;
              //---//
              len = 0;
              copy = 11 + (hold & 0x7f); //BITS(7);
              //--- DROPBITS(7) ---//
              hold >>>= 7;
              bits -= 7;
              //---//
            }
            if (state.have + copy > state.nlen + state.ndist) {
              strm.msg = 'invalid bit length repeat';
              state.mode = BAD;
              break;
            }
            while (copy--) {
              state.lens[state.have++] = len;
            }
          }
        }

        /* handle error breaks in while */
        if (state.mode === BAD) {
          break;
        }

        /* check for end-of-block code (better have one) */
        if (state.lens[256] === 0) {
          strm.msg = 'invalid code -- missing end-of-block';
          state.mode = BAD;
          break;
        }

        /* build code tables -- note: do not change the lenbits or distbits
           values here (9 and 6) without reading the comments in inftrees.h
           concerning the ENOUGH constants, which depend on those values */
        state.lenbits = 9;

        opts = { bits: state.lenbits };
        ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
        // We have separate tables & no pointers. 2 commented lines below not needed.
        // state.next_index = opts.table_index;
        state.lenbits = opts.bits;
        // state.lencode = state.next;

        if (ret) {
          strm.msg = 'invalid literal/lengths set';
          state.mode = BAD;
          break;
        }

        state.distbits = 6;
        //state.distcode.copy(state.codes);
        // Switch to use dynamic table
        state.distcode = state.distdyn;
        opts = { bits: state.distbits };
        ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
        // We have separate tables & no pointers. 2 commented lines below not needed.
        // state.next_index = opts.table_index;
        state.distbits = opts.bits;
        // state.distcode = state.next;

        if (ret) {
          strm.msg = 'invalid distances set';
          state.mode = BAD;
          break;
        }
        //Tracev((stderr, 'inflate:       codes ok\n'));
        state.mode = LEN_;
        if (flush === Z_TREES) {
          break inf_leave;
        }
      /* falls through */
      case LEN_:
        state.mode = LEN;
      /* falls through */
      case LEN:
        if (have >= 6 && left >= 258) {
          //--- RESTORE() ---
          strm.next_out = put;
          strm.avail_out = left;
          strm.next_in = next;
          strm.avail_in = have;
          state.hold = hold;
          state.bits = bits;
          //---
          inflate_fast(strm, _out);
          //--- LOAD() ---
          put = strm.next_out;
          output = strm.output;
          left = strm.avail_out;
          next = strm.next_in;
          input = strm.input;
          have = strm.avail_in;
          hold = state.hold;
          bits = state.bits;
          //---

          if (state.mode === TYPE) {
            state.back = -1;
          }
          break;
        }
        state.back = 0;
        for (;;) {
          here = state.lencode[hold & (1 << state.lenbits) - 1]; /*BITS(state.lenbits)*/
          here_bits = here >>> 24;
          here_op = here >>> 16 & 0xff;
          here_val = here & 0xffff;

          if (here_bits <= bits) {
            break;
          }
          //--- PULLBYTE() ---//
          if (have === 0) {
            break inf_leave;
          }
          have--;
          hold += input[next++] << bits;
          bits += 8;
          //---//
        }
        if (here_op && (here_op & 0xf0) === 0) {
          last_bits = here_bits;
          last_op = here_op;
          last_val = here_val;
          for (;;) {
            here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> /*BITS(last.bits + last.op)*/last_bits)];
            here_bits = here >>> 24;
            here_op = here >>> 16 & 0xff;
            here_val = here & 0xffff;

            if (last_bits + here_bits <= bits) {
              break;
            }
            //--- PULLBYTE() ---//
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
            //---//
          }
          //--- DROPBITS(last.bits) ---//
          hold >>>= last_bits;
          bits -= last_bits;
          //---//
          state.back += last_bits;
        }
        //--- DROPBITS(here.bits) ---//
        hold >>>= here_bits;
        bits -= here_bits;
        //---//
        state.back += here_bits;
        state.length = here_val;
        if (here_op === 0) {
          //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
          //        "inflate:         literal '%c'\n" :
          //        "inflate:         literal 0x%02x\n", here.val));
          state.mode = LIT;
          break;
        }
        if (here_op & 32) {
          //Tracevv((stderr, "inflate:         end of block\n"));
          state.back = -1;
          state.mode = TYPE;
          break;
        }
        if (here_op & 64) {
          strm.msg = 'invalid literal/length code';
          state.mode = BAD;
          break;
        }
        state.extra = here_op & 15;
        state.mode = LENEXT;
      /* falls through */
      case LENEXT:
        if (state.extra) {
          //=== NEEDBITS(state.extra);
          n = state.extra;
          while (bits < n) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          state.length += hold & (1 << state.extra) - 1 /*BITS(state.extra)*/;
          //--- DROPBITS(state.extra) ---//
          hold >>>= state.extra;
          bits -= state.extra;
          //---//
          state.back += state.extra;
        }
        //Tracevv((stderr, "inflate:         length %u\n", state.length));
        state.was = state.length;
        state.mode = DIST;
      /* falls through */
      case DIST:
        for (;;) {
          here = state.distcode[hold & (1 << state.distbits) - 1]; /*BITS(state.distbits)*/
          here_bits = here >>> 24;
          here_op = here >>> 16 & 0xff;
          here_val = here & 0xffff;

          if (here_bits <= bits) {
            break;
          }
          //--- PULLBYTE() ---//
          if (have === 0) {
            break inf_leave;
          }
          have--;
          hold += input[next++] << bits;
          bits += 8;
          //---//
        }
        if ((here_op & 0xf0) === 0) {
          last_bits = here_bits;
          last_op = here_op;
          last_val = here_val;
          for (;;) {
            here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> /*BITS(last.bits + last.op)*/last_bits)];
            here_bits = here >>> 24;
            here_op = here >>> 16 & 0xff;
            here_val = here & 0xffff;

            if (last_bits + here_bits <= bits) {
              break;
            }
            //--- PULLBYTE() ---//
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
            //---//
          }
          //--- DROPBITS(last.bits) ---//
          hold >>>= last_bits;
          bits -= last_bits;
          //---//
          state.back += last_bits;
        }
        //--- DROPBITS(here.bits) ---//
        hold >>>= here_bits;
        bits -= here_bits;
        //---//
        state.back += here_bits;
        if (here_op & 64) {
          strm.msg = 'invalid distance code';
          state.mode = BAD;
          break;
        }
        state.offset = here_val;
        state.extra = here_op & 15;
        state.mode = DISTEXT;
      /* falls through */
      case DISTEXT:
        if (state.extra) {
          //=== NEEDBITS(state.extra);
          n = state.extra;
          while (bits < n) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          state.offset += hold & (1 << state.extra) - 1 /*BITS(state.extra)*/;
          //--- DROPBITS(state.extra) ---//
          hold >>>= state.extra;
          bits -= state.extra;
          //---//
          state.back += state.extra;
        }
        //#ifdef INFLATE_STRICT
        if (state.offset > state.dmax) {
          strm.msg = 'invalid distance too far back';
          state.mode = BAD;
          break;
        }
        //#endif
        //Tracevv((stderr, "inflate:         distance %u\n", state.offset));
        state.mode = MATCH;
      /* falls through */
      case MATCH:
        if (left === 0) {
          break inf_leave;
        }
        copy = _out - left;
        if (state.offset > copy) {
          /* copy from window */
          copy = state.offset - copy;
          if (copy > state.whave) {
            if (state.sane) {
              strm.msg = 'invalid distance too far back';
              state.mode = BAD;
              break;
            }
            // (!) This block is disabled in zlib defailts,
            // don't enable it for binary compatibility
            //#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
            //          Trace((stderr, "inflate.c too far\n"));
            //          copy -= state.whave;
            //          if (copy > state.length) { copy = state.length; }
            //          if (copy > left) { copy = left; }
            //          left -= copy;
            //          state.length -= copy;
            //          do {
            //            output[put++] = 0;
            //          } while (--copy);
            //          if (state.length === 0) { state.mode = LEN; }
            //          break;
            //#endif
          }
          if (copy > state.wnext) {
            copy -= state.wnext;
            from = state.wsize - copy;
          } else {
            from = state.wnext - copy;
          }
          if (copy > state.length) {
            copy = state.length;
          }
          from_source = state.window;
        } else {
          /* copy from output */
          from_source = output;
          from = put - state.offset;
          copy = state.length;
        }
        if (copy > left) {
          copy = left;
        }
        left -= copy;
        state.length -= copy;
        do {
          output[put++] = from_source[from++];
        } while (--copy);
        if (state.length === 0) {
          state.mode = LEN;
        }
        break;
      case LIT:
        if (left === 0) {
          break inf_leave;
        }
        output[put++] = state.length;
        left--;
        state.mode = LEN;
        break;
      case CHECK:
        if (state.wrap) {
          //=== NEEDBITS(32);
          while (bits < 32) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            // Use '|' insdead of '+' to make sure that result is signed
            hold |= input[next++] << bits;
            bits += 8;
          }
          //===//
          _out -= left;
          strm.total_out += _out;
          state.total += _out;
          if (_out) {
            strm.adler = state.check =
            /*UPDATE(state.check, put - _out, _out);*/
            state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out);
          }
          _out = left;
          // NB: crc32 stored as signed 32-bit int, zswap32 returns signed too
          if ((state.flags ? hold : zswap32(hold)) !== state.check) {
            strm.msg = 'incorrect data check';
            state.mode = BAD;
            break;
          }
          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
          //Tracev((stderr, "inflate:   check matches trailer\n"));
        }
        state.mode = LENGTH;
      /* falls through */
      case LENGTH:
        if (state.wrap && state.flags) {
          //=== NEEDBITS(32);
          while (bits < 32) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          if (hold !== (state.total & 0xffffffff)) {
            strm.msg = 'incorrect length check';
            state.mode = BAD;
            break;
          }
          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
          //Tracev((stderr, "inflate:   length matches trailer\n"));
        }
        state.mode = DONE;
      /* falls through */
      case DONE:
        ret = Z_STREAM_END;
        break inf_leave;
      case BAD:
        ret = Z_DATA_ERROR;
        break inf_leave;
      case MEM:
        return Z_MEM_ERROR;
      case SYNC:
      /* falls through */
      default:
        return Z_STREAM_ERROR;
    }
  }

  // inf_leave <- here is real place for "goto inf_leave", emulated via "break inf_leave"

  /*
     Return from inflate(), updating the total counts and the check value.
     If there was no progress during the inflate() call, return a buffer
     error.  Call updatewindow() to create and/or update the window state.
     Note: a memory error from inflate() is non-recoverable.
   */

  //--- RESTORE() ---
  strm.next_out = put;
  strm.avail_out = left;
  strm.next_in = next;
  strm.avail_in = have;
  state.hold = hold;
  state.bits = bits;
  //---

  if (state.wsize || _out !== strm.avail_out && state.mode < BAD && (state.mode < CHECK || flush !== Z_FINISH)) {
    if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) {
      state.mode = MEM;
      return Z_MEM_ERROR;
    }
  }
  _in -= strm.avail_in;
  _out -= strm.avail_out;
  strm.total_in += _in;
  strm.total_out += _out;
  state.total += _out;
  if (state.wrap && _out) {
    strm.adler = state.check = /*UPDATE(state.check, strm.next_out - _out, _out);*/
    state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out);
  }
  strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === TYPE ? 128 : 0) + (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
  if ((_in === 0 && _out === 0 || flush === Z_FINISH) && ret === Z_OK) {
    ret = Z_BUF_ERROR;
  }
  return ret;
}

function inflateEnd(strm) {

  if (!strm || !strm.state /*|| strm->zfree == (free_func)0*/) {
      return Z_STREAM_ERROR;
    }

  var state = strm.state;
  if (state.window) {
    state.window = null;
  }
  strm.state = null;
  return Z_OK;
}

function inflateGetHeader(strm, head) {
  var state;

  /* check state */
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR;
  }
  state = strm.state;
  if ((state.wrap & 2) === 0) {
    return Z_STREAM_ERROR;
  }

  /* save header structure */
  state.head = head;
  head.done = false;
  return Z_OK;
}

function inflateSetDictionary(strm, dictionary) {
  var dictLength = dictionary.length;

  var state;
  var dictid;
  var ret;

  /* check state */
  if (!strm /* == Z_NULL */ || !strm.state /* == Z_NULL */) {
      return Z_STREAM_ERROR;
    }
  state = strm.state;

  if (state.wrap !== 0 && state.mode !== DICT) {
    return Z_STREAM_ERROR;
  }

  /* check for correct dictionary identifier */
  if (state.mode === DICT) {
    dictid = 1; /* adler32(0, null, 0)*/
    /* dictid = adler32(dictid, dictionary, dictLength); */
    dictid = adler32(dictid, dictionary, dictLength, 0);
    if (dictid !== state.check) {
      return Z_DATA_ERROR;
    }
  }
  /* copy dictionary to window using updatewindow(), which will amend the
   existing dictionary if appropriate */
  ret = updatewindow(strm, dictionary, dictLength, dictLength);
  if (ret) {
    state.mode = MEM;
    return Z_MEM_ERROR;
  }
  state.havedict = 1;
  // Tracev((stderr, "inflate:   dictionary set\n"));
  return Z_OK;
}

exports.inflateReset = inflateReset;
exports.inflateReset2 = inflateReset2;
exports.inflateResetKeep = inflateResetKeep;
exports.inflateInit = inflateInit;
exports.inflateInit2 = inflateInit2;
exports.inflate = inflate;
exports.inflateEnd = inflateEnd;
exports.inflateGetHeader = inflateGetHeader;
exports.inflateSetDictionary = inflateSetDictionary;
exports.inflateInfo = 'pako inflate (from Nodeca project)';

/* Not implemented
exports.inflateCopy = inflateCopy;
exports.inflateGetDictionary = inflateGetDictionary;
exports.inflateMark = inflateMark;
exports.inflatePrime = inflatePrime;
exports.inflateSync = inflateSync;
exports.inflateSyncPoint = inflateSyncPoint;
exports.inflateUndermine = inflateUndermine;
*/

},{"../utils/common":40,"./adler32":42,"./crc32":44,"./inffast":47,"./inftrees":49}],49:[function(require,module,exports){
'use strict';

var utils = require('../utils/common');

var MAXBITS = 15;
var ENOUGH_LENS = 852;
var ENOUGH_DISTS = 592;
//var ENOUGH = (ENOUGH_LENS+ENOUGH_DISTS);

var CODES = 0;
var LENS = 1;
var DISTS = 2;

var lbase = [/* Length codes 257..285 base */
3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0];

var lext = [/* Length codes 257..285 extra */
16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78];

var dbase = [/* Distance codes 0..29 base */
1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0];

var dext = [/* Distance codes 0..29 extra */
16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64];

module.exports = function inflate_table(type, lens, lens_index, codes, table, table_index, work, opts) {
  var bits = opts.bits;
  //here = opts.here; /* table entry for duplication */

  var len = 0; /* a code's length in bits */
  var sym = 0; /* index of code symbols */
  var min = 0,
      max = 0; /* minimum and maximum code lengths */
  var root = 0; /* number of index bits for root table */
  var curr = 0; /* number of index bits for current table */
  var drop = 0; /* code bits to drop for sub-table */
  var left = 0; /* number of prefix codes available */
  var used = 0; /* code entries in table used */
  var huff = 0; /* Huffman code */
  var incr; /* for incrementing code, index */
  var fill; /* index for replicating entries */
  var low; /* low bits for current root entry */
  var mask; /* mask for low root bits */
  var next; /* next available space in table */
  var base = null; /* base value table to use */
  var base_index = 0;
  //  var shoextra;    /* extra bits table to use */
  var end; /* use base and extra for symbol > end */
  var count = new utils.Buf16(MAXBITS + 1); //[MAXBITS+1];    /* number of codes of each length */
  var offs = new utils.Buf16(MAXBITS + 1); //[MAXBITS+1];     /* offsets in table for each length */
  var extra = null;
  var extra_index = 0;

  var here_bits, here_op, here_val;

  /*
   Process a set of code lengths to create a canonical Huffman code.  The
   code lengths are lens[0..codes-1].  Each length corresponds to the
   symbols 0..codes-1.  The Huffman code is generated by first sorting the
   symbols by length from short to long, and retaining the symbol order
   for codes with equal lengths.  Then the code starts with all zero bits
   for the first code of the shortest length, and the codes are integer
   increments for the same length, and zeros are appended as the length
   increases.  For the deflate format, these bits are stored backwards
   from their more natural integer increment ordering, and so when the
   decoding tables are built in the large loop below, the integer codes
   are incremented backwards.
    This routine assumes, but does not check, that all of the entries in
   lens[] are in the range 0..MAXBITS.  The caller must assure this.
   1..MAXBITS is interpreted as that code length.  zero means that that
   symbol does not occur in this code.
    The codes are sorted by computing a count of codes for each length,
   creating from that a table of starting indices for each length in the
   sorted table, and then entering the symbols in order in the sorted
   table.  The sorted table is work[], with that space being provided by
   the caller.
    The length counts are used for other purposes as well, i.e. finding
   the minimum and maximum length codes, determining if there are any
   codes at all, checking for a valid set of lengths, and looking ahead
   at length counts to determine sub-table sizes when building the
   decoding tables.
   */

  /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */
  for (len = 0; len <= MAXBITS; len++) {
    count[len] = 0;
  }
  for (sym = 0; sym < codes; sym++) {
    count[lens[lens_index + sym]]++;
  }

  /* bound code lengths, force root to be within code lengths */
  root = bits;
  for (max = MAXBITS; max >= 1; max--) {
    if (count[max] !== 0) {
      break;
    }
  }
  if (root > max) {
    root = max;
  }
  if (max === 0) {
    /* no symbols to code at all */
    //table.op[opts.table_index] = 64;  //here.op = (var char)64;    /* invalid code marker */
    //table.bits[opts.table_index] = 1;   //here.bits = (var char)1;
    //table.val[opts.table_index++] = 0;   //here.val = (var short)0;
    table[table_index++] = 1 << 24 | 64 << 16 | 0;

    //table.op[opts.table_index] = 64;
    //table.bits[opts.table_index] = 1;
    //table.val[opts.table_index++] = 0;
    table[table_index++] = 1 << 24 | 64 << 16 | 0;

    opts.bits = 1;
    return 0; /* no symbols, but wait for decoding to report error */
  }
  for (min = 1; min < max; min++) {
    if (count[min] !== 0) {
      break;
    }
  }
  if (root < min) {
    root = min;
  }

  /* check for an over-subscribed or incomplete set of lengths */
  left = 1;
  for (len = 1; len <= MAXBITS; len++) {
    left <<= 1;
    left -= count[len];
    if (left < 0) {
      return -1;
    } /* over-subscribed */
  }
  if (left > 0 && (type === CODES || max !== 1)) {
    return -1; /* incomplete set */
  }

  /* generate offsets into symbol table for each length for sorting */
  offs[1] = 0;
  for (len = 1; len < MAXBITS; len++) {
    offs[len + 1] = offs[len] + count[len];
  }

  /* sort symbols by length, by symbol order within each length */
  for (sym = 0; sym < codes; sym++) {
    if (lens[lens_index + sym] !== 0) {
      work[offs[lens[lens_index + sym]]++] = sym;
    }
  }

  /*
   Create and fill in decoding tables.  In this loop, the table being
   filled is at next and has curr index bits.  The code being used is huff
   with length len.  That code is converted to an index by dropping drop
   bits off of the bottom.  For codes where len is less than drop + curr,
   those top drop + curr - len bits are incremented through all values to
   fill the table with replicated entries.
    root is the number of index bits for the root table.  When len exceeds
   root, sub-tables are created pointed to by the root entry with an index
   of the low root bits of huff.  This is saved in low to check for when a
   new sub-table should be started.  drop is zero when the root table is
   being filled, and drop is root when sub-tables are being filled.
    When a new sub-table is needed, it is necessary to look ahead in the
   code lengths to determine what size sub-table is needed.  The length
   counts are used for this, and so count[] is decremented as codes are
   entered in the tables.
    used keeps track of how many table entries have been allocated from the
   provided *table space.  It is checked for LENS and DIST tables against
   the constants ENOUGH_LENS and ENOUGH_DISTS to guard against changes in
   the initial root table size constants.  See the comments in inftrees.h
   for more information.
    sym increments through all symbols, and the loop terminates when
   all codes of length max, i.e. all codes, have been processed.  This
   routine permits incomplete codes, so another loop after this one fills
   in the rest of the decoding tables with invalid code markers.
   */

  /* set up for code type */
  // poor man optimization - use if-else instead of switch,
  // to avoid deopts in old v8
  if (type === CODES) {
    base = extra = work; /* dummy value--not used */
    end = 19;
  } else if (type === LENS) {
    base = lbase;
    base_index -= 257;
    extra = lext;
    extra_index -= 257;
    end = 256;
  } else {
    /* DISTS */
    base = dbase;
    extra = dext;
    end = -1;
  }

  /* initialize opts for loop */
  huff = 0; /* starting code */
  sym = 0; /* starting code symbol */
  len = min; /* starting code length */
  next = table_index; /* current table to fill in */
  curr = root; /* current table index bits */
  drop = 0; /* current bits to drop from code for index */
  low = -1; /* trigger new sub-table when len > root */
  used = 1 << root; /* use root table entries */
  mask = used - 1; /* mask for comparing low */

  /* check available table space */
  if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {
    return 1;
  }

  var i = 0;
  /* process all codes and make table entries */
  for (;;) {
    i++;
    /* create table entry */
    here_bits = len - drop;
    if (work[sym] < end) {
      here_op = 0;
      here_val = work[sym];
    } else if (work[sym] > end) {
      here_op = extra[extra_index + work[sym]];
      here_val = base[base_index + work[sym]];
    } else {
      here_op = 32 + 64; /* end of block */
      here_val = 0;
    }

    /* replicate for those indices with low len bits equal to huff */
    incr = 1 << len - drop;
    fill = 1 << curr;
    min = fill; /* save offset to next table */
    do {
      fill -= incr;
      table[next + (huff >> drop) + fill] = here_bits << 24 | here_op << 16 | here_val | 0;
    } while (fill !== 0);

    /* backwards increment the len-bit code huff */
    incr = 1 << len - 1;
    while (huff & incr) {
      incr >>= 1;
    }
    if (incr !== 0) {
      huff &= incr - 1;
      huff += incr;
    } else {
      huff = 0;
    }

    /* go to next symbol, update count, len */
    sym++;
    if (--count[len] === 0) {
      if (len === max) {
        break;
      }
      len = lens[lens_index + work[sym]];
    }

    /* create new sub-table if needed */
    if (len > root && (huff & mask) !== low) {
      /* if first time, transition to sub-tables */
      if (drop === 0) {
        drop = root;
      }

      /* increment past last table */
      next += min; /* here min is 1 << curr */

      /* determine length of next table */
      curr = len - drop;
      left = 1 << curr;
      while (curr + drop < max) {
        left -= count[curr + drop];
        if (left <= 0) {
          break;
        }
        curr++;
        left <<= 1;
      }

      /* check for enough space */
      used += 1 << curr;
      if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {
        return 1;
      }

      /* point entry in root table to sub-table */
      low = huff & mask;
      /*table.op[low] = curr;
      table.bits[low] = root;
      table.val[low] = next - opts.table_index;*/
      table[low] = root << 24 | curr << 16 | next - table_index | 0;
    }
  }

  /* fill in remaining table entry if code is incomplete (guaranteed to have
   at most one remaining entry, since if the code is incomplete, the
   maximum code length that was allowed to get this far is one bit) */
  if (huff !== 0) {
    //table.op[next + huff] = 64;            /* invalid code marker */
    //table.bits[next + huff] = len - drop;
    //table.val[next + huff] = 0;
    table[next + huff] = len - drop << 24 | 64 << 16 | 0;
  }

  /* set return parameters */
  //opts.table_index += used;
  opts.bits = root;
  return 0;
};

},{"../utils/common":40}],50:[function(require,module,exports){
'use strict';

module.exports = {
  2: 'need dictionary', /* Z_NEED_DICT       2  */
  1: 'stream end', /* Z_STREAM_END      1  */
  0: '', /* Z_OK              0  */
  '-1': 'file error', /* Z_ERRNO         (-1) */
  '-2': 'stream error', /* Z_STREAM_ERROR  (-2) */
  '-3': 'data error', /* Z_DATA_ERROR    (-3) */
  '-4': 'insufficient memory', /* Z_MEM_ERROR     (-4) */
  '-5': 'buffer error', /* Z_BUF_ERROR     (-5) */
  '-6': 'incompatible version' /* Z_VERSION_ERROR (-6) */
};

},{}],51:[function(require,module,exports){
'use strict';

var utils = require('../utils/common');

/* Public constants ==========================================================*/
/* ===========================================================================*/

//var Z_FILTERED          = 1;
//var Z_HUFFMAN_ONLY      = 2;
//var Z_RLE               = 3;
var Z_FIXED = 4;
//var Z_DEFAULT_STRATEGY  = 0;

/* Possible values of the data_type field (though see inflate()) */
var Z_BINARY = 0;
var Z_TEXT = 1;
//var Z_ASCII             = 1; // = Z_TEXT
var Z_UNKNOWN = 2;

/*============================================================================*/

function zero(buf) {
  var len = buf.length;while (--len >= 0) {
    buf[len] = 0;
  }
}

// From zutil.h

var STORED_BLOCK = 0;
var STATIC_TREES = 1;
var DYN_TREES = 2;
/* The three kinds of block type */

var MIN_MATCH = 3;
var MAX_MATCH = 258;
/* The minimum and maximum match lengths */

// From deflate.h
/* ===========================================================================
 * Internal compression state.
 */

var LENGTH_CODES = 29;
/* number of length codes, not counting the special END_BLOCK code */

var LITERALS = 256;
/* number of literal bytes 0..255 */

var L_CODES = LITERALS + 1 + LENGTH_CODES;
/* number of Literal or Length codes, including the END_BLOCK code */

var D_CODES = 30;
/* number of distance codes */

var BL_CODES = 19;
/* number of codes used to transfer the bit lengths */

var HEAP_SIZE = 2 * L_CODES + 1;
/* maximum heap size */

var MAX_BITS = 15;
/* All codes must not exceed MAX_BITS bits */

var Buf_size = 16;
/* size of bit buffer in bi_buf */

/* ===========================================================================
 * Constants
 */

var MAX_BL_BITS = 7;
/* Bit length codes must not exceed MAX_BL_BITS bits */

var END_BLOCK = 256;
/* end of block literal code */

var REP_3_6 = 16;
/* repeat previous bit length 3-6 times (2 bits of repeat count) */

var REPZ_3_10 = 17;
/* repeat a zero length 3-10 times  (3 bits of repeat count) */

var REPZ_11_138 = 18;
/* repeat a zero length 11-138 times  (7 bits of repeat count) */

/* eslint-disable comma-spacing,array-bracket-spacing */
var extra_lbits = /* extra bits for each length code */
[0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0];

var extra_dbits = /* extra bits for each distance code */
[0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13];

var extra_blbits = /* extra bits for each bit length code */
[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7];

var bl_order = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
/* eslint-enable comma-spacing,array-bracket-spacing */

/* The lengths of the bit length codes are sent in order of decreasing
 * probability, to avoid transmitting the lengths for unused bit length codes.
 */

/* ===========================================================================
 * Local data. These are initialized only once.
 */

// We pre-fill arrays with 0 to avoid uninitialized gaps

var DIST_CODE_LEN = 512; /* see definition of array dist_code below */

// !!!! Use flat array insdead of structure, Freq = i*2, Len = i*2+1
var static_ltree = new Array((L_CODES + 2) * 2);
zero(static_ltree);
/* The static literal tree. Since the bit lengths are imposed, there is no
 * need for the L_CODES extra codes used during heap construction. However
 * The codes 286 and 287 are needed to build a canonical tree (see _tr_init
 * below).
 */

var static_dtree = new Array(D_CODES * 2);
zero(static_dtree);
/* The static distance tree. (Actually a trivial tree since all codes use
 * 5 bits.)
 */

var _dist_code = new Array(DIST_CODE_LEN);
zero(_dist_code);
/* Distance codes. The first 256 values correspond to the distances
 * 3 .. 258, the last 256 values correspond to the top 8 bits of
 * the 15 bit distances.
 */

var _length_code = new Array(MAX_MATCH - MIN_MATCH + 1);
zero(_length_code);
/* length code for each normalized match length (0 == MIN_MATCH) */

var base_length = new Array(LENGTH_CODES);
zero(base_length);
/* First normalized length for each code (0 = MIN_MATCH) */

var base_dist = new Array(D_CODES);
zero(base_dist);
/* First normalized distance for each code (0 = distance of 1) */

function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {

  this.static_tree = static_tree; /* static tree or NULL */
  this.extra_bits = extra_bits; /* extra bits for each code or NULL */
  this.extra_base = extra_base; /* base index for extra_bits */
  this.elems = elems; /* max number of elements in the tree */
  this.max_length = max_length; /* max bit length for the codes */

  // show if `static_tree` has data or dummy - needed for monomorphic objects
  this.has_stree = static_tree && static_tree.length;
}

var static_l_desc;
var static_d_desc;
var static_bl_desc;

function TreeDesc(dyn_tree, stat_desc) {
  this.dyn_tree = dyn_tree; /* the dynamic tree */
  this.max_code = 0; /* largest code with non zero frequency */
  this.stat_desc = stat_desc; /* the corresponding static tree */
}

function d_code(dist) {
  return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
}

/* ===========================================================================
 * Output a short LSB first on the stream.
 * IN assertion: there is enough room in pendingBuf.
 */
function put_short(s, w) {
  //    put_byte(s, (uch)((w) & 0xff));
  //    put_byte(s, (uch)((ush)(w) >> 8));
  s.pending_buf[s.pending++] = w & 0xff;
  s.pending_buf[s.pending++] = w >>> 8 & 0xff;
}

/* ===========================================================================
 * Send a value on a given number of bits.
 * IN assertion: length <= 16 and value fits in length bits.
 */
function send_bits(s, value, length) {
  if (s.bi_valid > Buf_size - length) {
    s.bi_buf |= value << s.bi_valid & 0xffff;
    put_short(s, s.bi_buf);
    s.bi_buf = value >> Buf_size - s.bi_valid;
    s.bi_valid += length - Buf_size;
  } else {
    s.bi_buf |= value << s.bi_valid & 0xffff;
    s.bi_valid += length;
  }
}

function send_code(s, c, tree) {
  send_bits(s, tree[c * 2] /*.Code*/, tree[c * 2 + 1] /*.Len*/);
}

/* ===========================================================================
 * Reverse the first len bits of a code, using straightforward code (a faster
 * method would use a table)
 * IN assertion: 1 <= len <= 15
 */
function bi_reverse(code, len) {
  var res = 0;
  do {
    res |= code & 1;
    code >>>= 1;
    res <<= 1;
  } while (--len > 0);
  return res >>> 1;
}

/* ===========================================================================
 * Flush the bit buffer, keeping at most 7 bits in it.
 */
function bi_flush(s) {
  if (s.bi_valid === 16) {
    put_short(s, s.bi_buf);
    s.bi_buf = 0;
    s.bi_valid = 0;
  } else if (s.bi_valid >= 8) {
    s.pending_buf[s.pending++] = s.bi_buf & 0xff;
    s.bi_buf >>= 8;
    s.bi_valid -= 8;
  }
}

/* ===========================================================================
 * Compute the optimal bit lengths for a tree and update the total bit length
 * for the current block.
 * IN assertion: the fields freq and dad are set, heap[heap_max] and
 *    above are the tree nodes sorted by increasing frequency.
 * OUT assertions: the field len is set to the optimal bit length, the
 *     array bl_count contains the frequencies for each bit length.
 *     The length opt_len is updated; static_len is also updated if stree is
 *     not null.
 */
function gen_bitlen(s, desc)
//    deflate_state *s;
//    tree_desc *desc;    /* the tree descriptor */
{
  var tree = desc.dyn_tree;
  var max_code = desc.max_code;
  var stree = desc.stat_desc.static_tree;
  var has_stree = desc.stat_desc.has_stree;
  var extra = desc.stat_desc.extra_bits;
  var base = desc.stat_desc.extra_base;
  var max_length = desc.stat_desc.max_length;
  var h; /* heap index */
  var n, m; /* iterate over the tree elements */
  var bits; /* bit length */
  var xbits; /* extra bits */
  var f; /* frequency */
  var overflow = 0; /* number of elements with bit length too large */

  for (bits = 0; bits <= MAX_BITS; bits++) {
    s.bl_count[bits] = 0;
  }

  /* In a first pass, compute the optimal bit lengths (which may
   * overflow in the case of the bit length tree).
   */
  tree[s.heap[s.heap_max] * 2 + 1] /*.Len*/ = 0; /* root of the heap */

  for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {
    n = s.heap[h];
    bits = tree[tree[n * 2 + 1] /*.Dad*/ * 2 + 1] /*.Len*/ + 1;
    if (bits > max_length) {
      bits = max_length;
      overflow++;
    }
    tree[n * 2 + 1] /*.Len*/ = bits;
    /* We overwrite tree[n].Dad which is no longer needed */

    if (n > max_code) {
      continue;
    } /* not a leaf node */

    s.bl_count[bits]++;
    xbits = 0;
    if (n >= base) {
      xbits = extra[n - base];
    }
    f = tree[n * 2] /*.Freq*/;
    s.opt_len += f * (bits + xbits);
    if (has_stree) {
      s.static_len += f * (stree[n * 2 + 1] /*.Len*/ + xbits);
    }
  }
  if (overflow === 0) {
    return;
  }

  // Trace((stderr,"\nbit length overflow\n"));
  /* This happens for example on obj2 and pic of the Calgary corpus */

  /* Find the first bit length which could increase: */
  do {
    bits = max_length - 1;
    while (s.bl_count[bits] === 0) {
      bits--;
    }
    s.bl_count[bits]--; /* move one leaf down the tree */
    s.bl_count[bits + 1] += 2; /* move one overflow item as its brother */
    s.bl_count[max_length]--;
    /* The brother of the overflow item also moves one step up,
     * but this does not affect bl_count[max_length]
     */
    overflow -= 2;
  } while (overflow > 0);

  /* Now recompute all bit lengths, scanning in increasing frequency.
   * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all
   * lengths instead of fixing only the wrong ones. This idea is taken
   * from 'ar' written by Haruhiko Okumura.)
   */
  for (bits = max_length; bits !== 0; bits--) {
    n = s.bl_count[bits];
    while (n !== 0) {
      m = s.heap[--h];
      if (m > max_code) {
        continue;
      }
      if (tree[m * 2 + 1] /*.Len*/ !== bits) {
        // Trace((stderr,"code %d bits %d->%d\n", m, tree[m].Len, bits));
        s.opt_len += (bits - tree[m * 2 + 1] /*.Len*/) * tree[m * 2] /*.Freq*/;
        tree[m * 2 + 1] /*.Len*/ = bits;
      }
      n--;
    }
  }
}

/* ===========================================================================
 * Generate the codes for a given tree and bit counts (which need not be
 * optimal).
 * IN assertion: the array bl_count contains the bit length statistics for
 * the given tree and the field len is set for all tree elements.
 * OUT assertion: the field code is set for all tree elements of non
 *     zero code length.
 */
function gen_codes(tree, max_code, bl_count)
//    ct_data *tree;             /* the tree to decorate */
//    int max_code;              /* largest code with non zero frequency */
//    ushf *bl_count;            /* number of codes at each bit length */
{
  var next_code = new Array(MAX_BITS + 1); /* next code value for each bit length */
  var code = 0; /* running code value */
  var bits; /* bit index */
  var n; /* code index */

  /* The distribution counts are first used to generate the code values
   * without bit reversal.
   */
  for (bits = 1; bits <= MAX_BITS; bits++) {
    next_code[bits] = code = code + bl_count[bits - 1] << 1;
  }
  /* Check that the bit counts in bl_count are consistent. The last code
   * must be all ones.
   */
  //Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,
  //        "inconsistent bit counts");
  //Tracev((stderr,"\ngen_codes: max_code %d ", max_code));

  for (n = 0; n <= max_code; n++) {
    var len = tree[n * 2 + 1] /*.Len*/;
    if (len === 0) {
      continue;
    }
    /* Now reverse the bits */
    tree[n * 2] /*.Code*/ = bi_reverse(next_code[len]++, len);

    //Tracecv(tree != static_ltree, (stderr,"\nn %3d %c l %2d c %4x (%x) ",
    //     n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len]-1));
  }
}

/* ===========================================================================
 * Initialize the various 'constant' tables.
 */
function tr_static_init() {
  var n; /* iterates over tree elements */
  var bits; /* bit counter */
  var length; /* length value */
  var code; /* code value */
  var dist; /* distance index */
  var bl_count = new Array(MAX_BITS + 1);
  /* number of codes at each bit length for an optimal tree */

  // do check in _tr_init()
  //if (static_init_done) return;

  /* For some embedded targets, global variables are not initialized: */
  /*#ifdef NO_INIT_GLOBAL_POINTERS
    static_l_desc.static_tree = static_ltree;
    static_l_desc.extra_bits = extra_lbits;
    static_d_desc.static_tree = static_dtree;
    static_d_desc.extra_bits = extra_dbits;
    static_bl_desc.extra_bits = extra_blbits;
  #endif*/

  /* Initialize the mapping length (0..255) -> length code (0..28) */
  length = 0;
  for (code = 0; code < LENGTH_CODES - 1; code++) {
    base_length[code] = length;
    for (n = 0; n < 1 << extra_lbits[code]; n++) {
      _length_code[length++] = code;
    }
  }
  //Assert (length == 256, "tr_static_init: length != 256");
  /* Note that the length 255 (match length 258) can be represented
   * in two different ways: code 284 + 5 bits or code 285, so we
   * overwrite length_code[255] to use the best encoding:
   */
  _length_code[length - 1] = code;

  /* Initialize the mapping dist (0..32K) -> dist code (0..29) */
  dist = 0;
  for (code = 0; code < 16; code++) {
    base_dist[code] = dist;
    for (n = 0; n < 1 << extra_dbits[code]; n++) {
      _dist_code[dist++] = code;
    }
  }
  //Assert (dist == 256, "tr_static_init: dist != 256");
  dist >>= 7; /* from now on, all distances are divided by 128 */
  for (; code < D_CODES; code++) {
    base_dist[code] = dist << 7;
    for (n = 0; n < 1 << extra_dbits[code] - 7; n++) {
      _dist_code[256 + dist++] = code;
    }
  }
  //Assert (dist == 256, "tr_static_init: 256+dist != 512");

  /* Construct the codes of the static literal tree */
  for (bits = 0; bits <= MAX_BITS; bits++) {
    bl_count[bits] = 0;
  }

  n = 0;
  while (n <= 143) {
    static_ltree[n * 2 + 1] /*.Len*/ = 8;
    n++;
    bl_count[8]++;
  }
  while (n <= 255) {
    static_ltree[n * 2 + 1] /*.Len*/ = 9;
    n++;
    bl_count[9]++;
  }
  while (n <= 279) {
    static_ltree[n * 2 + 1] /*.Len*/ = 7;
    n++;
    bl_count[7]++;
  }
  while (n <= 287) {
    static_ltree[n * 2 + 1] /*.Len*/ = 8;
    n++;
    bl_count[8]++;
  }
  /* Codes 286 and 287 do not exist, but we must include them in the
   * tree construction to get a canonical Huffman tree (longest code
   * all ones)
   */
  gen_codes(static_ltree, L_CODES + 1, bl_count);

  /* The static distance tree is trivial: */
  for (n = 0; n < D_CODES; n++) {
    static_dtree[n * 2 + 1] /*.Len*/ = 5;
    static_dtree[n * 2] /*.Code*/ = bi_reverse(n, 5);
  }

  // Now data ready and we can init static trees
  static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);
  static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES, MAX_BITS);
  static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES, MAX_BL_BITS);

  //static_init_done = true;
}

/* ===========================================================================
 * Initialize a new block.
 */
function init_block(s) {
  var n; /* iterates over tree elements */

  /* Initialize the trees. */
  for (n = 0; n < L_CODES; n++) {
    s.dyn_ltree[n * 2] /*.Freq*/ = 0;
  }
  for (n = 0; n < D_CODES; n++) {
    s.dyn_dtree[n * 2] /*.Freq*/ = 0;
  }
  for (n = 0; n < BL_CODES; n++) {
    s.bl_tree[n * 2] /*.Freq*/ = 0;
  }

  s.dyn_ltree[END_BLOCK * 2] /*.Freq*/ = 1;
  s.opt_len = s.static_len = 0;
  s.last_lit = s.matches = 0;
}

/* ===========================================================================
 * Flush the bit buffer and align the output on a byte boundary
 */
function bi_windup(s) {
  if (s.bi_valid > 8) {
    put_short(s, s.bi_buf);
  } else if (s.bi_valid > 0) {
    //put_byte(s, (Byte)s->bi_buf);
    s.pending_buf[s.pending++] = s.bi_buf;
  }
  s.bi_buf = 0;
  s.bi_valid = 0;
}

/* ===========================================================================
 * Copy a stored block, storing first the length and its
 * one's complement if requested.
 */
function copy_block(s, buf, len, header)
//DeflateState *s;
//charf    *buf;    /* the input data */
//unsigned len;     /* its length */
//int      header;  /* true if block header must be written */
{
  bi_windup(s); /* align on byte boundary */

  if (header) {
    put_short(s, len);
    put_short(s, ~len);
  }
  //  while (len--) {
  //    put_byte(s, *buf++);
  //  }
  utils.arraySet(s.pending_buf, s.window, buf, len, s.pending);
  s.pending += len;
}

/* ===========================================================================
 * Compares to subtrees, using the tree depth as tie breaker when
 * the subtrees have equal frequency. This minimizes the worst case length.
 */
function smaller(tree, n, m, depth) {
  var _n2 = n * 2;
  var _m2 = m * 2;
  return tree[_n2] /*.Freq*/ < tree[_m2] /*.Freq*/ || tree[_n2] /*.Freq*/ === tree[_m2] /*.Freq*/ && depth[n] <= depth[m];
}

/* ===========================================================================
 * Restore the heap property by moving down the tree starting at node k,
 * exchanging a node with the smallest of its two sons if necessary, stopping
 * when the heap property is re-established (each father smaller than its
 * two sons).
 */
function pqdownheap(s, tree, k)
//    deflate_state *s;
//    ct_data *tree;  /* the tree to restore */
//    int k;               /* node to move down */
{
  var v = s.heap[k];
  var j = k << 1; /* left son of k */
  while (j <= s.heap_len) {
    /* Set j to the smallest of the two sons: */
    if (j < s.heap_len && smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
      j++;
    }
    /* Exit if v is smaller than both sons */
    if (smaller(tree, v, s.heap[j], s.depth)) {
      break;
    }

    /* Exchange v with the smallest son */
    s.heap[k] = s.heap[j];
    k = j;

    /* And continue down the tree, setting j to the left son of k */
    j <<= 1;
  }
  s.heap[k] = v;
}

// inlined manually
// var SMALLEST = 1;

/* ===========================================================================
 * Send the block data compressed using the given Huffman trees
 */
function compress_block(s, ltree, dtree)
//    deflate_state *s;
//    const ct_data *ltree; /* literal tree */
//    const ct_data *dtree; /* distance tree */
{
  var dist; /* distance of matched string */
  var lc; /* match length or unmatched char (if dist == 0) */
  var lx = 0; /* running index in l_buf */
  var code; /* the code to send */
  var extra; /* number of extra bits to send */

  if (s.last_lit !== 0) {
    do {
      dist = s.pending_buf[s.d_buf + lx * 2] << 8 | s.pending_buf[s.d_buf + lx * 2 + 1];
      lc = s.pending_buf[s.l_buf + lx];
      lx++;

      if (dist === 0) {
        send_code(s, lc, ltree); /* send a literal byte */
        //Tracecv(isgraph(lc), (stderr," '%c' ", lc));
      } else {
        /* Here, lc is the match length - MIN_MATCH */
        code = _length_code[lc];
        send_code(s, code + LITERALS + 1, ltree); /* send the length code */
        extra = extra_lbits[code];
        if (extra !== 0) {
          lc -= base_length[code];
          send_bits(s, lc, extra); /* send the extra length bits */
        }
        dist--; /* dist is now the match distance - 1 */
        code = d_code(dist);
        //Assert (code < D_CODES, "bad d_code");

        send_code(s, code, dtree); /* send the distance code */
        extra = extra_dbits[code];
        if (extra !== 0) {
          dist -= base_dist[code];
          send_bits(s, dist, extra); /* send the extra distance bits */
        }
      } /* literal or match pair ? */

      /* Check that the overlay between pending_buf and d_buf+l_buf is ok: */
      //Assert((uInt)(s->pending) < s->lit_bufsize + 2*lx,
      //       "pendingBuf overflow");
    } while (lx < s.last_lit);
  }

  send_code(s, END_BLOCK, ltree);
}

/* ===========================================================================
 * Construct one Huffman tree and assigns the code bit strings and lengths.
 * Update the total bit length for the current block.
 * IN assertion: the field freq is set for all tree elements.
 * OUT assertions: the fields len and code are set to the optimal bit length
 *     and corresponding code. The length opt_len is updated; static_len is
 *     also updated if stree is not null. The field max_code is set.
 */
function build_tree(s, desc)
//    deflate_state *s;
//    tree_desc *desc; /* the tree descriptor */
{
  var tree = desc.dyn_tree;
  var stree = desc.stat_desc.static_tree;
  var has_stree = desc.stat_desc.has_stree;
  var elems = desc.stat_desc.elems;
  var n, m; /* iterate over heap elements */
  var max_code = -1; /* largest code with non zero frequency */
  var node; /* new node being created */

  /* Construct the initial heap, with least frequent element in
   * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].
   * heap[0] is not used.
   */
  s.heap_len = 0;
  s.heap_max = HEAP_SIZE;

  for (n = 0; n < elems; n++) {
    if (tree[n * 2] /*.Freq*/ !== 0) {
      s.heap[++s.heap_len] = max_code = n;
      s.depth[n] = 0;
    } else {
      tree[n * 2 + 1] /*.Len*/ = 0;
    }
  }

  /* The pkzip format requires that at least one distance code exists,
   * and that at least one bit should be sent even if there is only one
   * possible code. So to avoid special checks later on we force at least
   * two codes of non zero frequency.
   */
  while (s.heap_len < 2) {
    node = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0;
    tree[node * 2] /*.Freq*/ = 1;
    s.depth[node] = 0;
    s.opt_len--;

    if (has_stree) {
      s.static_len -= stree[node * 2 + 1] /*.Len*/;
    }
    /* node is 0 or 1 so it does not have extra bits */
  }
  desc.max_code = max_code;

  /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,
   * establish sub-heaps of increasing lengths:
   */
  for (n = s.heap_len >> 1 /*int /2*/; n >= 1; n--) {
    pqdownheap(s, tree, n);
  }

  /* Construct the Huffman tree by repeatedly combining the least two
   * frequent nodes.
   */
  node = elems; /* next internal node of the tree */
  do {
    //pqremove(s, tree, n);  /* n = node of least frequency */
    /*** pqremove ***/
    n = s.heap[1 /*SMALLEST*/];
    s.heap[1 /*SMALLEST*/] = s.heap[s.heap_len--];
    pqdownheap(s, tree, 1 /*SMALLEST*/);
    /***/

    m = s.heap[1 /*SMALLEST*/]; /* m = node of next least frequency */

    s.heap[--s.heap_max] = n; /* keep the nodes sorted by frequency */
    s.heap[--s.heap_max] = m;

    /* Create a new node father of n and m */
    tree[node * 2] /*.Freq*/ = tree[n * 2] /*.Freq*/ + tree[m * 2] /*.Freq*/;
    s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
    tree[n * 2 + 1] /*.Dad*/ = tree[m * 2 + 1] /*.Dad*/ = node;

    /* and insert the new node in the heap */
    s.heap[1 /*SMALLEST*/] = node++;
    pqdownheap(s, tree, 1 /*SMALLEST*/);
  } while (s.heap_len >= 2);

  s.heap[--s.heap_max] = s.heap[1 /*SMALLEST*/];

  /* At this point, the fields freq and dad are set. We can now
   * generate the bit lengths.
   */
  gen_bitlen(s, desc);

  /* The field len is now set, we can generate the bit codes */
  gen_codes(tree, max_code, s.bl_count);
}

/* ===========================================================================
 * Scan a literal or distance tree to determine the frequencies of the codes
 * in the bit length tree.
 */
function scan_tree(s, tree, max_code)
//    deflate_state *s;
//    ct_data *tree;   /* the tree to be scanned */
//    int max_code;    /* and its largest code of non zero frequency */
{
  var n; /* iterates over all tree elements */
  var prevlen = -1; /* last emitted length */
  var curlen; /* length of current code */

  var nextlen = tree[0 * 2 + 1] /*.Len*/; /* length of next code */

  var count = 0; /* repeat count of the current code */
  var max_count = 7; /* max repeat count */
  var min_count = 4; /* min repeat count */

  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }
  tree[(max_code + 1) * 2 + 1] /*.Len*/ = 0xffff; /* guard */

  for (n = 0; n <= max_code; n++) {
    curlen = nextlen;
    nextlen = tree[(n + 1) * 2 + 1] /*.Len*/;

    if (++count < max_count && curlen === nextlen) {
      continue;
    } else if (count < min_count) {
      s.bl_tree[curlen * 2] /*.Freq*/ += count;
    } else if (curlen !== 0) {

      if (curlen !== prevlen) {
        s.bl_tree[curlen * 2] /*.Freq*/++;
      }
      s.bl_tree[REP_3_6 * 2] /*.Freq*/++;
    } else if (count <= 10) {
      s.bl_tree[REPZ_3_10 * 2] /*.Freq*/++;
    } else {
      s.bl_tree[REPZ_11_138 * 2] /*.Freq*/++;
    }

    count = 0;
    prevlen = curlen;

    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;
    } else {
      max_count = 7;
      min_count = 4;
    }
  }
}

/* ===========================================================================
 * Send a literal or distance tree in compressed form, using the codes in
 * bl_tree.
 */
function send_tree(s, tree, max_code)
//    deflate_state *s;
//    ct_data *tree; /* the tree to be scanned */
//    int max_code;       /* and its largest code of non zero frequency */
{
  var n; /* iterates over all tree elements */
  var prevlen = -1; /* last emitted length */
  var curlen; /* length of current code */

  var nextlen = tree[0 * 2 + 1] /*.Len*/; /* length of next code */

  var count = 0; /* repeat count of the current code */
  var max_count = 7; /* max repeat count */
  var min_count = 4; /* min repeat count */

  /* tree[max_code+1].Len = -1; */ /* guard already set */
  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }

  for (n = 0; n <= max_code; n++) {
    curlen = nextlen;
    nextlen = tree[(n + 1) * 2 + 1] /*.Len*/;

    if (++count < max_count && curlen === nextlen) {
      continue;
    } else if (count < min_count) {
      do {
        send_code(s, curlen, s.bl_tree);
      } while (--count !== 0);
    } else if (curlen !== 0) {
      if (curlen !== prevlen) {
        send_code(s, curlen, s.bl_tree);
        count--;
      }
      //Assert(count >= 3 && count <= 6, " 3_6?");
      send_code(s, REP_3_6, s.bl_tree);
      send_bits(s, count - 3, 2);
    } else if (count <= 10) {
      send_code(s, REPZ_3_10, s.bl_tree);
      send_bits(s, count - 3, 3);
    } else {
      send_code(s, REPZ_11_138, s.bl_tree);
      send_bits(s, count - 11, 7);
    }

    count = 0;
    prevlen = curlen;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;
    } else {
      max_count = 7;
      min_count = 4;
    }
  }
}

/* ===========================================================================
 * Construct the Huffman tree for the bit lengths and return the index in
 * bl_order of the last bit length code to send.
 */
function build_bl_tree(s) {
  var max_blindex; /* index of last bit length code of non zero freq */

  /* Determine the bit length frequencies for literal and distance trees */
  scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
  scan_tree(s, s.dyn_dtree, s.d_desc.max_code);

  /* Build the bit length tree: */
  build_tree(s, s.bl_desc);
  /* opt_len now includes the length of the tree representations, except
   * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.
   */

  /* Determine the number of bit length codes to send. The pkzip format
   * requires that at least 4 bit length codes be sent. (appnote.txt says
   * 3 but the actual value used is 4.)
   */
  for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {
    if (s.bl_tree[bl_order[max_blindex] * 2 + 1] /*.Len*/ !== 0) {
      break;
    }
  }
  /* Update opt_len to include the bit length tree and counts */
  s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
  //Tracev((stderr, "\ndyn trees: dyn %ld, stat %ld",
  //        s->opt_len, s->static_len));

  return max_blindex;
}

/* ===========================================================================
 * Send the header for a block using dynamic Huffman trees: the counts, the
 * lengths of the bit length codes, the literal tree and the distance tree.
 * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.
 */
function send_all_trees(s, lcodes, dcodes, blcodes)
//    deflate_state *s;
//    int lcodes, dcodes, blcodes; /* number of codes for each tree */
{
  var rank; /* index in bl_order */

  //Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, "not enough codes");
  //Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,
  //        "too many codes");
  //Tracev((stderr, "\nbl counts: "));
  send_bits(s, lcodes - 257, 5); /* not +255 as stated in appnote.txt */
  send_bits(s, dcodes - 1, 5);
  send_bits(s, blcodes - 4, 4); /* not -3 as stated in appnote.txt */
  for (rank = 0; rank < blcodes; rank++) {
    //Tracev((stderr, "\nbl code %2d ", bl_order[rank]));
    send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1] /*.Len*/, 3);
  }
  //Tracev((stderr, "\nbl tree: sent %ld", s->bits_sent));

  send_tree(s, s.dyn_ltree, lcodes - 1); /* literal tree */
  //Tracev((stderr, "\nlit tree: sent %ld", s->bits_sent));

  send_tree(s, s.dyn_dtree, dcodes - 1); /* distance tree */
  //Tracev((stderr, "\ndist tree: sent %ld", s->bits_sent));
}

/* ===========================================================================
 * Check if the data type is TEXT or BINARY, using the following algorithm:
 * - TEXT if the two conditions below are satisfied:
 *    a) There are no non-portable control characters belonging to the
 *       "black list" (0..6, 14..25, 28..31).
 *    b) There is at least one printable character belonging to the
 *       "white list" (9 {TAB}, 10 {LF}, 13 {CR}, 32..255).
 * - BINARY otherwise.
 * - The following partially-portable control characters form a
 *   "gray list" that is ignored in this detection algorithm:
 *   (7 {BEL}, 8 {BS}, 11 {VT}, 12 {FF}, 26 {SUB}, 27 {ESC}).
 * IN assertion: the fields Freq of dyn_ltree are set.
 */
function detect_data_type(s) {
  /* black_mask is the bit mask of black-listed bytes
   * set bits 0..6, 14..25, and 28..31
   * 0xf3ffc07f = binary 11110011111111111100000001111111
   */
  var black_mask = 0xf3ffc07f;
  var n;

  /* Check for non-textual ("black-listed") bytes. */
  for (n = 0; n <= 31; n++, black_mask >>>= 1) {
    if (black_mask & 1 && s.dyn_ltree[n * 2] /*.Freq*/ !== 0) {
      return Z_BINARY;
    }
  }

  /* Check for textual ("white-listed") bytes. */
  if (s.dyn_ltree[9 * 2] /*.Freq*/ !== 0 || s.dyn_ltree[10 * 2] /*.Freq*/ !== 0 || s.dyn_ltree[13 * 2] /*.Freq*/ !== 0) {
    return Z_TEXT;
  }
  for (n = 32; n < LITERALS; n++) {
    if (s.dyn_ltree[n * 2] /*.Freq*/ !== 0) {
      return Z_TEXT;
    }
  }

  /* There are no "black-listed" or "white-listed" bytes:
   * this stream either is empty or has tolerated ("gray-listed") bytes only.
   */
  return Z_BINARY;
}

var static_init_done = false;

/* ===========================================================================
 * Initialize the tree data structures for a new zlib stream.
 */
function _tr_init(s) {

  if (!static_init_done) {
    tr_static_init();
    static_init_done = true;
  }

  s.l_desc = new TreeDesc(s.dyn_ltree, static_l_desc);
  s.d_desc = new TreeDesc(s.dyn_dtree, static_d_desc);
  s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);

  s.bi_buf = 0;
  s.bi_valid = 0;

  /* Initialize the first block of the first file: */
  init_block(s);
}

/* ===========================================================================
 * Send a stored block
 */
function _tr_stored_block(s, buf, stored_len, last)
//DeflateState *s;
//charf *buf;       /* input block */
//ulg stored_len;   /* length of input block */
//int last;         /* one if this is the last block for a file */
{
  send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3); /* send block type */
  copy_block(s, buf, stored_len, true); /* with header */
}

/* ===========================================================================
 * Send one empty static block to give enough lookahead for inflate.
 * This takes 10 bits, of which 7 may remain in the bit buffer.
 */
function _tr_align(s) {
  send_bits(s, STATIC_TREES << 1, 3);
  send_code(s, END_BLOCK, static_ltree);
  bi_flush(s);
}

/* ===========================================================================
 * Determine the best encoding for the current block: dynamic trees, static
 * trees or store, and output the encoded block to the zip file.
 */
function _tr_flush_block(s, buf, stored_len, last)
//DeflateState *s;
//charf *buf;       /* input block, or NULL if too old */
//ulg stored_len;   /* length of input block */
//int last;         /* one if this is the last block for a file */
{
  var opt_lenb, static_lenb; /* opt_len and static_len in bytes */
  var max_blindex = 0; /* index of last bit length code of non zero freq */

  /* Build the Huffman trees unless a stored block is forced */
  if (s.level > 0) {

    /* Check if the file is binary or text */
    if (s.strm.data_type === Z_UNKNOWN) {
      s.strm.data_type = detect_data_type(s);
    }

    /* Construct the literal and distance trees */
    build_tree(s, s.l_desc);
    // Tracev((stderr, "\nlit data: dyn %ld, stat %ld", s->opt_len,
    //        s->static_len));

    build_tree(s, s.d_desc);
    // Tracev((stderr, "\ndist data: dyn %ld, stat %ld", s->opt_len,
    //        s->static_len));
    /* At this point, opt_len and static_len are the total bit lengths of
     * the compressed block data, excluding the tree representations.
     */

    /* Build the bit length tree for the above two trees, and get the index
     * in bl_order of the last bit length code to send.
     */
    max_blindex = build_bl_tree(s);

    /* Determine the best encoding. Compute the block lengths in bytes. */
    opt_lenb = s.opt_len + 3 + 7 >>> 3;
    static_lenb = s.static_len + 3 + 7 >>> 3;

    // Tracev((stderr, "\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u ",
    //        opt_lenb, s->opt_len, static_lenb, s->static_len, stored_len,
    //        s->last_lit));

    if (static_lenb <= opt_lenb) {
      opt_lenb = static_lenb;
    }
  } else {
    // Assert(buf != (char*)0, "lost buf");
    opt_lenb = static_lenb = stored_len + 5; /* force a stored block */
  }

  if (stored_len + 4 <= opt_lenb && buf !== -1) {
    /* 4: two words for the lengths */

    /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.
     * Otherwise we can't have processed more than WSIZE input bytes since
     * the last block flush, because compression would have been
     * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to
     * transform a block into a stored block.
     */
    _tr_stored_block(s, buf, stored_len, last);
  } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {

    send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
    compress_block(s, static_ltree, static_dtree);
  } else {
    send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);
    send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
    compress_block(s, s.dyn_ltree, s.dyn_dtree);
  }
  // Assert (s->compressed_len == s->bits_sent, "bad compressed size");
  /* The above check is made mod 2^32, for files larger than 512 MB
   * and uLong implemented on 32 bits.
   */
  init_block(s);

  if (last) {
    bi_windup(s);
  }
  // Tracev((stderr,"\ncomprlen %lu(%lu) ", s->compressed_len>>3,
  //       s->compressed_len-7*last));
}

/* ===========================================================================
 * Save the match info and tally the frequency counts. Return true if
 * the current block must be flushed.
 */
function _tr_tally(s, dist, lc)
//    deflate_state *s;
//    unsigned dist;  /* distance of matched string */
//    unsigned lc;    /* match length-MIN_MATCH or unmatched char (if dist==0) */
{
  //var out_length, in_length, dcode;

  s.pending_buf[s.d_buf + s.last_lit * 2] = dist >>> 8 & 0xff;
  s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 0xff;

  s.pending_buf[s.l_buf + s.last_lit] = lc & 0xff;
  s.last_lit++;

  if (dist === 0) {
    /* lc is the unmatched char */
    s.dyn_ltree[lc * 2] /*.Freq*/++;
  } else {
    s.matches++;
    /* Here, lc is the match length - MIN_MATCH */
    dist--; /* dist = match distance - 1 */
    //Assert((ush)dist < (ush)MAX_DIST(s) &&
    //       (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&
    //       (ush)d_code(dist) < (ush)D_CODES,  "_tr_tally: bad match");

    s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2] /*.Freq*/++;
    s.dyn_dtree[d_code(dist) * 2] /*.Freq*/++;
  }

  // (!) This block is disabled in zlib defailts,
  // don't enable it for binary compatibility

  //#ifdef TRUNCATE_BLOCK
  //  /* Try to guess if it is profitable to stop the current block here */
  //  if ((s.last_lit & 0x1fff) === 0 && s.level > 2) {
  //    /* Compute an upper bound for the compressed length */
  //    out_length = s.last_lit*8;
  //    in_length = s.strstart - s.block_start;
  //
  //    for (dcode = 0; dcode < D_CODES; dcode++) {
  //      out_length += s.dyn_dtree[dcode*2]/*.Freq*/ * (5 + extra_dbits[dcode]);
  //    }
  //    out_length >>>= 3;
  //    //Tracev((stderr,"\nlast_lit %u, in %ld, out ~%ld(%ld%%) ",
  //    //       s->last_lit, in_length, out_length,
  //    //       100L - out_length*100L/in_length));
  //    if (s.matches < (s.last_lit>>1)/*int /2*/ && out_length < (in_length>>1)/*int /2*/) {
  //      return true;
  //    }
  //  }
  //#endif

  return s.last_lit === s.lit_bufsize - 1;
  /* We avoid equality with lit_bufsize because of wraparound at 64K
   * on 16 bit machines and because stored blocks are restricted to
   * 64K-1 bytes.
   */
}

exports._tr_init = _tr_init;
exports._tr_stored_block = _tr_stored_block;
exports._tr_flush_block = _tr_flush_block;
exports._tr_tally = _tr_tally;
exports._tr_align = _tr_align;

},{"../utils/common":40}],52:[function(require,module,exports){
'use strict';

function ZStream() {
  /* next input byte */
  this.input = null; // JS specific, because we have no pointers
  this.next_in = 0;
  /* number of bytes available at input */
  this.avail_in = 0;
  /* total number of input bytes read so far */
  this.total_in = 0;
  /* next output byte should be put there */
  this.output = null; // JS specific, because we have no pointers
  this.next_out = 0;
  /* remaining free space at output */
  this.avail_out = 0;
  /* total number of bytes output so far */
  this.total_out = 0;
  /* last error message, NULL if no error */
  this.msg = '' /*Z_NULL*/;
  /* not visible by applications */
  this.state = null;
  /* best guess about the data type: binary or text */
  this.data_type = 2 /*Z_UNKNOWN*/;
  /* adler32 value of the uncompressed data */
  this.adler = 0;
}

module.exports = ZStream;

},{}],53:[function(require,module,exports){
(function (process){
'use strict';

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) {
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = parts.length - 1; i >= 0; i--) {
    var last = parts[i];
    if (last === '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
}

// Split a filename into [root, dir, basename, ext], unix version
// 'root' is just a slash, or nothing.
var splitPathRe = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
var splitPath = function splitPath(filename) {
  return splitPathRe.exec(filename).slice(1);
};

// path.resolve([from ...], to)
// posix version
exports.resolve = function () {
  var resolvedPath = '',
      resolvedAbsolute = false;

  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    var path = i >= 0 ? arguments[i] : process.cwd();

    // Skip empty and invalid entries
    if (typeof path !== 'string') {
      throw new TypeError('Arguments to path.resolve must be strings');
    } else if (!path) {
      continue;
    }

    resolvedPath = path + '/' + resolvedPath;
    resolvedAbsolute = path.charAt(0) === '/';
  }

  // At this point the path should be resolved to a full absolute path, but
  // handle relative paths to be safe (might happen when process.cwd() fails)

  // Normalize the path
  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function (p) {
    return !!p;
  }), !resolvedAbsolute).join('/');

  return (resolvedAbsolute ? '/' : '') + resolvedPath || '.';
};

// path.normalize(path)
// posix version
exports.normalize = function (path) {
  var isAbsolute = exports.isAbsolute(path),
      trailingSlash = substr(path, -1) === '/';

  // Normalize the path
  path = normalizeArray(filter(path.split('/'), function (p) {
    return !!p;
  }), !isAbsolute).join('/');

  if (!path && !isAbsolute) {
    path = '.';
  }
  if (path && trailingSlash) {
    path += '/';
  }

  return (isAbsolute ? '/' : '') + path;
};

// posix version
exports.isAbsolute = function (path) {
  return path.charAt(0) === '/';
};

// posix version
exports.join = function () {
  var paths = Array.prototype.slice.call(arguments, 0);
  return exports.normalize(filter(paths, function (p, index) {
    if (typeof p !== 'string') {
      throw new TypeError('Arguments to path.join must be strings');
    }
    return p;
  }).join('/'));
};

// path.relative(from, to)
// posix version
exports.relative = function (from, to) {
  from = exports.resolve(from).substr(1);
  to = exports.resolve(to).substr(1);

  function trim(arr) {
    var start = 0;
    for (; start < arr.length; start++) {
      if (arr[start] !== '') break;
    }

    var end = arr.length - 1;
    for (; end >= 0; end--) {
      if (arr[end] !== '') break;
    }

    if (start > end) return [];
    return arr.slice(start, end - start + 1);
  }

  var fromParts = trim(from.split('/'));
  var toParts = trim(to.split('/'));

  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;
  for (var i = 0; i < length; i++) {
    if (fromParts[i] !== toParts[i]) {
      samePartsLength = i;
      break;
    }
  }

  var outputParts = [];
  for (var i = samePartsLength; i < fromParts.length; i++) {
    outputParts.push('..');
  }

  outputParts = outputParts.concat(toParts.slice(samePartsLength));

  return outputParts.join('/');
};

exports.sep = '/';
exports.delimiter = ':';

exports.dirname = function (path) {
  var result = splitPath(path),
      root = result[0],
      dir = result[1];

  if (!root && !dir) {
    // No dirname whatsoever
    return '.';
  }

  if (dir) {
    // It has a dirname, strip trailing slash
    dir = dir.substr(0, dir.length - 1);
  }

  return root + dir;
};

exports.basename = function (path, ext) {
  var f = splitPath(path)[2];
  // TODO: make this comparison case-insensitive on windows?
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
};

exports.extname = function (path) {
  return splitPath(path)[3];
};

function filter(xs, f) {
  if (xs.filter) return xs.filter(f);
  var res = [];
  for (var i = 0; i < xs.length; i++) {
    if (f(xs[i], i, xs)) res.push(xs[i]);
  }
  return res;
}

// String.prototype.substr - negative index don't work in IE8
var substr = 'ab'.substr(-1) === 'b' ? function (str, start, len) {
  return str.substr(start, len);
} : function (str, start, len) {
  if (start < 0) start = str.length + start;
  return str.substr(start, len);
};

}).call(this,require('_process'))

},{"_process":54}],54:[function(require,module,exports){
'use strict';

// shim for using process in browser

var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

(function () {
    try {
        cachedSetTimeout = setTimeout;
    } catch (e) {
        cachedSetTimeout = function cachedSetTimeout() {
            throw new Error('setTimeout is not defined');
        };
    }
    try {
        cachedClearTimeout = clearTimeout;
    } catch (e) {
        cachedClearTimeout = function cachedClearTimeout() {
            throw new Error('clearTimeout is not defined');
        };
    }
})();
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = cachedSetTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while (len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    cachedClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        cachedSetTimeout(drainQueue, 0);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () {
    return '/';
};
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function () {
    return 0;
};

},{}],55:[function(require,module,exports){
(function (Buffer){
'use strict';

// prototype class for hash functions
function Hash(blockSize, finalSize) {
  this._block = new Buffer(blockSize);
  this._finalSize = finalSize;
  this._blockSize = blockSize;
  this._len = 0;
  this._s = 0;
}

Hash.prototype.update = function (data, enc) {
  if (typeof data === 'string') {
    enc = enc || 'utf8';
    data = new Buffer(data, enc);
  }

  var l = this._len += data.length;
  var s = this._s || 0;
  var f = 0;
  var buffer = this._block;

  while (s < l) {
    var t = Math.min(data.length, f + this._blockSize - s % this._blockSize);
    var ch = t - f;

    for (var i = 0; i < ch; i++) {
      buffer[s % this._blockSize + i] = data[i + f];
    }

    s += ch;
    f += ch;

    if (s % this._blockSize === 0) {
      this._update(buffer);
    }
  }
  this._s = s;

  return this;
};

Hash.prototype.digest = function (enc) {
  // Suppose the length of the message M, in bits, is l
  var l = this._len * 8;

  // Append the bit 1 to the end of the message
  this._block[this._len % this._blockSize] = 0x80;

  // and then k zero bits, where k is the smallest non-negative solution to the equation (l + 1 + k) === finalSize mod blockSize
  this._block.fill(0, this._len % this._blockSize + 1);

  if (l % (this._blockSize * 8) >= this._finalSize * 8) {
    this._update(this._block);
    this._block.fill(0);
  }

  // to this append the block which is equal to the number l written in binary
  // TODO: handle case where l is > Math.pow(2, 29)
  this._block.writeInt32BE(l, this._blockSize - 4);

  var hash = this._update(this._block) || this._hash();

  return enc ? hash.toString(enc) : hash;
};

Hash.prototype._update = function () {
  throw new Error('_update must be implemented by subclass');
};

module.exports = Hash;

}).call(this,require("buffer").Buffer)

},{"buffer":2}],56:[function(require,module,exports){
'use strict';

var _exports = module.exports = function SHA(algorithm) {
  algorithm = algorithm.toLowerCase();

  var Algorithm = _exports[algorithm];
  if (!Algorithm) throw new Error(algorithm + ' is not supported (we accept pull requests)');

  return new Algorithm();
};

_exports.sha = require('./sha');
_exports.sha1 = require('./sha1');
_exports.sha224 = require('./sha224');
_exports.sha256 = require('./sha256');
_exports.sha384 = require('./sha384');
_exports.sha512 = require('./sha512');

},{"./sha":57,"./sha1":58,"./sha224":59,"./sha256":60,"./sha384":61,"./sha512":62}],57:[function(require,module,exports){
(function (Buffer){
'use strict';

/*
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-0, as defined
 * in FIPS PUB 180-1
 * This source code is derived from sha1.js of the same repository.
 * The difference between SHA-0 and SHA-1 is just a bitwise rotate left
 * operation was added.
 */

var inherits = require('inherits');
var Hash = require('./hash');

var K = [0x5a827999, 0x6ed9eba1, 0x8f1bbcdc | 0, 0xca62c1d6 | 0];

var W = new Array(80);

function Sha() {
  this.init();
  this._w = W;

  Hash.call(this, 64, 56);
}

inherits(Sha, Hash);

Sha.prototype.init = function () {
  this._a = 0x67452301;
  this._b = 0xefcdab89;
  this._c = 0x98badcfe;
  this._d = 0x10325476;
  this._e = 0xc3d2e1f0;

  return this;
};

function rotl5(num) {
  return num << 5 | num >>> 27;
}

function rotl30(num) {
  return num << 30 | num >>> 2;
}

function ft(s, b, c, d) {
  if (s === 0) return b & c | ~b & d;
  if (s === 2) return b & c | b & d | c & d;
  return b ^ c ^ d;
}

Sha.prototype._update = function (M) {
  var W = this._w;

  var a = this._a | 0;
  var b = this._b | 0;
  var c = this._c | 0;
  var d = this._d | 0;
  var e = this._e | 0;

  for (var i = 0; i < 16; ++i) {
    W[i] = M.readInt32BE(i * 4);
  }for (; i < 80; ++i) {
    W[i] = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16];
  }for (var j = 0; j < 80; ++j) {
    var s = ~~(j / 20);
    var t = rotl5(a) + ft(s, b, c, d) + e + W[j] + K[s] | 0;

    e = d;
    d = c;
    c = rotl30(b);
    b = a;
    a = t;
  }

  this._a = a + this._a | 0;
  this._b = b + this._b | 0;
  this._c = c + this._c | 0;
  this._d = d + this._d | 0;
  this._e = e + this._e | 0;
};

Sha.prototype._hash = function () {
  var H = new Buffer(20);

  H.writeInt32BE(this._a | 0, 0);
  H.writeInt32BE(this._b | 0, 4);
  H.writeInt32BE(this._c | 0, 8);
  H.writeInt32BE(this._d | 0, 12);
  H.writeInt32BE(this._e | 0, 16);

  return H;
};

module.exports = Sha;

}).call(this,require("buffer").Buffer)

},{"./hash":55,"buffer":2,"inherits":6}],58:[function(require,module,exports){
(function (Buffer){
'use strict';

/*
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined
 * in FIPS PUB 180-1
 * Version 2.1a Copyright Paul Johnston 2000 - 2002.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for details.
 */

var inherits = require('inherits');
var Hash = require('./hash');

var K = [0x5a827999, 0x6ed9eba1, 0x8f1bbcdc | 0, 0xca62c1d6 | 0];

var W = new Array(80);

function Sha1() {
  this.init();
  this._w = W;

  Hash.call(this, 64, 56);
}

inherits(Sha1, Hash);

Sha1.prototype.init = function () {
  this._a = 0x67452301;
  this._b = 0xefcdab89;
  this._c = 0x98badcfe;
  this._d = 0x10325476;
  this._e = 0xc3d2e1f0;

  return this;
};

function rotl1(num) {
  return num << 1 | num >>> 31;
}

function rotl5(num) {
  return num << 5 | num >>> 27;
}

function rotl30(num) {
  return num << 30 | num >>> 2;
}

function ft(s, b, c, d) {
  if (s === 0) return b & c | ~b & d;
  if (s === 2) return b & c | b & d | c & d;
  return b ^ c ^ d;
}

Sha1.prototype._update = function (M) {
  var W = this._w;

  var a = this._a | 0;
  var b = this._b | 0;
  var c = this._c | 0;
  var d = this._d | 0;
  var e = this._e | 0;

  for (var i = 0; i < 16; ++i) {
    W[i] = M.readInt32BE(i * 4);
  }for (; i < 80; ++i) {
    W[i] = rotl1(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16]);
  }for (var j = 0; j < 80; ++j) {
    var s = ~~(j / 20);
    var t = rotl5(a) + ft(s, b, c, d) + e + W[j] + K[s] | 0;

    e = d;
    d = c;
    c = rotl30(b);
    b = a;
    a = t;
  }

  this._a = a + this._a | 0;
  this._b = b + this._b | 0;
  this._c = c + this._c | 0;
  this._d = d + this._d | 0;
  this._e = e + this._e | 0;
};

Sha1.prototype._hash = function () {
  var H = new Buffer(20);

  H.writeInt32BE(this._a | 0, 0);
  H.writeInt32BE(this._b | 0, 4);
  H.writeInt32BE(this._c | 0, 8);
  H.writeInt32BE(this._d | 0, 12);
  H.writeInt32BE(this._e | 0, 16);

  return H;
};

module.exports = Sha1;

}).call(this,require("buffer").Buffer)

},{"./hash":55,"buffer":2,"inherits":6}],59:[function(require,module,exports){
(function (Buffer){
'use strict';

/**
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined
 * in FIPS 180-2
 * Version 2.2-beta Copyright Angel Marin, Paul Johnston 2000 - 2009.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 *
 */

var inherits = require('inherits');
var Sha256 = require('./sha256');
var Hash = require('./hash');

var W = new Array(64);

function Sha224() {
  this.init();

  this._w = W; // new Array(64)

  Hash.call(this, 64, 56);
}

inherits(Sha224, Sha256);

Sha224.prototype.init = function () {
  this._a = 0xc1059ed8;
  this._b = 0x367cd507;
  this._c = 0x3070dd17;
  this._d = 0xf70e5939;
  this._e = 0xffc00b31;
  this._f = 0x68581511;
  this._g = 0x64f98fa7;
  this._h = 0xbefa4fa4;

  return this;
};

Sha224.prototype._hash = function () {
  var H = new Buffer(28);

  H.writeInt32BE(this._a, 0);
  H.writeInt32BE(this._b, 4);
  H.writeInt32BE(this._c, 8);
  H.writeInt32BE(this._d, 12);
  H.writeInt32BE(this._e, 16);
  H.writeInt32BE(this._f, 20);
  H.writeInt32BE(this._g, 24);

  return H;
};

module.exports = Sha224;

}).call(this,require("buffer").Buffer)

},{"./hash":55,"./sha256":60,"buffer":2,"inherits":6}],60:[function(require,module,exports){
(function (Buffer){
'use strict';

/**
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined
 * in FIPS 180-2
 * Version 2.2-beta Copyright Angel Marin, Paul Johnston 2000 - 2009.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 *
 */

var inherits = require('inherits');
var Hash = require('./hash');

var K = [0x428A2F98, 0x71374491, 0xB5C0FBCF, 0xE9B5DBA5, 0x3956C25B, 0x59F111F1, 0x923F82A4, 0xAB1C5ED5, 0xD807AA98, 0x12835B01, 0x243185BE, 0x550C7DC3, 0x72BE5D74, 0x80DEB1FE, 0x9BDC06A7, 0xC19BF174, 0xE49B69C1, 0xEFBE4786, 0x0FC19DC6, 0x240CA1CC, 0x2DE92C6F, 0x4A7484AA, 0x5CB0A9DC, 0x76F988DA, 0x983E5152, 0xA831C66D, 0xB00327C8, 0xBF597FC7, 0xC6E00BF3, 0xD5A79147, 0x06CA6351, 0x14292967, 0x27B70A85, 0x2E1B2138, 0x4D2C6DFC, 0x53380D13, 0x650A7354, 0x766A0ABB, 0x81C2C92E, 0x92722C85, 0xA2BFE8A1, 0xA81A664B, 0xC24B8B70, 0xC76C51A3, 0xD192E819, 0xD6990624, 0xF40E3585, 0x106AA070, 0x19A4C116, 0x1E376C08, 0x2748774C, 0x34B0BCB5, 0x391C0CB3, 0x4ED8AA4A, 0x5B9CCA4F, 0x682E6FF3, 0x748F82EE, 0x78A5636F, 0x84C87814, 0x8CC70208, 0x90BEFFFA, 0xA4506CEB, 0xBEF9A3F7, 0xC67178F2];

var W = new Array(64);

function Sha256() {
  this.init();

  this._w = W; // new Array(64)

  Hash.call(this, 64, 56);
}

inherits(Sha256, Hash);

Sha256.prototype.init = function () {
  this._a = 0x6a09e667;
  this._b = 0xbb67ae85;
  this._c = 0x3c6ef372;
  this._d = 0xa54ff53a;
  this._e = 0x510e527f;
  this._f = 0x9b05688c;
  this._g = 0x1f83d9ab;
  this._h = 0x5be0cd19;

  return this;
};

function ch(x, y, z) {
  return z ^ x & (y ^ z);
}

function maj(x, y, z) {
  return x & y | z & (x | y);
}

function sigma0(x) {
  return (x >>> 2 | x << 30) ^ (x >>> 13 | x << 19) ^ (x >>> 22 | x << 10);
}

function sigma1(x) {
  return (x >>> 6 | x << 26) ^ (x >>> 11 | x << 21) ^ (x >>> 25 | x << 7);
}

function gamma0(x) {
  return (x >>> 7 | x << 25) ^ (x >>> 18 | x << 14) ^ x >>> 3;
}

function gamma1(x) {
  return (x >>> 17 | x << 15) ^ (x >>> 19 | x << 13) ^ x >>> 10;
}

Sha256.prototype._update = function (M) {
  var W = this._w;

  var a = this._a | 0;
  var b = this._b | 0;
  var c = this._c | 0;
  var d = this._d | 0;
  var e = this._e | 0;
  var f = this._f | 0;
  var g = this._g | 0;
  var h = this._h | 0;

  for (var i = 0; i < 16; ++i) {
    W[i] = M.readInt32BE(i * 4);
  }for (; i < 64; ++i) {
    W[i] = gamma1(W[i - 2]) + W[i - 7] + gamma0(W[i - 15]) + W[i - 16] | 0;
  }for (var j = 0; j < 64; ++j) {
    var T1 = h + sigma1(e) + ch(e, f, g) + K[j] + W[j] | 0;
    var T2 = sigma0(a) + maj(a, b, c) | 0;

    h = g;
    g = f;
    f = e;
    e = d + T1 | 0;
    d = c;
    c = b;
    b = a;
    a = T1 + T2 | 0;
  }

  this._a = a + this._a | 0;
  this._b = b + this._b | 0;
  this._c = c + this._c | 0;
  this._d = d + this._d | 0;
  this._e = e + this._e | 0;
  this._f = f + this._f | 0;
  this._g = g + this._g | 0;
  this._h = h + this._h | 0;
};

Sha256.prototype._hash = function () {
  var H = new Buffer(32);

  H.writeInt32BE(this._a, 0);
  H.writeInt32BE(this._b, 4);
  H.writeInt32BE(this._c, 8);
  H.writeInt32BE(this._d, 12);
  H.writeInt32BE(this._e, 16);
  H.writeInt32BE(this._f, 20);
  H.writeInt32BE(this._g, 24);
  H.writeInt32BE(this._h, 28);

  return H;
};

module.exports = Sha256;

}).call(this,require("buffer").Buffer)

},{"./hash":55,"buffer":2,"inherits":6}],61:[function(require,module,exports){
(function (Buffer){
'use strict';

var inherits = require('inherits');
var SHA512 = require('./sha512');
var Hash = require('./hash');

var W = new Array(160);

function Sha384() {
  this.init();
  this._w = W;

  Hash.call(this, 128, 112);
}

inherits(Sha384, SHA512);

Sha384.prototype.init = function () {
  this._ah = 0xcbbb9d5d;
  this._bh = 0x629a292a;
  this._ch = 0x9159015a;
  this._dh = 0x152fecd8;
  this._eh = 0x67332667;
  this._fh = 0x8eb44a87;
  this._gh = 0xdb0c2e0d;
  this._hh = 0x47b5481d;

  this._al = 0xc1059ed8;
  this._bl = 0x367cd507;
  this._cl = 0x3070dd17;
  this._dl = 0xf70e5939;
  this._el = 0xffc00b31;
  this._fl = 0x68581511;
  this._gl = 0x64f98fa7;
  this._hl = 0xbefa4fa4;

  return this;
};

Sha384.prototype._hash = function () {
  var H = new Buffer(48);

  function writeInt64BE(h, l, offset) {
    H.writeInt32BE(h, offset);
    H.writeInt32BE(l, offset + 4);
  }

  writeInt64BE(this._ah, this._al, 0);
  writeInt64BE(this._bh, this._bl, 8);
  writeInt64BE(this._ch, this._cl, 16);
  writeInt64BE(this._dh, this._dl, 24);
  writeInt64BE(this._eh, this._el, 32);
  writeInt64BE(this._fh, this._fl, 40);

  return H;
};

module.exports = Sha384;

}).call(this,require("buffer").Buffer)

},{"./hash":55,"./sha512":62,"buffer":2,"inherits":6}],62:[function(require,module,exports){
(function (Buffer){
'use strict';

var inherits = require('inherits');
var Hash = require('./hash');

var K = [0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd, 0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc, 0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019, 0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118, 0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe, 0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2, 0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1, 0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694, 0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3, 0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65, 0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483, 0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5, 0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210, 0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4, 0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725, 0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70, 0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926, 0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df, 0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8, 0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b, 0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001, 0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30, 0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910, 0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8, 0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53, 0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8, 0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb, 0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3, 0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60, 0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec, 0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9, 0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b, 0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207, 0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178, 0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6, 0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b, 0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493, 0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c, 0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a, 0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817];

var W = new Array(160);

function Sha512() {
  this.init();
  this._w = W;

  Hash.call(this, 128, 112);
}

inherits(Sha512, Hash);

Sha512.prototype.init = function () {
  this._ah = 0x6a09e667;
  this._bh = 0xbb67ae85;
  this._ch = 0x3c6ef372;
  this._dh = 0xa54ff53a;
  this._eh = 0x510e527f;
  this._fh = 0x9b05688c;
  this._gh = 0x1f83d9ab;
  this._hh = 0x5be0cd19;

  this._al = 0xf3bcc908;
  this._bl = 0x84caa73b;
  this._cl = 0xfe94f82b;
  this._dl = 0x5f1d36f1;
  this._el = 0xade682d1;
  this._fl = 0x2b3e6c1f;
  this._gl = 0xfb41bd6b;
  this._hl = 0x137e2179;

  return this;
};

function Ch(x, y, z) {
  return z ^ x & (y ^ z);
}

function maj(x, y, z) {
  return x & y | z & (x | y);
}

function sigma0(x, xl) {
  return (x >>> 28 | xl << 4) ^ (xl >>> 2 | x << 30) ^ (xl >>> 7 | x << 25);
}

function sigma1(x, xl) {
  return (x >>> 14 | xl << 18) ^ (x >>> 18 | xl << 14) ^ (xl >>> 9 | x << 23);
}

function Gamma0(x, xl) {
  return (x >>> 1 | xl << 31) ^ (x >>> 8 | xl << 24) ^ x >>> 7;
}

function Gamma0l(x, xl) {
  return (x >>> 1 | xl << 31) ^ (x >>> 8 | xl << 24) ^ (x >>> 7 | xl << 25);
}

function Gamma1(x, xl) {
  return (x >>> 19 | xl << 13) ^ (xl >>> 29 | x << 3) ^ x >>> 6;
}

function Gamma1l(x, xl) {
  return (x >>> 19 | xl << 13) ^ (xl >>> 29 | x << 3) ^ (x >>> 6 | xl << 26);
}

function getCarry(a, b) {
  return a >>> 0 < b >>> 0 ? 1 : 0;
}

Sha512.prototype._update = function (M) {
  var W = this._w;

  var ah = this._ah | 0;
  var bh = this._bh | 0;
  var ch = this._ch | 0;
  var dh = this._dh | 0;
  var eh = this._eh | 0;
  var fh = this._fh | 0;
  var gh = this._gh | 0;
  var hh = this._hh | 0;

  var al = this._al | 0;
  var bl = this._bl | 0;
  var cl = this._cl | 0;
  var dl = this._dl | 0;
  var el = this._el | 0;
  var fl = this._fl | 0;
  var gl = this._gl | 0;
  var hl = this._hl | 0;

  for (var i = 0; i < 32; i += 2) {
    W[i] = M.readInt32BE(i * 4);
    W[i + 1] = M.readInt32BE(i * 4 + 4);
  }
  for (; i < 160; i += 2) {
    var xh = W[i - 15 * 2];
    var xl = W[i - 15 * 2 + 1];
    var gamma0 = Gamma0(xh, xl);
    var gamma0l = Gamma0l(xl, xh);

    xh = W[i - 2 * 2];
    xl = W[i - 2 * 2 + 1];
    var gamma1 = Gamma1(xh, xl);
    var gamma1l = Gamma1l(xl, xh);

    // W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16]
    var Wi7h = W[i - 7 * 2];
    var Wi7l = W[i - 7 * 2 + 1];

    var Wi16h = W[i - 16 * 2];
    var Wi16l = W[i - 16 * 2 + 1];

    var Wil = gamma0l + Wi7l | 0;
    var Wih = gamma0 + Wi7h + getCarry(Wil, gamma0l) | 0;
    Wil = Wil + gamma1l | 0;
    Wih = Wih + gamma1 + getCarry(Wil, gamma1l) | 0;
    Wil = Wil + Wi16l | 0;
    Wih = Wih + Wi16h + getCarry(Wil, Wi16l) | 0;

    W[i] = Wih;
    W[i + 1] = Wil;
  }

  for (var j = 0; j < 160; j += 2) {
    Wih = W[j];
    Wil = W[j + 1];

    var majh = maj(ah, bh, ch);
    var majl = maj(al, bl, cl);

    var sigma0h = sigma0(ah, al);
    var sigma0l = sigma0(al, ah);
    var sigma1h = sigma1(eh, el);
    var sigma1l = sigma1(el, eh);

    // t1 = h + sigma1 + ch + K[j] + W[j]
    var Kih = K[j];
    var Kil = K[j + 1];

    var chh = Ch(eh, fh, gh);
    var chl = Ch(el, fl, gl);

    var t1l = hl + sigma1l | 0;
    var t1h = hh + sigma1h + getCarry(t1l, hl) | 0;
    t1l = t1l + chl | 0;
    t1h = t1h + chh + getCarry(t1l, chl) | 0;
    t1l = t1l + Kil | 0;
    t1h = t1h + Kih + getCarry(t1l, Kil) | 0;
    t1l = t1l + Wil | 0;
    t1h = t1h + Wih + getCarry(t1l, Wil) | 0;

    // t2 = sigma0 + maj
    var t2l = sigma0l + majl | 0;
    var t2h = sigma0h + majh + getCarry(t2l, sigma0l) | 0;

    hh = gh;
    hl = gl;
    gh = fh;
    gl = fl;
    fh = eh;
    fl = el;
    el = dl + t1l | 0;
    eh = dh + t1h + getCarry(el, dl) | 0;
    dh = ch;
    dl = cl;
    ch = bh;
    cl = bl;
    bh = ah;
    bl = al;
    al = t1l + t2l | 0;
    ah = t1h + t2h + getCarry(al, t1l) | 0;
  }

  this._al = this._al + al | 0;
  this._bl = this._bl + bl | 0;
  this._cl = this._cl + cl | 0;
  this._dl = this._dl + dl | 0;
  this._el = this._el + el | 0;
  this._fl = this._fl + fl | 0;
  this._gl = this._gl + gl | 0;
  this._hl = this._hl + hl | 0;

  this._ah = this._ah + ah + getCarry(this._al, al) | 0;
  this._bh = this._bh + bh + getCarry(this._bl, bl) | 0;
  this._ch = this._ch + ch + getCarry(this._cl, cl) | 0;
  this._dh = this._dh + dh + getCarry(this._dl, dl) | 0;
  this._eh = this._eh + eh + getCarry(this._el, el) | 0;
  this._fh = this._fh + fh + getCarry(this._fl, fl) | 0;
  this._gh = this._gh + gh + getCarry(this._gl, gl) | 0;
  this._hh = this._hh + hh + getCarry(this._hl, hl) | 0;
};

Sha512.prototype._hash = function () {
  var H = new Buffer(64);

  function writeInt64BE(h, l, offset) {
    H.writeInt32BE(h, offset);
    H.writeInt32BE(l, offset + 4);
  }

  writeInt64BE(this._ah, this._al, 0);
  writeInt64BE(this._bh, this._bl, 8);
  writeInt64BE(this._ch, this._cl, 16);
  writeInt64BE(this._dh, this._dl, 24);
  writeInt64BE(this._eh, this._el, 32);
  writeInt64BE(this._fh, this._fl, 40);
  writeInt64BE(this._gh, this._gl, 48);
  writeInt64BE(this._hh, this._hl, 56);

  return H;
};

module.exports = Sha512;

}).call(this,require("buffer").Buffer)

},{"./hash":55,"buffer":2,"inherits":6}],63:[function(require,module,exports){
'use strict';

module.exports = function (str, search, pos) {
	pos = typeof pos === 'number' ? pos : 0;

	if (typeof str !== 'string') {
		throw new TypeError('Expected a string');
	}

	return str.indexOf(search, pos) !== -1;
};

},{}],64:[function(require,module,exports){
'use strict';

var dateTimeRegex = /^(\d{4}):(\d{2}):(\d{2}) (\d{2}):(\d{2}):(\d{2})$/;

class IFD {
    constructor() {
        this.fields = new Map();
    }

    // Custom fields
    get size() {
        return this.width * this.height;
    }
    get width() {
        return this.imageWidth;
    }
    get height() {
        return this.imageLength;
    }
    get components() {
        return this.samplesPerPixel;
    }
    get date() {
        var date = new Date();
        var result = dateTimeRegex.exec(this.dateTime);
        date.setFullYear(result[1], result[2] - 1, result[3]);
        date.setHours(result[4], result[5], result[6]);
        return date;
    }

    // IFD fields
    get newSubfileType() {
        return this.fields.get(254);
    }
    get imageWidth() {
        return this.fields.get(256);
    }
    get imageLength() {
        return this.fields.get(257);
    }
    get bitsPerSample() {
        return this.fields.get(258);
    }
    get compression() {
        return this.fields.get(259) || 1;
    }
    get type() {
        return this.fields.get(262);
    }
    get fillOrder() {
        return this.fields.get(266) || 1;
    }
    get documentName() {
        return this.fields.get(269);
    }
    get imageDescription() {
        return this.fields.get(270);
    }
    get stripOffsets() {
        return alwaysArray(this.fields.get(273));
    }
    get orientation() {
        return this.fields.get(274);
    }
    get samplesPerPixel() {
        return this.fields.get(277);
    }
    get rowsPerStrip() {
        return this.fields.get(278);
    }
    get stripByteCounts() {
        return alwaysArray(this.fields.get(279));
    }
    get minSampleValue() {
        return this.fields.get(280) || 0;
    }
    get maxSampleValue() {
        return this.fields.get(281) || Math.pow(2, this.bitsPerSample) - 1;
    }
    get xResolution() {
        return this.fields.get(282);
    }
    get yResolution() {
        return this.fields.get(283);
    }
    get planarConfiguration() {
        return this.fields.get(284) || 1;
    }
    get resolutionUnit() {
        return this.fields.get(296) || 2;
    }
    get dateTime() {
        return this.fields.get(306);
    }
    get predictor() {
        return this.fields.get(317) || 1;
    }
    get sampleFormat() {
        return this.fields.get(339) || 1;
    }
    get sMinSampleValue() {
        return this.fields.get(340) || this.minSampleValue;
    }
    get sMaxSampleValue() {
        return this.fields.get(341) || this.maxSampleValue;
    }
}

module.exports = IFD;

function alwaysArray(value) {
    if (typeof value === 'number') return [value];
    return value;
}

},{}],65:[function(require,module,exports){
'use strict';

var types = new Map([[1, [1, readByte]], // BYTE
[2, [1, readASCII]], // ASCII
[3, [2, readShort]], // SHORT
[4, [4, readLong]], // LONG
[5, [8, readRational]], // RATIONAL
[6, [1, readSByte]], // SBYTE
[7, [1, readByte]], // UNDEFINED
[8, [2, readSShort]], // SSHORT
[9, [4, readSLong]], // SLONG
[10, [8, readSRational]], // SRATIONAL
[11, [4, readFloat]], // FLOAT
[12, [8, readDouble]] // DOUBLE
]);

exports.getByteLength = function (type, count) {
    return types.get(type)[0] * count;
};

exports.readData = function (decoder, type, count) {
    return types.get(type)[1](decoder, count);
};

function readByte(decoder, count) {
    if (count === 1) return decoder.readUint8();
    var array = new Uint8Array(count);
    for (var i = 0; i < count; i++) {
        array[i] = decoder.readUint8();
    }
    return array;
}

function readASCII(decoder, count) {
    var strings = [];
    var currentString = '';
    for (var i = 0; i < count; i++) {
        var char = String.fromCharCode(decoder.readUint8());
        if (char === '\0') {
            strings.push(currentString);
            currentString = '';
        } else {
            currentString += char;
        }
    }
    if (strings.length === 1) {
        return strings[0];
    } else {
        return strings;
    }
}

function readShort(decoder, count) {
    if (count === 1) return decoder.readUint16();
    var array = new Uint16Array(count);
    for (var i = 0; i < count; i++) {
        array[i] = decoder.readUint16();
    }
    return array;
}

function readLong(decoder, count) {
    if (count === 1) return decoder.readUint32();
    var array = new Uint32Array(count);
    for (var i = 0; i < count; i++) {
        array[i] = decoder.readUint32();
    }
    return array;
}

function readRational(decoder, count) {
    if (count === 1) {
        return [decoder.readUint32(), decoder.readUint32()];
    }
    var rationals = new Array(count);
    for (var i = 0; i < count; i++) {
        rationals[i] = [decoder.readUint32(), decoder.readUint32()];
    }
    return rationals;
}

function readSByte(decoder, count) {
    if (count === 1) return decoder.readInt8();
    var array = new Int8Array(count);
    for (var i = 0; i < count; i++) {
        array[i] = decoder.readInt8();
    }
    return array;
}

function readSShort(decoder, count) {
    if (count === 1) return decoder.readInt16();
    var array = new Int16Array(count);
    for (var i = 0; i < count; i++) {
        array[i] = decoder.readInt16();
    }
    return array;
}

function readSLong(decoder, count) {
    if (count === 1) return decoder.readInt32();
    var array = new Int32Array(count);
    for (var i = 0; i < count; i++) {
        array[i] = decoder.readInt32();
    }
    return array;
}

function readSRational(decoder, count) {
    if (count === 1) {
        return [decoder.readInt32(), decoder.readInt32()];
    }
    var rationals = new Array(count);
    for (var i = 0; i < count; i++) {
        rationals[i] = [decoder.readInt32(), decoder.readInt32()];
    }
    return rationals;
}

function readFloat(decoder, count) {
    if (count === 1) return decoder.readFloat32();
    var array = new Float32Array(count);
    for (var i = 0; i < count; i++) {
        array[i] = decoder.readFloat32();
    }
    return array;
}

function readDouble(decoder, count) {
    if (count === 1) return decoder.readFloat64();
    var array = new Float64Array(count);
    for (var i = 0; i < count; i++) {
        array[i] = decoder.readFloat64();
    }
    return array;
}

},{}],66:[function(require,module,exports){
'use strict';

class TIFF {
    constructor() {
        this.ifd = [];
    }
}

module.exports = TIFF;

},{}],67:[function(require,module,exports){
'use strict';

var IOBuffer = require('iobuffer');
var IFD = require('./IFD');
var IFDValue = require('./IFDValue');
var TIFF = require('./TIFF');

class TIFFDecoder extends IOBuffer {
    constructor(data) {
        super(data);
        this._decoded = false;
        this._tiff = null;
        this._nextIFD = 0;
    }

    decode() {
        if (this._decoded) return this._tiff;
        this._tiff = new TIFF();
        this.decodeHeader();
        while (this._nextIFD) {
            this.decodeIFD();
        }
        return this._tiff;
    }

    decodeHeader() {
        // Byte offset
        var value = this.readUint16();
        if (value === 0x4949) {
            this.setLittleEndian();
        } else if (value === 0x4D4D) {
            this.setBigEndian();
        } else {
            throw new Error('invalid byte order: 0x' + value.toString(16));
        }

        // Magic number
        value = this.readUint16();
        if (value !== 42) {
            throw new Error('not a TIFF file');
        }

        // Offset of the first IFD
        this._nextIFD = this.readUint32();
    }

    decodeIFD() {
        this.seek(this._nextIFD);
        var ifd = new IFD();
        this._tiff.ifd.push(ifd);
        var numEntries = this.readUint16();
        for (var i = 0; i < numEntries; i++) {
            this.decodeIFDEntry(ifd);
        }
        this.decodeImageData(ifd);
        this._nextIFD = this.readUint32();
    }

    decodeIFDEntry(ifd) {
        this.mark();
        var tag = this.readUint16();
        var type = this.readUint16();
        var numValues = this.readUint32();

        if (type < 1 || type > 12) {
            this.skip(4); // unknown type, skip this value
            return;
        }

        var valueByteLength = IFDValue.getByteLength(type, numValues);
        if (valueByteLength > 4) {
            this.seek(this.readUint32());
        }

        var value = IFDValue.readData(this, type, numValues);
        ifd.fields.set(tag, value);

        // go to the next entry
        this.reset();
        this.skip(12);
    }

    decodeImageData(ifd) {
        var orientation = ifd.orientation;
        if (orientation && orientation !== 1) {
            unsupported('orientation', orientation);
        }
        switch (ifd.type) {
            case 1:
                // BlackIsZero
                this.decodeBilevelOrGrey(ifd);
                break;
            default:
                unsupported('image type', ifd.type);
                break;
        }
    }

    decodeBilevelOrGrey(ifd) {
        var width = ifd.width;
        var height = ifd.height;

        var bitDepth = ifd.bitsPerSample;
        var sampleFormat = ifd.sampleFormat;
        var size = width * height;
        var data = getDataArray(size, 1, bitDepth, sampleFormat);

        var compression = ifd.compression;
        var rowsPerStrip = ifd.rowsPerStrip;
        var maxPixels = rowsPerStrip * width;
        var stripOffsets = ifd.stripOffsets;
        var stripByteCounts = ifd.stripByteCounts;

        var pixel = 0;
        for (var i = 0; i < stripOffsets.length; i++) {
            var stripData = this.getStripData(compression, stripOffsets[i], stripByteCounts[i]);
            // Last strip can be smaller
            var length = size > maxPixels ? maxPixels : size;
            size -= length;
            if (bitDepth === 8) {
                pixel = fill8bit(data, stripData, pixel, length);
            } else if (bitDepth === 16) {
                pixel = fill16bit(data, stripData, pixel, length, this.isLittleEndian());
            } else if (bitDepth === 32 && sampleFormat === 3) {
                pixel = fillFloat32(data, stripData, pixel, length, this.isLittleEndian());
            } else {
                unsupported('bitDepth', bitDepth);
            }
        }

        ifd.data = data;
    }

    getStripData(compression, offset, byteCounts) {
        switch (compression) {
            case 1:
                // No compression
                return new DataView(this.buffer, offset, byteCounts);
                break;
            case 2: // CCITT Group 3 1-Dimensional Modified Huffman run length encoding
            case 32773:
                // PackBits compression
                unsupported('Compression', compression);
                break;
            default:
                throw new Error('invalid compression: ' + compression);
        }
    }
}

module.exports = TIFFDecoder;

function getDataArray(size, channels, bitDepth, sampleFormat) {
    if (bitDepth === 8) {
        return new Uint8Array(size * channels);
    } else if (bitDepth === 16) {
        return new Uint16Array(size * channels);
    } else if (bitDepth === 32 && sampleFormat === 3) {
        return new Float32Array(size * channels);
    } else {
        unsupported('bit depth / sample format', bitDepth + ' / ' + sampleFormat);
    }
}

function fill8bit(dataTo, dataFrom, index, length) {
    for (var i = 0; i < length; i++) {
        dataTo[index++] = dataFrom.getUint8(i);
    }
    return index;
}

function fill16bit(dataTo, dataFrom, index, length, littleEndian) {
    for (var i = 0; i < length * 2; i += 2) {
        dataTo[index++] = dataFrom.getUint16(i, littleEndian);
    }
    return index;
}

function fillFloat32(dataTo, dataFrom, index, length, littleEndian) {
    for (var i = 0; i < length * 4; i += 4) {
        dataTo[index++] = dataFrom.getFloat32(i, littleEndian);
    }
    return index;
}

function unsupported(type, value) {
    throw new Error('Unsupported ' + type + ': ' + value);
}

},{"./IFD":64,"./IFDValue":65,"./TIFF":66,"iobuffer":7}],68:[function(require,module,exports){
'use strict';

exports.TIFFDecoder = require('./TIFFDecoder');

},{"./TIFFDecoder":67}],69:[function(require,module,exports){
'use strict';

var workerTemplate = require('./workerTemplate');

var CORES = navigator.hardwareConcurrency || 1;

var noop = Function.prototype;

function WorkerManager(func, options) {
    // Check arguments
    if (typeof func !== 'string' && typeof func !== 'function') throw new TypeError('func argument must be a function');
    if (options === undefined) options = {};
    if (typeof options !== 'object' || options === null) throw new TypeError('options argument must be an object');

    this._workerCode = func.toString();

    // Parse options
    if (options.maxWorkers === undefined || options.maxWorkers === 'auto') {
        this._numWorkers = Math.min(CORES - 1, 1);
    } else if (options.maxWorkers > 0) {
        this._numWorkers = Math.min(options.maxWorkers, CORES);
    } else {
        this._numWorkers = CORES;
    }

    this._workers = new Map();
    this._timeout = options.timeout || 0;
    this._terminateOnError = !!options.terminateOnError;

    var deps = options.deps;
    if (typeof deps === 'string') deps = [deps];
    if (!Array.isArray(deps)) deps = undefined;

    this._id = 0;
    this._terminated = false;
    this._working = 0;
    this._waiting = [];

    this._init(deps);
}

WorkerManager.prototype._init = function (deps) {
    var workerURL = workerTemplate.newWorkerURL(this._workerCode, deps);

    for (var i = 0; i < this._numWorkers; i++) {
        var worker = new Worker(workerURL);
        worker.onmessage = this._onmessage.bind(this, worker);
        worker.onerror = this._onerror.bind(this, worker);
        worker.running = false;
        worker.id = i;
        this._workers.set(worker, null);
    }

    URL.revokeObjectURL(workerURL);
};

WorkerManager.prototype._onerror = function (worker, error) {
    if (this._terminated) return;
    this._working--;
    worker.running = false;
    var callback = this._workers.get(worker);
    if (callback) {
        callback[1](error.message);
    }
    this._workers.set(worker, null);
    if (this._terminateOnError) {
        this.terminate();
    } else {
        this._exec();
    }
};

WorkerManager.prototype._onmessage = function (worker, event) {
    if (this._terminated) return;
    this._working--;
    worker.running = false;
    var callback = this._workers.get(worker);
    if (callback) {
        callback[0](event.data.data);
    }
    this._workers.set(worker, null);
    this._exec();
};

WorkerManager.prototype._exec = function () {
    for (var worker of this._workers.keys()) {
        if (this._working === this._numWorkers || this._waiting.length === 0) {
            return;
        }
        if (!worker.running) {
            for (var i = 0; i < this._waiting.length; i++) {
                var execInfo = this._waiting[i];
                if (typeof execInfo[4] === 'number' && execInfo[4] !== worker.id) {
                    // this message is intended to another worker, let's ignore it
                    continue;
                }
                this._waiting.splice(i, 1);
                worker.postMessage({
                    action: 'exec',
                    event: execInfo[0],
                    args: execInfo[1]
                }, execInfo[2]);
                worker.running = true;
                worker.time = Date.now();
                this._workers.set(worker, execInfo[3]);
                this._working++;
                break;
            }
        }
    }
};

WorkerManager.prototype.terminate = function () {
    if (this._terminated) return;
    for (var entry of this._workers) {
        entry[0].terminate();
        if (entry[1]) {
            entry[1][1](new Error('Terminated'));
        }
    }
    this._workers.clear();
    this._waiting = [];
    this._working = 0;
    this._terminated = true;
};

WorkerManager.prototype.postAll = function (event, args) {
    if (this._terminated) throw new Error('Cannot post (terminated)');
    var promises = [];
    for (var worker of this._workers.keys()) {
        promises.push(this.post(event, args, [], worker.id));
    }
    return Promise.all(promises);
};

WorkerManager.prototype.post = function (event, args, transferable, id) {
    if (args === undefined) args = [];
    if (transferable === undefined) transferable = [];
    if (!Array.isArray(args)) {
        args = [args];
    }
    if (!Array.isArray(transferable)) {
        transferable = [transferable];
    }

    var self = this;
    return new Promise(function (resolve, reject) {
        if (self._terminated) throw new Error('Cannot post (terminated)');
        self._waiting.push([event, args, transferable, [resolve, reject], id]);
        self._exec();
    });
};

module.exports = WorkerManager;

},{"./workerTemplate":70}],70:[function(require,module,exports){
'use strict';

var worker = function worker() {
    var window = self.window = self;
    function ManagedWorker() {
        this._listeners = {};
    }
    ManagedWorker.prototype.on = function (event, callback) {
        if (this._listeners[event]) throw new RangeError('there is already a listener for ' + event);
        if (typeof callback !== 'function') throw new TypeError('callback argument must be a function');
        this._listeners[event] = callback;
    };
    ManagedWorker.prototype._send = function (id, data, transferable) {
        if (transferable === undefined) {
            transferable = [];
        } else if (!Array.isArray(transferable)) {
            transferable = [transferable];
        }
        self.postMessage({
            id: id,
            data: data
        }, transferable);
    };
    ManagedWorker.prototype._trigger = function (event, args) {
        if (!this._listeners[event]) throw new Error('event ' + event + ' is not defined');
        this._listeners[event].apply(null, args);
    };
    var worker = new ManagedWorker();
    self.onmessage = function (event) {
        switch (event.data.action) {
            case 'exec':
                event.data.args.unshift(function (data, transferable) {
                    worker._send(event.data.id, data, transferable);
                });
                worker._trigger(event.data.event, event.data.args);
                break;
            case 'ping':
                worker._send(event.data.id, 'pong');
                break;
            default:
                throw new Error('unexpected action: ' + event.data.action);
        }
    };
    "CODE";
};

var workerStr = worker.toString().split('"CODE";');

exports.newWorkerURL = function newWorkerURL(code, deps) {
    var blob = new Blob(['(', workerStr[0], 'importScripts.apply(self, ' + JSON.stringify(deps) + ');\n', '(', code, ')();', workerStr[1], ')();'], { type: 'application/javascript' });
    return URL.createObjectURL(blob);
};

},{}],71:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

exports.default = function (Image) {
    for (var i in bitMethods) {
        Image.prototype[i] = bitMethods[i];
    }
};

// those methods can only apply on binary images... but we will not lose time to check!
var bitMethods = {
    setBitXY: function setBitXY(x, y) {
        var target = y * this.width + x;
        var shift = 7 - (target & 0b00000111);
        var slot = target >> 3;
        this.data[slot] |= 1 << shift;
    },
    clearBitXY: function clearBitXY(x, y) {
        var target = y * this.width + x;
        var shift = 7 - (target & 0b00000111);
        var slot = target >> 3;
        this.data[slot] &= ~(1 << shift);
    },
    toggleBitXY: function toggleBitXY(x, y) {
        var target = y * this.width + x;
        var shift = 7 - (target & 0b00000111);
        var slot = target >> 3;
        this.data[slot] ^= 1 << shift;
    },
    getBitXY: function getBitXY(x, y) {
        var target = y * this.width + x;
        var shift = 7 - (target & 0b00000111);
        var slot = target >> 3;
        return this.data[slot] & 1 << shift ? 1 : 0;
    },
    setBit: function setBit(pixel) {
        var shift = 7 - (pixel & 0b00000111);
        var slot = pixel >> 3;
        this.data[slot] |= 1 << shift;
    },
    clearBit: function clearBit(pixel) {
        var shift = 7 - (pixel & 0b00000111);
        var slot = pixel >> 3;
        this.data[slot] &= ~(1 << shift);
    },
    toggleBit: function toggleBit(pixel) {
        var shift = 7 - (pixel & 0b00000111);
        var slot = pixel >> 3;
        this.data[slot] ^= 1 << shift;
    },
    getBit: function getBit(pixel) {
        var shift = 7 - (pixel & 0b00000111);
        var slot = pixel >> 3;
        return this.data[slot] & 1 << shift ? 1 : 0;
    }
};

},{}],72:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = getColorHistogram;

var _newArray = require('new-array');

var _newArray2 = _interopRequireDefault(_newArray);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function getColorHistogram() {
    var _ref = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

    var _ref$useAlpha = _ref.useAlpha;
    var useAlpha = _ref$useAlpha === undefined ? true : _ref$useAlpha;
    var _ref$nbSlots = _ref.nbSlots;
    var nbSlots = _ref$nbSlots === undefined ? 512 : _ref$nbSlots;

    this.checkProcessable('getColorHistogram', {
        bitDepth: [8, 16],
        components: [3]
    });

    var nbSlotsCheck = Math.log(nbSlots) / Math.log(8);
    if (nbSlotsCheck !== Math.floor(nbSlotsCheck)) {
        throw new RangeError('nbSlots must be a power of 8. Usually 8, 64, 512 or 4096');
    }

    var bitShift = this.bitDepth - nbSlotsCheck;

    var data = this.data;
    var result = (0, _newArray2.default)(Math.pow(8, nbSlotsCheck), 0);
    var factor2 = Math.pow(2, nbSlotsCheck * 2);
    var factor1 = Math.pow(2, nbSlotsCheck);

    for (var i = 0; i < data.length; i += this.channels) {
        var slot = (data[i] >> bitShift) * factor2 + (data[i + 1] >> bitShift) * factor1 + (data[i + 2] >> bitShift);
        if (useAlpha && this.alpha) {
            result[slot] += data[i + this.channels - 1] / this.maxValue;
        } else {
            result[slot]++;
        }
    }

    return result;
}

},{"new-array":35}],73:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = countAlphaPixels;

// returns the number of transparent

function countAlphaPixels() {
    var _ref = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

    var alpha = _ref.alpha;

    this.checkProcessable('countAlphaPixels', {
        bitDepth: [8, 16],
        alpha: 1
    });

    var count = 0;

    if (alpha !== undefined) {
        for (var i = this.components; i < this.data.length; i += this.channels) {
            if (this.data[i] === alpha) count++;
        }
        return count;
    } else {
        // because there is an alpha channel all the pixels have an alpha
        return this.size;
    }
}

},{}],74:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.getHistogram = getHistogram;
exports.getHistograms = getHistograms;

var _newArray = require('new-array');

var _newArray2 = _interopRequireDefault(_newArray);

var _isInteger = require('is-integer');

var _isInteger2 = _interopRequireDefault(_isInteger);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function getHistogram() {
    var _ref = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

    var _ref$maxSlots = _ref.maxSlots;
    var maxSlots = _ref$maxSlots === undefined ? 256 : _ref$maxSlots;
    var channel = _ref.channel;
    var _ref$useAlpha = _ref.useAlpha;
    var useAlpha = _ref$useAlpha === undefined ? true : _ref$useAlpha;

    this.checkProcessable('getHistogram', {
        bitDepth: [8, 16]
    });
    if (channel === undefined) {
        if (this.components > 1) {
            throw new RangeError('You need to define the channel for an image that contains more than one channel');
        }
        channel = 0;
    }
    return getChannelHistogram.call(this, channel, useAlpha, maxSlots);
}

function getHistograms() {
    var _ref2 = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

    var _ref2$maxSlots = _ref2.maxSlots;
    var maxSlots = _ref2$maxSlots === undefined ? 256 : _ref2$maxSlots;
    var _ref2$useAlpha = _ref2.useAlpha;
    var useAlpha = _ref2$useAlpha === undefined ? true : _ref2$useAlpha;

    this.checkProcessable('getHistograms', {
        bitDepth: [8, 16]
    });
    var results = new Array(useAlpha ? this.components : this.channels);
    for (var i = 0; i < results.length; i++) {
        results[i] = getChannelHistogram.call(this, i, useAlpha, maxSlots);
    }
    return results;
}

function getChannelHistogram(channel, useAlpha, maxSlots) {
    var bitSlots = Math.log2(maxSlots);
    if (!(0, _isInteger2.default)(bitSlots)) {
        throw new RangeError('maxSlots must be a power of 2, for example: 64, 256, 1024');
    }
    // we will compare the bitSlots to the bitDepth of the image
    // based on this we will shift the values. This allows to generate a histogram
    // of 16 grey even if the images has 256 shade of grey

    var bitShift = 0;
    if (this.bitDepth > bitSlots) bitShift = this.bitDepth - bitSlots;

    var data = this.data;
    var result = (0, _newArray2.default)(Math.pow(2, Math.min(this.bitDepth, bitSlots)), 0);
    if (useAlpha && this.alpha) {
        var alphaChannelDiff = this.channels - channel - 1;

        for (var i = channel; i < data.length; i += this.channels) {
            result[data[i] >> bitShift] += data[i + alphaChannelDiff] / this.maxValue;
        }
    } else {
        for (var _i = channel; _i < data.length; _i += this.channels) {
            result[data[_i] >> bitShift]++;
        }
    }

    return result;
}

},{"is-integer":10,"new-array":35}],75:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = max;

var _newArray = require('new-array');

var _newArray2 = _interopRequireDefault(_newArray);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// returns an array with the maximal value of each channel

function max() {
    this.checkProcessable('max', {
        bitDepth: [8, 16]
    });

    var result = (0, _newArray2.default)(this.channels, -Infinity);

    for (var i = 0; i < this.data.length; i += this.channels) {
        for (var c = 0; c < this.channels; c++) {
            if (this.data[i + c] > result[c]) result[c] = this.data[i + c];
        }
    }
    return result;
}

},{"new-array":35}],76:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = mean;

var _histogram = require('../../util/histogram');

// returns an array with the average value of each component

function mean() {
    var histograms = this.getHistograms({ maxSlots: this.maxValue + 1 });
    var result = new Array(histograms.length);
    for (var c = 0; c < histograms.length; c++) {
        var histogram = histograms[c];
        result[c] = (0, _histogram.mean)(histogram);
    }
    return result;
}

},{"../../util/histogram":173}],77:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = median;

var _histogram = require('../../util/histogram');

// returns an array with the median value of each component

function median() {
    var histograms = this.getHistograms({ maxSlots: this.maxValue + 1 });
    var result = new Array(histograms.length);
    for (var c = 0; c < histograms.length; c++) {
        var histogram = histograms[c];
        result[c] = (0, _histogram.median)(histogram);
    }
    return result;
}

},{"../../util/histogram":173}],78:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = min;

var _newArray = require('new-array');

var _newArray2 = _interopRequireDefault(_newArray);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// returns an array with the minimal value of each channel

function min() {
    this.checkProcessable('min', {
        bitDepth: [8, 16]
    });

    var result = (0, _newArray2.default)(this.channels, +Infinity);

    for (var i = 0; i < this.data.length; i += this.channels) {
        for (var c = 0; c < this.channels; c++) {
            if (this.data[i + c] < result[c]) result[c] = this.data[i + c];
        }
    }
    return result;
}

},{"new-array":35}],79:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = getPixelsArray;
// this function will return an array containing an array of XY

function getPixelsArray() {
    this.checkProcessable('getPixelsArray', {
        bitDepth: [1]
    });

    if (this.bitDepth === 1) {
        var pixels = new Array(this.size);
        var counter = 0;
        for (var x = 0; x < this.width; x++) {
            for (var y = 0; y < this.height; y++) {
                if (this.getBitXY(x, y) === 1) {
                    pixels[counter++] = [x, y];
                }
            }
        }
        pixels.length = counter;
        return pixels;
    }
}

},{}],80:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = getRelativePosition;
/*
 An image may be derived from another image either by a crop
 or because it is a Roi (region of interest)
 Also a region of interest can be reprocessed to generated another
 set of region of interests.
 It is therefore important to keep the hierarchy of images to know
 which image is derived from which one and be able to get the
 relative position of one image in another
 This methods takes care of this.
 */

function getRelativePosition(targetImage) {
    if (this === targetImage) return [0, 0];
    var position = [0, 0];

    var currentImage = this;
    while (currentImage) {
        if (currentImage === targetImage) return position;
        if (currentImage.position) {
            position[0] += currentImage.position[0];
            position[1] += currentImage.position[1];
        }
        currentImage = currentImage.parent;
    }
    // we should never reach this place, this means we could not find the parent
    return undefined;
    // throw Error('Parent image was not found, can not get relative position.')
}

},{}],81:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = sum;

var _newArray = require('new-array');

var _newArray2 = _interopRequireDefault(_newArray);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// returns an array with the sum values of each channel

function sum() {
    this.checkProcessable('sum', {
        bitDepth: [8, 16]
    });

    var result = (0, _newArray2.default)(this.channels, 0);

    for (var i = 0; i < this.data.length; i += this.channels) {
        for (var c = 0; c < this.channels; c++) {
            result[c] += this.data[i + c];
        }
    }
    return result;
}

},{"new-array":35}],82:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = getSVD;
var Matrix = require('ml-matrix');

function getSVD() {
    this.checkProcessable('getSVD', {
        bitDepth: [1]
    });

    return Matrix.DC.SVD(this.pixelsArray);
}

},{"ml-matrix":28}],83:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
var loadBinary = void 0,
    DOMImage = void 0,
    Canvas = void 0,
    ImageData = void 0,
    isDifferentOrigin = void 0,
    env = void 0;

if (typeof self !== 'undefined') {
    (function () {
        // Browser
        exports.env = env = 'browser';
        var origin = self.location.origin;
        exports.isDifferentOrigin = isDifferentOrigin = function isDifferentOrigin(url) {
            try {
                var parsedURL = new self.URL(url);
                return parsedURL.origin !== origin;
            } catch (e) {
                // may be a relative URL. In this case, it cannot be parsed but is effectively from same origin
                return false;
            }
        };

        exports.ImageData = ImageData = self.ImageData;

        exports.DOMImage = DOMImage = self.Image;
        exports.Canvas = Canvas = function Canvas(width, height) {
            var canvas = self.document.createElement('canvas');
            canvas.width = width;
            canvas.height = height;
            return canvas;
        };

        exports.loadBinary = loadBinary = function loadBinary(url) {
            return new Promise(function (resolve, reject) {
                var xhr = new self.XMLHttpRequest();
                xhr.open('GET', url, true);
                xhr.responseType = 'arraybuffer';

                xhr.onload = function (e) {
                    this.status === 200 ? resolve(this.response) : reject('wrong status', e);
                };
                xhr.onerror = reject;
                xhr.send();
            });
        };
    })();
} else if (typeof module !== 'undefined' && module.exports) {
    (function () {
        // Node.js
        exports.env = env = 'node';
        exports.isDifferentOrigin = isDifferentOrigin = function isDifferentOrigin(url) {
            return false;
        };

        var canvas = require('canvas');
        exports.DOMImage = DOMImage = canvas.Image;
        exports.Canvas = Canvas = canvas;
        exports.ImageData = ImageData = canvas.ImageData;

        var fs = require('fs');
        exports.loadBinary = loadBinary = function loadBinary(path) {
            return new Promise(function (resolve, reject) {
                fs.readFile(path, function (err, data) {
                    err ? reject(err) : resolve(data.buffer);
                });
            });
        };
    })();
}

exports.loadBinary = loadBinary;
exports.DOMImage = DOMImage;
exports.Canvas = Canvas;
exports.ImageData = ImageData;
exports.isDifferentOrigin = isDifferentOrigin;
exports.env = env;

},{"canvas":undefined,"fs":2}],84:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = extend;

var _invertGetSet = require('./filter/invertGetSet');

var _invertGetSet2 = _interopRequireDefault(_invertGetSet);

var _invertIterator = require('./filter/invertIterator');

var _invertIterator2 = _interopRequireDefault(_invertIterator);

var _invertOneLoop = require('./filter/invertOneLoop');

var _invertOneLoop2 = _interopRequireDefault(_invertOneLoop);

var _invertPixel = require('./filter/invertPixel');

var _invertPixel2 = _interopRequireDefault(_invertPixel);

var _invertApply = require('./filter/invertApply');

var _invertApply2 = _interopRequireDefault(_invertApply);

var _invertBinaryLoop = require('./filter/invertBinaryLoop');

var _invertBinaryLoop2 = _interopRequireDefault(_invertBinaryLoop);

var _invert = require('./filter/invert');

var _invert2 = _interopRequireDefault(_invert);

var _blur = require('./filter/blur');

var _blur2 = _interopRequireDefault(_blur);

var _median = require('./filter/median');

var _median2 = _interopRequireDefault(_median);

var _gaussian = require('./filter/gaussian');

var _gaussian2 = _interopRequireDefault(_gaussian);

var _sobel = require('./filter/sobel');

var _sobel2 = _interopRequireDefault(_sobel);

var _level = require('./filter/level');

var _level2 = _interopRequireDefault(_level);

var _add = require('./filter/add');

var _add2 = _interopRequireDefault(_add);

var _subtract = require('./filter/subtract');

var _subtract2 = _interopRequireDefault(_subtract);

var _hypotenuse = require('./filter/hypotenuse');

var _hypotenuse2 = _interopRequireDefault(_hypotenuse);

var _multiply = require('./filter/multiply');

var _multiply2 = _interopRequireDefault(_multiply);

var _divide = require('./filter/divide');

var _divide2 = _interopRequireDefault(_divide);

var _getBackground = require('./filter/background');

var _getBackground2 = _interopRequireDefault(_getBackground);

var _crop = require('./transform/crop');

var _crop2 = _interopRequireDefault(_crop);

var _scale = require('./transform/scale/scale');

var _scale2 = _interopRequireDefault(_scale);

var _hsv = require('./transform/hsv');

var _hsv2 = _interopRequireDefault(_hsv);

var _hsl = require('./transform/hsl');

var _hsl2 = _interopRequireDefault(_hsl);

var _rgba = require('./transform/rgba8');

var _rgba2 = _interopRequireDefault(_rgba);

var _grey = require('./transform/grey/grey');

var _grey2 = _interopRequireDefault(_grey);

var _mask = require('./transform/mask/mask');

var _mask2 = _interopRequireDefault(_mask);

var _pad = require('./transform/pad');

var _pad2 = _interopRequireDefault(_pad);

var _resizeBinary = require('./transform/resizeBinary');

var _resizeBinary2 = _interopRequireDefault(_resizeBinary);

var _colorDepth = require('./transform/colorDepth');

var _colorDepth2 = _interopRequireDefault(_colorDepth);

var _setBorder = require('./utility/setBorder');

var _setBorder2 = _interopRequireDefault(_setBorder);

var _split = require('./utility/split');

var _split2 = _interopRequireDefault(_split);

var _getChannel = require('./utility/getChannel');

var _getChannel2 = _interopRequireDefault(_getChannel);

var _setChannel = require('./utility/setChannel');

var _setChannel2 = _interopRequireDefault(_setChannel);

var _getSimilarity = require('./utility/getSimilarity');

var _getSimilarity2 = _interopRequireDefault(_getSimilarity);

var _getPixelsGrid = require('./utility/getPixelsGrid');

var _getPixelsGrid2 = _interopRequireDefault(_getPixelsGrid);

var _getBestMatch = require('./utility/getBestMatch');

var _getBestMatch2 = _interopRequireDefault(_getBestMatch);

var _getRow = require('./utility/getRow');

var _getRow2 = _interopRequireDefault(_getRow);

var _getColumn = require('./utility/getColumn');

var _getColumn2 = _interopRequireDefault(_getColumn);

var _paintMasks = require('./operator/paintMasks');

var _paintMasks2 = _interopRequireDefault(_paintMasks);

var _paintPixels = require('./operator/paintPoints');

var _paintPixels2 = _interopRequireDefault(_paintPixels);

var _extract = require('./operator/extract');

var _extract2 = _interopRequireDefault(_extract);

var _convolution = require('./operator/convolution');

var _convolution2 = _interopRequireDefault(_convolution);

var _histogram = require('./compute/histogram');

var _colorHistogram = require('./compute/colorHistogram');

var _colorHistogram2 = _interopRequireDefault(_colorHistogram);

var _min = require('./compute/min');

var _min2 = _interopRequireDefault(_min);

var _max = require('./compute/max');

var _max2 = _interopRequireDefault(_max);

var _sum = require('./compute/sum');

var _sum2 = _interopRequireDefault(_sum);

var _mean = require('./compute/mean');

var _mean2 = _interopRequireDefault(_mean);

var _median3 = require('./compute/median');

var _median4 = _interopRequireDefault(_median3);

var _pixelsArray = require('./compute/pixelsArray');

var _pixelsArray2 = _interopRequireDefault(_pixelsArray);

var _relativePosition = require('./compute/relativePosition');

var _relativePosition2 = _interopRequireDefault(_relativePosition);

var _svd = require('./compute/svd');

var _svd2 = _interopRequireDefault(_svd);

var _countAlphaPixels = require('./compute/countAlphaPixels');

var _countAlphaPixels2 = _interopRequireDefault(_countAlphaPixels);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// methods
// filters
function extend(Image) {
    var inPlace = { inPlace: true };
    var inPlaceStack = { inPlace: true, stack: true };
    var stack = { stack: true };

    Image.extendMethod('invertGetSet', _invertGetSet2.default, inPlace);
    Image.extendMethod('invertIterator', _invertIterator2.default, inPlace);
    Image.extendMethod('invertPixel', _invertPixel2.default, inPlace);
    Image.extendMethod('invertOneLoop', _invertOneLoop2.default, inPlace);
    Image.extendMethod('invertApply', _invertApply2.default, inPlace);
    Image.extendMethod('invert', _invert2.default, inPlaceStack);
    Image.extendMethod('invertBinaryLoop', _invertBinaryLoop2.default, inPlace);
    Image.extendMethod('level', _level2.default, inPlace);
    Image.extendMethod('add', _add2.default, inPlace);
    Image.extendMethod('subtract', _subtract2.default, inPlace);
    Image.extendMethod('multiply', _multiply2.default, inPlace);
    Image.extendMethod('divide', _divide2.default, inPlace);
    Image.extendMethod('hypotenuse', _hypotenuse2.default);
    Image.extendMethod('getBackground', _getBackground2.default);

    Image.extendMethod('meanFilter', _blur2.default);
    Image.extendMethod('medianFilter', _median2.default);
    Image.extendMethod('gaussianFilter', _gaussian2.default);
    Image.extendMethod('sobelFilter', _sobel2.default);

    Image.extendMethod('crop', _crop2.default, stack);
    Image.extendMethod('scale', _scale2.default, stack);
    Image.extendMethod('hsv', _hsv2.default);
    Image.extendMethod('hsl', _hsl2.default);
    Image.extendMethod('rgba8', _rgba2.default);
    Image.extendMethod('grey', _grey2.default).extendMethod('gray', _grey2.default);
    Image.extendMethod('mask', _mask2.default);
    Image.extendMethod('pad', _pad2.default);
    Image.extendMethod('resizeBinary', _resizeBinary2.default);
    Image.extendMethod('colorDepth', _colorDepth2.default);
    Image.extendMethod('setBorder', _setBorder2.default, inPlace);

    Image.extendMethod('getRow', _getRow2.default);
    Image.extendMethod('getColumn', _getColumn2.default);

    Image.extendMethod('split', _split2.default);
    Image.extendMethod('getChannel', _getChannel2.default);
    Image.extendMethod('setChannel', _setChannel2.default);
    Image.extendMethod('getSimilarity', _getSimilarity2.default);
    Image.extendMethod('getPixelsGrid', _getPixelsGrid2.default);
    Image.extendMethod('getBestMatch', _getBestMatch2.default);

    Image.extendMethod('paintMasks', _paintMasks2.default, inPlace);
    Image.extendMethod('paintPixels', _paintPixels2.default, inPlace);
    Image.extendMethod('extract', _extract2.default);
    Image.extendMethod('convolution', _convolution2.default);

    Image.extendMethod('countAlphaPixels', _countAlphaPixels2.default);
    Image.extendMethod('getHistogram', _histogram.getHistogram).extendProperty('histogram', _histogram.getHistogram);
    Image.extendMethod('getHistograms', _histogram.getHistograms).extendProperty('histograms', _histogram.getHistograms);
    Image.extendMethod('getColorHistogram', _colorHistogram2.default).extendProperty('colorHistogram', _colorHistogram2.default);
    Image.extendMethod('getMin', _min2.default).extendProperty('min', _min2.default);
    Image.extendMethod('getMax', _max2.default).extendProperty('max', _max2.default);
    Image.extendMethod('getSum', _sum2.default).extendProperty('sum', _sum2.default);
    Image.extendMethod('getMedian', _sum2.default).extendProperty('median', _median4.default);
    Image.extendMethod('getMean', _mean2.default).extendProperty('mean', _mean2.default);
    Image.extendMethod('getPixelsArray', _pixelsArray2.default).extendProperty('pixelsArray', _pixelsArray2.default);
    Image.extendMethod('getRelativePosition', _relativePosition2.default);
    Image.extendMethod('getSVD', _svd2.default).extendProperty('svd', _svd2.default);
}

// computers

},{"./compute/colorHistogram":72,"./compute/countAlphaPixels":73,"./compute/histogram":74,"./compute/max":75,"./compute/mean":76,"./compute/median":77,"./compute/min":78,"./compute/pixelsArray":79,"./compute/relativePosition":80,"./compute/sum":81,"./compute/svd":82,"./filter/add":85,"./filter/blur":86,"./filter/divide":87,"./filter/gaussian":88,"./filter/getBackground":89,"./filter/hypotenuse":90,"./filter/invert":91,"./filter/invertApply":92,"./filter/invertBinaryLoop":93,"./filter/invertGetSet":94,"./filter/invertIterator":95,"./filter/invertOneLoop":96,"./filter/invertPixel":97,"./filter/level":98,"./filter/median":99,"./filter/multiply":100,"./filter/sobel":101,"./filter/subtract":102,"./operator/convolution":109,"./operator/extract":110,"./operator/paintMasks":111,"./operator/paintPixels":112,"./transform/colorDepth":120,"./transform/crop":121,"./transform/grey/grey":123,"./transform/hsl":128,"./transform/hsv":129,"./transform/mask/mask":134,"./transform/pad":146,"./transform/resizeBinary":147,"./transform/rgba8":148,"./transform/scale/scale":150,"./utility/getBestMatch":152,"./utility/getChannel":153,"./utility/getColumn":154,"./utility/getPixelsGrid":155,"./utility/getRow":156,"./utility/getSimilarity":157,"./utility/setBorder":158,"./utility/setChannel":159,"./utility/split":160}],85:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = add;

var _channel = require('../../util/channel');

var _image = require('../image');

var _image2 = _interopRequireDefault(_image);

var _value = require('../../util/value');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function add(value) {
    var _ref = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

    var channels = _ref.channels;

    this.checkProcessable('add', {
        bitDepth: [8, 16]
    });

    channels = (0, _channel.validateArrayOfChannels)(this, { channels: channels });
    value = (0, _value.checkNumberArray)(value);

    // we allow 3 cases, the value may be an array (1D), an image or a single value
    if (!isNaN(value)) {
        for (var j = 0; j < channels.length; j++) {
            var c = channels[j];
            for (var i = 0; i < this.data.length; i += this.channels) {
                this.data[i + c] = Math.min(this.maxValue, this.data[i + c] + value >> 0);
            }
        }
    } else {
        if (this.data.length !== value.length) {
            throw new Error('add: the data size is different');
        }
        for (var _j = 0; _j < channels.length; _j++) {
            var _c = channels[_j];
            for (var _i = 0; _i < this.data.length; _i += this.channels) {
                this.data[_i + _c] = Math.max(0, Math.min(this.maxValue, this.data[_i + _c] + value[_i + _c] >> 0));
            }
        }
    }
}

},{"../../util/channel":171,"../../util/value":178,"../image":103}],86:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = meanFilter;

var _image = require('../image');

var _image2 = _interopRequireDefault(_image);

var _convolution = require('../operator/convolution');

var _convolution2 = _interopRequireDefault(_convolution);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// first release of mean filter
function meanFilter(k) {

    this.checkProcessable('meanFilter', {
        components: [1],
        bitDepth: [8, 16]
    });

    if (k < 1) {
        throw new Error('Number of neighbors should be grater than 0');
    }

    var n = 2 * k + 1;
    var size = n * n;
    var kernel = new Array(size);

    for (var i = 0; i < kernel.length; i++) {
        kernel[i] = 1;
    }

    return _convolution2.default.call(this, kernel);
}

},{"../image":103,"../operator/convolution":109}],87:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = add;

var _channel = require('../../util/channel');

var _image = require('../image');

var _image2 = _interopRequireDefault(_image);

var _value = require('../../util/value');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function add(value) {
    var _ref = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

    var channels = _ref.channels;

    this.checkProcessable('divide', {
        bitDepth: [8, 16]
    });

    channels = (0, _channel.validateArrayOfChannels)(this, { channels: channels });
    value = (0, _value.checkNumberArray)(value);

    if (!isNaN(value)) {
        for (var j = 0; j < channels.length; j++) {
            var c = channels[j];
            for (var i = 0; i < this.data.length; i += this.channels) {
                this.data[i + c] = Math.min(this.maxValue, this.data[i + c] / value >> 0);
            }
        }
    } else {
        if (this.data.length !== value.length) {
            throw new Error('divide: the: the data size is different');
        }
        for (var _j = 0; _j < channels.length; _j++) {
            var _c = channels[_j];
            for (var _i = 0; _i < this.data.length; _i += this.channels) {
                this.data[_i + _c] = Math.max(0, Math.min(this.maxValue, this.data[_i + _c] / value[_i + _c] >> 0));
            }
        }
    }
}

},{"../../util/channel":171,"../../util/value":178,"../image":103}],88:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.default = gaussianFilter;

var _image = require('../image');

var _image2 = _interopRequireDefault(_image);

var _convolution = require('../operator/convolution');

var _convolution2 = _interopRequireDefault(_convolution);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function gaussianFilter() {
	var _ref = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

	var _ref$radius = _ref.radius;
	var radius = _ref$radius === undefined ? 1 : _ref$radius;
	var sigma = _ref.sigma;
	var channels = _ref.channels;
	var _ref$border = _ref.border;
	var border = _ref$border === undefined ? 'copy' : _ref$border;


	this.checkProcessable('gaussianFilter', {
		bitDepth: [8, 16]
	});

	var kernel = void 0;
	if (sigma) {
		kernel = getSigmaKernel(sigma);
	} else {
		// sigma approximation using radius
		sigma = 0.3 * (radius - 1) + 0.8;
		kernel = getKernel(radius, sigma);
	}

	return _convolution2.default.call(this, kernel, {
		border: border,
		channels: channels
	});
}

function getKernel(radius, sigma) {
	if (radius < 1) {
		throw new RangeError('Radius should be grater than 0');
	}
	var n = 2 * radius + 1;

	var kernel = new Array(n * n);

	//gaussian kernel is calculated
	var sigma2 = 2 * (sigma * sigma); //2*sigma^2
	var PI2sigma2 = Math.PI * sigma2; //2*PI*sigma^2

	for (var i = 0; i <= radius; i++) {
		for (var j = i; j <= radius; j++) {
			var value = Math.exp(-(i * i + j * j) / sigma2) / PI2sigma2;
			kernel[(i + radius) * n + (j + radius)] = value;
			kernel[(i + radius) * n + (-j + radius)] = value;
			kernel[(-i + radius) * n + (j + radius)] = value;
			kernel[(-i + radius) * n + (-j + radius)] = value;
			kernel[(j + radius) * n + (i + radius)] = value;
			kernel[(j + radius) * n + (-i + radius)] = value;
			kernel[(-j + radius) * n + (i + radius)] = value;
			kernel[(-j + radius) * n + (-i + radius)] = value;
		}
	}
	return kernel;
}

function getSigmaKernel(sigma) {
	if (sigma <= 0) {
		throw new RangeError('Sigma should be grater than 0');
	}
	var sigma2 = 2 * (sigma * sigma); //2*sigma^2
	var PI2sigma2 = Math.PI * sigma2; //2*PI*sigma^2
	var value = 1 / PI2sigma2;
	var sum = value;
	var neighbors = 0;

	while (sum < 0.99) {
		neighbors++;
		value = Math.exp(-(neighbors * neighbors) / sigma2) / PI2sigma2;
		sum += 4 * value;
		for (var i = 1; i < neighbors; i++) {
			value = Math.exp(-(i * i + neighbors * neighbors) / sigma2) / PI2sigma2;
			sum += 8 * value;
		}
		value = 4 * Math.exp(-(2 * neighbors * neighbors) / sigma2) / PI2sigma2;
		sum += value;
	}

	// What does this case mean ?
	if (sum > 1) {
		throw new Error('unexpected sum over 1');
	}

	return getKernel(neighbors, sigma);
}

},{"../image":103,"../operator/convolution":109}],89:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = getBackground;

var _mlRegression = require('ml-regression');

var _image = require('../image');

var _image2 = _interopRequireDefault(_image);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function getBackground(coordinates, values, options) {
    var model = new _mlRegression.KernelRidgeRegression(coordinates, values, options);
    var allCoordinates = new Array(this.size);
    for (var i = 0; i < this.width; i++) {
        for (var j = 0; j < this.height; j++) {
            allCoordinates[j * this.width + i] = [i, j];
        }
    }
    var result = model.predict(allCoordinates);
    var background = _image2.default.createFrom(this);
    for (var _i = 0; _i < this.size; _i++) {
        background.data[_i] = Math.min(this.maxValue, Math.max(0, result[_i][0]));
    }
    return background;
}

},{"../image":103,"ml-regression":31}],90:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = hypotenuse;

var _channel = require('../../util/channel');

var _image = require('../image');

var _image2 = _interopRequireDefault(_image);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function hypotenuse(otherImage) {
    var _ref = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

    var bitDepth = _ref.bitDepth;
    var channels = _ref.channels;

    this.checkProcessable('hypotenuse', {
        bitDepth: [8, 16, 32]
    });
    if (this.width !== otherImage.width || this.height !== otherImage.height) {
        throw new Error('hypotenuse: both images must have the same size');
    }
    if (this.alpha !== otherImage.alpha || this.bitDepth !== otherImage.bitDepth) {
        throw new Error('hypotenuse: both images must have the same alpha and bitDepth');
    }
    if (this.channels !== otherImage.channels) {
        throw new Error('hypotenuse: both images must have the same number of channels');
    }

    var newImage = _image2.default.createFrom(this, { bitDepth: bitDepth });

    channels = (0, _channel.validateArrayOfChannels)(this, { channels: channels });

    var clamped = newImage.isClamped;

    for (var j = 0; j < channels.length; j++) {
        var c = channels[j];
        for (var i = c; i < this.data.length; i += this.channels) {
            var value = Math.sqrt(this.data[i] * this.data[i] + otherImage.data[i] * otherImage.data[i]);
            if (clamped) {
                // we calculate the clamped result
                newImage.data[i] = Math.min(Math.max(Math.round(value), 0), newImage.maxValue);
            } else {
                newImage.data[i] = value;
            }
        }
    }

    return newImage;
}

},{"../../util/channel":171,"../image":103}],91:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = invert;

var _channel = require('../../util/channel');

function invert() {
    var _ref = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

    var channels = _ref.channels;

    this.checkProcessable('invertOneLoop', {
        bitDepth: [1, 8, 16]
    });

    if (this.bitDepth === 1) {
        // we simply invert all the integers value
        // there could be a small mistake if the number of points
        // is not a multiple of 8 but it is not important
        var data = this.data;
        for (var i = 0; i < data.length; i++) {
            data[i] = ~data[i];
        }
    } else {
        channels = (0, _channel.validateArrayOfChannels)(this, channels, true);

        var _data = this.data;

        // for (let j of channels) { WOULD SLOW DO OF A FACTOR 10 !

        for (var c = 0; c < channels.length; c++) {
            var j = channels[c];
            for (var _i = j; _i < _data.length; _i += this.channels) {
                _data[_i] = this.maxValue - _data[_i];
            }
        }
    }
} // we try the faster methods

},{"../../util/channel":171}],92:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = invertApply;
// this code gives the same result as invert()
// but is based on a matrix of pixels
// may be easier to implement some algorithm
// but it will likely be much slower

// this method is 50 times SLOWER than invert !!!!!!

function invertApply() {

    if (this.bitDepth === 1) {
        // we simply invert all the integers value
        // there could be a small mistake if the number of points
        // is not a multiple of 8 but it is not important
        var data = this.data;
        for (var i = 0; i < data.length; i++) {
            data[i] = ~data[i];
        }
    } else {
        this.checkProcessable('invertApply', {
            bitDepth: [8, 16]
        });
        this.apply(function (index) {
            for (var k = 0; k < this.components; k++) {
                this.data[index + k] = this.maxValue - this.data[index + k];
            }
        });
    }
}

},{}],93:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = invertBinaryLoop;
function invertBinaryLoop() {
    this.checkProcessable('invertBinaryLoop', {
        bitDepth: [1]
    });

    for (var i = 0; i < this.size; i++) {
        this.toggleBit(i);
    }
}

},{}],94:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = invert;
function invert() {
    this.checkProcessable('invert', {
        bitDepth: [1, 8, 16]
    });

    if (this.bitDepth === 1) {
        // we simply invert all the integers value
        // there could be a small mistake if the number of points
        // is not a multiple of 8 but it is not important
        var data = this.data;
        for (var i = 0; i < data.length; i++) {
            data[i] = ~data[i];
        }
    } else {
        for (var x = 0; x < this.width; x++) {
            for (var y = 0; y < this.height; y++) {
                for (var k = 0; k < this.components; k++) {
                    var value = this.getValueXY(x, y, k);
                    this.setValueXY(x, y, k, this.maxValue - value);
                }
            }
        }
    }
}

},{}],95:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = invertIterator;
function invertIterator() {
    this.checkProcessable('invert', {
        bitDepth: [1, 8, 16]
    });

    if (this.bitDepth === 1) {
        // we simply invert all the integers value
        // there could be a small mistake if the number of points
        // is not a multiple of 8 but it is not important
        var data = this.data;
        for (var i = 0; i < data.length; i++) {
            data[i] = ~data[i];
        }
    } else {
        for (var _ref of this.pixels()) {
            var index = _ref.index;
            var pixel = _ref.pixel;

            for (var k = 0; k < this.components; k++) {
                this.setValue(index, k, this.maxValue - pixel[k]);
            }
        }
    }
}

},{}],96:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = invertOneLoop;
function invertOneLoop() {
    this.checkProcessable('invertOneLoop', {
        bitDepth: [8, 16]
    });

    var data = this.data;
    for (var i = 0; i < data.length; i += this.channels) {
        for (var j = 0; j < this.components; j++) {
            data[i + j] = this.maxValue - data[i + j];
        }
    }
}

},{}],97:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = invertPixel;
// this code gives the same result as invert()
// but is based on a matrix of pixels
// may be easier to implement some algorithm
// but it will likely be much slower

function invertPixel() {
    this.checkProcessable('invertPixel', {
        bitDepth: [8, 16]
    });

    for (var x = 0; x < this.width; x++) {
        for (var y = 0; y < this.height; y++) {
            var value = this.getPixelXY(x, y);
            for (var k = 0; k < this.components; k++) {
                value[k] = this.maxValue - value[k];
            }
            this.setPixelXY(x, y, value);
        }
    }
}

},{}],98:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = level;

var _newArray = require('new-array');

var _newArray2 = _interopRequireDefault(_newArray);

var _channel = require('../../util/channel');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function level() {
    var _ref = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

    var _ref$algorithm = _ref.algorithm;
    var algorithm = _ref$algorithm === undefined ? 'range' : _ref$algorithm;
    var channels = _ref.channels;
    var _ref$min = _ref.min;
    var min = _ref$min === undefined ? this.min : _ref$min;
    var _ref$max = _ref.max;
    var max = _ref$max === undefined ? this.max : _ref$max;

    this.checkProcessable('level', {
        bitDepth: [8, 16]
    });

    channels = (0, _channel.validateArrayOfChannels)(this, { channels: channels });

    switch (algorithm) {

        case 'range':
            if (min < 0) min = 0;
            if (max > this.maxValue) max = this.maxValue;

            if (!Array.isArray(min)) min = (0, _newArray2.default)(channels.length, min);
            if (!Array.isArray(max)) max = (0, _newArray2.default)(channels.length, max);

            processImage(this, min, max, channels);
            break;

        default:
            throw new Error('level: algorithm not implement: ' + algorithm);
    }
}

function processImage(image, min, max, channels) {
    var delta = 1e-5; // sorry no better value that this "best guess"
    var factor = new Array(image.channels);

    for (var c of channels) {
        if (min[c] === 0 && max[c] === image.maxValue) {
            factor[c] = 0;
        } else if (max[c] === min[c]) {
            factor[c] = 0;
        } else {
            factor[c] = (image.maxValue + 1 - delta) / (max[c] - min[c]);
        }
        min[c] += (0.5 - delta / 2) / factor[c];
    }

    /*
     Note on border effect
     For 8 bits images we should calculate for the space between -0.5 and 255.5
     so that after ronding the first and last points still have the same population
     But doing this we need to deal with Math.round that gives 256 if the value is 255.5
     */

    for (var j = 0; j < channels.length; j++) {
        var _c = channels[j];
        if (factor[_c] !== 0) {
            for (var i = 0; i < image.data.length; i += image.channels) {
                image.data[i + _c] = Math.min(Math.max(0, (image.data[i + _c] - min[_c]) * factor[_c] + 0.5 | 0), image.maxValue);
            }
        }
    }
}

},{"../../util/channel":171,"new-array":35}],99:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = medianFilter;

var _channel = require('../../util/channel');

var _image = require('../image');

var _image2 = _interopRequireDefault(_image);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Created by Cristian on 18/07/2015.
 */
function medianFilter(radius, channels) {
    var border = arguments.length <= 2 || arguments[2] === undefined ? 'copy' : arguments[2];

    this.checkProcessable('medianFilter', {
        bitDepth: [8, 16]
    });

    if (radius < 1) {
        throw new Error('Kernel radius should be greater than 0');
    }

    channels = (0, _channel.validateArrayOfChannels)(this, channels, true);

    var kWidth = radius;
    var kHeight = radius;
    var newImage = _image2.default.createFrom(this);

    var size = (kWidth * 2 + 1) * (kHeight * 2 + 1);
    var middle = Math.floor(size / 2);
    var kernel = new Array(size);

    for (var channel = 0; channel < channels.length; channel++) {
        var c = channels[channel];
        for (var y = kHeight; y < this.height - kHeight; y++) {
            for (var x = kWidth; x < this.width - kWidth; x++) {
                var n = 0;
                for (var j = -kHeight; j <= kHeight; j++) {
                    for (var i = -kWidth; i <= kWidth; i++) {
                        var _index = ((y + j) * this.width + x + i) * this.channels + c;
                        kernel[n++] = this.data[_index];
                    }
                }
                var index = (y * this.width + x) * this.channels + c;
                var newValue = kernel.sort()[middle];
                newImage.data[index] = newValue;
            }
        }
    }

    if (this.alpha && channels.indexOf(this.channels) === -1) {
        for (var _i = this.components; _i < this.data.length; _i = _i + this.channels) {
            newImage.data[_i] = this.data[_i];
        }
    }

    newImage.setBorder({ size: [kWidth, kHeight], algorithm: border });

    return newImage;
} //End median function

},{"../../util/channel":171,"../image":103}],100:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = add;

var _channel = require('../../util/channel');

var _image = require('../image');

var _image2 = _interopRequireDefault(_image);

var _value = require('../../util/value');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function add(value) {
    var _ref = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

    var channels = _ref.channels;

    this.checkProcessable('multiply', {
        bitDepth: [8, 16]
    });
    if (value <= 0) throw new Error('multiply: the value must be greater than 0');

    channels = (0, _channel.validateArrayOfChannels)(this, { channels: channels });
    value = (0, _value.checkNumberArray)(value);

    if (!isNaN(value)) {
        for (var j = 0; j < channels.length; j++) {
            var c = channels[j];
            for (var i = 0; i < this.data.length; i += this.channels) {
                this.data[i + c] = Math.min(this.maxValue, this.data[i + c] * value >> 0);
            }
        }
    } else {
        if (this.data.length !== value.length) {
            throw new Error('multiply: the data size is different');
        }
        for (var _j = 0; _j < channels.length; _j++) {
            var _c = channels[_j];
            for (var _i = 0; _i < this.data.length; _i += this.channels) {
                this.data[_i + _c] = Math.max(0, Math.min(this.maxValue, this.data[_i + _c] * value[_i + _c] >> 0));
            }
        }
    }
}

},{"../../util/channel":171,"../../util/value":178,"../image":103}],101:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.default = sobelFilter;

var _image = require('../image');

var _image2 = _interopRequireDefault(_image);

var _convolution = require('../operator/convolution');

var _convolution2 = _interopRequireDefault(_convolution);

var _kernels = require('../../util/kernels');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function sobelFilter() {
	var _ref = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

	var _ref$kernelX = _ref.kernelX;
	var kernelX = _ref$kernelX === undefined ? _kernels.GRADIENT_X : _ref$kernelX;
	var _ref$kernelY = _ref.kernelY;
	var kernelY = _ref$kernelY === undefined ? _kernels.GRADIENT_Y : _ref$kernelY;
	var _ref$border = _ref.border;
	var border = _ref$border === undefined ? 'copy' : _ref$border;
	var channels = _ref.channels;


	this.checkProcessable('sobelFilter', {
		bitDepth: [8, 16]
	});

	var gX = _convolution2.default.call(this, kernelX, {
		channels: channels,
		border: border,
		bitDepth: 32
	});

	var gY = _convolution2.default.call(this, kernelY, {
		channels: channels,
		border: border,
		bitDepth: 32
	});

	return gX.hypotenuse(gY, { bitDepth: this.bitDepth, channels: channels });
}

},{"../../util/kernels":175,"../image":103,"../operator/convolution":109}],102:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = subtract;

var _channel = require('../../util/channel');

var _image = require('../image');

var _image2 = _interopRequireDefault(_image);

var _value = require('../../util/value');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function subtract(value) {
    var _ref = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

    var channels = _ref.channels;

    this.checkProcessable('subtract', {
        bitDepth: [8, 16]
    });

    channels = (0, _channel.validateArrayOfChannels)(this, { channels: channels });
    value = (0, _value.checkNumberArray)(value);

    if (!isNaN(value)) {
        for (var j = 0; j < channels.length; j++) {
            var c = channels[j];
            for (var i = 0; i < this.data.length; i += this.channels) {
                this.data[i + c] = Math.max(0, this.data[i + c] - value >> 0);
            }
        }
    } else {
        if (this.data.length !== value.length) {
            throw new Error('substract: the data size is different');
        }
        for (var _j = 0; _j < channels.length; _j++) {
            var _c = channels[_j];
            for (var _i = 0; _i < this.data.length; _i += this.channels) {
                this.data[_i + _c] = Math.max(0, Math.min(this.maxValue, this.data[_i + _c] - value[_i + _c] >> 0));
            }
        }
    }
}

},{"../../util/channel":171,"../../util/value":178,"../image":103}],103:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _kind = require('./kind');

var _kindNames = require('./kindNames');

var _environment = require('./environment');

var _extend = require('./extend');

var _extend2 = _interopRequireDefault(_extend);

var _bitMethods = require('./bitMethods');

var _bitMethods2 = _interopRequireDefault(_bitMethods);

var _fs = require('fs');

var _model = require('./model/model');

var _manager = require('./roi/manager');

var _manager2 = _interopRequireDefault(_manager);

var _mediaTypes = require('./mediaTypes');

var _extend3 = require('extend');

var _extend4 = _interopRequireDefault(_extend3);

var _load = require('./load');

var _stack = require('../stack/stack');

var _stack2 = _interopRequireDefault(_stack);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

var computedPropertyDescriptor = {
    configurable: true,
    enumerable: false,
    get: undefined
};

class Image {
    constructor(width, height, data, options) {
        if (width === undefined) width = 1;
        if (height === undefined) height = 1;

        // copy another image
        if (typeof width === 'object') {
            var otherImage = width;
            var cloneData = height === true;
            width = otherImage.width;
            height = otherImage.height;
            data = cloneData ? otherImage.data.slice() : otherImage.data;
            options = {
                position: otherImage.position,
                components: otherImage.components,
                alpha: otherImage.alpha,
                bitDepth: otherImage.bitDepth,
                colorModel: otherImage.colorModel
            };
        }

        if (data && !data.length) {
            options = data;
            data = null;
        }
        if (options === undefined) options = {};

        this.width = width;
        this.height = height;

        if (this.width <= 0) {
            throw new RangeError('width must be greater than 0');
        }
        if (this.height <= 0) {
            throw new RangeError('height must be greater than 0');
        }

        // We will set the parent image for relative position

        Object.defineProperty(this, 'parent', {
            enumerable: false,
            writable: true
        });
        this.parent = options.parent;
        this.position = options.position || [0, 0];

        var theKind = void 0;
        if (typeof options.kind === 'string') {
            theKind = (0, _kind.getKind)(options.kind);
            if (!theKind) throw new RangeError('invalid image kind: ' + options.kind);
        } else {
            theKind = (0, _kind.getKind)(_kindNames.RGBA);
        }

        var kindDefinition = (0, _extend4.default)({}, theKind, options);
        this.components = kindDefinition.components;
        this.alpha = kindDefinition.alpha + 0;
        this.bitDepth = kindDefinition.bitDepth;
        this.colorModel = kindDefinition.colorModel;

        this.computed = null;

        this.initialize();

        if (!data) (0, _kind.createPixelArray)(this);else {
            var length = (0, _kind.getTheoreticalPixelArraySize)(this);
            if (length !== data.length) {
                throw new RangeError(`incorrect data size. Should be ${ length } and found ${ data.length }`);
            }
            this.data = data;
        }
    }

    initialize() {
        this.size = this.width * this.height;
        this.sizes = [this.width, this.height];
        this.channels = this.components + this.alpha;
        if (this.bitDepth === 32) {
            this.maxValue = Number.MAX_VALUE;
        } else {
            this.maxValue = Math.pow(2, this.bitDepth) - 1; // we may not use 1 << this.bitDepth for 32 bits images
        }

        this.multiplierX = this.channels;
        this.multiplierY = this.channels * this.width;
        this.isClamped = this.bitDepth < 32;
        this.borderSizes = [0, 0]; // when a filter create a border it may have impact on future processing like Roi
    }

    static load(url) {
        return (0, _load.loadURL)(url);
    }

    static extendMethod(name, method) {
        var _ref = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];

        var _ref$inPlace = _ref.inPlace;
        var inPlace = _ref$inPlace === undefined ? false : _ref$inPlace;
        var _ref$returnThis = _ref.returnThis;
        var returnThis = _ref$returnThis === undefined ? true : _ref$returnThis;
        var _ref$partialArgs = _ref.partialArgs;
        var partialArgs = _ref$partialArgs === undefined ? [] : _ref$partialArgs;
        var _ref$stack = _ref.stack;
        var stack = _ref$stack === undefined ? false : _ref$stack;

        if (inPlace) {
            Image.prototype[name] = function () {
                // remove computed properties
                this.computed = null;

                for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
                    args[_key] = arguments[_key];
                }

                var result = method.apply(this, [].concat(_toConsumableArray(partialArgs), args));
                if (returnThis) return this;
                return result;
            };
            if (stack) {
                var stackName = typeof stack === 'string' ? stack : name;
                if (returnThis) {
                    _stack2.default.prototype[stackName] = function () {
                        for (var image of this) {
                            image[name].apply(image, arguments);
                        }
                        return this;
                    };
                } else {
                    _stack2.default.prototype[stackName] = function () {
                        var result = new _stack2.default(this.length);
                        for (var i = 0; i < this.length; i++) {
                            var _i;

                            result[i] = (_i = this[i])[name].apply(_i, arguments);
                        }
                        return result;
                    };
                }
            }
        } else {
            Image.prototype[name] = function () {
                for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
                    args[_key2] = arguments[_key2];
                }

                return method.apply(this, [].concat(_toConsumableArray(partialArgs), args));
            };
            if (stack) {
                var _stackName = typeof stack === 'string' ? stack : name;
                _stack2.default.prototype[_stackName] = function () {
                    var result = new _stack2.default(this.length);
                    for (var i = 0; i < this.length; i++) {
                        var _i2;

                        result[i] = (_i2 = this[i])[name].apply(_i2, arguments);
                    }
                    return result;
                };
            }
        }
        return Image;
    }

    static extendProperty(name, method) {
        var _ref2 = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];

        var _ref2$partialArgs = _ref2.partialArgs;
        var partialArgs = _ref2$partialArgs === undefined ? [] : _ref2$partialArgs;

        computedPropertyDescriptor.get = function () {
            if (this.computed === null) {
                this.computed = {};
            } else if (this.computed.hasOwnProperty(name)) {
                return this.computed[name];
            }
            var result = method.apply(this, partialArgs);
            this.computed[name] = result;
            return result;
        };
        Object.defineProperty(Image.prototype, name, computedPropertyDescriptor);
        return Image;
    }

    static createFrom(other, options) {
        var newOptions = {
            width: other.width,
            height: other.height,
            position: other.position,
            components: other.components,
            alpha: other.alpha,
            colorModel: other.colorModel,
            bitDepth: other.bitDepth,
            parent: other
        };
        (0, _extend4.default)(newOptions, options);
        return new Image(newOptions.width, newOptions.height, newOptions);
    }

    static isTypeSupported(type) {
        var operation = arguments.length <= 1 || arguments[1] === undefined ? 'write' : arguments[1];

        if (typeof type !== 'string') {
            throw new TypeError('type argument must be a string');
        }
        type = (0, _mediaTypes.getType)(type);
        if (operation === 'write') {
            return (0, _mediaTypes.canWrite)(type);
        } else {
            throw new TypeError('unknown operation: ' + operation);
        }
    }

    getPixelIndex(indices) {
        var shift = 0;
        for (var i = 0; i < indices.length; i++) {
            shift += this.multipliers[i] * indices[i];
        }
        return shift;
    }

    setValueXY(x, y, channel, value) {
        this.data[(y * this.width + x) * this.channels + channel] = value;
        this.computed = null;
        return this;
    }

    getValueXY(x, y, channel) {
        return this.data[(y * this.width + x) * this.channels + channel];
    }

    setValue(pixel, channel, value) {
        this.data[pixel * this.channels + channel] = value;
        this.computed = null;
        return this;
    }

    getValue(pixel, channel) {
        return this.data[pixel * this.channels + channel];
    }

    setPixelXY(x, y, value) {
        return this.setPixel(y * this.width + x, value);
    }

    getPixelXY(x, y) {
        return this.getPixel(y * this.width + x);
    }

    setPixel(pixel, value) {
        var target = pixel * this.channels;
        for (var i = 0; i < value.length; i++) {
            this.data[target + i] = value[i];
        }
        this.computed = null;
        return this;
    }

    getPixel(pixel) {
        var value = new Array(this.channels);
        var target = pixel * this.channels;
        for (var i = 0; i < this.channels; i++) {
            value[i] = this.data[target + i];
        }
        return value;
    }

    toDataURL() {
        var type = arguments.length <= 0 || arguments[0] === undefined ? 'image/png' : arguments[0];

        return this.getCanvas().toDataURL((0, _mediaTypes.getType)(type));
    }

    getCanvas() {
        var data = new _environment.ImageData(this.getRGBAData(), this.width, this.height);
        var canvas = new _environment.Canvas(this.width, this.height);
        var ctx = canvas.getContext('2d');
        ctx.putImageData(data, 0, 0);
        return canvas;
    }

    getRGBAData() {
        this.checkProcessable('getRGBAData', {
            components: [1, 3],
            bitDepth: [1, 8, 16]
        });
        var size = this.size;
        var newData = new Uint8ClampedArray(this.width * this.height * 4);
        if (this.bitDepth === 1) {
            for (var i = 0; i < size; i++) {
                var value = this.getBit(i);
                newData[i * 4] = value * 255;
                newData[i * 4 + 1] = value * 255;
                newData[i * 4 + 2] = value * 255;
            }
        } else {
            if (this.components === 1) {
                for (var _i3 = 0; _i3 < size; _i3++) {
                    newData[_i3 * 4] = this.data[_i3 * this.channels] >>> this.bitDepth - 8;
                    newData[_i3 * 4 + 1] = this.data[_i3 * this.channels] >>> this.bitDepth - 8;
                    newData[_i3 * 4 + 2] = this.data[_i3 * this.channels] >>> this.bitDepth - 8;
                }
            } else if (this.components === 3) {
                this.checkProcessable('getRGBAData', { colorModel: [_model.RGB] });
                if (this.colorModel === _model.RGB) {
                    for (var _i4 = 0; _i4 < size; _i4++) {
                        newData[_i4 * 4] = this.data[_i4 * this.channels] >>> this.bitDepth - 8;
                        newData[_i4 * 4 + 1] = this.data[_i4 * this.channels + 1] >>> this.bitDepth - 8;
                        newData[_i4 * 4 + 2] = this.data[_i4 * this.channels + 2] >>> this.bitDepth - 8;
                    }
                }
            }
        }
        if (this.alpha) {
            this.checkProcessable('getRGBAData', { bitDepth: [8, 16] });
            for (var _i5 = 0; _i5 < size; _i5++) {
                newData[_i5 * 4 + 3] = this.data[_i5 * this.channels + this.components] >> this.bitDepth - 8;
            }
        } else {
            for (var _i6 = 0; _i6 < size; _i6++) {
                newData[_i6 * 4 + 3] = 255;
            }
        }
        return newData;
    }

    getROIManager(mask, options) {
        return new _manager2.default(this, options);
    }

    clone() {
        var _ref3 = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

        var _ref3$copyData = _ref3.copyData;
        var copyData = _ref3$copyData === undefined ? true : _ref3$copyData;

        return new Image(this, copyData);
    }

    save(path) {
        var _ref4 = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

        var _ref4$format = _ref4.format;
        var format = _ref4$format === undefined ? 'png' : _ref4$format;
        // Node.JS only
        return new Promise((resolve, reject) => {
            var out = (0, _fs.createWriteStream)(path);
            var canvas = this.getCanvas();
            var stream = void 0;
            switch (format.toLowerCase()) {
                case 'png':
                    stream = canvas.pngStream();
                    break;
                case 'jpg':
                case 'jpeg':
                    stream = canvas.jpegStream();
                    break;
                default:
                    return reject(new RangeError('invalid output format: ' + format));
            }
            out.on('finish', resolve);
            out.on('error', reject);
            stream.pipe(out);
        });
    }

    // this method check if a process can be applied on the current image
    checkProcessable(processName) {
        var _ref5 = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

        var bitDepth = _ref5.bitDepth;
        var alpha = _ref5.alpha;
        var colorModel = _ref5.colorModel;
        var components = _ref5.components;

        if (typeof processName !== 'string') {
            throw new TypeError('checkProcessable requires as first parameter the processName (a string)');
        }
        if (bitDepth) {
            if (!Array.isArray(bitDepth)) bitDepth = [bitDepth];
            if (bitDepth.indexOf(this.bitDepth) === -1) {
                throw new TypeError('The process: ' + processName + ' can only be applied if bit depth is in: ' + bitDepth);
            }
        }
        if (alpha) {
            if (!Array.isArray(alpha)) alpha = [alpha];
            if (alpha.indexOf(this.alpha) === -1) {
                throw new TypeError('The process: ' + processName + ' can only be applied if alpha is in: ' + alpha);
            }
        }
        if (colorModel) {
            if (!Array.isArray(colorModel)) colorModel = [colorModel];
            if (colorModel.indexOf(this.colorModel) === -1) {
                throw new TypeError('The process: ' + processName + ' can only be applied if color model is in: ' + colorModel);
            }
        }
        if (components) {
            if (!Array.isArray(components)) components = [components];
            if (components.indexOf(this.components) === -1) {
                throw new TypeError('The process: ' + processName + ' can only be applied if the number of channels is in: ' + components);
            }
        }
    }

    checkColumn(column) {
        if (column < 0 || column >= this.width) {
            throw new RangeError(`checkColumn: column should be included between 0 and ${ this.width - 1 }. Current value: ${ column }`);
        }
    }

    checkRow(row) {
        if (row < 0 || row >= this.height) {
            throw new RangeError(`checkRow: row should be included between 0 and ${ this.height - 1 }. Current value: ${ row }`);
        }
    }

    checkChannel(channel) {
        if (channel < 0 || channel >= this.channels) {
            throw new RangeError(`checkChannel: channel should be included between 0 and ${ this.channels - 1 }. Current value: ${ channel }`);
        }
    }

    apply(filter) {
        for (var y = 0; y < this.height; y++) {
            for (var x = 0; x < this.width; x++) {
                var index = (y * this.width + x) * this.channels;
                filter.call(this, index);
            }
        }
    }
}

exports.default = Image;
(0, _extend2.default)(Image);
(0, _bitMethods2.default)(Image);

},{"../stack/stack":168,"./bitMethods":71,"./environment":83,"./extend":84,"./kind":104,"./kindNames":105,"./load":106,"./mediaTypes":107,"./model/model":108,"./roi/manager":118,"extend":3,"fs":2}],104:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.getKind = getKind;
exports.getTheoreticalPixelArraySize = getTheoreticalPixelArraySize;
exports.createPixelArray = createPixelArray;

var _kindNames = require('./kindNames');

var Kind = _interopRequireWildcard(_kindNames);

var _model = require('./model/model');

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var kinds = {};

kinds[Kind.BINARY] = {
    components: 1,
    alpha: 0,
    bitDepth: 1
};

kinds[Kind.GREYA] = {
    components: 1,
    alpha: 1,
    bitDepth: 8
};

kinds[Kind.GREY] = {
    components: 1,
    alpha: 0,
    bitDepth: 8
};

kinds[Kind.RGBA] = {
    components: 3,
    alpha: 1,
    bitDepth: 8,
    colorModel: _model.RGB
};

kinds[Kind.RGB] = {
    components: 3,
    alpha: 0,
    bitDepth: 8,
    colorModel: _model.RGB
};

function getKind(kind) {
    return kinds[kind];
}

function getTheoreticalPixelArraySize(image) {
    var length = image.channels * image.size;
    if (image.bitDepth === 1) {
        length = Math.ceil(length / 8);
    }
    return length;
}

function createPixelArray(image) {
    var length = image.channels * image.size;
    var arr = void 0;
    switch (image.bitDepth) {
        case 1:
            arr = new Uint8Array(Math.ceil(length / 8));
            break;
        case 8:
            arr = new Uint8ClampedArray(length);
            break;
        case 16:
            arr = new Uint16Array(length);
            break;
        case 32:
            arr = new Float32Array(length);
            break;
        default:
            throw new Error('Cannot create pixel array for bit depth ' + image.bitDepth);
    }

    // alpha channel is 100% by default
    if (image.alpha) {
        for (var i = image.components; i < arr.length; i += image.channels) {
            arr[i] = image.maxValue;
        }
    }
    image.data = arr;
}

},{"./kindNames":105,"./model/model":108}],105:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
// Shortcuts for common image kinds

var BINARY = exports.BINARY = 'BINARY';
var GREYA = exports.GREYA = 'GREYA';
var RGBA = exports.RGBA = 'RGBA';
var RGB = exports.RGB = 'RGB';
var GREY = exports.GREY = 'GREY';

},{}],106:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.loadURL = loadURL;

var _image = require('./image');

var _image2 = _interopRequireDefault(_image);

var _stack = require('../stack/stack');

var _stack2 = _interopRequireDefault(_stack);

var _environment = require('./environment');

var _fastPng = require('fast-png');

var _tiff = require('tiff');

var _atobLite = require('atob-lite');

var _atobLite2 = _interopRequireDefault(_atobLite);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var isDataURL = /^data:[a-z]+\/([a-z]+);base64,/;
var isPNG = /\.png$/i;
var isTIFF = /\.tiff?$/i;

function str2ab(str) {
    var arr = new Uint8Array(str.length);
    for (var i = 0; i < str.length; i++) {
        arr[i] = str.charCodeAt(i);
    }
    return arr;
}

function swap16(val) {
    return (val & 0xFF) << 8 | val >> 8 & 0xFF;
}

function loadURL(url) {
    var dataURL = url.slice(0, 64).match(isDataURL);
    if (dataURL) {
        var mimetype = dataURL[1];
        var offset = dataURL[0].length;
        if (mimetype === 'png') {
            var slice = url.slice(offset);
            return Promise.resolve(str2ab((0, _atobLite2.default)(slice))).then(loadPNG);
        } else if (mimetype === 'tiff') {
            var _slice = url.slice(offset);
            return Promise.resolve(str2ab((0, _atobLite2.default)(_slice))).then(loadTIFF);
        }
    }

    if (isPNG.test(url)) {
        return (0, _environment.loadBinary)(url).then(loadPNG);
    } else if (isTIFF.test(url)) {
        return (0, _environment.loadBinary)(url).then(loadTIFF);
    }

    return loadGeneric(url);
}

function loadPNG(data) {
    var decoder = new _fastPng.PNGDecoder(data);
    var png = decoder.decode();
    var bitDepth = png.bitDepth;
    var buffer = png.data.buffer;
    var bitmap = void 0;
    if (bitDepth === 8) {
        bitmap = new Uint8ClampedArray(buffer);
    } else if (bitDepth === 16) {
        bitmap = new Uint16Array(buffer);
        for (var i = 0; i < bitmap.length; i++) {
            bitmap[i] = swap16(bitmap[i]);
        }
    }

    var type = png.colourType;
    var components = void 0,
        alpha = 0;
    switch (type) {
        case 0:
            components = 1;break;
        case 2:
            components = 3;break;
        case 4:
            components = 1;alpha = 1;break;
        case 6:
            components = 3;alpha = 1;break;
    }

    return new _image2.default(png.width, png.height, bitmap, { components: components, alpha: alpha, bitDepth: bitDepth });
}

function loadTIFF(data) {
    var decoder = new _tiff.TIFFDecoder(data);
    var result = decoder.decode();
    if (result.ifd.length === 1) {
        return getImageFromIFD(result.ifd[0]);
    } else {
        return new _stack2.default(result.ifd.map(getImageFromIFD));
    }
}

function getImageFromIFD(image) {
    return new _image2.default(image.width, image.height, image.data, {
        components: 1,
        alpha: 0,
        colorModel: null,
        bitDepth: image.bitsPerSample
    });
}

function loadGeneric(url) {
    return new Promise(function (resolve, reject) {
        var image = new _environment.DOMImage();

        if ((0, _environment.isDifferentOrigin)(url)) {
            // see https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image
            image.crossOrigin = 'Anonymous';
        }

        image.onload = function () {
            var w = image.width,
                h = image.height;
            var canvas = new _environment.Canvas(w, h);
            var ctx = canvas.getContext('2d');
            ctx.drawImage(image, 0, 0, w, h);
            var data = ctx.getImageData(0, 0, w, h).data;
            resolve(new _image2.default(w, h, data));
        };
        image.onerror = function () {
            reject(new Error('Could not load ' + url));
        };
        image.src = url;
    });
}

},{"../stack/stack":168,"./environment":83,"./image":103,"atob-lite":1,"fast-png":5,"tiff":68}],107:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.canWrite = canWrite;
exports.getType = getType;

var _image = require('./image');

var _image2 = _interopRequireDefault(_image);

var _environment = require('./environment');

var _stringIncludes = require('string-includes');

var _stringIncludes2 = _interopRequireDefault(_stringIncludes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var types = new Map();
var image = void 0;

function getMediaType(type) {
    if (!image) {
        image = new _image2.default(1, 1);
    }
    var theType = types.get(type);
    if (!theType) {
        theType = new MediaType(type);
        types.set(type, theType);
    }
    return theType;
}

function canWrite(type) {
    if (_environment.env === 'node' && type !== 'image/png') {
        return false; // node-canvas throws for other types
    } else {
        return getMediaType(type).canWrite();
    }
}

class MediaType {
    constructor(type) {
        this.type = type;
        this._canWrite = null;
    }

    canWrite() {
        if (this._canWrite === null) {
            this._canWrite = image.toDataURL(this.type).startsWith('data:' + this.type);
        }
        return this._canWrite;
    }
}

function getType(type) {
    if (!(0, _stringIncludes2.default)(type, '/')) {
        type = 'image/' + type;
    }
    return type;
}

},{"./environment":83,"./image":103,"string-includes":63}],108:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
var RGB = exports.RGB = 'RGB';
var HSL = exports.HSL = 'HSL';
var HSV = exports.HSV = 'HSV';

},{}],109:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = convolution;

var _image = require('../image');

var _image2 = _interopRequireDefault(_image);

var _channel = require('../../util/channel');

var _kernel = require('../../util/kernel');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 *
 * @param kernel
 * @param bitDepth : We can specify a new bitDepth for the image. This allow to specify 32 bits in order no to clamp
 * @param normalize
 * @param divisor
 * @param border
 * @returns {*}
 */
function convolution(kernel) {
    var _ref = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

    var channels = _ref.channels;
    var bitDepth = _ref.bitDepth;
    var _ref$normalize = _ref.normalize;
    var normalize = _ref$normalize === undefined ? false : _ref$normalize;
    var _ref$divisor = _ref.divisor;
    var divisor = _ref$divisor === undefined ? 1 : _ref$divisor;
    var _ref$border = _ref.border;
    var border = _ref$border === undefined ? 'copy' : _ref$border;


    var newImage = _image2.default.createFrom(this, { bitDepth: bitDepth });

    channels = (0, _channel.validateArrayOfChannels)(this, channels, true);

    var kWidth = void 0,
        kHeight = void 0;


    //calculate divisor

    var _validateKernel = (0, _kernel.validateKernel)(kernel);

    kWidth = _validateKernel.kWidth;
    kHeight = _validateKernel.kHeight;
    kernel = _validateKernel.kernel;
    if (normalize) {
        divisor = 0;
        for (var i = 0; i < kernel.length; i++) {
            for (var j = 0; j < kernel[0].length; j++) {
                divisor += kernel[i][j];
            }
        }
    }

    if (divisor === 0) {
        throw new RangeError('convolution: The divisor is equal to zero');
    }

    var clamped = newImage.isClamped;

    for (var channel = 0; channel < channels.length; channel++) {
        var c = channels[channel];
        for (var y = kHeight; y < this.height - kHeight; y++) {
            for (var x = kWidth; x < this.width - kWidth; x++) {
                var sum = 0;
                for (var _j = -kHeight; _j <= kHeight; _j++) {
                    for (var _i = -kWidth; _i <= kWidth; _i++) {
                        var kVal = kernel[kHeight + _j][kWidth + _i];
                        var _index = ((y + _j) * this.width + x + _i) * this.channels + c;
                        sum += this.data[_index] * kVal;
                    }
                }

                var index = (y * this.width + x) * this.channels + c;
                if (clamped) {
                    // we calculate the clamped result
                    newImage.data[index] = Math.min(Math.max(Math.round(sum / divisor), 0), newImage.maxValue);
                } else {
                    newImage.data[index] = sum / divisor;
                }
            }
        }
    }
    // if the kernel was not applied on the alpha channel we just copy it
    // TODO: in general we should copy the channels that where not changed
    // TODO: probably we should just copy the image at the beginning ?

    if (this.alpha && channels.indexOf(this.channels) === -1) {
        for (var _i2 = this.components; _i2 < this.data.length; _i2 = _i2 + this.channels) {
            newImage.data[_i2] = this.data[_i2];
        }
    }

    newImage.setBorder({ size: [kWidth, kHeight], algorithm: border });

    return newImage;
}

},{"../../util/channel":171,"../../util/kernel":174,"../image":103}],110:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = extract;

var _image = require('../image');

var _image2 = _interopRequireDefault(_image);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function extract(mask) {
    var _ref = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

    var _ref$scale = _ref.scale;
    var scale = _ref$scale === undefined ? 1 : _ref$scale;
    var position = _ref.position;


    this.checkProcessable('extract', {
        bitDepth: [8, 16]
    });

    // we need to find the relative position to the parent
    if (!position) {
        position = mask.getRelativePosition(this);
        if (!position) {
            throw new Error('extract : can not extract an image because the relative position can not be ' + 'determined, try to specify manualy the position as an array of 2 elements [x,y].');
        }
    }
    var extract = _image2.default.createFrom(this, {
        width: mask.width,
        height: mask.height,
        alpha: 1, // we force the alpha, otherwise dificult to extract a mask ...
        position: position,
        parent: this
    });

    for (var x = 0; x < mask.width; x++) {
        for (var y = 0; y < mask.height; y++) {
            // we copy the point
            for (var channel = 0; channel < this.channels; channel++) {
                var value = this.getValueXY(x + position[0], y + position[1], channel);
                extract.setValueXY(x, y, channel, value);
            }
            // we make it transparent in case it is not in the mask
            if (!mask.getBitXY(x, y)) {
                extract.setValueXY(x, y, this.components, 0);
            }
        }
    }

    return extract;
} // we will create a small image from a mask

},{"../image":103}],111:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = paintMasks;

var _model = require('../model/model');

function paintMasks(masks) {
    var _ref = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

    var _ref$color = _ref.color;
    var color = _ref$color === undefined ? [this.maxValue, 0, 0] : _ref$color;


    this.checkProcessable('paintMasks', {
        components: 3,
        bitDepth: [8, 16],
        colorModel: _model.RGB
    });

    if (!Array.isArray(masks)) masks = [masks];

    var numberChannels = Math.min(this.channels, color.length);

    for (var i = 0; i < masks.length; i++) {
        var roi = masks[i];
        // we need to find the parent image to calculate the relative position

        for (var x = 0; x < roi.width; x++) {
            for (var y = 0; y < roi.height; y++) {
                if (roi.getBitXY(x, y)) {
                    for (var channel = 0; channel < numberChannels; channel++) {
                        this.setValueXY(x + roi.position[0], y + roi.position[1], channel, color[channel]);
                    }
                }
            }
        }
    }
}

},{"../model/model":108}],112:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = paintPixels;

var _model = require('../model/model');

var _shape = require('../../util/shape');

var _shape2 = _interopRequireDefault(_shape);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function paintPixels(pixels) {
    var _ref = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

    var _ref$color = _ref.color;
    var color = _ref$color === undefined ? [this.maxValue, 0, 0] : _ref$color;
    var shape = _ref.shape;


    this.checkProcessable('paintPixels', {
        components: 3,
        bitDepth: [8, 16],
        colorModel: _model.RGB
    });

    var shapePixels = new _shape2.default(shape).getPoints();

    var numberChannels = Math.min(this.channels, color.length);

    for (var i = 0; i < pixels.length; i++) {
        var xP = pixels[i][0];
        var yP = pixels[i][1];
        for (var j = 0; j < shapePixels.length; j++) {
            var xS = shapePixels[j][0];
            var yS = shapePixels[j][1];
            if (xP + xS >= 0 && yP + yS >= 0 && xP + xS < this.width && yP + yS < this.height) {
                var position = (xP + xS + (yP + yS) * this.width) * this.channels;
                for (var channel = 0; channel < numberChannels; channel++) {
                    this.data[position + channel] = color[channel];
                }
            }
        }
    }
}

},{"../../util/shape":177,"../model/model":108}],113:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
class ROIMap {
    constructor(parent, pixels, negativeID, positiveID) {
        this.parent = parent;
        this.width = parent.width;
        this.height = parent.height;
        this.pixels = pixels; // pixels containing the annotations
        this.negative = -negativeID; // number of negative zones
        this.positive = positiveID; // number of positivie zones
        this.total = positiveID - negativeID; // total number of zones
    }
}
exports.default = ROIMap;

},{}],114:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = createROI;

var _roi = require('./roi');

var _roi2 = _interopRequireDefault(_roi);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*
Roi are created from a roiMap
The roiMap contains mainty an array of identifiers that define
for each pixels to which Roi it belongs
 */

function createROI(roiMap) {

    var size = roiMap.total;
    var rois = new Array(size);
    for (var i = 0; i < size; i++) {
        var mapID = -roiMap.negative + i;
        if (i >= roiMap.negative) mapID++;
        rois[i] = new _roi2.default(roiMap, mapID);
    }
    var pixels = roiMap.pixels;

    var width = roiMap.parent.width;
    var height = roiMap.parent.height;

    for (var x = 0; x < width; x++) {
        for (var y = 0; y < height; y++) {
            var target = y * width + x;
            if (pixels[target] !== 0) {
                var _mapID = pixels[target] + roiMap.negative;
                if (_mapID > roiMap.negative) _mapID--;
                if (x < rois[_mapID].minX) rois[_mapID].minX = x;
                if (x > rois[_mapID].maxX) rois[_mapID].maxX = x;
                if (y < rois[_mapID].minY) rois[_mapID].minY = y;
                if (y > rois[_mapID].maxY) rois[_mapID].maxY = y;
                rois[_mapID].meanX += x;
                rois[_mapID].meanY += y;
                rois[_mapID].surface++;
            }
        }
    }
    for (var _i = 0; _i < size; _i++) {
        var _mapID2 = -roiMap.negative + _i;
        if (_i >= roiMap.negative) _mapID2++;
        rois[_i].meanX /= rois[_i].surface;
        rois[_i].meanY /= rois[_i].surface;
    }
    return rois;
}

},{"./roi":119}],115:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = createROIMapFromExtrema;

var _ROIMap = require('./../RoiMap');

var _ROIMap2 = _interopRequireDefault(_ROIMap);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function createROIMapFromExtrema() {
    var _ref = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

    var _ref$allowCorner = _ref.allowCorner;
    var allowCorner = _ref$allowCorner === undefined ? true : _ref$allowCorner;
    var onlyTop = _ref.onlyTop;
    var _ref$invert = _ref.invert;
    var invert = _ref$invert === undefined ? false : _ref$invert;


    var image = this;
    image.checkProcessable('createROIMapFromExtrema', { components: [1] });

    var PROCESS_TOP = 1;
    var PROCESS_NORMAL = 2;

    // split will always return an array of images
    var positiveID = 0;
    var negativeID = 0;

    var MIN_VALUE = -32768;

    var pixels = new Int16Array(image.size); // maxValue: 32767, minValue: -32768
    var processed = new Int8Array(image.size);
    var variations = new Float32Array(image.size);

    var MAX_ARRAY = 0x0fffff; // should be enough for most of the cases
    var xToProcess = new Uint16Array(MAX_ARRAY + 1); // assign dynamically ????
    var yToProcess = new Uint16Array(MAX_ARRAY + 1); // mask +1 is of course mandatory !!!

    var from = 0;
    var to = 0;

    var xToProcessTop = new Uint16Array(MAX_ARRAY + 1); // assign dynamically ????
    var yToProcessTop = new Uint16Array(MAX_ARRAY + 1); // mask +1 is of course mandatory !!!

    var fromTop = 0;
    var toTop = 0;

    appendExtrema(image, { maxima: !invert });

    while (from < to) {
        var currentX = xToProcess[from & MAX_ARRAY];
        var currentY = yToProcess[from & MAX_ARRAY];
        process(currentX, currentY, PROCESS_NORMAL);
        from++;
    }

    return new _ROIMap2.default(image, pixels, negativeID, positiveID);

    // we will look for the maxima (or minima) that is present in the picture
    // a maxima is a point that is surrounded by lower values
    // should deal with allowCorner and invert
    function appendExtrema(_ref2) {
        var _ref2$maxima = _ref2.maxima;
        var maxima = _ref2$maxima === undefined ? true : _ref2$maxima;

        for (var y = 1; y < image.height - 1; y++) {
            for (var x = 1; x < image.width - 1; x++) {
                var index = x + y * image.width;
                if (processed[index] === 0) {
                    var currentValue = maxima ? image.data[index] : -image.data[x + y * image.width];
                    if (image.data[y * image.width + x - 1] > currentValue) {
                        // LEFT
                        continue;
                    }
                    if (image.data[y * image.width + x + 1] > currentValue) {
                        // RIGHT
                        continue;
                    }
                    if (image.data[(y - 1) * image.width + x] > currentValue) {
                        // TOP
                        continue;
                    }
                    if (image.data[(y + 1) * image.width + x] > currentValue) {
                        // BOTTOM
                        continue;
                    }
                    if (allowCorner) {
                        if (image.data[(y - 1) * image.width + x - 1] > currentValue) {
                            // LEFT TOP
                            continue;
                        }
                        if (image.data[(y - 1) * image.width + x + 1] > currentValue) {
                            // RIGHT TOP
                            continue;
                        }
                        if (image.data[(y + 1) * image.width + x - 1] > currentValue) {
                            // LEFT BOTTOM
                            continue;
                        }
                        if (image.data[(y + 1) * image.width + x + 1] > currentValue) {
                            // RIGHT BOTTOM
                            continue;
                        }
                    }

                    pixels[index] = maxima ? ++positiveID : --negativeID;

                    // console.log('---',pixels[index]);

                    var valid = processTop(x, y, PROCESS_TOP);
                    if (!valid) maxima ? --positiveID : ++negativeID;
                }
            }
        }
    }

    // we will try to get all the points of the top (same value)
    // and to check if the whole group is surrounded by lower value
    // as soon as one of them if not part we need to reverse the process
    // and just for get those points
    function processTop(xToProcess, yToProcess) {
        // console.log('process top');
        var currentTo = to; // in case if fails we come back
        fromTop = 0;
        toTop = 1;
        xToProcessTop[0] = xToProcess;
        yToProcessTop[0] = yToProcess;
        var valid = true;
        while (fromTop < toTop) {
            var _currentX = xToProcessTop[fromTop & MAX_ARRAY];
            var _currentY = yToProcessTop[fromTop & MAX_ARRAY];
            valid &= process(_currentX, _currentY, PROCESS_TOP);
            fromTop++;
        }
        if (!valid) {
            // console.log('REVERT');
            // need to clear all the calculated pixels because the top is not surrounded by negative values
            for (var i = 0; i < toTop; i++) {
                var _currentX2 = xToProcessTop[i & MAX_ARRAY];
                var _currentY2 = yToProcessTop[i & MAX_ARRAY];
                var index = _currentY2 * image.width + _currentX2;
                pixels[index] = 0;
            }
            to = currentTo;
        }
        return valid;
    }

    /*
     For a specific point we will check the points around, increase the area of interests and add
     them to the processing list
     type=0 : top
     type=1 : normal
     */
    function process(xCenter, yCenter, type) {
        // console.log('PROCESS', xCenter, yCenter);
        var currentID = pixels[yCenter * image.width + xCenter];
        var currentValue = image.data[yCenter * image.width + xCenter];
        var currentVariation = variations[yCenter * image.width + xCenter];
        for (var y = yCenter - 1; y <= yCenter + 1; y++) {
            for (var x = xCenter - 1; x <= xCenter + 1; x++) {
                var index = y * image.width + x;
                if (processed[index] === 0) {
                    processed[index] = 1;
                    // we store the variation compare to the parent pixel
                    variations[index] = image.data[index] - currentValue;
                    switch (type) {
                        case PROCESS_TOP:
                            // console.log(x, y, variations[index]);
                            if (variations[index] === 0) {
                                // we look for maxima
                                // console.log('ZERO', currentID, x, y);
                                // if we are next to a border ... it is not surrounded !
                                if (x === 0 || y === 0 || x === image.width - 1 || y === image.height - 1) return false;
                                pixels[index] = currentID;
                                xToProcessTop[toTop & MAX_ARRAY] = x;
                                yToProcessTop[toTop & MAX_ARRAY] = y;
                                toTop++;
                            } else if (variations[index] > 0) {
                                // not a global maximum
                                // console.log('LARGER');
                                return false;
                            } else {
                                // a point we will have to process
                                if (!onlyTop) {
                                    pixels[index] = currentID;
                                    xToProcess[to & MAX_ARRAY] = x;
                                    yToProcess[to & MAX_ARRAY] = y;
                                    to++;
                                }
                            }
                            break;
                        case PROCESS_NORMAL:
                            if (variations[index] <= 0) {
                                // we look for maxima
                                pixels[index] = currentID;
                                xToProcess[to & MAX_ARRAY] = x;
                                yToProcess[to & MAX_ARRAY] = y;
                                to++;
                            }
                            break;
                    }
                }
            }
        }
        return true;
    }
}

},{"./../ROIMap":113}],116:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = createROIMapFromMask;

var _ROIMap = require('./../RoiMap');

var _ROIMap2 = _interopRequireDefault(_ROIMap);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function createROIMapFromMask(mask) {
    var _ref = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

    var _ref$allowCorner = _ref.allowCorner;
    var allowCorner = _ref$allowCorner === undefined ? false : _ref$allowCorner;


    // based on a binary image we will create plenty of small images
    var pixels = new Int16Array(mask.size); // maxValue: 32767, minValue: -32768

    // split will always return an array of images
    var positiveID = 0;
    var negativeID = 0;

    var MAX_ARRAY = 0x00ffff; // should be enough for most of the cases
    var xToProcess = new Uint16Array(MAX_ARRAY + 1); // assign dynamically ????
    var yToProcess = new Uint16Array(MAX_ARRAY + 1); // mask +1 is of course mandatory !!!

    for (var x = 0; x < mask.width; x++) {
        for (var y = 0; y < mask.height; y++) {
            if (pixels[y * mask.width + x] === 0) {
                // need to process the whole surface
                analyseSurface(x, y);
            }
        }
    }

    function analyseSurface(x, y) {
        var from = 0;
        var to = 0;
        var targetState = mask.getBitXY(x, y);
        var id = targetState ? ++positiveID : --negativeID;
        xToProcess[0] = x;
        yToProcess[0] = y;
        while (from <= to) {
            var currentX = xToProcess[from & MAX_ARRAY];
            var currentY = yToProcess[from & MAX_ARRAY];
            pixels[currentY * mask.width + currentX] = id;
            // need to check all around mask pixel
            if (currentX > 0 && pixels[currentY * mask.width + currentX - 1] === 0 && mask.getBitXY(currentX - 1, currentY) === targetState) {
                // LEFT
                to++;
                xToProcess[to & MAX_ARRAY] = currentX - 1;
                yToProcess[to & MAX_ARRAY] = currentY;
                pixels[currentY * mask.width + currentX - 1] = -32768;
            }
            if (currentY > 0 && pixels[(currentY - 1) * mask.width + currentX] === 0 && mask.getBitXY(currentX, currentY - 1) === targetState) {
                // TOP
                to++;
                xToProcess[to & MAX_ARRAY] = currentX;
                yToProcess[to & MAX_ARRAY] = currentY - 1;
                pixels[(currentY - 1) * mask.width + currentX] = -32768;
            }
            if (currentX < mask.width - 1 && pixels[currentY * mask.width + currentX + 1] === 0 && mask.getBitXY(currentX + 1, currentY) === targetState) {
                // RIGHT
                to++;
                xToProcess[to & MAX_ARRAY] = currentX + 1;
                yToProcess[to & MAX_ARRAY] = currentY;
                pixels[currentY * mask.width + currentX + 1] = -32768;
            }
            if (currentY < mask.height - 1 && pixels[(currentY + 1) * mask.width + currentX] === 0 && mask.getBitXY(currentX, currentY + 1) === targetState) {
                // BOTTOM
                to++;
                xToProcess[to & MAX_ARRAY] = currentX;
                yToProcess[to & MAX_ARRAY] = currentY + 1;
                pixels[(currentY + 1) * mask.width + currentX] = -32768;
            }
            if (allowCorner) {
                if (currentX > 0 && currentY > 0 && pixels[(currentY - 1) * mask.width + currentX - 1] === 0 && mask.getBitXY(currentX - 1, currentY - 1) === targetState) {
                    // TOP LEFT
                    to++;
                    xToProcess[to & MAX_ARRAY] = currentX - 1;
                    yToProcess[to & MAX_ARRAY] = currentY - 1;
                    pixels[(currentY - 1) * mask.width + currentX - 1] = -32768;
                }
                if (currentX < mask.width - 1 && currentY > 0 && pixels[(currentY - 1) * mask.width + currentX + 1] === 0 && mask.getBitXY(currentX + 1, currentY - 1) === targetState) {
                    // TOP RIGHT
                    to++;
                    xToProcess[to & MAX_ARRAY] = currentX + 1;
                    yToProcess[to & MAX_ARRAY] = currentY - 1;
                    pixels[(currentY - 1) * mask.width + currentX + 1] = -32768;
                }
                if (currentX > 0 && currentY < mask.height - 1 && pixels[(currentY + 1) * mask.width + currentX - 1] === 0 && mask.getBitXY(currentX - 1, currentY + 1) === targetState) {
                    // BOTTOM LEFT
                    to++;
                    xToProcess[to & MAX_ARRAY] = currentX - 1;
                    yToProcess[to & MAX_ARRAY] = currentY + 1;
                    pixels[(currentY + 1) * mask.width + currentX - 1] = -32768;
                }
                if (currentX < mask.width - 1 && currentY < mask.height - 1 && pixels[(currentY + 1) * mask.width + currentX + 1] === 0 && mask.getBitXY(currentX + 1, currentY + 1) === targetState) {
                    // BOTTOM RIGHT
                    to++;
                    xToProcess[to & MAX_ARRAY] = currentX + 1;
                    yToProcess[to & MAX_ARRAY] = currentY + 1;
                    pixels[(currentY + 1) * mask.width + currentX + 1] = -32768;
                }
            }

            from++;

            if (to - from > MAX_ARRAY) {
                throw new Error('analyseMask can not finish, the array to manage internal data is not big enough.' + 'You could improve mask by changing MAX_ARRAY');
            }
        }
    }

    return new _ROIMap2.default(mask, pixels, negativeID, positiveID);
} /*
  We will annotate each point to define to which area it belongs
   */

},{"./../ROIMap":113}],117:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = fromCoordinates;

var _ROIMap = require('./../RoiMap');

var _ROIMap2 = _interopRequireDefault(_ROIMap);

var _shape = require('./../../../util/shape');

var _shape2 = _interopRequireDefault(_shape);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*
We will annotate each point to define to which area it belongs
 */

function fromCoordinates(pixelsToPaint) {
    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

    var shape = new _shape2.default(options);

    // based on a binary image we will create plenty of small images
    var mapPixels = new Int16Array(this.size); // maxValue: 32767, minValue: -32768
    var positiveID = 0;
    var shapePixels = shape.getPoints();
    for (var i = 0; i < pixelsToPaint.length; i++) {
        positiveID++;
        var xP = pixelsToPaint[i][0];
        var yP = pixelsToPaint[i][1];
        for (var j = 0; j < shapePixels.length; j++) {
            var xS = shapePixels[j][0];
            var yS = shapePixels[j][1];
            if (xP + xS >= 0 && yP + yS >= 0 && xP + xS < this.width && yP + yS < this.height) {
                mapPixels[xP + xS + (yP + yS) * this.width] = positiveID;
            }
        }
    }
    return new _ROIMap2.default(this, mapPixels, 0, positiveID);
}

},{"./../../../util/shape":177,"./../ROIMap":113}],118:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _fromMask = require('./creator/fromMask');

var _fromMask2 = _interopRequireDefault(_fromMask);

var _fromExtrema = require('./creator/fromExtrema');

var _fromExtrema2 = _interopRequireDefault(_fromExtrema);

var _fromPixels = require('./creator/fromPixels');

var _fromPixels2 = _interopRequireDefault(_fromPixels);

var _createROI = require('./createRoi');

var _createROI2 = _interopRequireDefault(_createROI);

var _extend = require('extend');

var _extend2 = _interopRequireDefault(_extend);

var _image = require('../image');

var _image2 = _interopRequireDefault(_image);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class ROIManager {

    constructor(image) {
        var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

        this._image = image;
        this._options = options;
        if (!this._options.lebel) this._options.label = 'default';
        this._layers = {};
        this._painted = null;
    }

    generateROIFromExtrema() {
        var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

        var opt = (0, _extend2.default)({}, this._options, options);
        var roiMap = _fromExtrema2.default.call(this._image, options);
        this._layers[opt.label] = new ROILayer(roiMap, opt);
    }

    putPixels(pixels) {
        var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

        var opt = (0, _extend2.default)({}, this._options, options);
        var roiMap = _fromPixels2.default.call(this._image, pixels, options);
        this._layers[opt.label] = new ROILayer(roiMap, opt);
    }

    putMap(roiMap) {
        var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

        var opt = (0, _extend2.default)({}, this._options, options);
        this._layers[opt.label] = new ROILayer(roiMap, opt);
    }

    putMask(mask) {
        var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

        var opt = (0, _extend2.default)({}, this._options, options);
        var roiMap = _fromMask2.default.call(this._image, mask, options);
        this._layers[opt.label] = new ROILayer(roiMap, opt);
    }

    getMap() {
        var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

        var opt = (0, _extend2.default)({}, this._options, options);
        if (!this._layers[opt.label]) return;
        return this._layers[opt.label].roiMap;
    }

    getROIIDs() {
        var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

        var rois = this.getROI(options);
        if (!rois) return;
        var ids = new Array(rois.length);
        for (var i = 0; i < rois.length; i++) {
            ids[i] = rois[i].id;
        }
        return ids;
    }

    getROI() {
        var _ref = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

        var _ref$label = _ref.label;
        var label = _ref$label === undefined ? this._options.label : _ref$label;
        var _ref$positive = _ref.positive;
        var positive = _ref$positive === undefined ? true : _ref$positive;
        var _ref$negative = _ref.negative;
        var negative = _ref$negative === undefined ? true : _ref$negative;
        var _ref$minSurface = _ref.minSurface;
        var minSurface = _ref$minSurface === undefined ? 0 : _ref$minSurface;
        var _ref$maxSurface = _ref.maxSurface;
        var maxSurface = _ref$maxSurface === undefined ? Number.POSITIVE_INFINITY : _ref$maxSurface;


        var allROIs = this._layers[label].roi;
        var rois = new Array(allROIs.length);
        var ptr = 0;
        for (var i = 0; i < allROIs.length; i++) {
            var roi = allROIs[i];
            if ((roi.id < 0 && negative || roi.id > 0 && positive) && roi.surface >= minSurface && roi.surface <= maxSurface) {
                rois[ptr++] = roi;
            }
        }
        rois.length = ptr;
        return rois;
    }

    getROIMasks() {
        var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

        var rois = this.getROI(options);
        var masks = new Array(rois.length);
        for (var i = 0; i < rois.length; i++) {
            masks[i] = rois[i].mask;
        }
        return masks;
    }

    getPixels() {
        var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

        var opt = (0, _extend2.default)({}, this._options, options);
        if (this._layers[opt.label]) {
            return this._layers[opt.label].roiMap.pixels;
        }
    }

    paint() {
        var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

        if (!this._painted) this._painted = this._image.rgba8();
        var masks = this.getROIMasks(options);
        this._painted.paintMasks(masks, options);
        return this._painted;
    }

    // return a mask corresponding to all the selected masks
    getMask() {
        var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

        var mask = new _image2.default(this._image.width, this._image.height, { kind: 'BINARY' });
        var masks = this.getROIMasks(options);
        for (var i = 0; i < masks.length; i++) {
            var roi = masks[i];
            // we need to find the parent image to calculate the relative position

            for (var x = 0; x < roi.width; x++) {
                for (var y = 0; y < roi.height; y++) {
                    if (roi.getBitXY(x, y)) {
                        mask.setBitXY(x + roi.position[0], y + roi.position[1]);
                    }
                }
            }
        }
        return mask;
    }

    resetPainted(image) {
        this._painted = image;
    }
}

exports.default = ROIManager;
class ROILayer {
    constructor(roiMap, options) {
        this.roiMap = roiMap;
        this.options = options;
        this.roi = (0, _createROI2.default)(this.roiMap);
    }
}

},{"../image":103,"./createROI":114,"./creator/fromExtrema":115,"./creator/fromMask":116,"./creator/fromPixels":117,"extend":3}],119:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _image = require('../image');

var _image2 = _interopRequireDefault(_image);

var _kindNames = require('../kindNames');

var KindNames = _interopRequireWildcard(_kindNames);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class ROI {

    constructor(map, id) {
        this.map = map;
        this.id = id;
        this.minX = Number.POSITIVE_INFINITY;
        this.maxX = Number.NEGATIVE_INFINITY;
        this.minY = Number.POSITIVE_INFINITY;
        this.maxY = Number.NEGATIVE_INFINITY;
        this.meanX = 0;
        this.meanY = 0;
        this.surface = 0;
        this.computed = {};
    }

    getMask() {
        var _ref = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

        var _ref$fill = _ref.fill;
        var fill = _ref$fill === undefined ? false : _ref$fill;
        var _ref$scale = _ref.scale;
        var scale = _ref$scale === undefined ? 1 : _ref$scale;

        var mask = void 0;
        if (fill) {
            mask = this.filledMask;
        } else {
            mask = this.mask;
        }

        if (scale < 1) {
            mask = mask.resizeBinary(scale);
        }

        return mask;
    }

    get width() {
        return this.maxX - this.minX + 1;
    }

    get height() {
        return this.maxY - this.minY + 1;
    }

    get surround() {
        if (this.computed.surround) return this.computed.surround;
        return this.computed.surround = getSurroundingIDs(this);
    }

    get internalMapIDs() {
        if (this.computed.internalMapIDs) return this.computed.internalMapIDs;
        return this.computed.internalMapIDs = getInternalMapIDs(this);
    }

    get external() {
        // points of the Roi that touch the rectangular shape
        if (this.computed.external) return this.computed.external;
        return this.computed.external = getExternal(this);
    }

    get contour() {
        if (this.computed.contourMask) return this.computed.contourMask;
        return this.computed.contour = getContour(this);
    }

    get border() {
        if (this.computed.border) return this.computed.border;
        return this.computed.border = getBorder(this);
    }

    get mask() {
        if (this.computed.mask) return this.computed.mask;

        var img = new _image2.default(this.width, this.height, {
            kind: KindNames.BINARY,
            position: [this.minX, this.minY],
            parent: this.map.parent
        });

        for (var x = 0; x < this.width; x++) {
            for (var y = 0; y < this.height; y++) {
                if (this.map.pixels[x + this.minX + (y + this.minY) * this.map.width] === this.id) {
                    img.setBitXY(x, y);
                }
            }
        }
        return this.computed.mask = img;
    }

    get filledMask() {
        if (this.computed.filledMask) return this.computed.filledMask;

        var img = new _image2.default(this.width, this.height, {
            kind: KindNames.BINARY,
            position: [this.minX, this.minY],
            parent: this.map.parent
        });

        for (var x = 0; x < this.width; x++) {
            for (var y = 0; y < this.height; y++) {
                var target = x + this.minX + (y + this.minY) * this.map.width;
                if (this.internalMapIDs.indexOf(this.map.pixels[target]) >= 0) {
                    img.setBitXY(x, y);
                } // by default a pixel is to 0 so no problems, it will be transparent
            }
        }

        return this.computed.filledMask = img;
    }
}

exports.default = ROI; /* it should really be an array to solve complex cases related to border effect
                        Like the image
                        0000
                        1111
                        0000
                        1111
                       
                        The first row of 1 will be surrouned by 2 differents zones
                       
                        Or even worse
                        010
                        111
                        010
                        The cross will be surrouned by 4 differents zones
                       
                        However in most of the cases it will be an array of one element
                        */

function getSurroundingIDs(roi) {
    var surrounding = new Array(1);

    var ptr = 0;
    var roiMap = roi.map;
    var pixels = roiMap.pixels;
    // we check the first line and the last line
    var fromX = Math.max(roi.minX, 1);
    var toX = Math.min(roi.width, roiMap.width - 2);

    // not optimized  if height=1 !
    for (var y of [0, roi.height - 1]) {
        for (var x = 0; x < roi.width; x++) {
            var target = (y + roi.minY) * roiMap.width + x + roi.minX;
            if (x - roi.minX > 0 && pixels[target] === roi.id && pixels[target - 1] !== roi.id) {
                var value = pixels[target - 1];
                if (surrounding.indexOf(value) === -1) {
                    surrounding[ptr++] = value;
                }
            }
            if (roiMap.width - x - roi.minX > 1 && pixels[target] === roi.id && pixels[target + 1] !== roi.id) {
                var _value = pixels[target + 1];
                if (surrounding.indexOf(_value) === -1) {
                    surrounding[ptr++] = _value;
                }
            }
        }
    }

    // we check the first column and the last column
    var fromY = Math.max(roi.minY, 1);
    var toY = Math.min(roi.height, roiMap.height - 2);
    // not optimized  if width=1 !
    for (var _x2 of [0, roi.width - 1]) {
        for (var _y = 0; _y < roi.height; _y++) {
            var _target = (_y + roi.minY) * roiMap.width + _x2 + roi.minX;
            if (_y - roi.minY > 0 && pixels[_target] === roi.id && pixels[_target - roiMap.width] !== roi.id) {
                var _value2 = pixels[_target - roiMap.width];
                if (surrounding.indexOf(_value2) === -1) {
                    surrounding[ptr++] = _value2;
                }
            }
            if (roiMap.height - _y - roi.minY > 1 && pixels[_target] === roi.id && pixels[_target + roiMap.width] !== roi.id) {
                var _value3 = pixels[_target + roiMap.width];
                if (surrounding.indexOf(_value3) === -1) {
                    surrounding[ptr++] = _value3;
                }
            }
        }
    }
    if (surrounding[0] === undefined) return [0];
    return surrounding; // the selection takes the whole rectangle
}

/*
 We get the number of pixels of the Roi that touch the rectangle
 This is useful for the calculation of the border
 because we will ignore those special pixels of the rectangle
 border that don't have neighbourgs all around them.
 */

function getExternal(roi) {
    var total = 0;
    var roiMap = roi.map;
    var pixels = roiMap.pixels;

    var topBottom = [0];
    if (roi.height > 1) topBottom[1] = roi.height - 1;
    for (var y of topBottom) {
        for (var x = 1; x < roi.width - 1; x++) {
            var target = (y + roi.minY) * roiMap.width + x + roi.minX;
            if (pixels[target] === roi.id) {
                total++;
            }
        }
    }

    var leftRight = [0];
    if (roi.width > 1) leftRight[1] = roi.width - 1;
    for (var _x3 of leftRight) {
        for (var _y2 = 0; _y2 < roi.height; _y2++) {
            var _target2 = (_y2 + roi.minY) * roiMap.width + _x3 + roi.minX;
            if (pixels[_target2] === roi.id) {
                total++;
            }
        }
    }
    return total;
}

/*
 We will calculate the number of pixels that are involved in border
 Border are all the pixels that touch another "zone". It could be external
 or internal
 All the pixels that touch the box are part of the border and
 are calculated in the getBoxPixels procedure
 */
function getBorder(roi) {
    var total = 0;
    var roiMap = roi.map;
    var pixels = roiMap.pixels;

    for (var x = 1; x < roi.width - 1; x++) {
        for (var y = 1; y < roi.height - 1; y++) {
            var target = (y + roi.minY) * roiMap.width + x + roi.minX;
            if (pixels[target] === roi.id) {
                // if a pixel around is not roi.id it is a border
                if (pixels[target - 1] !== roi.id || pixels[target + 1] !== roi.id || pixels[target - roiMap.width] !== roi.id || pixels[target + roiMap.width] !== roi.id) {
                    total++;
                }
            }
        }
    }
    return total + roi.external;
}

/*
 We will calculate the number of pixels that are in the external border
 Contour are all the pixels that touch an external "zone".
 All the pixels that touch the box are part of the border and
 are calculated in the getBoxPixels procedure
 */
function getContour(roi) {
    var total = 0;
    var roiMap = roi.map;
    var pixels = roiMap.pixels;

    for (var x = 1; x < roi.width - 1; x++) {
        for (var y = 1; y < roi.height - 1; y++) {
            var target = (y + roi.minY) * roiMap.width + x + roi.minX;
            if (pixels[target] === roi.id) {
                // if a pixel around is not roi.id it is a border
                if (roi.surround.indexOf(pixels[target - 1]) !== -1 || roi.surround.indexOf(pixels[target + 1]) !== -1 || roi.surround.indexOf(pixels[target - roiMap.width]) !== -1 || roi.surround.indexOf(pixels[target + roiMap.width]) !== -1) {
                    total++;
                }
            }
        }
    }
    return total + roi.external;
}

/*
We will calculate all the ids of the map that are "internal"
This will allow to extract the 'plain' image
 */
function getInternalMapIDs(roi) {
    var internal = [roi.id];
    var roiMap = roi.map;
    var pixels = roiMap.pixels;

    if (roi.height > 2) {
        for (var x = 0; x < roi.width; x++) {
            var target = roi.minY * roiMap.width + x + roi.minX;
            if (internal.indexOf(pixels[target]) >= 0) {
                var id = pixels[target + roiMap.width];
                if (internal.indexOf(id) === -1 && roi.surround.indexOf(id) === -1) {
                    internal.push(id);
                }
            }
        }
    }

    var array = new Array(4);
    for (var _x4 = 1; _x4 < roi.width - 1; _x4++) {
        for (var y = 1; y < roi.height - 1; y++) {
            var _target3 = (y + roi.minY) * roiMap.width + _x4 + roi.minX;
            if (internal.indexOf(pixels[_target3]) >= 0) {
                // we check if one of the neighbour is not yet in

                array[0] = pixels[_target3 - 1];
                array[1] = pixels[_target3 + 1];
                array[2] = pixels[_target3 - roiMap.width];
                array[3] = pixels[_target3 + roiMap.width];

                for (var i = 0; i < 4; i++) {
                    var _id = array[i];
                    if (internal.indexOf(_id) === -1 && roi.surround.indexOf(_id) === -1) {
                        internal.push(_id);
                    }
                }
            }
        }
    }

    return internal;
}

},{"../image":103,"../kindNames":105}],120:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = colorDepth;

var _image = require('../image');

var _image2 = _interopRequireDefault(_image);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function colorDepth() {
    var newColorDepth = arguments.length <= 0 || arguments[0] === undefined ? 8 : arguments[0];


    this.checkProcessable('colorDepth', {
        bitDepth: [8, 16]
    });

    if (!~[8, 16].indexOf(newColorDepth)) throw Error('You need to specify the new colorDepth as 8 or 16');

    if (this.bitDepth === newColorDepth) return this.clone();

    var newImage = _image2.default.createFrom(this, { bitDepth: newColorDepth });

    if (newColorDepth === 8) {
        for (var i = 0; i < this.data.length; i++) {
            newImage.data[i] = this.data[i] >> 8;
        }
    } else {
        for (var _i = 0; _i < this.data.length; _i++) {
            newImage.data[_i] = this.data[_i] << 8 | this.data[_i];
        }
    }

    return newImage;
}

},{"../image":103}],121:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = crop;

var _image = require('../image');

var _image2 = _interopRequireDefault(_image);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function crop() {
    var _ref = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

    var _ref$x = _ref.x;
    var x = _ref$x === undefined ? 0 : _ref$x;
    var _ref$y = _ref.y;
    var y = _ref$y === undefined ? 0 : _ref$y;
    var _ref$width = _ref.width;
    var width = _ref$width === undefined ? this.width - x : _ref$width;
    var _ref$height = _ref.height;
    var height = _ref$height === undefined ? this.height - y : _ref$height;


    if (x > this.width - 1 || y > this.height - 1) throw new RangeError(`crop: origin (x:${ x }, y:${ y }) out of range (${ this.width - 1 }; ${ this.height - 1 })`);
    if (width <= 0 || height <= 0) throw new RangeError(`crop: width and height (width:${ width }; height:${ height }) must be positive numbers`);
    if (x < 0 || y < 0) throw new RangeError(`crop: x and y (x:${ x }, y:${ y }) must be positive numbers`);
    if (width > this.width - x || height > this.height - y) throw new RangeError(`crop: (x: ${ x }, y:${ y }, width:${ width }, height:${ height }) size is out of range`);

    var newImage = _image2.default.createFrom(this, { width: width, height: height });

    var xWidth = width * this.channels;
    var y1 = y + height;

    var ptr = 0; // pointer for new array

    var jLeft = x * this.channels;

    for (var i = y; i < y1; i++) {
        var j = i * this.width * this.channels + jLeft;
        var jL = j + xWidth;
        for (; j < jL; j++) {
            newImage.data[ptr++] = this.data[j];
        }
    }

    return newImage;
}

},{"../image":103}],122:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = average;
function average(newImage) {
    var ptr = 0;
    for (var i = 0; i < this.data.length; i += this.channels) {
        newImage.data[ptr++] = (this.data[i] + this.data[i + 1] + this.data[i + 2]) / 3;
        if (this.alpha) {
            newImage.data[ptr++] = this.data[i + 3];
        }
    }
}

},{}],123:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = grey;

var _image = require('../../image');

var _image2 = _interopRequireDefault(_image);

var _model = require('../../model/model');

var _luma = require('./luma709');

var _luma2 = _interopRequireDefault(_luma);

var _luma3 = require('./luma601');

var _luma4 = _interopRequireDefault(_luma3);

var _minmax = require('./minmax');

var _minmax2 = _interopRequireDefault(_minmax);

var _maximum = require('./maximum');

var _maximum2 = _interopRequireDefault(_maximum);

var _average = require('./average');

var _average2 = _interopRequireDefault(_average);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function grey() {
    var _ref = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

    var _ref$algorithm = _ref.algorithm;
    var algorithm = _ref$algorithm === undefined ? 'luma709' : _ref$algorithm;


    if (this.components === 1) {
        return this.clone();
    }

    this.checkProcessable('grey', { colorModel: _model.RGB });

    var newImage = _image2.default.createFrom(this, {
        components: 1,
        colorModel: null
    });

    switch (algorithm.toLowerCase()) {
        case 'luma709':
            // sRGB
            _luma2.default.call(this, newImage);
            break;
        case 'luma601':
            // NTSC
            _luma4.default.call(this, newImage);
            break;
        case 'minmax':
            // used in HSL color model
            _minmax2.default.call(this, newImage);
            break;
        case 'maximum':
            _maximum2.default.call(this, newImage);
            break;
        case 'average':
            // used in HSI color model
            _average2.default.call(this, newImage);
            break;
        default:
            throw new Error('Unsupported grey algorithm: ' + algorithm);
    }

    return newImage;
}

},{"../../image":103,"../../model/model":108,"./average":122,"./luma601":124,"./luma709":125,"./maximum":126,"./minmax":127}],124:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = luma601;
function luma601(newImage) {
    var ptr = 0;
    for (var i = 0; i < this.data.length; i += this.channels) {
        newImage.data[ptr++] = this.data[i] * 0.299 + this.data[i + 1] * 0.587 + this.data[i + 2] * 0.114;
        if (this.alpha) {
            newImage.data[ptr++] = this.data[i + 3];
        }
    }
}

},{}],125:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = luma709;
function luma709(newImage) {
    var ptr = 0;
    for (var i = 0; i < this.data.length; i += this.channels) {
        newImage.data[ptr++] = this.data[i] * 0.2126 + this.data[i + 1] * 0.7152 + this.data[i + 2] * 0.0722;
        if (this.alpha) {
            newImage.data[ptr++] = this.data[i + 3];
        }
    }
}

},{}],126:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = maximum;
function maximum(newImage) {
    var ptr = 0;
    for (var i = 0; i < this.data.length; i += this.channels) {
        newImage.data[ptr++] = Math.max(this.data[i], this.data[i + 1], this.data[i + 2]);
        if (this.alpha) {
            newImage.data[ptr++] = this.data[i + 3];
        }
    }
}

},{}],127:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = minmax;
function minmax(newImage) {
    var ptr = 0;
    for (var i = 0; i < this.data.length; i += this.channels) {
        newImage.data[ptr++] = (Math.max(this.data[i], this.data[i + 1], this.data[i + 2]) + Math.min(this.data[i], this.data[i + 1], this.data[i + 2])) / 2;
        if (this.alpha) {
            newImage.data[ptr++] = this.data[i + 3];
        }
    }
}

},{}],128:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = hsv;

var _model = require('../model/model');

var _image = require('../image');

var _image2 = _interopRequireDefault(_image);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// http://www.easyrgb.com/index.php?X=MATH&H=18#text18
// check rgbToHsl : https://bgrins.github.io/TinyColor/docs/tinycolor.html

function hsv() {
    this.checkProcessable('hsv', {
        bitDepth: [8, 16],
        alpha: [0, 1],
        colorModel: [_model.RGB]
    });

    var newImage = _image2.default.createFrom(this, {
        colorModel: _model.HSL
    });

    var threshold = Math.floor(this.maxValue / 2);
    var ptr = 0;
    var data = this.data;
    for (var i = 0; i < data.length; i += this.channels) {
        var red = data[i];
        var green = data[i + 1];
        var blue = data[i + 2];

        var max = Math.max(red, green, blue);
        var min = Math.min(red, green, blue);
        var hue = 0;
        var saturation = 0;
        var luminance = (max + min) / 2;
        if (max !== min) {
            var delta = max - min;
            saturation = luminance > threshold ? delta / (2 - max - min) : delta / (max + min);
            switch (max) {
                case red:
                    hue = (green - blue) / delta + (green < blue ? 6 : 0);
                    break;
                case green:
                    hue = (blue - red) / delta + 2;
                    break;
                case blue:
                    hue = (red - green) / delta + 4;
                    break;
            }
            hue /= 6;
        }

        newImage.data[ptr++] = hue * this.maxValue;
        newImage.data[ptr++] = saturation * this.maxValue;
        newImage.data[ptr++] = luminance;
        if (this.alpha) {
            newImage.data[ptr++] = data[i + 3];
        }
    }

    return newImage;
}

},{"../image":103,"../model/model":108}],129:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = hsv;

var _model = require('../model/model');

var _image = require('../image');

var _image2 = _interopRequireDefault(_image);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// based on https://bgrins.github.io/TinyColor/docs/tinycolor.html

function hsv() {
    this.checkProcessable('hsv', {
        bitDepth: [8, 16],
        alpha: [0, 1],
        colorModel: [_model.RGB]
    });

    var newImage = _image2.default.createFrom(this, {
        colorModel: _model.HSV
    });

    var ptr = 0;
    var data = this.data;
    for (var i = 0; i < data.length; i += this.channels) {
        var red = data[i];
        var green = data[i + 1];
        var blue = data[i + 2];

        var min = Math.min(red, green, blue);
        var max = Math.max(red, green, blue);
        var delta = max - min;
        var hue = 0;
        var saturation = max === 0 ? 0 : delta / max;
        var value = max;

        if (max !== min) {
            switch (max) {
                case red:
                    hue = (green - blue) / delta + (green < blue ? 6 : 0);
                    break;
                case green:
                    hue = (blue - red) / delta + 2;
                    break;
                case blue:
                    hue = (red - green) / delta + 4;
                    break;
            }
            hue /= 6;
        }

        newImage.data[ptr++] = hue * this.maxValue;
        newImage.data[ptr++] = saturation * this.maxValue;
        newImage.data[ptr++] = value;
        if (this.alpha) {
            newImage.data[ptr++] = data[i + 3];
        }
    }

    return newImage;
}

},{"../image":103,"../model/model":108}],130:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = huang;
/***
 *
 * see http://rsb.info.nih.gov/ij/developer/source/ij/process/AutoThresholder.java.html.
 * Huang: Implements Huang's fuzzy thresholding method: Huang, L-K & Wang, M-J J (1995),
 * "Image thresholding by minimizing the measure of fuzziness", Pattern Recognition 28(1): 41-51
 *
 */

function huang(histogram) {
    /* Determine the first non-zero bin */
    var first_bin = 0;
    for (var ih = 0; ih < histogram.length; ih++) {
        if (histogram[ih] !== 0) {
            first_bin = ih;
            break;
        }
    }

    /* Determine the last non-zero bin */
    var last_bin = histogram.length - 1;
    for (var _ih = histogram.length - 1; _ih >= first_bin; _ih--) {
        if (histogram[_ih] !== 0) {
            last_bin = _ih;
            break;
        }
    }

    var term = 1.0 / (last_bin - first_bin);
    var mu_0 = new Array(histogram.length);
    var sum_pix = 0;
    var num_pix = 0;
    for (var _ih2 = first_bin; _ih2 < histogram.length; _ih2++) {
        sum_pix += _ih2 * histogram[_ih2];
        num_pix += histogram[_ih2];
        mu_0[_ih2] = sum_pix / num_pix;
    }

    var mu_1 = new Array(histogram.length);
    sum_pix = num_pix = 0;
    for (var _ih3 = last_bin; _ih3 > 0; _ih3--) {
        sum_pix += _ih3 * histogram[_ih3];
        num_pix += histogram[_ih3];
        mu_1[_ih3 - 1] = sum_pix / num_pix;
    }

    /* Determine the threshold that minimizes the fuzzy entropy*/
    var threshold = -1;
    var min_ent = Number.MAX_VALUE;
    for (var it = 0; it < histogram.length; it++) {
        var ent = 0;
        var mu_x = void 0;
        for (var _ih4 = 0; _ih4 <= it; _ih4++) {
            /* Equation (4) in Ref. 1 */
            mu_x = 1 / (1 + term * Math.abs(_ih4 - mu_0[it]));
            if (!(mu_x < 1e-06 || mu_x > 0.999999)) {
                /* Equation (6) & (8) in Ref. 1 */
                ent += histogram[_ih4] * (-mu_x * Math.log(mu_x) - (1 - mu_x) * Math.log(1 - mu_x));
            }
        }

        for (var _ih5 = it + 1; _ih5 < histogram.length; _ih5++) {
            /* Equation (4) in Ref. 1 */
            mu_x = 1 / (1 + term * Math.abs(_ih5 - mu_1[it]));
            if (!(mu_x < 1e-06 || mu_x > 0.999999)) {
                /* Equation (6) & (8) in Ref. 1 */
                ent += histogram[_ih5] * (-mu_x * Math.log(mu_x) - (1 - mu_x) * Math.log(1 - mu_x));
            }
        }

        if (ent < min_ent) {
            min_ent = ent;
            threshold = it;
        }
    }
    return threshold;
}

},{}],131:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = intermodes;
/***
 *
 * see https://github.com/fiji/Auto_Threshold/blob/master/src/main/java/fiji/threshold/Auto_Threshold.java
 * Intermodes: This assumes a bimodal histogram. Implements the thresholding Prewitt, JMS & Mendelsohn, ML (1966),
 * "The analysis of cell images", Annals of the NewYork Academy of Sciences 128: 1035-1053
 *
 */

function intermodes(histogram) {
    var iHisto = histogram.slice();
    var iter = 0;
    while (!bimodalTest(iHisto)) {
        //smooth with a 3 point running mean filter
        var previous = 0,
            current = 0,
            next = iHisto[0];
        for (var i = 0; i < histogram.length - 1; i++) {
            previous = current;
            current = next;
            next = iHisto[i + 1];
            iHisto[i] = (previous + current + next) / 3;
        }
        iHisto[histogram.length - 1] = (current + next) / 3;
        iter++;
        if (iter > 10000) {
            throw new Error('Intermodes Threshold not found after 10000 iterations');
        }
    }

    // The threshold is the mean between the two peaks.
    var tt = 0;
    for (var _i = 1; _i < histogram.length - 1; _i++) {
        if (iHisto[_i - 1] < iHisto[_i] && iHisto[_i + 1] < iHisto[_i]) {
            tt += _i;
        }
    }
    return Math.floor(tt / 2.0);
}

function bimodalTest(iHisto) {
    var b = false;
    var modes = 0;

    for (var k = 1; k < iHisto.length - 1; k++) {
        if (iHisto[k - 1] < iHisto[k] && iHisto[k + 1] < iHisto[k]) {
            modes++;
            if (modes > 2) {
                return false;
            }
        }
    }
    if (modes === 2) {
        b = true;
    }
    return b;
}

},{}],132:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = isodata;
/**
 * see https://github.com/fiji/Auto_Threshold/blob/master/src/main/java/fiji/threshold/Auto_Threshold.java
 * Isodata: Ridler, TW & Calvard, S (1978), "Picture thresholding using an iterative selection method"
 * IEEE Transactions on Systems, Man and Cybernetics 8: 630-632.
 *
 */
function isodata(histogram) {

    var l = void 0; //the average grey value of pixels with intensities < g
    var toth = void 0; //the the average grey value of pixels with intensities > g
    var totl = void 0; //the total the average grey value of pixels with intensities < g
    var h = void 0; //the average grey value of pixels with intensities > g
    var g = 0; //threshold value

    for (var i = 1; i < histogram.length; i++) {
        if (histogram[i] > 0) {
            g = i + 1;
            break;
        }
    }

    while (true) {
        l = 0;
        totl = 0;
        for (var _i = 0; _i < g; _i++) {
            totl = totl + histogram[_i];
            l = l + histogram[_i] * _i;
        }
        h = 0;
        toth = 0;
        for (var _i2 = g + 1; _i2 < histogram.length; _i2++) {
            toth += histogram[_i2];
            h += histogram[_i2] * _i2;
        }
        if (totl > 0 && toth > 0) {
            l /= totl;
            h /= toth;
            if (g === Math.round((l + h) / 2.0)) break;
        }
        g++;
        if (g > histogram.length - 2) {
            throw new Error('Threshold not found');
        }
    }
    return g;
}

},{}],133:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = li;
/*
 * see http://rsb.info.nih.gov/ij/developer/source/ij/process/AutoThresholder.java.html
 * The method is present in: Implements Li's Minimum Cross Entropy thresholding method
 * This implementation is based on the iterative version (Ref. 2nd reference below) of the algorithm.
 *  1) Li, CH & Lee, CK (1993), "Minimum Cross 	Entropy Thresholding", Pattern Recognition 26(4): 61 625
 *  2) Li, CH & Tam, PKS (1998), "An Iterative 	Algorithm for Minimum Cross Entropy Thresholding",
 *     Pattern 	Recognition Letters 18(8): 771-776
 *  3) Sezgin, M & Sankur, B (2004), "Survey 	over Image Thresholding Techniques and Quantitative Performance
 *     Evaluation",Journal of Electronic Imaging 13(1): 146-165
 * @param histogram - the histogram of the image
 *        total - the number of pixels in the image
 * @returns {number} - the threshold
 */

function li(histogram, total) {

    var threshold = void 0;
    var sum_back = void 0; /* sum of the background pixels at a given threshold */
    var sum_obj = void 0; /* sum of the object pixels at a given threshold */
    var num_back = void 0; /* number of background pixels at a given threshold */
    var num_obj = void 0; /* number of object pixels at a given threshold */
    var old_thresh = void 0;
    var new_thresh = void 0;
    var mean_back = void 0; /* mean of the background pixels at a given threshold */
    var mean_obj = void 0; /* mean of the object pixels at a given threshold */
    var mean = void 0; /* mean gray-level in the image */
    var tolerance = void 0; /* threshold tolerance */
    var temp = void 0;
    tolerance = 0.5;

    /* Calculate the mean gray-level */
    mean = 0.0;
    for (var ih = 0; ih < histogram.length; ih++) {
        mean += ih * histogram[ih];
    }

    mean /= total;
    /* Initial estimate */
    new_thresh = mean;

    do {
        old_thresh = new_thresh;
        threshold = old_thresh + 0.5 | 0; /* range */

        /* Calculate the means of background and object pixels */
        /* Background */
        sum_back = 0;
        num_back = 0;

        for (var _ih = 0; _ih <= threshold; _ih++) {
            sum_back += _ih * histogram[_ih];
            num_back += histogram[_ih];
        }
        mean_back = num_back === 0 ? 0.0 : sum_back / num_back;

        /* Object */
        sum_obj = 0;
        num_obj = 0;
        for (var _ih2 = threshold + 1; _ih2 < histogram.length; _ih2++) {
            sum_obj += _ih2 * histogram[_ih2];
            num_obj += histogram[_ih2];
        }
        mean_obj = num_obj === 0 ? 0.0 : sum_obj / num_obj;
        temp = (mean_back - mean_obj) / (Math.log(mean_back) - Math.log(mean_obj));

        if (temp < -Number.EPSILON) {
            new_thresh = temp - 0.5 | 0;
        } else {
            new_thresh = temp + 0.5 | 0;
        }
        /*  Stop the iterations when the difference between the
         new and old threshold values is less than the tolerance */
    } while (Math.abs(new_thresh - old_thresh) > tolerance);

    return threshold;
}

},{}],134:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = mask;

var _image = require('../../image');

var _image2 = _interopRequireDefault(_image);

var _huang = require('./huang');

var _huang2 = _interopRequireDefault(_huang);

var _intermodes = require('./intermodes');

var _intermodes2 = _interopRequireDefault(_intermodes);

var _isodata = require('./isodata');

var _isodata2 = _interopRequireDefault(_isodata);

var _li = require('./li');

var _li2 = _interopRequireDefault(_li);

var _maxEntropy = require('./maxEntropy');

var _maxEntropy2 = _interopRequireDefault(_maxEntropy);

var _mean = require('./mean');

var _mean2 = _interopRequireDefault(_mean);

var _minError = require('./minError');

var _minError2 = _interopRequireDefault(_minError);

var _minimum = require('./minimum');

var _minimum2 = _interopRequireDefault(_minimum);

var _moments = require('./moments');

var _moments2 = _interopRequireDefault(_moments);

var _otsu = require('./otsu');

var _otsu2 = _interopRequireDefault(_otsu);

var _percentile = require('./percentile');

var _percentile2 = _interopRequireDefault(_percentile);

var _renyiEntropy = require('./renyiEntropy.js');

var _renyiEntropy2 = _interopRequireDefault(_renyiEntropy);

var _shanbhag = require('./shanbhag');

var _shanbhag2 = _interopRequireDefault(_shanbhag);

var _triangle = require('./triangle');

var _triangle2 = _interopRequireDefault(_triangle);

var _yen = require('./yen');

var _yen2 = _interopRequireDefault(_yen);

var _converter = require('../../../util/converter');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*
 Creation of binary mask is based on the determination of a threshold
 You may either choose among the provided algorithm or just specify a threshold value
 */

function mask() {
    var _ref = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

    var _ref$algorithm = _ref.algorithm;
    var algorithm = _ref$algorithm === undefined ? 'threshold' : _ref$algorithm;
    var _ref$threshold = _ref.threshold;
    var threshold = _ref$threshold === undefined ? 0.5 : _ref$threshold;
    var _ref$useAlpha = _ref.useAlpha;
    var useAlpha = _ref$useAlpha === undefined ? true : _ref$useAlpha;
    var _ref$invert = _ref.invert;
    var invert = _ref$invert === undefined ? false : _ref$invert;


    this.checkProcessable('mask', {
        components: 1,
        bitDepth: [8, 16]
    });

    var histogram = this.getHistogram();
    switch (algorithm.toLowerCase()) {
        case 'threshold':
            threshold = (0, _converter.getThreshold)(threshold, this.maxValue);
            break;
        case 'huang':
            threshold = (0, _huang2.default)(histogram);
            break;
        case 'intermodes':
            threshold = (0, _intermodes2.default)(histogram);
            break;
        case 'isodata':
            threshold = (0, _isodata2.default)(histogram);
            break;
        case 'li':
            threshold = (0, _li2.default)(histogram, this.size);
            break;
        case 'maxentropy':
            threshold = (0, _maxEntropy2.default)(histogram, this.size);
            break;
        case 'mean':
            threshold = (0, _mean2.default)(histogram, this.size);
            break;
        case 'minerror':
            threshold = (0, _minError2.default)(histogram, this.size);
            break;
        case 'minimum':
            threshold = (0, _minimum2.default)(histogram);
            break;
        case 'moments':
            threshold = (0, _moments2.default)(histogram, this.size);
            break;
        case 'otsu':
            threshold = (0, _otsu2.default)(histogram, this.size);
            break;
        case 'percentile':
            threshold = (0, _percentile2.default)(histogram);
            break;
        case 'renyientropy':
            threshold = (0, _renyiEntropy2.default)(histogram, this.size);
            break;
        case 'shanbhag':
            threshold = (0, _shanbhag2.default)(histogram, this.size);
            break;
        case 'triangle':
            threshold = (0, _triangle2.default)(histogram);
            break;
        case 'yen':
            threshold = (0, _yen2.default)(histogram, this.size);
            break;
        default:
            throw new Error('mask transform unknown algorithm: ' + algorithm);
    }

    var newImage = new _image2.default(this.width, this.height, {
        kind: 'BINARY',
        parent: this
    });

    var ptr = 0;
    if (this.alpha && useAlpha) {
        for (var i = 0; i < this.data.length; i += this.channels) {
            var value = this.data[i] + (this.maxValue - this.data[i]) * (this.maxValue - this.data[i + 1]) / this.maxValue;
            if (invert && value <= threshold || !invert && value >= threshold) {
                newImage.setBit(ptr);
            }
            ptr++;
        }
    } else {
        for (var _i = 0; _i < this.data.length; _i += this.channels) {
            if (invert && this.data[_i] <= threshold || !invert && this.data[_i] >= threshold) {
                newImage.setBit(ptr);
            }
            ptr++;
        }
    }
    return newImage;
}

},{"../../../util/converter":172,"../../image":103,"./huang":130,"./intermodes":131,"./isodata":132,"./li":133,"./maxEntropy":135,"./mean":136,"./minError":137,"./minimum":138,"./moments":139,"./otsu":140,"./percentile":141,"./renyiEntropy.js":142,"./shanbhag":143,"./triangle":144,"./yen":145}],135:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = maxEntropy;
/*
 * see http://rsb.info.nih.gov/ij/developer/source/ij/process/AutoThresholder.java.html
 * The method is present in: Implements Kapur-Sahoo-Wong (Maximum Entropy) thresholding method:
 * Kapur, JN; Sahoo, PK & Wong, ACK (1985), "A New Method for Gray-Level Picture Thresholding Using the Entropy of the Histogram",
 * Graphical Models and Image Processing 29(3): 273-285
 * @param histogram - the histogram of the image
 *        total - the number of pixels in the image
 * @returns {number} - the threshold
 */

function maxEntropy(histogram, total) {
    var norm_histo = new Array(histogram.length); // normalized histogram
    for (var ih = 0; ih < histogram.length; ih++) {
        norm_histo[ih] = histogram[ih] / total;
    }var P1 = new Array(histogram.length); // cumulative normalized histogram
    var P2 = new Array(histogram.length);
    P1[0] = norm_histo[0];
    P2[0] = 1.0 - P1[0];

    for (var _ih = 1; _ih < histogram.length; _ih++) {
        P1[_ih] = P1[_ih - 1] + norm_histo[_ih];
        P2[_ih] = 1.0 - P1[_ih];
    }

    /* Determine the first non-zero bin */
    var first_bin = 0;
    for (var _ih2 = 0; _ih2 < histogram.length; _ih2++) {
        if (Math.abs(P1[_ih2]) >= Number.EPSILON) {
            first_bin = _ih2;
            break;
        }
    }

    /* Determine the last non-zero bin */
    var last_bin = histogram.length - 1;
    for (var _ih3 = histogram.length - 1; _ih3 >= first_bin; _ih3--) {
        if (Math.abs(P2[_ih3]) >= Number.EPSILON) {
            last_bin = _ih3;
            break;
        }
    }

    // Calculate the total entropy each gray-level
    // and find the threshold that maximizes it
    var threshold = -1;
    var tot_ent = void 0; // total entropy
    var max_ent = Number.MIN_VALUE; // max entropy
    var ent_back = void 0; // entropy of the background pixels at a given threshold
    var ent_obj = void 0; // entropy of the object pixels at a given threshold

    for (var it = first_bin; it <= last_bin; it++) {
        /* Entropy of the background pixels */
        ent_back = 0.0;
        for (var _ih4 = 0; _ih4 <= it; _ih4++) {
            if (histogram[_ih4] !== 0) {
                ent_back -= norm_histo[_ih4] / P1[it] * Math.log(norm_histo[_ih4] / P1[it]);
            }
        }

        /* Entropy of the object pixels */
        ent_obj = 0.0;
        for (var _ih5 = it + 1; _ih5 < histogram.length; _ih5++) {
            if (histogram[_ih5] !== 0) {
                ent_obj -= norm_histo[_ih5] / P2[it] * Math.log(norm_histo[_ih5] / P2[it]);
            }
        }

        /* Total entropy */
        tot_ent = ent_back + ent_obj;

        if (max_ent < tot_ent) {
            max_ent = tot_ent;
            threshold = it;
        }
    }
    return threshold;
}

},{}],136:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = mean;
/*
 * The method is present in: Uses the 	mean of grey levels as the threshold. It is described in:
 * Glasbey, CA (1993), "An analysis of histogram-based thresholding names",
 * CVGIP: Graphical Models and Image Processing 55: 532-537
 * @param histogram - the histogram of the image
 *        total - the number of pixels in the image
 * @returns {number} - the threshold
 */

function mean(histogram, total) {
    var sum = 0;
    for (var i = 0; i < histogram.length; i++) {
        sum += i * histogram[i];
    }
    return Math.floor(sum / total);
}

},{}],137:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = minError;
/*
 * see http://rsb.info.nih.gov/ij/developer/source/ij/process/AutoThresholder.java.html
 * The method is present in: An 	iterative implementation of Kittler and Illingworth's Minimum Error
 * thresholding:Kittler, J & Illingworth, J (1986), "Minimum error thresholding", Pattern Recognition 19: 41-47
 * @param histogram - the histogram of the image
 *        total - the number of pixels in the image
 * @returns {number} - the threshold
 */

function minError(histogram, total) {

    var threshold = void 0;
    var Tprev = -2;
    var mu = void 0,
        nu = void 0,
        p = void 0,
        q = void 0,
        sigma2 = void 0,
        tau2 = void 0,
        w0 = void 0,
        w1 = void 0,
        w2 = void 0,
        sqterm = void 0,
        temp = void 0;

    /* Calculate the mean gray-level */
    var mean = 0.0;
    for (var ih = 0; ih < histogram.length; ih++) {
        mean += ih * histogram[ih];
    }

    mean /= total;

    threshold = mean;

    while (threshold !== Tprev) {
        //Calculate some statistics.
        var sumA1 = sumA(histogram, threshold);
        var sumA2 = sumA(histogram, histogram.length - 1);
        var sumB1 = sumB(histogram, threshold);
        var sumB2 = sumB(histogram, histogram.length - 1);
        var sumC1 = sumC(histogram, threshold);
        var sumC2 = sumC(histogram, histogram.length - 1);

        mu = sumB1 / sumA1;
        nu = (sumB2 - sumB1) / (sumA2 - sumA1);
        p = sumA1 / sumA2;
        q = (sumA2 - sumA1) / sumA2;
        sigma2 = sumC1 / sumA1 - mu * mu;
        tau2 = (sumC2 - sumC1) / (sumA2 - sumA1) - nu * nu;

        //The terms of the quadratic equation to be solved.
        w0 = 1.0 / sigma2 - 1.0 / tau2;
        w1 = mu / sigma2 - nu / tau2;
        w2 = mu * mu / sigma2 - nu * nu / tau2 + Math.log10(sigma2 * (q * q) / (tau2 * (p * p)));

        //If the next threshold would be imaginary, return with the current one.
        sqterm = w1 * w1 - w0 * w2;
        if (sqterm < 0) {
            return threshold;
        }

        //The updated threshold is the integer part of the solution of the quadratic equation.
        Tprev = threshold;
        temp = (w1 + Math.sqrt(sqterm)) / w0;

        if (isNaN(temp)) {
            threshold = Tprev;
        } else {
            threshold = Math.floor(temp);
        }
    }
    return threshold;
}

//aux func

function sumA(y, j) {
    var x = 0;
    for (var i = 0; i <= j; i++) {
        x += y[i];
    }
    return x;
}

function sumB(y, j) {
    var x = 0;
    for (var i = 0; i <= j; i++) {
        x += i * y[i];
    }
    return x;
}

function sumC(y, j) {
    var x = 0;
    for (var i = 0; i <= j; i++) {
        x += i * i * y[i];
    }
    return x;
}

},{}],138:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = minimum;
//see https://github.com/fiji/Auto_Threshold/blob/master/src/main/java/fiji/threshold/Auto_Threshold.java
// J. M. S. Prewitt and M. L. Mendelsohn, "The analysis of cell images," in
// Annals of the New York Academy of Sciences, vol. 128, pp. 1035-1053, 1966.
// ported to ImageJ plugin by G.Landini from Antti Niemisto's Matlab code (GPL)
// Original Matlab code Copyright (C) 2004 Antti Niemisto
// See http://www.cs.tut.fi/~ant/histthresh/ for an excellent slide presentation
// and the original Matlab code
function minimum(histogram) {
    if (histogram.length < 2) {
        //validate that the histogram has at least two color values
        return 0;
    }
    var iterations = 0; //number of iterations of the smoothing process
    var threshold = -1;
    var max = -1; // maximum color value with a greater number of pixels to 0
    var histogramCopy = new Array(histogram.length); //a copy of the histogram
    for (var i = 0; i < histogram.length; i++) {
        histogramCopy[i] = histogram[i];
        if (histogram[i] > 0) {
            max = i;
        }
    }
    while (!bimodalTest(histogramCopy)) {
        histogramCopy = smoothed(histogramCopy);
        iterations++;
        if (iterations > 10000) {
            //if they occur more than 10000 iterations it returns -1
            return threshold;
        }
    }
    threshold = minimumBetweenPeeks(histogramCopy, max);
    return threshold;
}
function smoothed(histogram) {
    //Smooth with a 3 point running mean filter
    var auHistogram = new Array(histogram.length); // a copy of the histograma for the smoothing process
    for (var i = 1; i < histogram.length - 1; i++) {
        auHistogram[i] = (histogram[i - 1] + histogram[i] + histogram[i + 1]) / 3;
    }
    auHistogram[0] = (histogram[0] + histogram[1]) / 3;
    auHistogram[histogram.length - 1] = (histogram[histogram.length - 2] + histogram[histogram.length - 1]) / 3;
    return auHistogram;
}
function minimumBetweenPeeks(histogramBimodal, max) {
    var threshold = void 0;
    for (var i = 1; i < max; i++) {
        if (histogramBimodal[i - 1] > histogramBimodal[i] && histogramBimodal[i + 1] >= histogramBimodal[i]) {
            threshold = i;
            break;
        }
    }
    return threshold;
}
function bimodalTest(histogram) {
    //It is responsible for determining if a histogram is bimodal
    var len = histogram.length;
    var isBimodal = false;
    var peaks = 0;
    for (var k = 1; k < len - 1; k++) {
        if (histogram[k - 1] < histogram[k] && histogram[k + 1] < histogram[k]) {
            peaks++;
            if (peaks > 2) return false;
        }
    }
    if (peaks === 2) isBimodal = true;
    return isBimodal;
}

},{}],139:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = moments;
//see https://github.com/fiji/Auto_Threshold/blob/master/src/main/java/fiji/threshold/Auto_Threshold.java
// W. Tsai, "Moment-preserving thresholding: a new approach," Computer Vision,
// Graphics, and Image Processing, vol. 29, pp. 377-393, 1985.
// Ported to ImageJ plugin by G.Landini from the the open source project FOURIER 0.8
// by M. Emre Celebi , Department of Computer Science, Louisiana State University in Shreveport
// Shreveport, LA 71115, USA
// http://sourceforge.net/projects/fourier-ipal
// http://www.lsus.edu/faculty/~ecelebi/fourier.htm
function moments(histogram, total) {
    //moments
    var m0 = 1.0;
    var m1 = 0.0;
    var m2 = 0.0;
    var m3 = 0.0;
    var sum = 0.0;
    var p0 = void 0;
    var cd = void 0,
        c0 = void 0,
        c1 = void 0,
        z0 = void 0,
        z1 = void 0; /* auxiliary variables */
    var threshold = -1;
    var histogramLength = histogram.length;
    var normalizedHistogram = new Array(histogramLength);
    for (var i = 0; i < histogramLength; i++) {
        normalizedHistogram[i] = histogram[i] / total;
    }
    /* Calculate the first, second, and third order moments */
    for (var _i = 0; _i < histogramLength; _i++) {
        m1 += _i * normalizedHistogram[_i];
        m2 += _i * _i * normalizedHistogram[_i];
        m3 += _i * _i * _i * normalizedHistogram[_i];
    }
    /*
     First 4 moments of the gray-level image should match the first 4 moments
     of the target binary image. This leads to 4 equalities whose solutions
     are given in the Appendix of Ref. 1
     */
    cd = m0 * m2 - m1 * m1; //determinant of the matriz of hankel for moments 2x2
    c0 = (-m2 * m2 + m1 * m3) / cd;
    c1 = (m0 * -m3 + m2 * m1) / cd;
    //new two gray values where z0<z1
    z0 = 0.5 * (-c1 - Math.sqrt(c1 * c1 - 4.0 * c0));
    z1 = 0.5 * (-c1 + Math.sqrt(c1 * c1 - 4.0 * c0));
    p0 = (z1 - m1) / (z1 - z0); /* Fraction of the object pixels in the target binary image (p0z0+p1z1=m1) */
    // The threshold is the gray-level closest to the p0-tile of the normalized histogram
    for (var _i2 = 0; _i2 < histogramLength; _i2++) {
        sum += normalizedHistogram[_i2];
        if (sum > p0) {
            threshold = _i2;
            break;
        }
    }
    return threshold;
}
function partialSum(histogram, limite) {
    //a partial sum is calculated according to the value limit
    var sum = 0;
    for (var i = 0; i <= limite; i++) {
        sum += histogram[i];
    }
    return sum;
}

},{}],140:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = otsu;
/**
 * The method is present in: Otsu, N (1979), "A threshold selection method from gray-level histograms", IEEE Trans. Sys., Man., Cyber. 9: 62-66
 * The Otsu implementation is based on: https://en.wikipedia.org/wiki/Otsu's_method
 * @param histogram - the histogram of the image
 * @returns {number} - the threshold
 */

function otsu(histogram, total) {

    var sum = 0; //Total Intensities of the histogram
    var sumB = 0; //Total intensities in the 1-class histogram
    var wB = 0; //Total pixels in the 1-class histogram
    var wF = 0; //Total pixels in the 2-class histogram
    var mB = void 0; //Mean of 1-class intensities
    var mF = void 0; //Mean of 2-class intensities
    var max = 0.0; //Auxiliary variable to save temporarily the max variance
    var between = 0.0; //To save the current variance
    var threshold = 0.0;

    for (var i = 1; i < histogram.length; ++i) {
        sum += i * histogram[i];
    }

    for (var _i = 1; _i < histogram.length; ++_i) {
        wB += histogram[_i];

        if (wB === 0) continue;
        wF = total - wB;
        if (wF === 0) break;

        sumB += _i * histogram[_i];
        mB = sumB / wB;
        mF = (sum - sumB) / wF;
        between = wB * wF * (mB - mF) * (mB - mF);

        if (between >= max) {
            threshold = _i;
            max = between;
        }
    }
    return threshold;
}

},{}],141:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = percentile;
function percentile(histogram) {
    // See http://imagej.nih.gov/ij/download/tools/source/ij/process/AutoThresholder.java
    // W. Doyle, "Operation useful for similarity-invariant pattern recognition,"
    // Journal of the Association for Computing Machinery, vol. 9,pp. 259-267, 1962.
    // ported to ImageJ plugin by G.Landini from Antti Niemisto's Matlab code (GPL)
    // Original Matlab code Copyright (C) 2004 Antti Niemisto
    // See http://www.cs.tut.fi/~ant/histthresh/ for an excellent slide presentation
    // and the original Matlab code.

    var threshold = -1;
    var percentile = 0.5; // default fraction of foreground pixels
    var avec = new Array(histogram.length);

    var total = partialSum(histogram, histogram.length - 1);
    var temp = 1.0;

    for (var i = 0; i < histogram.length; i++) {
        avec[i] = Math.abs(partialSum(histogram, i) / total - percentile);
        if (avec[i] < temp) {
            temp = avec[i];
            threshold = i;
        }
    }

    return threshold;
}

function partialSum(histogram, endIndex) {
    var x = 0;
    for (var i = 0; i <= endIndex; i++) {
        x += histogram[i];
    }
    return x;
}

},{}],142:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = renyiEntropy;
// see https://github.com/fiji/Auto_Threshold/blob/master/src/main/java/fiji/threshold/Auto_Threshold.java
// Kapur J.N., Sahoo P.K., and Wong A.K.C. (1985) "A New Method for
// Gray-Level Picture Thresholding Using the Entropy of the Histogram"
// Graphical Models and Image Processing, 29(3): 273-285
// M. Emre Celebi
// 06.15.2007
// Ported to ImageJ plugin by G.Landini from E Celebi's fourier_0.8 routines

function renyiEntropy(histogram, total) {
    var opt_threshold = void 0; //Optimal threshold
    var first_bin = void 0; //First non-zero bin
    var last_bin = void 0; //last non-zero bin

    var norm_histo = new Array(histogram.length); //normalized histogram
    var P1 = new Array(histogram.length); //acumulative normalized histogram
    var P2 = new Array(histogram.length); //acumulative normalized histogram

    //Entropy Variables
    var threshold1 = 0;
    var threshold2 = 0;
    var threshold3 = 0;
    var max_ent1 = 0.0;
    var max_ent2 = 0.0;
    var max_ent3 = 0.0;
    var alpha2 = 0.5;
    var term2 = 1.0 / (1.0 - alpha2);
    var alpha3 = 2.0;
    var term3 = 1.0 / (1.0 - alpha3);

    for (var ih = 0; ih < histogram.length; ih++) {
        norm_histo[ih] = histogram[ih] / total;
    }P1[0] = norm_histo[0];
    P2[0] = 1.0 - P1[0];
    for (var _ih = 1; _ih < histogram.length; _ih++) {
        P1[_ih] = P1[_ih - 1] + norm_histo[_ih];
        P2[_ih] = 1.0 - P1[_ih];
    }

    /* Determine the first non-zero bin */
    first_bin = 0;
    for (var _ih2 = 0; _ih2 < histogram.length; _ih2++) {
        if (Math.abs(P1[_ih2]) >= Number.EPSILON) {
            first_bin = _ih2;
            break;
        }
    }

    /* Determine the last non-zero bin */
    last_bin = histogram.length - 1;
    for (var _ih3 = histogram.length - 1; _ih3 >= first_bin; _ih3--) {
        if (Math.abs(P2[_ih3]) >= Number.EPSILON) {
            last_bin = _ih3;
            break;
        }
    }

    /* Maximum Entropy Thresholding - BEGIN */
    /* ALPHA = 1.0 */
    /* Calculate the total entropy each gray-level
     and find the threshold that maximizes it
     */
    for (var it = first_bin; it <= last_bin; it++) {
        /* Entropy of the background pixels */
        var ent_back1 = 0.0;
        var ent_back2 = 0.0;
        var ent_back3 = 0.0;
        for (var _ih4 = 0; _ih4 <= it; _ih4++) {
            if (histogram[_ih4] !== 0) {
                ent_back1 -= norm_histo[_ih4] / P1[it] * Math.log(norm_histo[_ih4] / P1[it]);
            }
            ent_back2 += Math.sqrt(norm_histo[_ih4] / P1[it]);
            ent_back3 += norm_histo[_ih4] * norm_histo[_ih4] / (P1[it] * P1[it]);
        }

        /* Entropy of the object pixels */
        var ent_obj1 = 0.0;
        var ent_obj2 = 0.0;
        var ent_obj3 = 0.0;
        for (var _ih5 = it + 1; _ih5 < histogram.length; _ih5++) {
            if (histogram[_ih5] !== 0) {
                ent_obj1 -= norm_histo[_ih5] / P2[it] * Math.log(norm_histo[_ih5] / P2[it]);
            }
            ent_obj2 += Math.sqrt(norm_histo[_ih5] / P2[it]);
            ent_obj3 += norm_histo[_ih5] * norm_histo[_ih5] / (P2[it] * P2[it]);
        }

        /* Total entropy */
        var tot_ent1 = ent_back1 + ent_obj1;
        var tot_ent2 = term2 * (ent_back2 * ent_obj2 > 0.0 ? Math.log(ent_back2 * ent_obj2) : 0.0);
        var tot_ent3 = term3 * (ent_back3 * ent_obj3 > 0.0 ? Math.log(ent_back3 * ent_obj3) : 0.0);

        if (tot_ent1 > max_ent1) {
            max_ent1 = tot_ent1;
            threshold1 = it;
        }

        if (tot_ent2 > max_ent2) {
            max_ent2 = tot_ent2;
            threshold2 = it;
        }

        if (tot_ent3 > max_ent3) {
            max_ent3 = tot_ent3;
            threshold3 = it;
        }
    }
    /* End Maximum Entropy Thresholding */

    var t_stars = [threshold1, threshold2, threshold3];
    t_stars.sort();

    var betas = void 0;

    /* Adjust beta values */
    if (Math.abs(t_stars[0] - t_stars[1]) <= 5) {
        if (Math.abs(t_stars[1] - t_stars[2]) <= 5) {
            betas = [1, 2, 1];
        } else {
            betas = [0, 1, 3];
        }
    } else {
        if (Math.abs(t_stars[1] - t_stars[2]) <= 5) {
            betas = [3, 1, 0];
        } else {
            betas = [1, 2, 1];
        }
    }

    /* Determine the optimal threshold value */
    var omega = P1[t_stars[2]] - P1[t_stars[0]];
    opt_threshold = Math.round(t_stars[0] * (P1[t_stars[0]] + 0.25 * omega * betas[0]) + 0.25 * t_stars[1] * omega * betas[1] + t_stars[2] * (P2[t_stars[2]] + 0.25 * omega * betas[2]));

    return opt_threshold;
}

},{}],143:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = shanbhag;
// see https://github.com/fiji/Auto_Threshold/blob/master/src/main/java/fiji/threshold/Auto_Threshold.java
// Shanhbag A.G. (1994) "Utilization of Information Measure as a Means of
// Image Thresholding" Graphical Models and Image Processing, 56(5): 414-419
// Ported to ImageJ plugin by G.Landini from E Celebi's fourier_0.8 routines

function shanbhag(histogram, total) {
    var norm_histo = new Array(histogram.length); // normalized histogram
    for (var ih = 0; ih < histogram.length; ih++) {
        norm_histo[ih] = histogram[ih] / total;
    }var P1 = new Array(histogram.length); // cumulative normalized histogram
    var P2 = new Array(histogram.length);
    P1[0] = norm_histo[0];
    P2[0] = 1.0 - P1[0];
    for (var _ih = 1; _ih < histogram.length; _ih++) {
        P1[_ih] = P1[_ih - 1] + norm_histo[_ih];
        P2[_ih] = 1.0 - P1[_ih];
    }

    /* Determine the first non-zero bin */
    var first_bin = 0;
    for (var _ih2 = 0; _ih2 < histogram.length; _ih2++) {
        if (Math.abs(P1[_ih2]) >= Number.EPSILON) {
            first_bin = _ih2;
            break;
        }
    }

    /* Determine the last non-zero bin */
    var last_bin = histogram.length - 1;
    for (var _ih3 = histogram.length - 1; _ih3 >= first_bin; _ih3--) {
        if (Math.abs(P2[_ih3]) >= Number.EPSILON) {
            last_bin = _ih3;
            break;
        }
    }

    // Calculate the total entropy each gray-level
    // and find the threshold that maximizes it
    var threshold = -1;
    var min_ent = Number.MAX_VALUE; // min entropy

    var term = void 0;
    var tot_ent = void 0; // total entropy
    var ent_back = void 0; // entropy of the background pixels at a given threshold
    var ent_obj = void 0; // entropy of the object pixels at a given threshold
    for (var it = first_bin; it <= last_bin; it++) {
        /* Entropy of the background pixels */
        ent_back = 0.0;
        term = 0.5 / P1[it];
        for (var _ih4 = 1; _ih4 <= it; _ih4++) {
            ent_back -= norm_histo[_ih4] * Math.log(1.0 - term * P1[_ih4 - 1]);
        }
        ent_back *= term;

        /* Entropy of the object pixels */
        ent_obj = 0.0;
        term = 0.5 / P2[it];
        for (var _ih5 = it + 1; _ih5 < histogram.length; _ih5++) {
            ent_obj -= norm_histo[_ih5] * Math.log(1.0 - term * P2[_ih5]);
        }
        ent_obj *= term;

        /* Total entropy */
        tot_ent = Math.abs(ent_back - ent_obj);

        if (tot_ent < min_ent) {
            min_ent = tot_ent;
            threshold = it;
        }
    }
    return threshold;
}

},{}],144:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = triangle;
// see https://github.com/fiji/Auto_Threshold/blob/master/src/main/java/fiji/threshold/Auto_Threshold.java
// Zack, G. W., Rogers, W. E. and Latt, S. A., 1977,
// Automatic Measurement of Sister Chromatid Exchange Frequency,
// Journal of Histochemistry and Cytochemistry 25 (7), pp. 741-753
//
//  modified from Johannes Schindelin plugin
//
function triangle(histogram) {

    // find min and max
    var min = 0,
        dmax = 0,
        max = 0,
        min2 = 0;
    for (var i = 0; i < histogram.length; i++) {
        if (histogram[i] > 0) {
            min = i;
            break;
        }
    }
    if (min > 0) min--; // line to the (p==0) point, not to histogram[min]

    // The Triangle algorithm cannot tell whether the data is skewed to one side or another.
    // This causes a problem as there are 2 possible thresholds between the max and the 2 extremes
    // of the histogram.
    // Here I propose to find out to which side of the max point the data is furthest, and use that as
    //  the other extreme.
    for (var _i = histogram.length - 1; _i > 0; _i--) {
        if (histogram[_i] > 0) {
            min2 = _i;
            break;
        }
    }
    if (min2 < histogram.length - 1) min2++; // line to the (p==0) point, not to data[min]

    for (var _i2 = 0; _i2 < histogram.length; _i2++) {
        if (histogram[_i2] > dmax) {
            max = _i2;
            dmax = histogram[_i2];
        }
    }

    // find which is the furthest side
    var inverted = false;
    if (max - min < min2 - max) {
        // reverse the histogram
        inverted = true;
        var left = 0; // index of leftmost element
        var right = histogram.length - 1; // index of rightmost element
        while (left < right) {
            // exchange the left and right elements
            var temp = histogram[left];
            histogram[left] = histogram[right];
            histogram[right] = temp;
            // move the bounds toward the center
            left++;
            right--;
        }
        min = histogram.length - 1 - min2;
        max = histogram.length - 1 - max;
    }

    if (min === max) return min;

    // describe line by nx * x + ny * y - d = 0
    var nx = void 0,
        ny = void 0,
        d = void 0;
    // nx is just the max frequency as the other point has freq=0
    nx = histogram[max]; //-min; // data[min]; //  lowest value bmin = (p=0)% in the image
    ny = min - max;
    d = Math.sqrt(nx * nx + ny * ny);
    nx /= d;
    ny /= d;
    d = nx * min + ny * histogram[min];

    // find split point
    var split = min;
    var splitDistance = 0;
    for (var _i3 = min + 1; _i3 <= max; _i3++) {
        var newDistance = nx * _i3 + ny * histogram[_i3] - d;
        if (newDistance > splitDistance) {
            split = _i3;
            splitDistance = newDistance;
        }
    }
    split--;

    if (inverted) {
        // The histogram might be used for something else, so let's reverse it back
        var _left = 0;
        var _right = histogram.length - 1;
        while (_left < _right) {
            var _temp = histogram[_left];
            histogram[_left] = histogram[_right];
            histogram[_right] = _temp;
            _left++;
            _right--;
        }
        return histogram.length - 1 - split;
    } else return split;
}

},{}],145:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = yen;
// see https://github.com/fiji/Auto_Threshold/blob/master/src/main/java/fiji/threshold/Auto_Threshold.java
// Implements Yen  thresholding method
// 1) Yen J.C., Chang F.J., and Chang S. (1995) "A New Criterion
//    for Automatic Multilevel Thresholding" IEEE Trans. on Image
//    Processing, 4(3): 370-378
// 2) Sezgin M. and Sankur B. (2004) "Survey over Image Thresholding
//    Techniques and Quantitative Performance Evaluation" Journal of
//    Electronic Imaging, 13(1): 146-165
//    http://citeseer.ist.psu.edu/sezgin04survey.html
//
// M. Emre Celebi
// 06.15.2007
// Ported to ImageJ plugin by G.Landini from E Celebi's fourier_0.8 routines

function yen(histogram, total) {
    var norm_histo = new Array(histogram.length); // normalized histogram
    for (var ih = 0; ih < histogram.length; ih++) {
        norm_histo[ih] = histogram[ih] / total;
    }var P1 = new Array(histogram.length); // cumulative normalized histogram
    P1[0] = norm_histo[0];
    for (var _ih = 1; _ih < histogram.length; _ih++) {
        P1[_ih] = P1[_ih - 1] + norm_histo[_ih];
    }var P1_sq = new Array(histogram.length);
    P1_sq[0] = norm_histo[0] * norm_histo[0];
    for (var _ih2 = 1; _ih2 < histogram.length; _ih2++) {
        P1_sq[_ih2] = P1_sq[_ih2 - 1] + norm_histo[_ih2] * norm_histo[_ih2];
    }var P2_sq = new Array(histogram.length);
    P2_sq[histogram.length - 1] = 0.0;
    for (var _ih3 = histogram.length - 2; _ih3 >= 0; _ih3--) {
        P2_sq[_ih3] = P2_sq[_ih3 + 1] + norm_histo[_ih3 + 1] * norm_histo[_ih3 + 1];
    } /* Find the threshold that maximizes the criterion */
    var threshold = -1;
    var max_crit = Number.MIN_VALUE;
    var crit = void 0;
    for (var it = 0; it < histogram.length; it++) {
        crit = -1.0 * (P1_sq[it] * P2_sq[it] > 0.0 ? Math.log(P1_sq[it] * P2_sq[it]) : 0.0) + 2 * (P1[it] * (1.0 - P1[it]) > 0.0 ? Math.log(P1[it] * (1.0 - P1[it])) : 0.0);
        if (crit > max_crit) {
            max_crit = crit;
            threshold = it;
        }
    }
    return threshold;
}

},{}],146:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = pad;

var _image = require('../image');

var _image2 = _interopRequireDefault(_image);

var _newArray = require('new-array');

var _newArray2 = _interopRequireDefault(_newArray);

var _copy = require('../utility/copy');

var _copy2 = _interopRequireDefault(_copy);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function pad() {
    var _ref = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

    var _ref$size = _ref.size;
    var size = _ref$size === undefined ? 0 : _ref$size;
    var _ref$algorithm = _ref.algorithm;
    var algorithm = _ref$algorithm === undefined ? 'copy' : _ref$algorithm;
    var color = _ref.color;


    this.checkProcessable('pad', {
        bitDepth: [8, 16]
    });

    if (algorithm === 'set') {
        if (color.length !== this.channels) {
            throw new Error('pad: the color array must have the same length as the number of channels. Here: ' + this.channels);
        }
        for (var i = 0; i < color.length; i++) {
            if (color[i] === 0) color[i] = 0.001;
        }
    } else {
        color = (0, _newArray2.default)(this.channels, null);
    }

    if (!Array.isArray(size)) {
        size = [size, size];
    }

    var newWidth = this.width + size[0] * 2;
    var newHeight = this.height + size[1] * 2;
    var channels = this.channels;

    var newImage = _image2.default.createFrom(this, { width: newWidth, height: newHeight });

    (0, _copy2.default)(this, newImage, size[0], size[1]);

    for (var _i = size[0]; _i < newWidth - size[0]; _i++) {
        for (var k = 0; k < channels; k++) {
            var value = color[k] || newImage.data[(size[1] * newWidth + _i) * channels + k];
            for (var j = 0; j < size[1]; j++) {
                newImage.data[(j * newWidth + _i) * channels + k] = value;
            }
            value = color[k] || newImage.data[((newHeight - size[1] - 1) * newWidth + _i) * channels + k];
            for (var _j = newHeight - size[1]; _j < newHeight; _j++) {
                newImage.data[(_j * newWidth + _i) * channels + k] = value;
            }
        }
    }

    for (var _j2 = 0; _j2 < newHeight; _j2++) {
        for (var _k = 0; _k < channels; _k++) {
            var _value = color[_k] || newImage.data[(_j2 * newWidth + size[0]) * channels + _k];
            for (var _i2 = 0; _i2 < size[0]; _i2++) {
                newImage.data[(_j2 * newWidth + _i2) * channels + _k] = _value;
            }
            _value = color[_k] || newImage.data[(_j2 * newWidth + newWidth - size[0] - 1) * channels + _k];
            for (var _i3 = newWidth - size[0]; _i3 < newWidth; _i3++) {
                newImage.data[(_j2 * newWidth + _i3) * channels + _k] = _value;
            }
        }
    }

    return newImage;
}

},{"../image":103,"../utility/copy":151,"new-array":35}],147:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = resizeBinary;

var _image = require('../image');

var _image2 = _interopRequireDefault(_image);

var _kindNames = require('../kindNames');

var KindNames = _interopRequireWildcard(_kindNames);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// This is a temporary code that should be placed in the more generate resize method
// it only works for scaled down !

function resizeBinary() {
    var scale = arguments.length <= 0 || arguments[0] === undefined ? 0.5 : arguments[0];
    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

    this.checkProcessable('resizeBinary', {
        bitDepth: [1]
    });

    var width = Math.floor(this.width * scale);
    var height = Math.floor(this.height * scale);
    var shiftX = Math.round((this.width - width) / 2);
    var shiftY = Math.round((this.height - height) / 2);

    var newImage = _image2.default.createFrom(this, {
        kind: KindNames.BINARY,
        width: width,
        height: height,
        position: [shiftX, shiftY]
    });

    for (var x = 0; x < this.width; x++) {
        for (var y = 0; y < this.height; y++) {
            if (this.getBitXY(x, y)) {
                newImage.setBitXY(Math.floor(x * scale), Math.floor(y * scale));
            }
        }
    }

    return newImage;
}

},{"../image":103,"../kindNames":105}],148:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = rgba8;

var _image = require('../image');

var _image2 = _interopRequireDefault(_image);

var _model = require('../model/model');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function rgba8() {

    var newImage = new _image2.default(this.width, this.height, {
        kind: 'RGBA'
    });

    newImage.data = this.getRGBAData();
    return newImage;
}

},{"../image":103,"../model/model":108}],149:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = nearestNeighbor;
function nearestNeighbor(newImage, newWidth, newHeight) {
    var wRatio = this.width / newWidth;
    var hRatio = this.height / newHeight;
    for (var i = 0; i < newWidth; i++) {
        var w = Math.floor((i + 0.5) * wRatio);
        for (var j = 0; j < newHeight; j++) {
            var h = Math.floor((j + 0.5) * hRatio);
            for (var c = 0; c < this.channels; c++) {
                newImage.setValueXY(i, j, c, this.getValueXY(w, h, c));
            }
        }
    }
}

},{}],150:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = scale;

var _image = require('../../image');

var _image2 = _interopRequireDefault(_image);

var _nearestNeighbor = require('./nearestNeighbor');

var _nearestNeighbor2 = _interopRequireDefault(_nearestNeighbor);

var _converter = require('../../../util/converter');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function scale() {
    var _ref = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

    var _ref$width = _ref.width;
    var width = _ref$width === undefined ? this.width : _ref$width;
    var _ref$height = _ref.height;
    var height = _ref$height === undefined ? this.height : _ref$height;
    var _ref$factor = _ref.factor;
    var factor = _ref$factor === undefined ? 1 : _ref$factor;
    var _ref$algorithm = _ref.algorithm;
    var algorithm = _ref$algorithm === undefined ? 'nearestNeighbor' : _ref$algorithm;

    var _factorDimensions = (0, _converter.factorDimensions)(factor, width, height);

    var newWidth = _factorDimensions.width;
    var newHeight = _factorDimensions.height;


    var newImage = _image2.default.createFrom(this, { width: newWidth, height: newHeight });

    switch (algorithm.toLowerCase()) {
        case 'nearestneighbor':
        case 'nearestneighbour':
            _nearestNeighbor2.default.call(this, newImage, newWidth, newHeight);
            break;
        default:
            throw new Error('Unsupported scale algorithm: ' + algorithm);
    }

    return newImage;
}

},{"../../../util/converter":172,"../../image":103,"./nearestNeighbor":149}],151:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = copyImage;
function copyImage(fromImage, toImage, x, y) {
    var fromWidth = fromImage.width;
    var fromHeight = fromImage.height;
    var toWidth = toImage.width;
    var toHeight = toImage.height;
    var channels = fromImage.channels;
    for (var i = 0; i < fromWidth; i++) {
        for (var j = 0; j < fromHeight; j++) {
            for (var k = 0; k < channels; k++) {
                var source = (j * fromWidth + i) * channels + k;
                var target = ((y + j) * toWidth + x + i) * channels + k;
                toImage.data[target] = fromImage.data[source];
            }
        }
    }
}

},{}],152:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = match;

var _image = require('../image');

var _image2 = _interopRequireDefault(_image);

var _newArray = require('new-array');

var _newArray2 = _interopRequireDefault(_newArray);

var _matrix = require('../../util/matrix');

var _matrix2 = _interopRequireDefault(_matrix);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Try to match the current pictures with another one

function match(image) {
    var _ref = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

    var border = _ref.border;


    this.checkProcessable('getChannel', {
        bitDepth: [8, 16]
    });

    if (this.bitDepth !== image.bitDepth) {
        throw new Error('Both images must have the same bitDepth');
    }
    if (this.channels !== image.channels) {
        throw new Error('Both images must have the same number of channels');
    }
    if (this.colorModel !== image.colorModel) {
        throw new Error('Both images must have the same colorModel');
    }

    // there could be many names
    var similarityMatrix = new _matrix2.default(image.width, image.height, -Infinity);

    var currentX = Math.floor(image.width / 2);
    var currentY = Math.floor(image.height / 2);
    var middleX = currentX;
    var middleY = currentY;
    var theEnd = false;

    while (!theEnd) {
        var toCalculatePositions = similarityMatrix.localSearch(currentX, currentY, -Infinity);
        for (var i = 0; i < toCalculatePositions.length; i++) {
            var position = toCalculatePositions[i];
            var similarity = this.getSimilarity(image, { border: border, shift: [middleX - position[0], middleY - position[1]] });
            similarityMatrix[position[0]][position[1]] = similarity;
        }

        var max = similarityMatrix.localMax(currentX, currentY);
        if (max.position[0] !== currentX || max.position[1] !== currentY) {
            currentX = max.position[0];
            currentY = max.position[1];
        } else {
            theEnd = true;
        }
    }

    /*
    for (let i=0; i<similarityMatrix.length; i++) {
        let line=[];
        for (let j=0; j<similarityMatrix[i].length; j++) {
            line.push(similarityMatrix[i][j]);
        }
        console.log(line.join(" "));
    }
    console.log(currentX, middleX, currentY, middleY);
    */

    return [currentX - middleX, currentY - middleY];
}

},{"../../util/matrix":176,"../image":103,"new-array":35}],153:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = getChannel;

var _image = require('../image');

var _image2 = _interopRequireDefault(_image);

var _channel = require('./../../util/channel');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function getChannel(channel) {

    this.checkProcessable('getChannel', {
        bitDepth: [8, 16]
    });

    channel = (0, _channel.validateChannel)(this, channel);

    var newImage = _image2.default.createFrom(this, {
        components: 1,
        alpha: false,
        colorModel: null
    });
    var ptr = 0;
    for (var j = channel; j < this.data.length; j += this.channels) {
        newImage.data[ptr++] = this.data[j];
    }

    return newImage;
}

},{"../image":103,"./../../util/channel":171}],154:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = getColumn;

var _image = require('../image');

var _image2 = _interopRequireDefault(_image);

var _channel = require('./../../util/channel');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function getColumn(column) {
    var channel = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];


    this.checkProcessable('getColumn', {
        bitDepth: [8, 16]
    });

    this.checkColumn(column);
    this.checkChannel(channel);

    var array = new Array(this.height);
    var ptr = 0;
    var step = this.width * this.channels;
    for (var j = channel + column * this.channels; j < this.data.length; j += step) {
        array[ptr++] = this.data[j];
    }
    return array;
}

},{"../image":103,"./../../util/channel":171}],155:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = getPixelsGrid;
function getPixelsGrid() {
    var _ref = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

    var _ref$sampling = _ref.sampling;
    var sampling = _ref$sampling === undefined ? [10, 10] : _ref$sampling;
    var _ref$painted = _ref.painted;
    var painted = _ref$painted === undefined ? false : _ref$painted;
    var mask = _ref.mask;


    this.checkProcessable('getPixelsGrid', {
        bitDepth: [8, 16],
        channels: 1
    });

    if (!Array.isArray(sampling)) sampling = [sampling, sampling];

    var xSampling = sampling[0];
    var ySampling = sampling[1];
    var nbSamples = xSampling * ySampling;

    var xyS = new Array(nbSamples);
    var zS = new Array(nbSamples);

    var xStep = this.width / xSampling;
    var yStep = this.height / ySampling;
    var currentX = Math.floor(xStep / 2);

    var position = 0;
    for (var i = 0; i < xSampling; i++) {
        var currentY = Math.floor(yStep / 2);
        for (var j = 0; j < ySampling; j++) {
            var x = Math.round(currentX);
            var y = Math.round(currentY);
            if (!mask || mask.getBitXY(x, y)) {
                xyS[position] = [x, y];
                zS[position] = this.getPixelXY(x, y);
                position++;
            }
            currentY += yStep;
        }
        currentX += xStep;
    }

    // resize arrays if needed
    xyS.length = position;
    zS.length = position;

    var toReturn = { xyS: xyS, zS: zS };

    if (painted) {
        toReturn.painted = this.rgba8().paintPixels(xyS);
    }

    return toReturn;
}

},{}],156:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = getRow;

var _image = require('../image');

var _image2 = _interopRequireDefault(_image);

var _channel = require('./../../util/channel');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function getRow(row) {
    var channel = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];


    this.checkProcessable('getRow', {
        bitDepth: [8, 16]
    });

    this.checkRow(row);
    this.checkChannel(channel);

    var array = new Array(this.width);
    var ptr = 0;
    var begin = row * this.width * this.channels + channel;
    var end = begin + this.width * this.channels;
    for (var j = begin; j < end; j += this.channels) {
        array[ptr++] = this.data[j];
    }

    return array;
}

},{"../image":103,"./../../util/channel":171}],157:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = getSimilarity;

var _image = require('../image');

var _image2 = _interopRequireDefault(_image);

var _channel = require('./../../util/channel');

var _newArray = require('new-array');

var _newArray2 = _interopRequireDefault(_newArray);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Try to match the current pictures with another one

// if normalize we normalize separately the 2 images

function getSimilarity(image) {
    var _ref = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

    var _ref$shift = _ref.shift;
    var shift = _ref$shift === undefined ? [0, 0] : _ref$shift;
    var average = _ref.average;
    var channels = _ref.channels;
    var defaultAlpha = _ref.defaultAlpha;
    var normalize = _ref.normalize;
    var _ref$border = _ref.border;
    var border = _ref$border === undefined ? [0, 0] : _ref$border;


    this.checkProcessable('getSimilarity', {
        bitDepth: [8, 16]
    });

    if (!Array.isArray(border)) border = [border, border];
    channels = (0, _channel.validateArrayOfChannels)(this, { channels: channels, defaultAlpha: defaultAlpha });

    if (this.bitDepth !== image.bitDepth) {
        throw new Error('Both images must have the same bitDepth');
    }
    if (this.channels !== image.channels) {
        throw new Error('Both images must have the same number of channels');
    }
    if (this.colorModel !== image.colorModel) {
        throw new Error('Both images must have the same colorModel');
    }

    if (typeof average === 'undefined') average = true;

    // we allow a shift
    // we need to find the minX, maxX, minY, maxY
    var minX = Math.max(border[0], -shift[0]);
    var maxX = Math.min(this.width - border[0], this.width - shift[0]);
    var minY = Math.max(border[1], -shift[1]);
    var maxY = Math.min(this.height - border[1], this.height - shift[1]);

    var results = (0, _newArray2.default)(channels.length, 0);
    for (var i = 0; i < channels.length; i++) {
        var c = channels[i];
        var sumThis = normalize ? this.sum[c] : Math.max(this.sum[c], image.sum[c]);
        var sumImage = normalize ? image.sum[c] : Math.max(this.sum[c], image.sum[c]);

        if (sumThis !== 0 && sumImage !== 0) {
            for (var x = minX; x < maxX; x++) {
                for (var y = minY; y < maxY; y++) {
                    var indexThis = x * this.multiplierX + y * this.multiplierY + c;
                    var indexImage = indexThis + shift[0] * this.multiplierX + shift[1] * this.multiplierY;
                    results[i] += Math.min(this.data[indexThis] / sumThis, image.data[indexImage] / sumImage);
                }
            }
        }
    }

    if (average) {
        return results.reduce((sum, x) => sum + x) / results.length;
    }
    return results;
}

},{"../image":103,"./../../util/channel":171,"new-array":35}],158:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = setBorder;

var _image = require('../image');

var _image2 = _interopRequireDefault(_image);

var _newArray = require('new-array');

var _newArray2 = _interopRequireDefault(_newArray);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// this method will change the border
// that may not be calculated

function setBorder() {
    var _ref = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

    var _ref$size = _ref.size;
    var size = _ref$size === undefined ? 0 : _ref$size;
    var _ref$algorithm = _ref.algorithm;
    var algorithm = _ref$algorithm === undefined ? 'copy' : _ref$algorithm;
    var color = _ref.color;


    this.checkProcessable('setBorder', {
        bitDepth: [8, 16, 32, 64]
    });

    if (algorithm === 'set') {
        if (color.length !== this.channels) {
            throw new Error('setBorder: the color array must have the same length as the number of channels. Here: ' + this.channels);
        }
        for (var i = 0; i < color.length; i++) {
            if (color[i] === 0) color[i] = 0.001;
        }
    } else {
        color = (0, _newArray2.default)(this.channels, null);
    }

    if (!Array.isArray(size)) {
        size = [size, size];
    }

    var leftRightSize = size[0];
    var topBottomSize = size[1];
    var channels = this.channels;

    for (var _i = leftRightSize; _i < this.width - leftRightSize; _i++) {
        for (var k = 0; k < channels; k++) {
            var value = color[k] || this.data[(_i + this.width * topBottomSize) * channels + k];
            for (var j = 0; j < topBottomSize; j++) {
                this.data[(j * this.width + _i) * channels + k] = value;
            }
            value = color[k] || this.data[(_i + this.width * (this.height - topBottomSize - 1)) * channels + k];
            for (var _j = this.height - topBottomSize; _j < this.height; _j++) {
                this.data[(_j * this.width + _i) * channels + k] = value;
            }
        }
    }

    for (var _j2 = 0; _j2 < this.height; _j2++) {
        for (var _k = 0; _k < channels; _k++) {
            var _value = color[_k] || this.data[(_j2 * this.width + leftRightSize) * channels + _k];
            for (var _i2 = 0; _i2 < leftRightSize; _i2++) {
                this.data[(_j2 * this.width + _i2) * channels + _k] = _value;
            }
            _value = color[_k] || this.data[(_j2 * this.width + this.width - leftRightSize - 1) * channels + _k];
            for (var _i3 = this.width - leftRightSize; _i3 < this.width; _i3++) {
                this.data[(_j2 * this.width + _i3) * channels + _k] = _value;
            }
        }
    }
}

},{"../image":103,"new-array":35}],159:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = setChannel;

var _image = require('../image');

var _image2 = _interopRequireDefault(_image);

var _channel = require('./../../util/channel');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function setChannel(channel, image) {

    this.checkProcessable('setChannel', {
        bitDepth: [8, 16]
    });

    image.checkProcessable('setChannel (image parameter check)', {
        bitDepth: [this.bitDepth],
        alpha: [0],
        components: [1]
    });

    if (image.width !== this.width || image.height !== this.height) {
        throw new Error('Images must have exactly the same width and height');
    }

    channel = (0, _channel.validateChannel)(this, channel);

    var ptr = channel;
    for (var i = 0; i < image.data.length; i++) {
        this.data[ptr] = image.data[i];
        ptr += this.channels;
    }
}

},{"../image":103,"./../../util/channel":171}],160:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = split;

var _image = require('../image');

var _image2 = _interopRequireDefault(_image);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function split() {
    var _ref = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

    var _ref$preserveAlpha = _ref.preserveAlpha;
    var preserveAlpha = _ref$preserveAlpha === undefined ? true : _ref$preserveAlpha;


    this.checkProcessable('split', {
        bitDepth: [8, 16]
    });

    // split will always return an array of images
    if (this.components === 1) {
        return [this.clone()];
    }

    var images = [];

    var data = this.data;
    if (this.alpha && preserveAlpha) {
        for (var i = 0; i < this.components; i++) {
            var newImage = _image2.default.createFrom(this, {
                components: 1,
                alpha: true,
                colorModel: null
            });
            var ptr = 0;
            for (var j = 0; j < data.length; j += this.channels) {
                newImage.data[ptr++] = data[j + i];
                newImage.data[ptr++] = data[j + this.components];
            }
            images.push(newImage);
        }
    } else {
        for (var _i = 0; _i < this.channels; _i++) {
            var _newImage = _image2.default.createFrom(this, {
                components: 1,
                alpha: false,
                colorModel: null
            });
            var _ptr = 0;
            for (var _j = 0; _j < data.length; _j += this.channels) {
                _newImage.data[_ptr++] = data[_j + _i];
            }
            images.push(_newImage);
        }
    }

    return images;
}

},{"../image":103}],161:[function(require,module,exports){
'use strict';

var _environment = require('./image/environment');

module.exports = exports = require('./image/image').default;
exports.Stack = require('./stack/stack').default;

if (_environment.env === 'browser') {
    exports.Worker = require('./worker/worker').default;
}

},{"./image/environment":83,"./image/image":103,"./stack/stack":168,"./worker/worker":181}],162:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = histogram;
function histogram(options) {

    this.checkProcessable('min', {
        bitDepth: [8, 16]
    });

    var histogram = this[0].getHistogram(options);
    for (var i = 1; i < this.length; i++) {
        var secondHistogram = this[i].getHistogram(options);
        for (var j = 0; j < histogram.length; j++) {
            histogram[j] += secondHistogram[j];
        }
    }
    return histogram;
}

},{}],163:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = histograms;
function histograms(options) {

    this.checkProcessable('min', {
        bitDepth: [8, 16]
    });

    var histograms = this[0].getHistograms(options);
    var histogramLength = histograms[0].length;
    for (var i = 1; i < this.length; i++) {
        var secondHistograms = this[i].getHistograms(options);
        for (var c = 0; c < histograms.length; c++) {
            for (var j = 0; j < histogramLength; j++) {
                histograms[c][j] += secondHistograms[c][j];
            }
        }
    }
    return histograms;
}

},{}],164:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = max;
function max() {

    this.checkProcessable('min', {
        bitDepth: [8, 16]
    });

    var max = this[0].max;
    for (var i = 1; i < this.length; i++) {
        for (var j = 0; j < max.length; j++) {
            max[j] = Math.max(max[j], this[i].max[j]);
        }
    }
    return max;
}

},{}],165:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = median;

var _histograms = require('./histograms');

var _histograms2 = _interopRequireDefault(_histograms);

var _histogram = require('../../util/histogram');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function median() {

    this.checkProcessable('median', {
        bitDepth: [8, 16]
    });

    var histograms = this.getHistograms({ maxSlots: this[0].maxValue + 1 });
    var result = new Array(histograms.length);
    for (var c = 0; c < histograms.length; c++) {
        var histogram = histograms[c];
        result[c] = (0, _histogram.median)(histogram);
    }
    return result;
}

},{"../../util/histogram":173,"./histograms":163}],166:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = min;
function min() {
    this.checkProcessable('min', {
        bitDepth: [8, 16]
    });

    var min = this[0].min;
    for (var i = 1; i < this.length; i++) {
        for (var j = 0; j < min.length; j++) {
            min[j] = Math.min(min[j], this[i].min[j]);
        }
    }
    return min;
}

},{}],167:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = extend;

var _matchAndCrop = require('./transform/matchAndCrop');

var _matchAndCrop2 = _interopRequireDefault(_matchAndCrop);

var _min = require('./compute/min');

var _min2 = _interopRequireDefault(_min);

var _max = require('./compute/max');

var _max2 = _interopRequireDefault(_max);

var _median = require('./compute/median');

var _median2 = _interopRequireDefault(_median);

var _histogram = require('./compute/histogram');

var _histogram2 = _interopRequireDefault(_histogram);

var _histograms = require('./compute/histograms');

var _histograms2 = _interopRequireDefault(_histograms);

var _average = require('./utility/average');

var _average2 = _interopRequireDefault(_average);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function extend(Stack) {
    var inPlace = { inPlace: true };
    Stack.extendMethod('matchAndCrop', _matchAndCrop2.default);

    Stack.extendMethod('getMin', _min2.default);
    Stack.extendMethod('getMax', _max2.default);
    Stack.extendMethod('getMedian', _median2.default);
    Stack.extendMethod('getHistogram', _histogram2.default);
    Stack.extendMethod('getHistograms', _histograms2.default);

    Stack.extendMethod('getAverage', _average2.default);
}

},{"./compute/histogram":162,"./compute/histograms":163,"./compute/max":164,"./compute/median":165,"./compute/min":166,"./transform/matchAndCrop":169,"./utility/average":170}],168:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = Stack;

var _extend = require('./extend');

var _extend2 = _interopRequireDefault(_extend);

var _image = require('../image/image');

var _image2 = _interopRequireDefault(_image);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

var computedPropertyDescriptor = {
    configurable: true,
    enumerable: false,
    get: undefined
};

function Stack(images) {
    var stack = void 0;
    if (Array.isArray(images)) {
        stack = new Array(images.length);
        for (var i = 0; i < images.length; i++) {
            stack[i] = images[i];
        }
    } else if (typeof images === 'number') {
        stack = new Array(images);
    } else {
        stack = [];
    }
    stack.computed = null;
    stack.__proto__ = Stack.prototype;
    return stack;
}

Stack.load = function (urls) {
    return Promise.all(urls.map(_image2.default.load)).then(Stack);
};

Stack.extendMethod = function extendMethod(name, method) {
    var _ref = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];

    var _ref$inPlace = _ref.inPlace;
    var inPlace = _ref$inPlace === undefined ? false : _ref$inPlace;
    var _ref$returnThis = _ref.returnThis;
    var returnThis = _ref$returnThis === undefined ? true : _ref$returnThis;
    var _ref$partialArgs = _ref.partialArgs;
    var partialArgs = _ref$partialArgs === undefined ? [] : _ref$partialArgs;

    if (inPlace) {
        Stack.prototype[name] = function () {
            // remove computed properties
            this.computed = null;

            for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
                args[_key] = arguments[_key];
            }

            var result = method.apply(this, [].concat(_toConsumableArray(partialArgs), args));
            if (returnThis) return this;
            return result;
        };
    } else {
        Stack.prototype[name] = function () {
            for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
                args[_key2] = arguments[_key2];
            }

            return method.apply(this, [].concat(_toConsumableArray(partialArgs), args));
        };
    }
    return Stack;
};

Stack.extendProperty = function extendProperty(name, method) {
    var _ref2 = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];

    var _ref2$partialArgs = _ref2.partialArgs;
    var partialArgs = _ref2$partialArgs === undefined ? [] : _ref2$partialArgs;

    computedPropertyDescriptor.get = function () {
        if (this.computed === null) {
            this.computed = {};
        } else if (this.computed.hasOwnProperty(name)) {
            return this.computed[name];
        }
        var result = method.apply(this, partialArgs);
        this.computed[name] = result;
        return result;
    };
    Object.defineProperty(Stack.prototype, name, computedPropertyDescriptor);
    return Stack;
};

Stack.__proto__ = Array;
Stack.prototype.__proto__ = Array.prototype;
Stack.prototype.map = function (cb, thisArg) {
    if (typeof cb !== 'function') {
        throw new TypeError(cb + ' is not a function');
    }
    var newStack = new Stack(this.length);
    for (var i = 0; i < this.length; i++) {
        newStack[i] = cb.call(thisArg, this[i], i, this);
    }
    return newStack;
};

// this method check if a process can be applied on the current image
Stack.prototype.checkProcessable = function (processName) {
    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

    if (typeof processName !== 'string') {
        throw new TypeError('checkProcessable requires as first parameter the processName (a string)');
    }
    if (this.size === 0) {
        throw new TypeError('The process: ' + processName + ' can not be applied on an empty stack');
    }
    this[0].checkProcessable(processName, options);
    for (var i = 1; i < this.length; i++) {
        if ((options.sameSize === undefined || options.sameSize) && this[0].width !== this[i].width) {
            throw new TypeError('The process: ' + processName + ' can not be applied if width is not identical in all images');
        }
        if ((options.sameSize === undefined || options.sameSize) && this[0].height !== this[i].height) {
            throw new TypeError('The process: ' + processName + ' can not be applied if height is not identical in all images');
        }
        if ((options.sameAlpha === undefined || options.sameAlpha) && this[0].alpha !== this[i].alpha) {
            throw new TypeError('The process: ' + processName + ' can not be applied if alpha is not identical in all images');
        }
        if ((options.sameBitDepth === undefined || options.sameBitDepth) && this[0].bitDepth !== this[i].bitDepth) {
            throw new TypeError('The process: ' + processName + ' can not be applied if bitDepth is not identical in all images');
        }
        if ((options.sameColorModel === undefined || options.sameColorModel) && this[0].colorModel !== this[i].colorModel) {
            throw new TypeError('The process: ' + processName + ' can not be applied if colorModel is not identical in all images');
        }
        if ((options.sameNumberChannels === undefined || options.sameNumberChannels) && this[0].channels !== this[i].channels) {
            throw new TypeError('The process: ' + processName + ' can not be applied if channels is not identical in all images');
        }
    }
};

(0, _extend2.default)(Stack);

},{"../image/image":103,"./extend":167}],169:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = matchAndCrop;

var _stack = require('../stack');

var _stack2 = _interopRequireDefault(_stack);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// in a stack we compare 2 consecutive images
// or directly to a parent

// algorithm: matchToPrevious || matchToFirst

// Ignoring border may be dangerous ! Is there is a shape on the side of the image there will be a
// continuous shift if you ignore border. By default it is better to leave it to 0,0
// Now if the background is not black there will also be no way to shift ...
// It may therefore be much better to make a background correction before trying to match and crop
// TODO this code seems also buggy if it is not 0,0

function matchAndCrop() {
    var _ref = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

    var _ref$algorithm = _ref.algorithm;
    var algorithm = _ref$algorithm === undefined ? 'matchToPrevious' : _ref$algorithm;
    var _ref$ignoreBorder = _ref.ignoreBorder;
    var ignoreBorder = _ref$ignoreBorder === undefined ? [0, 0] : _ref$ignoreBorder;

    this.checkProcessable('matchAndCrop', {
        bitDepth: [8, 16]
    });

    var matchToPrevious = algorithm === 'matchToPrevious' ? true : false;

    var parent = this[0];
    var results = [];
    results[0] = {
        position: [0, 0],
        image: this[0]
    };

    var relativePosition = [0, 0];

    // we calculate the best relative position to the parent image
    for (var i = 1; i < this.length; i++) {

        var position = parent.getBestMatch(this[i], { border: ignoreBorder });

        results[i] = {
            position: [position[0] + relativePosition[0], position[1] + relativePosition[1]],
            image: this[i]
        };
        if (matchToPrevious) {
            relativePosition[0] += position[0];
            relativePosition[1] += position[1];
            parent = this[i];
        }
    }
    // now we can calculate the cropping that we need to do

    var leftShift = 0;
    var rightShift = 0;
    var topShift = 0;
    var bottomShift = 0;

    for (var _i = 0; _i < results.length; _i++) {
        var result = results[_i];
        if (result.position[0] > leftShift) leftShift = result.position[0];
        if (result.position[0] < rightShift) rightShift = result.position[0];
        if (result.position[1] > topShift) topShift = result.position[1];
        if (result.position[1] < bottomShift) bottomShift = result.position[1];
    }
    rightShift *= -1;
    bottomShift *= -1;

    for (var _i2 = 0; _i2 < results.length; _i2++) {
        var _result = results[_i2];

        /*
        console.log("CROP",
            leftShift - result.position[0],
            topShift - result.position[1],
            parent.width - rightShift - leftShift,
            parent.height - bottomShift - topShift
        )
        */

        _result.crop = _result.image.crop({
            x: leftShift - _result.position[0],
            y: topShift - _result.position[1],
            width: parent.width - rightShift - leftShift,
            height: parent.height - bottomShift - topShift
        });
    }

    // finally we crop and create a new array of images
    var newImages = [];
    for (var _i3 = 0; _i3 < results.length; _i3++) {
        newImages[_i3] = results[_i3].crop;
    }

    return new _stack2.default(newImages);
} /*
   We will try to move a set of images in order to get only the best common part of them
   The match is always done on the first image ?
  */

},{"../stack":168}],170:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = average;

var _stack = require('../stack');

var _stack2 = _interopRequireDefault(_stack);

var _image = require('../../image/image');

var _image2 = _interopRequireDefault(_image);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectDestructuringEmpty(obj) { if (obj == null) throw new TypeError("Cannot destructure undefined"); }

function average() {
    var _ref = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

    _objectDestructuringEmpty(_ref);

    this.checkProcessable('average', {
        bitDepth: [8, 16]
    });

    var data = new Uint32Array(this[0].data.length);
    for (var i = 0; i < this.length; i++) {
        var current = this[i];
        for (var j = 0; j < this[0].data.length; j++) {
            data[j] += current.data[j];
        }
    }

    var image = _image2.default.createFrom(this[0]);
    var newData = image.data;

    for (var _i = 0; _i < this[0].data.length; _i++) {
        newData[_i] = data[_i] / this.length;
    }

    return image;
}

},{"../../image/image":103,"../stack":168}],171:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.validateArrayOfChannels = validateArrayOfChannels;
exports.validateChannel = validateChannel;

var _model = require('../image/model/model');

var Model = _interopRequireWildcard(_model);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function validateArrayOfChannels(image) {
    var _ref = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

    var channels = _ref.channels;
    var allowAlpha = _ref.allowAlpha;
    var defaultAlpha = _ref.defaultAlpha;


    if (typeof allowAlpha !== 'boolean') allowAlpha = true;

    if (typeof channels === 'undefined') {
        return allChannels(image, defaultAlpha);
    } else {
        return validateChannels(image, channels, allowAlpha);
    }
}

function allChannels(image, defaultAlpha) {
    var length = defaultAlpha ? image.channels : image.components;
    var array = new Array(length);
    for (var i = 0; i < length; i++) {
        array[i] = i;
    }
    return array;
}

function validateChannels(image, channels, allowAlpha) {
    if (!Array.isArray(channels)) channels = [channels];
    for (var c = 0; c < channels.length; c++) {
        channels[c] = validateChannel(image, channels[c], allowAlpha);
    }
    return channels;
}

function validateChannel(image, channel) {
    var allowAlpha = arguments.length <= 2 || arguments[2] === undefined ? true : arguments[2];

    if (channel === undefined) {
        throw new RangeError('validateChannel : the channel has to be >=0 and <' + image.channels);
    }

    if (typeof channel === 'string') {
        if ('rgb'.indexOf(channel) > -1) {
            if (image.colorModel !== Model.RGB) throw new Error('getChannel : not a RGB image');
            switch (channel) {
                case 'r':
                    channel = 0;
                    break;
                case 'g':
                    channel = 1;
                    break;
                case 'b':
                    channel = 2;
                    break;
            }
        }

        if (channel === 'a') {
            if (!image.alpha) throw new Error('validateChannel : the image does not contain alpha channel');
            channel = image.components;
        }

        if (typeof channel === 'string') {
            throw new Error('validateChannel : undefined channel: ' + channel);
        }
    }

    if (channel >= image.channels) {
        throw new RangeError('validateChannel : the channel has to be >=0 and <' + image.channels);
    }

    if (!allowAlpha && channel >= image.components) {
        throw new RangeError('validateChannel : alpha channel may not be selected');
    }

    return channel;
}

},{"../image/model/model":108}],172:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.getFactor = getFactor;
exports.getThreshold = getThreshold;
exports.factorDimensions = factorDimensions;
/**
 * Converts a factor value to a number between 0 and 1
 * @param value
 */
function getFactor(value) {
    if (typeof value === 'string') {
        var last = value[value.length - 1];
        value = parseFloat(value);
        if (last === '%') {
            value /= 100;
        }
    }
    return value;
}

/**
 * We can specify a threshold as "0.4", "40%" or 123
 * @param value
 * @param maxValue
 * @returns {*}
 */
function getThreshold(value, maxValue) {
    if (!maxValue) {
        throw Error('getThreshold : the maxValue should be specified');
    }
    if (typeof value === 'string') {
        var last = value[value.length - 1];
        if (last !== '%') {
            throw Error('getThreshold : if the value is a string it must finish by %');
        }
        return parseFloat(value) / 100 * maxValue;
    } else if (typeof value === 'number') {
        if (value < 1) {
            return value * maxValue;
        }
        return value;
    } else {
        throw Error('getThreshold : the value is not valid');
    }
}

function factorDimensions(factor, width, height) {
    factor = getFactor(factor);
    return {
        width: Math.round(factor * width),
        height: Math.round(factor * height)
    };
}

},{}],173:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.median = median;
exports.mean = mean;
function median(histogram) {
    var total = histogram.reduce((sum, x) => sum + x);

    if (total <= 0) return undefined;

    var position = 0;
    var currentTotal = 0;
    var middle = total / 2;
    var previous = void 0;

    while (true) {
        if (histogram[position] > 0) {
            if (previous !== undefined) {
                return (previous + position) / 2;
            }
            currentTotal += histogram[position];
            if (currentTotal > middle) {
                return position;
            } else if (currentTotal === middle) {
                previous = position;
            }
        }
        position++;
    }
}

function mean(histogram) {
    var total = 0;
    var sum = 0;

    for (var i = 0; i < histogram.length; i++) {
        total += histogram[i];
        sum += histogram[i] * i;
    }

    if (total <= 0) return undefined;

    return sum / total;
}

},{}],174:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.validateKernel = validateKernel;

var _isInteger = require('is-integer');

var _isInteger2 = _interopRequireDefault(_isInteger);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function validateKernel(kernel) {
    var kHeight = void 0,
        kWidth = void 0;
    if (Array.isArray(kernel)) {
        if (Array.isArray(kernel[0])) {
            // 2D array
            if ((kernel.length & 1) === 0 || (kernel[0].length & 1) === 0) throw new RangeError('validateKernel: Kernel rows and columns should be odd numbers');else {
                kHeight = Math.floor(kernel.length / 2);
                kWidth = Math.floor(kernel[0].length / 2);
            }
        } else {
            var kernelWidth = Math.sqrt(kernel.length);
            if ((0, _isInteger2.default)(kernelWidth)) {
                kWidth = kHeight = Math.floor(Math.sqrt(kernel.length) / 2);
            } else {
                throw new RangeError('validateKernel: Kernel array should be a square');
            }
            // we convert the array to a matrix
            var newKernel = new Array(kWidth);
            for (var i = 0; i < kernelWidth; i++) {
                newKernel[i] = new Array(kernelWidth);
                for (var j = 0; j < kernelWidth; j++) {
                    newKernel[i][j] = kernel[i * kernelWidth + j];
                }
            }
            kernel = newKernel;
        }
    } else {
        throw new Error('validateKernel: Invalid Kernel: ' + kernel);
    }
    return { kernel: kernel, kWidth: kWidth, kHeight: kHeight };
}

},{"is-integer":10}],175:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
var DISCRETE_LAPLACE_4 = exports.DISCRETE_LAPLACE_4 = [[0, 1, 0], [1, -4, 1], [0, 1, 0]];

var DISCRETE_LAPLACE_8 = exports.DISCRETE_LAPLACE_8 = [[1, 1, 1], [1, -8, 1], [1, 1, 1]];

var GRADIENT_X = exports.GRADIENT_X = [[-1, 0, +1], [-2, 0, +2], [-1, 0, +1]];

var GRADIENT_Y = exports.GRADIENT_Y = [[-1, -2, -1], [0, 0, 0], [+1, +2, +1]];

var SECOND_DERIVATIVE = exports.SECOND_DERIVATIVE = [[-1, -2, 0, 2, 1], [-2, -4, 0, 4, 2], [0, 0, 0, 0, 0], [1, 2, 0, -2, -1], [2, 4, 0, -4, -2]];

var SECOND_DERIVATIVE_INV = exports.SECOND_DERIVATIVE_INV = [[1, 2, 0, -2, -1], [2, 4, 0, -4, -2], [0, 0, 0, 0, 0], [-2, -4, 0, 4, 2], [-1, -2, 0, 2, 1]];

},{}],176:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = Matrix;
function Matrix(width, height, defaultValue) {
    var matrix = new Array(width);
    for (var x = 0; x < width; x++) {
        matrix[x] = new Array(height);
    }
    if (defaultValue) {
        for (var _x = 0; _x < width; _x++) {
            for (var y = 0; y < height; y++) {
                matrix[_x][y] = defaultValue;
            }
        }
    }
    matrix.width = width;
    matrix.height = height;
    matrix.__proto__ = Matrix.prototype;
    return matrix;
}

Matrix.prototype.localMin = function (x, y) {
    var min = this[x][y];
    var position = [x, y];
    for (var i = Math.max(0, x - 1); i < Math.min(this.length, x + 2); i++) {
        for (var j = Math.max(0, y - 1); j < Math.min(this[0].length, y + 2); j++) {
            if (this[i][j] < min) {
                min = this[i][j];
                position = [i, j];
            }
        }
    }
    return {
        position: position,
        value: min
    };
};

Matrix.prototype.localMax = function (x, y) {
    var max = this[x][y];
    var position = [x, y];
    for (var i = Math.max(0, x - 1); i < Math.min(this.length, x + 2); i++) {
        for (var j = Math.max(0, y - 1); j < Math.min(this[0].length, y + 2); j++) {
            if (this[i][j] > max) {
                max = this[i][j];
                position = [i, j];
            }
        }
    }
    return {
        position: position,
        value: max
    };
};

Matrix.prototype.localSearch = function (x, y, value) {
    var results = [];
    for (var i = Math.max(0, x - 1); i < Math.min(this.length, x + 2); i++) {
        for (var j = Math.max(0, y - 1); j < Math.min(this[0].length, y + 2); j++) {
            if (this[i][j] === value) {
                results.push([i, j]);
            }
        }
    }
    return results;
};

},{}],177:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
var Matrix = require('ml-matrix');

var cross = [[0, 0, 1, 0, 0], [0, 0, 1, 0, 0], [1, 1, 1, 1, 1], [0, 0, 1, 0, 0], [0, 0, 1, 0, 0]];

var smallCross = [[0, 1, 0], [1, 1, 1], [0, 1, 0]];

class Shape {
    constructor() {
        var _ref = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

        var _ref$kind = _ref.kind;
        var kind = _ref$kind === undefined ? 'cross' : _ref$kind;
        var shape = _ref.shape;
        var size = _ref.size;
        var width = _ref.width;
        var height = _ref.height;
        var filled = _ref.filled;

        if (shape) kind = undefined;
        if (size) {
            width = size;
            height = size;
        }
        if (width && 1 !== 1 || height && 1 !== 1) {
            throw Error('Shape: The width and height has to be odd numbers.');
        }
        if (kind) {
            switch (kind) {
                case 'cross':
                    this.matrix = cross;
                    break;
                case 'smallCross':
                    this.matrix = smallCross;
                    break;
            }
            this.height = this.matrix.length;
            this.width = this.matrix[0].length;
            if (this.height & 1 === 0 || this.width & 1 === 0) {
                throw new Error('Shapes must have an odd height and width');
            }
        } else {
            switch (shape) {
                case 'square':
                case 'rectangle':
                    this.matrix = rectangle(width, height);
                    break;
                case 'circle':
                case 'ellipse':
                    this.matrix = ellipse(width, height);
                    break;
                case 'triangle':
                    this.matrix = triangle(width, height);
                    break;
                default:

            }
        }

        this.halfHeight = this.height / 2 >> 0;
        this.halfWidth = this.width / 2 >> 0;
    }
}

exports.default = Shape;
Shape.prototype.getPoints = function () {
    var matrix = this.matrix;
    var pixels = new Array(matrix.size);
    var position = 0;
    for (var y = 0; y < matrix.length; y++) {
        for (var x = 0; x < matrix[0].length; x++) {
            if (matrix[y][x]) {
                pixels[position++] = [x - this.halfWidth, y - this.halfHeight];
            }
        }
    }
    return pixels;
};

function rectangle(width, height) {
    var matrix = Matrix.zeros(height, width);
    for (var y = 0; y < height; y++) {
        for (var x = 0; x < width; x++) {
            matrix[y][x] = 1;
        }
    }
    return matrix;
}

function ellipse(width, height) {
    var matrix = Matrix.zeros(height, width);
    var a = Math.floor(width / 2);
    var b = Math.floor(height / 2);
    for (var y = 0; y < height; y++) {
        var yp = Math.floor(y / 2);
        var shift = Math.floor(width / 2 - Math.sqrt((a * a * b * b - a * a * yp * yp) / b * b));
        for (var x = shift; x < width - shift; x++) {
            matrix[y][x] = 1;
        }
    }
    return matrix;
}

function triangle(width, height) {
    var matrix = Matrix.zeros(height, width);
    for (var y = 0; y < height; y++) {
        var shift = Math.floor((1 - y / height) * width / 2);
        for (var x = shift; x < width - shift; x++) {
            matrix[y][x] = 1;
        }
    }
    return matrix;
}

},{"ml-matrix":28}],178:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.checkNumberArray = checkNumberArray;

var _image = require('../image/image');

var _image2 = _interopRequireDefault(_image);

var _isArrayType = require('is-array-type');

var _isArrayType2 = _interopRequireDefault(_isArrayType);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function checkNumberArray(value) {
    if (!isNaN(value)) {
        if (value <= 0) throw new Error('checkNumberArray: the value must be greater than 0');
        return value;
    } else {
        if (value instanceof _image2.default) {
            return value.data;
        }
        if (!(0, _isArrayType2.default)(value)) {
            throw new Error('checkNumberArray: the value should be either a number, array or Image');
        }
        return value;
    }
}

},{"../image/image":103,"is-array-type":8}],179:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = extend;

var _background = require('./process/background');

var _background2 = _interopRequireDefault(_background);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function extend(Worker) {
    Worker.extendMethod('background', _background2.default);
}

},{"./process/background":180}],180:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _extend = require('extend');

var _extend2 = _interopRequireDefault(_extend);

var _image = require('../../image/image');

var _image2 = _interopRequireDefault(_image);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var defaultOptions = {
    regression: {
        kernelType: 'polynomial',
        kernelOptions: { degree: 2, constant: 1 }
    },
    threshold: 0.02,
    roi: {
        minSurface: 100,
        positive: false
    },
    sampling: 20,
    include: []
};

function run(image, options, onStep) {
    options = (0, _extend2.default)({}, defaultOptions, options);
    var manager = this.manager;
    if (Array.isArray(image)) {
        return Promise.all(image.map(function (img) {
            var run = runOnce(manager, img, options);
            if (typeof onStep === 'function') {
                run.then(onStep);
            }
            return run;
        }));
    } else {
        return runOnce(manager, image, options);
    }
}

function runOnce(manager, image, options) {
    return manager.post('data', [image, options]).then(function (response) {
        for (var i in response) {
            response[i] = new _image2.default(response[i]);
        }
        return response;
    });
}

function work() {
    worker.on('data', function (send, image, options) {
        image = new IJS(image);
        var result = {};
        var toTransfer = [];

        var grey = image.grey();

        var sobel = grey.sobelFilter();
        maybeInclude('sobel', sobel);

        var mask = sobel.level().mask({ threshold: options.threshold });
        maybeInclude('mask', mask);

        var roiManager = sobel.getRoiManager();
        roiManager.fromMask(mask);
        var realMask = roiManager.getMask(options.roi);
        maybeInclude('realMask', realMask);

        var pixels = grey.getPixelsGrid({
            sampling: options.sampling,
            mask: realMask
        });

        var background = image.getBackground(pixels.xyS, pixels.zS, options.regression);
        maybeInclude('background', background);

        var corrected = image.subtract(background);

        result.result = corrected;
        toTransfer.push(corrected.data.buffer);
        send(result, toTransfer);

        function maybeInclude(name, image) {
            if (options.include.indexOf(name) !== -1) {
                result[name] = image;
                toTransfer.push(image.data.buffer);
            }
        }
    });
}

exports.default = { run: run, work: work };

},{"../../image/image":103,"extend":3}],181:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _webWorkerManager = require('web-worker-manager');

var _webWorkerManager2 = _interopRequireDefault(_webWorkerManager);

var _image = require('../image/image');

var _image2 = _interopRequireDefault(_image);

var _extend = require('./extend');

var _extend2 = _interopRequireDefault(_extend);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class Worker {
    constructor() {
        this._url = null;
        this._deps = [null];
    }
    checkUrl() {
        if (this._url === null) {
            throw new Error('image worker must be initialized with an URL');
        }
    }
    get url() {
        return this._url;
    }
    set url(value) {
        if (typeof value !== 'string') {
            throw new TypeError('worker URL must be a string');
        }
        this._url = value;
        this._deps[0] = value;
    }
    static extendMethod(name, method) {
        var manager = void 0;
        var url = void 0;
        var runner = {};
        function run() {
            var _method$run;

            if (!manager) {
                this.checkUrl();
                url = this.url;
                manager = new _webWorkerManager2.default(method.work, { deps: url });
                runner.manager = manager;
            }

            for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
                args[_key] = arguments[_key];
            }

            return (_method$run = method.run).call.apply(_method$run, [runner].concat(args));
        }
        run.reset = function () {
            if (manager) {
                manager.terminate();
                manager = new _webWorkerManager2.default(method.work, { deps: url });
                runner.manager = manager;
            }
        };
        Worker.prototype[name] = run;
    }
}

(0, _extend2.default)(Worker);

exports.default = new Worker();

},{"../image/image":103,"./extend":179,"web-worker-manager":69}],182:[function(require,module,exports){
'use strict';

var _src = require('../../src');

var _src2 = _interopRequireDefault(_src);

var _test = require('../test');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

window.images = _test.imageList;
window.getHash = _test.getHash;

var root = '../img/';

window.load = function load(name) {
    return _src2.default.load(root + name);
};

var left = document.getElementById('left');
window.setLeft = function setLeft(img) {
    left.innerHTML = '';
    left.appendChild(img.getCanvas());
};

var right = document.getElementById('right');
window.setRight = function setRight(img) {
    right.innerHTML = '';
    right.appendChild(img.getCanvas());
};

module.exports = _src2.default;

},{"../../src":161,"../test":184}],183:[function(require,module,exports){
module.exports=[
  "BW11x11.png",
  "BW15x15.png",
  "BW15x15notTransparent.png",
  "BW15x15transparent.png",
  "BW2x2.png",
  "BW3x3.png",
  "BW4x4.png",
  "BW5x5.png",
  "BW7x7.png",
  "BWGrid5x5.png",
  "ColorGrid5x5.png",
  "cat-blur.jpg",
  "cat-small.png",
  "cat.jpg",
  "cells/cells.jpg",
  "cells/complexCells.png",
  "cells/ecoli.png",
  "cells/isolateCells.png",
  "format/grey16.png",
  "format/grey8.png",
  "format/greya16.png",
  "format/greya32.png",
  "format/rgb24.png",
  "format/rgb48.png",
  "format/rgba32.png",
  "format/rgba64.png",
  "grey16.png",
  "grey8.png",
  "moon/crop/BloodMoonTest-1.png",
  "moon/crop/BloodMoonTest-2.png",
  "moon/crop/BloodMoonTest-3.png",
  "moon/crop/BloodMoonTest-4.png",
  "moon/crop/BloodMoonTest-5.png",
  "moon/crop/BloodMoonTest-6.png",
  "moon/crop/BloodMoonTest-7.png",
  "moon/crop/BloodMoonTest-8.png",
  "moon/nocrop/BloodMoonTest-1.png",
  "moon/nocrop/BloodMoonTest-2.png",
  "moon/nocrop/BloodMoonTest-3.png",
  "moon/nocrop/BloodMoonTest-4.png",
  "moon/nocrop/BloodMoonTest-5.png",
  "moon/nocrop/BloodMoonTest-6.png",
  "moon/nocrop/BloodMoonTest-7.png",
  "moon/nocrop/BloodMoonTest-8.png",
  "resize/5x5a_1.png",
  "resize/5x5a_10.png",
  "resize/5x5a_13.png",
  "resize/5x5a_18.png",
  "resize/5x5a_2.png",
  "resize/5x5a_3.png",
  "resize/5x5a_4.png",
  "resize/5x5a_5.png",
  "rgb24bits.png",
  "rgb32bits.png",
  "rgb48bits.png",
  "rgb8bits.png",
  "xtc.jpg"
]
},{}],184:[function(require,module,exports){
(function (__dirname){
'use strict';

var path = require('path');
var SHA256 = require('sha.js').sha256;

exports.imageList = require('./imgList.json');

exports.getImage = function getImage(name) {
    return path.resolve(__dirname, 'img', name);
};

exports.getHash = function getHash(img) {
    if (!img.length) {
        img = img.data;
    }
    var sha = new SHA256();
    sha.update(img);
    return sha.digest('hex');
};

}).call(this,"/test")

},{"./imgList.json":183,"path":53,"sha.js":56}]},{},[182])(182)
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvYXRvYi1saXRlL2F0b2ItYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L2xpYi9fZW1wdHkuanMiLCJub2RlX21vZHVsZXMvZXh0ZW5kL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2Zhc3QtcG5nL3NyYy9QTkdEZWNvZGVyLmpzIiwibm9kZV9tb2R1bGVzL2Zhc3QtcG5nL3NyYy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9pbmhlcml0cy9pbmhlcml0c19icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL2lvYnVmZmVyL0lPQnVmZmVyLmpzIiwibm9kZV9tb2R1bGVzL2lzLWFycmF5LXR5cGUvaXMtYXJyYXktdHlwZS5qcyIsIm5vZGVfbW9kdWxlcy9pcy1maW5pdGUvaW5kZXguanMiLCJub2RlX21vZHVsZXMvaXMtaW50ZWdlci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9tbC1ldWNsaWRlYW4tZGlzdGFuY2UvZXVjbGlkZWFuLmpzIiwibm9kZV9tb2R1bGVzL21sLWdhdXNzaWFuLWtlcm5lbC9nYXVzc2lhbi1rZXJuZWwuanMiLCJub2RlX21vZHVsZXMvbWwta2VybmVsL3NyYy9rZXJuZWwuanMiLCJub2RlX21vZHVsZXMvbWwta2VybmVsL3NyYy9rZXJuZWxzL2Fub3ZhLWtlcm5lbC5qcyIsIm5vZGVfbW9kdWxlcy9tbC1rZXJuZWwvc3JjL2tlcm5lbHMvY2F1Y2h5LWtlcm5lbC5qcyIsIm5vZGVfbW9kdWxlcy9tbC1rZXJuZWwvc3JjL2tlcm5lbHMvZXhwb25lbnRpYWwta2VybmVsLmpzIiwibm9kZV9tb2R1bGVzL21sLWtlcm5lbC9zcmMva2VybmVscy9oaXN0b2dyYW0taW50ZXJzZWN0aW9uLWtlcm5lbC5qcyIsIm5vZGVfbW9kdWxlcy9tbC1rZXJuZWwvc3JjL2tlcm5lbHMvbGFwbGFjaWFuLWtlcm5lbC5qcyIsIm5vZGVfbW9kdWxlcy9tbC1rZXJuZWwvc3JjL2tlcm5lbHMvbXVsdGlxdWFkcmF0aWMta2VybmVsLmpzIiwibm9kZV9tb2R1bGVzL21sLWtlcm5lbC9zcmMva2VybmVscy9yYXRpb25hbC1xdWFkcmF0aWMta2VybmVsLmpzIiwibm9kZV9tb2R1bGVzL21sLW1hdHJpeC9zcmMvZGMvY2hvbGVza3kuanMiLCJub2RlX21vZHVsZXMvbWwtbWF0cml4L3NyYy9kYy9ldmQuanMiLCJub2RlX21vZHVsZXMvbWwtbWF0cml4L3NyYy9kYy9sdS5qcyIsIm5vZGVfbW9kdWxlcy9tbC1tYXRyaXgvc3JjL2RjL3FyLmpzIiwibm9kZV9tb2R1bGVzL21sLW1hdHJpeC9zcmMvZGMvc3ZkLmpzIiwibm9kZV9tb2R1bGVzL21sLW1hdHJpeC9zcmMvZGMvdXRpbC5qcyIsIm5vZGVfbW9kdWxlcy9tbC1tYXRyaXgvc3JjL2RlY29tcG9zaXRpb25zLmpzIiwibm9kZV9tb2R1bGVzL21sLW1hdHJpeC9zcmMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvbWwtbWF0cml4L3NyYy9tYXRyaXguanMiLCJub2RlX21vZHVsZXMvbWwtcG9seW5vbWlhbC1rZXJuZWwvcG9seW5vbWlhbC1rZXJuZWwuanMiLCJub2RlX21vZHVsZXMvbWwtcmVncmVzc2lvbi9zcmMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvbWwtcmVncmVzc2lvbi9zcmMvcmVncmVzc2lvbi9rZXJuZWwtcmlkZ2UtcmVncmVzc2lvbi5qcyIsIm5vZGVfbW9kdWxlcy9tbC1yZWdyZXNzaW9uL3NyYy9yZWdyZXNzaW9uL3NpbXBsZS1saW5lYXItcmVncmVzc2lvbi5qcyIsIm5vZGVfbW9kdWxlcy9tbC1yZWdyZXNzaW9uL3NyYy9yZWdyZXNzaW9uL3V0aWwuanMiLCJub2RlX21vZHVsZXMvbmV3LWFycmF5L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL251bWJlci1pcy1uYW4vaW5kZXguanMiLCJub2RlX21vZHVsZXMvcGFrby9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9wYWtvL2xpYi9kZWZsYXRlLmpzIiwibm9kZV9tb2R1bGVzL3Bha28vbGliL2luZmxhdGUuanMiLCJub2RlX21vZHVsZXMvcGFrby9saWIvdXRpbHMvY29tbW9uLmpzIiwibm9kZV9tb2R1bGVzL3Bha28vbGliL3V0aWxzL3N0cmluZ3MuanMiLCJub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi9hZGxlcjMyLmpzIiwibm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvY29uc3RhbnRzLmpzIiwibm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvY3JjMzIuanMiLCJub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi9kZWZsYXRlLmpzIiwibm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvZ3poZWFkZXIuanMiLCJub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi9pbmZmYXN0LmpzIiwibm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvaW5mbGF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL2luZnRyZWVzLmpzIiwibm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvbWVzc2FnZXMuanMiLCJub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi90cmVlcy5qcyIsIm5vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL3pzdHJlYW0uanMiLCJub2RlX21vZHVsZXMvcGF0aC1icm93c2VyaWZ5L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9zaGEuanMvaGFzaC5qcyIsIm5vZGVfbW9kdWxlcy9zaGEuanMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvc2hhLmpzL3NoYS5qcyIsIm5vZGVfbW9kdWxlcy9zaGEuanMvc2hhMS5qcyIsIm5vZGVfbW9kdWxlcy9zaGEuanMvc2hhMjI0LmpzIiwibm9kZV9tb2R1bGVzL3NoYS5qcy9zaGEyNTYuanMiLCJub2RlX21vZHVsZXMvc2hhLmpzL3NoYTM4NC5qcyIsIm5vZGVfbW9kdWxlcy9zaGEuanMvc2hhNTEyLmpzIiwibm9kZV9tb2R1bGVzL3N0cmluZy1pbmNsdWRlcy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy90aWZmL3NyYy9JRkQuanMiLCJub2RlX21vZHVsZXMvdGlmZi9zcmMvSUZEVmFsdWUuanMiLCJub2RlX21vZHVsZXMvdGlmZi9zcmMvVElGRi5qcyIsIm5vZGVfbW9kdWxlcy90aWZmL3NyYy9USUZGRGVjb2Rlci5qcyIsIm5vZGVfbW9kdWxlcy90aWZmL3NyYy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy93ZWItd29ya2VyLW1hbmFnZXIvc3JjL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3dlYi13b3JrZXItbWFuYWdlci9zcmMvd29ya2VyVGVtcGxhdGUuanMiLCJzcmMvaW1hZ2UvYml0TWV0aG9kcy5qcyIsInNyYy9pbWFnZS9jb21wdXRlL2NvbG9ySGlzdG9ncmFtLmpzIiwic3JjL2ltYWdlL2NvbXB1dGUvY291bnRBbHBoYVBpeGVscy5qcyIsInNyYy9pbWFnZS9jb21wdXRlL2hpc3RvZ3JhbS5qcyIsInNyYy9pbWFnZS9jb21wdXRlL21heC5qcyIsInNyYy9pbWFnZS9jb21wdXRlL21lYW4uanMiLCJzcmMvaW1hZ2UvY29tcHV0ZS9tZWRpYW4uanMiLCJzcmMvaW1hZ2UvY29tcHV0ZS9taW4uanMiLCJzcmMvaW1hZ2UvY29tcHV0ZS9waXhlbHNBcnJheS5qcyIsInNyYy9pbWFnZS9jb21wdXRlL3JlbGF0aXZlUG9zaXRpb24uanMiLCJzcmMvaW1hZ2UvY29tcHV0ZS9zdW0uanMiLCJzcmMvaW1hZ2UvY29tcHV0ZS9zdmQuanMiLCJzcmMvaW1hZ2UvZW52aXJvbm1lbnQuanMiLCJzcmMvaW1hZ2UvZXh0ZW5kLmpzIiwic3JjL2ltYWdlL2ZpbHRlci9hZGQuanMiLCJzcmMvaW1hZ2UvZmlsdGVyL2JsdXIuanMiLCJzcmMvaW1hZ2UvZmlsdGVyL2RpdmlkZS5qcyIsInNyYy9pbWFnZS9maWx0ZXIvZ2F1c3NpYW4uanMiLCJzcmMvaW1hZ2UvZmlsdGVyL2dldEJhY2tncm91bmQuanMiLCJzcmMvaW1hZ2UvZmlsdGVyL2h5cG90ZW51c2UuanMiLCJzcmMvaW1hZ2UvZmlsdGVyL2ludmVydC5qcyIsInNyYy9pbWFnZS9maWx0ZXIvaW52ZXJ0QXBwbHkuanMiLCJzcmMvaW1hZ2UvZmlsdGVyL2ludmVydEJpbmFyeUxvb3AuanMiLCJzcmMvaW1hZ2UvZmlsdGVyL2ludmVydEdldFNldC5qcyIsInNyYy9pbWFnZS9maWx0ZXIvaW52ZXJ0SXRlcmF0b3IuanMiLCJzcmMvaW1hZ2UvZmlsdGVyL2ludmVydE9uZUxvb3AuanMiLCJzcmMvaW1hZ2UvZmlsdGVyL2ludmVydFBpeGVsLmpzIiwic3JjL2ltYWdlL2ZpbHRlci9sZXZlbC5qcyIsInNyYy9pbWFnZS9maWx0ZXIvbWVkaWFuLmpzIiwic3JjL2ltYWdlL2ZpbHRlci9tdWx0aXBseS5qcyIsInNyYy9pbWFnZS9maWx0ZXIvc29iZWwuanMiLCJzcmMvaW1hZ2UvZmlsdGVyL3N1YnRyYWN0LmpzIiwic3JjL2ltYWdlL2ltYWdlLmpzIiwic3JjL2ltYWdlL2tpbmQuanMiLCJzcmMvaW1hZ2Uva2luZE5hbWVzLmpzIiwic3JjL2ltYWdlL2xvYWQuanMiLCJzcmMvaW1hZ2UvbWVkaWFUeXBlcy5qcyIsInNyYy9pbWFnZS9tb2RlbC9tb2RlbC5qcyIsInNyYy9pbWFnZS9vcGVyYXRvci9jb252b2x1dGlvbi5qcyIsInNyYy9pbWFnZS9vcGVyYXRvci9leHRyYWN0LmpzIiwic3JjL2ltYWdlL29wZXJhdG9yL3BhaW50TWFza3MuanMiLCJzcmMvaW1hZ2Uvb3BlcmF0b3IvcGFpbnRQaXhlbHMuanMiLCJzcmMvaW1hZ2Uvcm9pL1JPSU1hcC5qcyIsInNyYy9pbWFnZS9yb2kvY3JlYXRlUk9JLmpzIiwic3JjL2ltYWdlL3JvaS9jcmVhdG9yL2Zyb21FeHRyZW1hLmpzIiwic3JjL2ltYWdlL3JvaS9jcmVhdG9yL2Zyb21NYXNrLmpzIiwic3JjL2ltYWdlL3JvaS9jcmVhdG9yL2Zyb21QaXhlbHMuanMiLCJzcmMvaW1hZ2Uvcm9pL21hbmFnZXIuanMiLCJzcmMvaW1hZ2Uvcm9pL3JvaS5qcyIsInNyYy9pbWFnZS90cmFuc2Zvcm0vY29sb3JEZXB0aC5qcyIsInNyYy9pbWFnZS90cmFuc2Zvcm0vY3JvcC5qcyIsInNyYy9pbWFnZS90cmFuc2Zvcm0vZ3JleS9hdmVyYWdlLmpzIiwic3JjL2ltYWdlL3RyYW5zZm9ybS9ncmV5L2dyZXkuanMiLCJzcmMvaW1hZ2UvdHJhbnNmb3JtL2dyZXkvbHVtYTYwMS5qcyIsInNyYy9pbWFnZS90cmFuc2Zvcm0vZ3JleS9sdW1hNzA5LmpzIiwic3JjL2ltYWdlL3RyYW5zZm9ybS9ncmV5L21heGltdW0uanMiLCJzcmMvaW1hZ2UvdHJhbnNmb3JtL2dyZXkvbWlubWF4LmpzIiwic3JjL2ltYWdlL3RyYW5zZm9ybS9oc2wuanMiLCJzcmMvaW1hZ2UvdHJhbnNmb3JtL2hzdi5qcyIsInNyYy9pbWFnZS90cmFuc2Zvcm0vbWFzay9odWFuZy5qcyIsInNyYy9pbWFnZS90cmFuc2Zvcm0vbWFzay9pbnRlcm1vZGVzLmpzIiwic3JjL2ltYWdlL3RyYW5zZm9ybS9tYXNrL2lzb2RhdGEuanMiLCJzcmMvaW1hZ2UvdHJhbnNmb3JtL21hc2svbGkuanMiLCJzcmMvaW1hZ2UvdHJhbnNmb3JtL21hc2svbWFzay5qcyIsInNyYy9pbWFnZS90cmFuc2Zvcm0vbWFzay9tYXhFbnRyb3B5LmpzIiwic3JjL2ltYWdlL3RyYW5zZm9ybS9tYXNrL21lYW4uanMiLCJzcmMvaW1hZ2UvdHJhbnNmb3JtL21hc2svbWluRXJyb3IuanMiLCJzcmMvaW1hZ2UvdHJhbnNmb3JtL21hc2svbWluaW11bS5qcyIsInNyYy9pbWFnZS90cmFuc2Zvcm0vbWFzay9tb21lbnRzLmpzIiwic3JjL2ltYWdlL3RyYW5zZm9ybS9tYXNrL290c3UuanMiLCJzcmMvaW1hZ2UvdHJhbnNmb3JtL21hc2svcGVyY2VudGlsZS5qcyIsInNyYy9pbWFnZS90cmFuc2Zvcm0vbWFzay9yZW55aUVudHJvcHkuanMiLCJzcmMvaW1hZ2UvdHJhbnNmb3JtL21hc2svc2hhbmJoYWcuanMiLCJzcmMvaW1hZ2UvdHJhbnNmb3JtL21hc2svdHJpYW5nbGUuanMiLCJzcmMvaW1hZ2UvdHJhbnNmb3JtL21hc2sveWVuLmpzIiwic3JjL2ltYWdlL3RyYW5zZm9ybS9wYWQuanMiLCJzcmMvaW1hZ2UvdHJhbnNmb3JtL3Jlc2l6ZUJpbmFyeS5qcyIsInNyYy9pbWFnZS90cmFuc2Zvcm0vcmdiYTguanMiLCJzcmMvaW1hZ2UvdHJhbnNmb3JtL3NjYWxlL25lYXJlc3ROZWlnaGJvci5qcyIsInNyYy9pbWFnZS90cmFuc2Zvcm0vc2NhbGUvc2NhbGUuanMiLCJzcmMvaW1hZ2UvdXRpbGl0eS9jb3B5LmpzIiwic3JjL2ltYWdlL3V0aWxpdHkvZ2V0QmVzdE1hdGNoLmpzIiwic3JjL2ltYWdlL3V0aWxpdHkvZ2V0Q2hhbm5lbC5qcyIsInNyYy9pbWFnZS91dGlsaXR5L2dldENvbHVtbi5qcyIsInNyYy9pbWFnZS91dGlsaXR5L2dldFBpeGVsc0dyaWQuanMiLCJzcmMvaW1hZ2UvdXRpbGl0eS9nZXRSb3cuanMiLCJzcmMvaW1hZ2UvdXRpbGl0eS9nZXRTaW1pbGFyaXR5LmpzIiwic3JjL2ltYWdlL3V0aWxpdHkvc2V0Qm9yZGVyLmpzIiwic3JjL2ltYWdlL3V0aWxpdHkvc2V0Q2hhbm5lbC5qcyIsInNyYy9pbWFnZS91dGlsaXR5L3NwbGl0LmpzIiwic3JjL2luZGV4LmpzIiwic3JjL3N0YWNrL2NvbXB1dGUvaGlzdG9ncmFtLmpzIiwic3JjL3N0YWNrL2NvbXB1dGUvaGlzdG9ncmFtcy5qcyIsInNyYy9zdGFjay9jb21wdXRlL21heC5qcyIsInNyYy9zdGFjay9jb21wdXRlL21lZGlhbi5qcyIsInNyYy9zdGFjay9jb21wdXRlL21pbi5qcyIsInNyYy9zdGFjay9leHRlbmQuanMiLCJzcmMvc3RhY2svc3RhY2suanMiLCJzcmMvc3RhY2svdHJhbnNmb3JtL21hdGNoQW5kQ3JvcC5qcyIsInNyYy9zdGFjay91dGlsaXR5L2F2ZXJhZ2UuanMiLCJzcmMvdXRpbC9jaGFubmVsLmpzIiwic3JjL3V0aWwvY29udmVydGVyLmpzIiwic3JjL3V0aWwvaGlzdG9ncmFtLmpzIiwic3JjL3V0aWwva2VybmVsLmpzIiwic3JjL3V0aWwva2VybmVscy5qcyIsInNyYy91dGlsL21hdHJpeC5qcyIsInNyYy91dGlsL3NoYXBlLmpzIiwic3JjL3V0aWwvdmFsdWUuanMiLCJzcmMvd29ya2VyL2V4dGVuZC5qcyIsInNyYy93b3JrZXIvcHJvY2Vzcy9iYWNrZ3JvdW5kLmpzIiwic3JjL3dvcmtlci93b3JrZXIuanMiLCJ0ZXN0L2Jyb3dzZXIvYm9vdHN0cmFwLmpzIiwidGVzdC9pbWdMaXN0Lmpzb24iLCJ0ZXN0L3Rlc3QuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7OztBQ0FBLE9BQU8sT0FBUCxHQUFpQixTQUFTLEtBQVQsQ0FBZSxHQUFmLEVBQW9CO0FBQ25DLFNBQU8sS0FBSyxHQUFMLENBQVA7QUFDRCxDQUZEOzs7QUNBQTtBQUNBOztBQ0RBOztBQUVBLElBQUksU0FBUyxPQUFPLFNBQVAsQ0FBaUIsY0FBOUI7QUFDQSxJQUFJLFFBQVEsT0FBTyxTQUFQLENBQWlCLFFBQTdCOztBQUVBLElBQUksVUFBVSxTQUFTLE9BQVQsQ0FBaUIsR0FBakIsRUFBc0I7QUFDbkMsS0FBSSxPQUFPLE1BQU0sT0FBYixLQUF5QixVQUE3QixFQUF5QztBQUN4QyxTQUFPLE1BQU0sT0FBTixDQUFjLEdBQWQsQ0FBUDtBQUNBOztBQUVELFFBQU8sTUFBTSxJQUFOLENBQVcsR0FBWCxNQUFvQixnQkFBM0I7QUFDQSxDQU5EOztBQVFBLElBQUksZ0JBQWdCLFNBQVMsYUFBVCxDQUF1QixHQUF2QixFQUE0QjtBQUMvQyxLQUFJLENBQUMsR0FBRCxJQUFRLE1BQU0sSUFBTixDQUFXLEdBQVgsTUFBb0IsaUJBQWhDLEVBQW1EO0FBQ2xELFNBQU8sS0FBUDtBQUNBOztBQUVELEtBQUksb0JBQW9CLE9BQU8sSUFBUCxDQUFZLEdBQVosRUFBaUIsYUFBakIsQ0FBeEI7QUFDQSxLQUFJLG1CQUFtQixJQUFJLFdBQUosSUFBbUIsSUFBSSxXQUFKLENBQWdCLFNBQW5DLElBQWdELE9BQU8sSUFBUCxDQUFZLElBQUksV0FBSixDQUFnQixTQUE1QixFQUF1QyxlQUF2QyxDQUF2RTs7QUFFQSxLQUFJLElBQUksV0FBSixJQUFtQixDQUFDLGlCQUFwQixJQUF5QyxDQUFDLGdCQUE5QyxFQUFnRTtBQUMvRCxTQUFPLEtBQVA7QUFDQTs7OztBQUlELEtBQUksR0FBSjtBQUNBLE1BQUssR0FBTCxJQUFZLEdBQVosRUFBaUIsQyxJQUFNOztBQUV2QixRQUFPLE9BQU8sR0FBUCxLQUFlLFdBQWYsSUFBOEIsT0FBTyxJQUFQLENBQVksR0FBWixFQUFpQixHQUFqQixDQUFyQztBQUNBLENBbEJEOztBQW9CQSxPQUFPLE9BQVAsR0FBaUIsU0FBUyxNQUFULEdBQWtCO0FBQ2xDLEtBQUksT0FBSjtBQUFBLEtBQWEsSUFBYjtBQUFBLEtBQW1CLEdBQW5CO0FBQUEsS0FBd0IsSUFBeEI7QUFBQSxLQUE4QixXQUE5QjtBQUFBLEtBQTJDLEtBQTNDO0FBQUEsS0FDQyxTQUFTLFVBQVUsQ0FBVixDQURWO0FBQUEsS0FFQyxJQUFJLENBRkw7QUFBQSxLQUdDLFNBQVMsVUFBVSxNQUhwQjtBQUFBLEtBSUMsT0FBTyxLQUpSOzs7QUFPQSxLQUFJLE9BQU8sTUFBUCxLQUFrQixTQUF0QixFQUFpQztBQUNoQyxTQUFPLE1BQVA7QUFDQSxXQUFTLFVBQVUsQ0FBVixLQUFnQixFQUF6Qjs7QUFFQSxNQUFJLENBQUo7QUFDQSxFQUxELE1BS08sSUFBSyxPQUFPLE1BQVAsS0FBa0IsUUFBbEIsSUFBOEIsT0FBTyxNQUFQLEtBQWtCLFVBQWpELElBQWdFLFVBQVUsSUFBOUUsRUFBb0Y7QUFDMUYsV0FBUyxFQUFUO0FBQ0E7O0FBRUQsUUFBTyxJQUFJLE1BQVgsRUFBbUIsRUFBRSxDQUFyQixFQUF3QjtBQUN2QixZQUFVLFVBQVUsQ0FBVixDQUFWOztBQUVBLE1BQUksV0FBVyxJQUFmLEVBQXFCOztBQUVwQixRQUFLLElBQUwsSUFBYSxPQUFiLEVBQXNCO0FBQ3JCLFVBQU0sT0FBTyxJQUFQLENBQU47QUFDQSxXQUFPLFFBQVEsSUFBUixDQUFQOzs7QUFHQSxRQUFJLFdBQVcsSUFBZixFQUFxQjs7QUFFcEIsU0FBSSxRQUFRLElBQVIsS0FBaUIsY0FBYyxJQUFkLE1BQXdCLGNBQWMsUUFBUSxJQUFSLENBQXRDLENBQWpCLENBQUosRUFBNEU7QUFDM0UsVUFBSSxXQUFKLEVBQWlCO0FBQ2hCLHFCQUFjLEtBQWQ7QUFDQSxlQUFRLE9BQU8sUUFBUSxHQUFSLENBQVAsR0FBc0IsR0FBdEIsR0FBNEIsRUFBcEM7QUFDQSxPQUhELE1BR087QUFDTixlQUFRLE9BQU8sY0FBYyxHQUFkLENBQVAsR0FBNEIsR0FBNUIsR0FBa0MsRUFBMUM7QUFDQTs7O0FBR0QsYUFBTyxJQUFQLElBQWUsT0FBTyxJQUFQLEVBQWEsS0FBYixFQUFvQixJQUFwQixDQUFmOzs7QUFHQSxNQVpELE1BWU8sSUFBSSxPQUFPLElBQVAsS0FBZ0IsV0FBcEIsRUFBaUM7QUFDdkMsYUFBTyxJQUFQLElBQWUsSUFBZjtBQUNBO0FBQ0Q7QUFDRDtBQUNEO0FBQ0Q7OztBQUdELFFBQU8sTUFBUDtBQUNBLENBbkREOzs7QUNqQ0E7O0FBRUEsSUFBTSxXQUFXLFFBQVEsVUFBUixDQUFqQjtBQUNBLElBQU0sV0FBVyxRQUFRLE1BQVIsRUFBZ0IsT0FBakM7O0FBRUEsSUFBTSxRQUFRLElBQUksVUFBSixDQUFlLENBQWYsQ0FBZDtBQUNBLElBQU0sT0FBTyxJQUFiO0FBQ0EsSUFBTSxlQUFlLENBQUMsR0FBRCxFQUFNLEVBQU4sRUFBVSxFQUFWLEVBQWMsRUFBZCxFQUFrQixFQUFsQixFQUFzQixFQUF0QixFQUEwQixFQUExQixFQUE4QixFQUE5QixDQUFyQjs7QUFFQSxNQUFNLFVBQU4sU0FBeUIsUUFBekIsQ0FBa0M7QUFDOUIsZ0JBQVksSUFBWixFQUFrQjtBQUNkLGNBQU0sSUFBTjtBQUNBLGFBQUssUUFBTCxHQUFnQixLQUFoQjtBQUNBLGFBQUssU0FBTCxHQUFpQixJQUFJLFFBQUosRUFBakI7QUFDQSxhQUFLLElBQUwsR0FBWSxJQUFaO0FBQ0EsYUFBSyxJQUFMLEdBQVksS0FBWjs7O0FBR0EsYUFBSyxZQUFMO0FBQ0g7O0FBRUQsYUFBUztBQUNMLFlBQUksS0FBSyxRQUFULEVBQW1CLE9BQU8sS0FBSyxJQUFaO0FBQ25CLGFBQUssSUFBTCxHQUFZO0FBQ1Isa0JBQU07QUFERSxTQUFaO0FBR0EsYUFBSyxlQUFMO0FBQ0EsZUFBTyxDQUFDLEtBQUssSUFBYixFQUFtQjtBQUNmLGlCQUFLLFdBQUw7QUFDSDtBQUNELGFBQUssV0FBTDtBQUNBLGVBQU8sS0FBSyxJQUFaO0FBQ0g7OztBQUdELHNCQUFrQjtBQUNkLGFBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxDQUFwQixFQUF1QixHQUF2QixFQUE0QjtBQUN4QixnQkFBSSxLQUFLLFNBQUwsT0FBcUIsYUFBYSxDQUFiLENBQXpCLEVBQTBDO0FBQ3RDLHNCQUFNLElBQUksS0FBSixDQUFXLGlDQUErQixDQUFFLGdCQUFhLGFBQWEsQ0FBYixDQUFnQixJQUF6RSxDQUFOO0FBQ0g7QUFDSjtBQUNKOzs7QUFHRCxrQkFBYztBQUNWLFlBQUksU0FBUyxLQUFLLFVBQUwsRUFBYjtBQUNBLFlBQUksT0FBTyxLQUFLLFNBQUwsQ0FBZSxDQUFmLENBQVg7QUFDQSxZQUFJLFNBQVMsS0FBSyxNQUFsQjtBQUNBLGdCQUFRLElBQVI7QUFDSSxpQkFBSyxNQUFMO0FBQ0kscUJBQUssVUFBTDtBQUNBO0FBQ0osaUJBQUssTUFBTDtBQUNJLHFCQUFLLFVBQUwsQ0FBZ0IsTUFBaEI7QUFDQTtBQUNKLGlCQUFLLE1BQUw7QUFDSSxxQkFBSyxVQUFMLENBQWdCLE1BQWhCO0FBQ0E7QUFDSixpQkFBSyxNQUFMO0FBQ0kscUJBQUssVUFBTCxDQUFnQixNQUFoQjtBQUNBO0FBQ0osaUJBQUssTUFBTDtBQUNJLHFCQUFLLElBQUwsR0FBWSxJQUFaO0FBQ0E7QUFDSjtBQUNJLHFCQUFLLElBQUwsQ0FBVSxNQUFWO0FBQ0E7QUFsQlI7QUFvQkEsWUFBSSxLQUFLLE1BQUwsR0FBYyxNQUFkLEtBQXlCLE1BQTdCLEVBQXFDO0FBQ2pDLGtCQUFNLElBQUksS0FBSixDQUFVLDBDQUEwQyxJQUFwRCxDQUFOO0FBQ0g7OztBQUdELFlBQUksTUFBTSxLQUFLLFVBQUwsRUFBVjtBQUNIOzs7QUFHRCxpQkFBYTtBQUNULFlBQUksUUFBUSxLQUFLLElBQWpCO0FBQ0EsY0FBTSxLQUFOLEdBQWMsS0FBSyxVQUFMLEVBQWQ7QUFDQSxjQUFNLE1BQU4sR0FBZSxLQUFLLFVBQUwsRUFBZjtBQUNBLGNBQU0sUUFBTixHQUFpQixLQUFLLFNBQUwsRUFBakI7QUFDQSxjQUFNLFVBQU4sR0FBbUIsS0FBSyxTQUFMLEVBQW5CO0FBQ0EsY0FBTSxpQkFBTixHQUEwQixLQUFLLFNBQUwsRUFBMUI7QUFDQSxjQUFNLFlBQU4sR0FBcUIsS0FBSyxTQUFMLEVBQXJCO0FBQ0EsY0FBTSxlQUFOLEdBQXdCLEtBQUssU0FBTCxFQUF4QjtBQUNBLFlBQUksS0FBSyxJQUFMLENBQVUsaUJBQVYsS0FBZ0MsQ0FBcEMsRUFBdUM7QUFDbkMsa0JBQU0sSUFBSSxLQUFKLENBQVUscUNBQXFDLE1BQU0saUJBQXJELENBQU47QUFDSDtBQUNKOzs7QUFHRCxlQUFXLE1BQVgsRUFBbUI7QUFDZixZQUFJLFNBQVMsQ0FBVCxLQUFlLENBQW5CLEVBQXNCO0FBQ2xCLGtCQUFNLElBQUksVUFBSixDQUFlLG9EQUFvRCxNQUFuRSxDQUFOO0FBQ0g7QUFDRCxZQUFJLElBQUksU0FBUyxDQUFqQjtBQUNBLGFBQUssV0FBTCxHQUFtQixJQUFuQjtBQUNBLFlBQUksVUFBVSxLQUFLLFFBQUwsR0FBZ0IsSUFBSSxLQUFKLENBQVUsQ0FBVixDQUE5QjtBQUNBLGFBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxDQUFwQixFQUF1QixHQUF2QixFQUE0QjtBQUN4QixvQkFBUSxDQUFSLElBQWEsQ0FBQyxLQUFLLFNBQUwsRUFBRCxFQUFtQixLQUFLLFNBQUwsRUFBbkIsRUFBcUMsS0FBSyxTQUFMLEVBQXJDLENBQWI7QUFDSDtBQUNKOzs7QUFHRCxlQUFXLE1BQVgsRUFBbUI7QUFDZixhQUFLLFNBQUwsQ0FBZSxJQUFmLENBQW9CLElBQUksVUFBSixDQUFlLEtBQUssTUFBcEIsRUFBNEIsS0FBSyxNQUFqQyxFQUF5QyxNQUF6QyxDQUFwQjtBQUNBLGFBQUssSUFBTCxDQUFVLE1BQVY7QUFDSDs7O0FBR0QsZUFBVyxNQUFYLEVBQW1CO0FBQ2YsWUFBSSxVQUFVLEVBQWQ7QUFDQSxZQUFJLElBQUo7QUFDQSxlQUFPLENBQUMsT0FBTyxLQUFLLFFBQUwsRUFBUixNQUE2QixJQUFwQyxFQUEwQztBQUN0Qyx1QkFBVyxJQUFYO0FBQ0g7QUFDRCxhQUFLLElBQUwsQ0FBVSxJQUFWLENBQWUsT0FBZixJQUEwQixLQUFLLFNBQUwsQ0FBZSxTQUFTLFFBQVEsTUFBakIsR0FBMEIsQ0FBekMsQ0FBMUI7QUFDSDs7QUFFRCxrQkFBYztBQUNWLGFBQUssU0FBTCxDQUFlLElBQWYsQ0FBb0IsS0FBcEIsRUFBMkIsSUFBM0I7QUFDQSxZQUFJLEtBQUssU0FBTCxDQUFlLEdBQW5CLEVBQXdCO0FBQ3BCLGtCQUFNLElBQUksS0FBSixDQUFVLG9DQUFWLENBQU47QUFDSDtBQUNELFlBQUksT0FBTyxLQUFLLFNBQUwsQ0FBZSxNQUExQjtBQUNBLGFBQUssU0FBTCxHQUFpQixJQUFqQjs7QUFFQSxZQUFJLEtBQUssSUFBTCxDQUFVLFlBQVYsS0FBMkIsQ0FBL0IsRUFBa0M7QUFDOUIsa0JBQU0sSUFBSSxLQUFKLENBQVUsbUJBQW1CLEtBQUssSUFBTCxDQUFVLFlBQTdCLEdBQTRDLGdCQUF0RCxDQUFOO0FBQ0g7O0FBRUQsWUFBSSxLQUFLLElBQUwsQ0FBVSxlQUFWLEtBQThCLENBQWxDLEVBQXFDO0FBQ2pDLGlCQUFLLG1CQUFMLENBQXlCLElBQXpCO0FBQ0gsU0FGRCxNQUVPO0FBQ0gsa0JBQU0sSUFBSSxLQUFKLENBQVUsc0JBQXNCLEtBQUssSUFBTCxDQUFVLGVBQWhDLEdBQWtELGdCQUE1RCxDQUFOO0FBQ0g7QUFDSjs7QUFFRCx3QkFBb0IsSUFBcEIsRUFBMEI7O0FBRXRCLFlBQUksUUFBSjtBQUNBLGdCQUFRLEtBQUssSUFBTCxDQUFVLFVBQWxCO0FBQ0ksaUJBQUssQ0FBTDtBQUFRLDJCQUFXLENBQVgsQ0FBYztBQUN0QixpQkFBSyxDQUFMO0FBQVEsMkJBQVcsQ0FBWCxDQUFjO0FBQ3RCLGlCQUFLLENBQUw7QUFDSSxvQkFBSSxDQUFDLEtBQUssV0FBVixFQUF1QixNQUFNLElBQUksS0FBSixDQUFVLGlCQUFWLENBQU47QUFDdkIsMkJBQVcsQ0FBWDtBQUNBO0FBQ0osaUJBQUssQ0FBTDtBQUFRLDJCQUFXLENBQVgsQ0FBYztBQUN0QixpQkFBSyxDQUFMO0FBQVEsMkJBQVcsQ0FBWCxDQUFjO0FBQ3RCO0FBQVMsc0JBQU0sSUFBSSxLQUFKLENBQVUsMEJBQTBCLEtBQUssSUFBTCxDQUFVLFVBQTlDLENBQU47QUFUYjs7QUFZQSxZQUFNLFNBQVMsS0FBSyxJQUFMLENBQVUsTUFBekI7QUFDQSxZQUFNLGdCQUFnQixXQUFXLEtBQUssSUFBTCxDQUFVLFFBQXJCLEdBQWdDLENBQXREO0FBQ0EsWUFBTSxlQUFlLEtBQUssSUFBTCxDQUFVLEtBQVYsR0FBa0IsYUFBdkM7QUFDQSxZQUFNLFVBQVUsSUFBSSxVQUFKLENBQWUsS0FBSyxJQUFMLENBQVUsTUFBVixHQUFtQixZQUFsQyxDQUFoQjs7QUFFQSxZQUFJLFdBQVcsS0FBZjtBQUNBLFlBQUksU0FBUyxDQUFiO0FBQ0EsWUFBSSxXQUFKLEVBQWlCLE9BQWpCOztBQUVBLGFBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxNQUFwQixFQUE0QixHQUE1QixFQUFpQztBQUM3QiwwQkFBYyxLQUFLLFFBQUwsQ0FBYyxTQUFTLENBQXZCLEVBQTBCLFNBQVMsQ0FBVCxHQUFhLFlBQXZDLENBQWQ7QUFDQSxzQkFBVSxRQUFRLFFBQVIsQ0FBaUIsSUFBSSxZQUFyQixFQUFtQyxDQUFDLElBQUksQ0FBTCxJQUFVLFlBQTdDLENBQVY7QUFDQSxvQkFBUSxLQUFLLE1BQUwsQ0FBUjtBQUNJLHFCQUFLLENBQUw7QUFDSSxpQ0FBYSxXQUFiLEVBQTBCLE9BQTFCLEVBQW1DLFlBQW5DO0FBQ0E7QUFDSixxQkFBSyxDQUFMO0FBQ0ksZ0NBQVksV0FBWixFQUF5QixPQUF6QixFQUFrQyxZQUFsQyxFQUFnRCxhQUFoRDtBQUNBO0FBQ0oscUJBQUssQ0FBTDtBQUNJLCtCQUFXLFdBQVgsRUFBd0IsT0FBeEIsRUFBaUMsUUFBakMsRUFBMkMsWUFBM0M7QUFDQTtBQUNKLHFCQUFLLENBQUw7QUFDSSxvQ0FBZ0IsV0FBaEIsRUFBNkIsT0FBN0IsRUFBc0MsUUFBdEMsRUFBZ0QsWUFBaEQsRUFBOEQsYUFBOUQ7QUFDQTtBQUNKLHFCQUFLLENBQUw7QUFDSSxrQ0FBYyxXQUFkLEVBQTJCLE9BQTNCLEVBQW9DLFFBQXBDLEVBQThDLFlBQTlDLEVBQTRELGFBQTVEO0FBQ0E7QUFDSjtBQUFTLDBCQUFNLElBQUksS0FBSixDQUFVLHlCQUF5QixLQUFLLE1BQUwsQ0FBbkMsQ0FBTjtBQWhCYjtBQWtCQSx1QkFBVyxPQUFYO0FBQ0Esc0JBQVUsZUFBZSxDQUF6QjtBQUNIOztBQUVELFlBQUksS0FBSyxXQUFULEVBQXNCO0FBQ2xCLGlCQUFLLElBQUwsQ0FBVSxPQUFWLEdBQW9CLEtBQUssUUFBekI7QUFDSDtBQUNELGFBQUssSUFBTCxDQUFVLElBQVYsR0FBaUIsT0FBakI7QUFDSDs7QUF2TDZCOztBQTRMbEMsT0FBTyxPQUFQLEdBQWlCLFVBQWpCOztBQUVBLFNBQVMsWUFBVCxDQUFzQixXQUF0QixFQUFtQyxPQUFuQyxFQUE0QyxZQUE1QyxFQUEwRDtBQUN0RCxTQUFJLElBQUksSUFBSSxDQUFaLEVBQWUsSUFBSSxZQUFuQixFQUFpQyxHQUFqQyxFQUFzQztBQUNsQyxnQkFBUSxDQUFSLElBQWEsWUFBWSxDQUFaLENBQWI7QUFDSDtBQUNKOztBQUVELFNBQVMsV0FBVCxDQUFxQixXQUFyQixFQUFrQyxPQUFsQyxFQUEyQyxZQUEzQyxFQUF5RCxhQUF6RCxFQUF3RTtBQUNwRSxRQUFJLElBQUksQ0FBUjtBQUNBLFdBQU8sSUFBSSxhQUFYLEVBQTBCLEdBQTFCLEVBQStCOztBQUUzQixnQkFBUSxDQUFSLElBQWEsWUFBWSxDQUFaLENBQWI7QUFDSDtBQUNELFdBQU0sSUFBSSxZQUFWLEVBQXdCLEdBQXhCLEVBQTZCO0FBQ3pCLGdCQUFRLENBQVIsSUFBYyxZQUFZLENBQVosSUFBaUIsUUFBUSxJQUFJLGFBQVosQ0FBbEIsR0FBOEMsSUFBM0Q7QUFDSDtBQUNKOztBQUVELFNBQVMsVUFBVCxDQUFvQixXQUFwQixFQUFpQyxPQUFqQyxFQUEwQyxRQUExQyxFQUFvRCxZQUFwRCxFQUFrRTtBQUM5RCxRQUFJLElBQUksQ0FBUjtBQUNBLFFBQUksU0FBUyxNQUFULEtBQW9CLENBQXhCLEVBQTJCOztBQUV2QixlQUFPLElBQUksWUFBWCxFQUF5QixHQUF6QixFQUE4QjtBQUMxQixvQkFBUSxDQUFSLElBQWEsWUFBWSxDQUFaLENBQWI7QUFDSDtBQUNKLEtBTEQsTUFLTztBQUNILGVBQU8sSUFBSSxZQUFYLEVBQXlCLEdBQXpCLEVBQThCO0FBQzFCLG9CQUFRLENBQVIsSUFBYyxZQUFZLENBQVosSUFBaUIsU0FBUyxDQUFULENBQWxCLEdBQWlDLElBQTlDO0FBQ0g7QUFDSjtBQUNKOztBQUVELFNBQVMsZUFBVCxDQUF5QixXQUF6QixFQUFzQyxPQUF0QyxFQUErQyxRQUEvQyxFQUF5RCxZQUF6RCxFQUF1RSxhQUF2RSxFQUFzRjtBQUNsRixRQUFJLElBQUksQ0FBUjtBQUNBLFFBQUksU0FBUyxNQUFULEtBQW9CLENBQXhCLEVBQTJCO0FBQ3ZCLGVBQU8sSUFBSSxhQUFYLEVBQTBCLEdBQTFCLEVBQStCO0FBQzNCLG9CQUFRLENBQVIsSUFBYSxZQUFZLENBQVosQ0FBYjtBQUNIO0FBQ0QsZUFBTyxJQUFJLFlBQVgsRUFBeUIsR0FBekIsRUFBOEI7QUFDMUIsb0JBQVEsQ0FBUixJQUFjLFlBQVksQ0FBWixLQUFrQixRQUFRLElBQUksYUFBWixLQUE0QixDQUE5QyxDQUFELEdBQW1ELElBQWhFO0FBQ0g7QUFDSixLQVBELE1BT087QUFDSCxlQUFPLElBQUksYUFBWCxFQUEwQixHQUExQixFQUErQjtBQUMzQixvQkFBUSxDQUFSLElBQWMsWUFBWSxDQUFaLEtBQWtCLFNBQVMsQ0FBVCxLQUFhLENBQS9CLENBQUQsR0FBb0MsSUFBakQ7QUFDSDtBQUNELGVBQU8sSUFBSSxZQUFYLEVBQXlCLEdBQXpCLEVBQThCO0FBQzFCLG9CQUFRLENBQVIsSUFBYyxZQUFZLENBQVosS0FBbUIsUUFBUSxJQUFJLGFBQVosSUFBNkIsU0FBUyxDQUFULENBQTlCLElBQTRDLENBQTlELENBQUQsR0FBbUUsSUFBaEY7QUFDSDtBQUNKO0FBQ0o7O0FBRUQsU0FBUyxhQUFULENBQXVCLFdBQXZCLEVBQW9DLE9BQXBDLEVBQTZDLFFBQTdDLEVBQXVELFlBQXZELEVBQXFFLGFBQXJFLEVBQW9GO0FBQ2hGLFFBQUksSUFBSSxDQUFSO0FBQ0EsUUFBSSxTQUFTLE1BQVQsS0FBb0IsQ0FBeEIsRUFBMkI7QUFDdkIsZUFBTyxJQUFJLGFBQVgsRUFBMEIsR0FBMUIsRUFBK0I7QUFDM0Isb0JBQVEsQ0FBUixJQUFhLFlBQVksQ0FBWixDQUFiO0FBQ0g7QUFDRCxlQUFNLElBQUksWUFBVixFQUF3QixHQUF4QixFQUE2QjtBQUN6QixvQkFBUSxDQUFSLElBQWMsWUFBWSxDQUFaLElBQWlCLFFBQVEsSUFBSSxhQUFaLENBQWxCLEdBQThDLElBQTNEO0FBQ0g7QUFDSixLQVBELE1BT087QUFDSCxlQUFPLElBQUksYUFBWCxFQUEwQixHQUExQixFQUErQjtBQUMzQixvQkFBUSxDQUFSLElBQWMsWUFBWSxDQUFaLElBQWlCLFNBQVMsQ0FBVCxDQUFsQixHQUErQixJQUE1QztBQUNIO0FBQ0QsZUFBTSxJQUFJLFlBQVYsRUFBd0IsR0FBeEIsRUFBNkI7QUFDekIsb0JBQVEsQ0FBUixJQUFjLFlBQVksQ0FBWixJQUFpQixlQUFlLFFBQVEsSUFBSSxhQUFaLENBQWYsRUFBMkMsU0FBUyxDQUFULENBQTNDLEVBQXdELFNBQVMsSUFBSSxhQUFiLENBQXhELENBQWxCLEdBQXdHLElBQXJIO0FBQ0g7QUFDSjtBQUNKOztBQUVELFNBQVMsY0FBVCxDQUF3QixDQUF4QixFQUEyQixDQUEzQixFQUE4QixDQUE5QixFQUFpQztBQUM3QixRQUFJLElBQUksSUFBSSxDQUFKLEdBQVEsQ0FBaEI7QUFDQSxRQUFJLEtBQUssS0FBSyxHQUFMLENBQVMsSUFBSSxDQUFiLENBQVQ7QUFDQSxRQUFJLEtBQUssS0FBSyxHQUFMLENBQVMsSUFBSSxDQUFiLENBQVQ7QUFDQSxRQUFJLEtBQUssS0FBSyxHQUFMLENBQVMsSUFBSSxDQUFiLENBQVQ7QUFDQSxRQUFJLE1BQU0sRUFBTixJQUFZLE1BQU0sRUFBdEIsRUFBMEIsT0FBTyxDQUFQLENBQTFCLEtBQ0ssSUFBSSxNQUFNLEVBQVYsRUFBYyxPQUFPLENBQVAsQ0FBZCxLQUNBLE9BQU8sQ0FBUDtBQUNSOzs7QUNwUkQ7O0FBRUEsUUFBUSxVQUFSLEdBQXFCLFFBQVEsY0FBUixDQUFyQjs7Ozs7QUNGQSxJQUFJLE9BQU8sT0FBTyxNQUFkLEtBQXlCLFVBQTdCLEVBQXlDOztBQUV2QyxTQUFPLE9BQVAsR0FBaUIsU0FBUyxRQUFULENBQWtCLElBQWxCLEVBQXdCLFNBQXhCLEVBQW1DO0FBQ2xELFNBQUssTUFBTCxHQUFjLFNBQWQ7QUFDQSxTQUFLLFNBQUwsR0FBaUIsT0FBTyxNQUFQLENBQWMsVUFBVSxTQUF4QixFQUFtQztBQUNsRCxtQkFBYTtBQUNYLGVBQU8sSUFESTtBQUVYLG9CQUFZLEtBRkQ7QUFHWCxrQkFBVSxJQUhDO0FBSVgsc0JBQWM7QUFKSDtBQURxQyxLQUFuQyxDQUFqQjtBQVFELEdBVkQ7QUFXRCxDQWJELE1BYU87O0FBRUwsU0FBTyxPQUFQLEdBQWlCLFNBQVMsUUFBVCxDQUFrQixJQUFsQixFQUF3QixTQUF4QixFQUFtQztBQUNsRCxTQUFLLE1BQUwsR0FBYyxTQUFkO0FBQ0EsUUFBSSxXQUFXLFNBQVgsUUFBVyxHQUFZLENBQUUsQ0FBN0I7QUFDQSxhQUFTLFNBQVQsR0FBcUIsVUFBVSxTQUEvQjtBQUNBLFNBQUssU0FBTCxHQUFpQixJQUFJLFFBQUosRUFBakI7QUFDQSxTQUFLLFNBQUwsQ0FBZSxXQUFmLEdBQTZCLElBQTdCO0FBQ0QsR0FORDtBQU9EOzs7QUN0QkQ7O0FBRUEsSUFBTSxvQkFBb0IsT0FBTyxDQUFqQztBQUNBLElBQU0sWUFBWSxFQUFsQjs7QUFFQSxNQUFNLFFBQU4sQ0FBZTtBQUNYLGdCQUFZLElBQVosRUFBa0I7QUFDZCxZQUFJLFNBQVMsQ0FBYjtBQUNBLFlBQUksU0FBUyxTQUFiLEVBQXdCO0FBQ3BCLG1CQUFPLGlCQUFQO0FBQ0g7QUFDRCxZQUFJLE9BQU8sSUFBUCxLQUFnQixRQUFwQixFQUE4QjtBQUMxQixxQkFBUyxJQUFUO0FBQ0EsbUJBQU8sSUFBSSxXQUFKLENBQWdCLElBQWhCLENBQVA7QUFDSDtBQUNELGlCQUFTLEtBQUssVUFBZDtBQUNBLFlBQUksS0FBSyxNQUFULEVBQWlCO0FBQ2IscUJBQVMsS0FBSyxVQUFkO0FBQ0EsZ0JBQUksS0FBSyxVQUFMLEtBQW9CLEtBQUssTUFBTCxDQUFZLFVBQXBDLEVBQWdEOztBQUM1Qyx1QkFBTyxLQUFLLE1BQUwsQ0FBWSxLQUFaLENBQWtCLEtBQUssVUFBdkIsRUFBbUMsS0FBSyxVQUFMLEdBQWtCLEtBQUssVUFBMUQsQ0FBUDtBQUNILGFBRkQsTUFFTztBQUNILHVCQUFPLEtBQUssTUFBWjtBQUNIO0FBQ0o7QUFDRCxhQUFLLE1BQUwsR0FBYyxJQUFkO0FBQ0EsYUFBSyxNQUFMLEdBQWMsTUFBZDtBQUNBLGFBQUssTUFBTCxHQUFjLENBQWQ7QUFDQSxhQUFLLFlBQUwsR0FBb0IsSUFBcEI7QUFDQSxhQUFLLEtBQUwsR0FBYSxJQUFJLFFBQUosQ0FBYSxLQUFLLE1BQWxCLENBQWI7QUFDQSxhQUFLLFVBQUwsR0FBa0IsVUFBVSxpQkFBNUI7QUFDQSxhQUFLLEtBQUwsR0FBYSxDQUFiO0FBQ0g7O0FBRUQsY0FBVSxVQUFWLEVBQXNCO0FBQ2xCLFlBQUksZUFBZSxTQUFuQixFQUE4QixhQUFhLENBQWI7QUFDOUIsZUFBUSxLQUFLLE1BQUwsR0FBYyxVQUFmLElBQThCLEtBQUssTUFBMUM7QUFDSDs7QUFFRCxxQkFBaUI7QUFDYixlQUFPLEtBQUssWUFBWjtBQUNIOztBQUVELHNCQUFrQjtBQUNkLGFBQUssWUFBTCxHQUFvQixJQUFwQjtBQUNIOztBQUVELGtCQUFjO0FBQ1YsZUFBTyxDQUFDLEtBQUssWUFBYjtBQUNIOztBQUVELG1CQUFlO0FBQ1gsYUFBSyxZQUFMLEdBQW9CLEtBQXBCO0FBQ0g7O0FBRUQsU0FBSyxDQUFMLEVBQVE7QUFDSixZQUFJLE1BQU0sU0FBVixFQUFxQixJQUFJLENBQUo7QUFDckIsYUFBSyxNQUFMLElBQWUsQ0FBZjtBQUNIOztBQUVELFNBQUssTUFBTCxFQUFhO0FBQ1QsYUFBSyxNQUFMLEdBQWMsTUFBZDtBQUNIOztBQUVELFdBQU87QUFDSCxhQUFLLEtBQUwsR0FBYSxLQUFLLE1BQWxCO0FBQ0g7O0FBRUQsWUFBUTtBQUNKLGFBQUssTUFBTCxHQUFjLEtBQUssS0FBbkI7QUFDSDs7QUFFRCxhQUFTO0FBQ0wsYUFBSyxNQUFMLEdBQWMsQ0FBZDtBQUNIOztBQUVELG9CQUFnQixVQUFoQixFQUE0QjtBQUN4QixZQUFJLGVBQWUsU0FBbkIsRUFBOEIsYUFBYSxDQUFiO0FBQzlCLFlBQUksQ0FBQyxLQUFLLFNBQUwsQ0FBZSxVQUFmLENBQUwsRUFBaUM7QUFDN0IsZ0JBQU0sZUFBZSxLQUFLLFVBQUwsR0FBa0IsS0FBSyxVQUE1QztBQUNBLGlCQUFLLFVBQUwsR0FBa0IsWUFBbEI7QUFDQSxnQkFBTSxZQUFZLEtBQUssTUFBTCxHQUFjLFlBQWhDO0FBQ0EsZ0JBQU0sV0FBVyxJQUFJLFVBQUosQ0FBZSxTQUFmLENBQWpCO0FBQ0EscUJBQVMsR0FBVCxDQUFhLElBQUksVUFBSixDQUFlLEtBQUssTUFBcEIsQ0FBYjtBQUNBLGlCQUFLLE1BQUwsR0FBYyxTQUFTLE1BQXZCO0FBQ0EsaUJBQUssTUFBTCxHQUFjLFNBQWQ7QUFDQSxpQkFBSyxLQUFMLEdBQWEsSUFBSSxRQUFKLENBQWEsS0FBSyxNQUFsQixDQUFiO0FBQ0g7QUFDSjs7QUFFRCxrQkFBYztBQUNWLGVBQU8sS0FBSyxTQUFMLE9BQXFCLENBQTVCO0FBQ0g7O0FBRUQsZUFBVztBQUNQLGVBQU8sS0FBSyxLQUFMLENBQVcsT0FBWCxDQUFtQixLQUFLLE1BQUwsRUFBbkIsQ0FBUDtBQUNIOztBQUVELGdCQUFZO0FBQ1IsZUFBTyxLQUFLLEtBQUwsQ0FBVyxRQUFYLENBQW9CLEtBQUssTUFBTCxFQUFwQixDQUFQO0FBQ0g7O0FBRUQsZUFBVztBQUNQLGVBQU8sS0FBSyxTQUFMLEVBQVA7QUFDSDs7QUFFRCxjQUFVLENBQVYsRUFBYTtBQUNULFlBQUksTUFBTSxTQUFWLEVBQXFCLElBQUksQ0FBSjtBQUNyQixZQUFJLFFBQVEsSUFBSSxVQUFKLENBQWUsQ0FBZixDQUFaO0FBQ0EsYUFBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLENBQXBCLEVBQXVCLEdBQXZCLEVBQTRCO0FBQ3hCLGtCQUFNLENBQU4sSUFBVyxLQUFLLFFBQUwsRUFBWDtBQUNIO0FBQ0QsZUFBTyxLQUFQO0FBQ0g7O0FBRUQsZ0JBQVk7QUFDUixZQUFJLFFBQVEsS0FBSyxLQUFMLENBQVcsUUFBWCxDQUFvQixLQUFLLE1BQXpCLEVBQWlDLEtBQUssWUFBdEMsQ0FBWjtBQUNBLGFBQUssTUFBTCxJQUFlLENBQWY7QUFDQSxlQUFPLEtBQVA7QUFDSDs7QUFFRCxpQkFBYTtBQUNULFlBQUksUUFBUSxLQUFLLEtBQUwsQ0FBVyxTQUFYLENBQXFCLEtBQUssTUFBMUIsRUFBa0MsS0FBSyxZQUF2QyxDQUFaO0FBQ0EsYUFBSyxNQUFMLElBQWUsQ0FBZjtBQUNBLGVBQU8sS0FBUDtBQUNIOztBQUVELGdCQUFZO0FBQ1IsWUFBSSxRQUFRLEtBQUssS0FBTCxDQUFXLFFBQVgsQ0FBb0IsS0FBSyxNQUF6QixFQUFpQyxLQUFLLFlBQXRDLENBQVo7QUFDQSxhQUFLLE1BQUwsSUFBZSxDQUFmO0FBQ0EsZUFBTyxLQUFQO0FBQ0g7O0FBRUQsaUJBQWE7QUFDVCxZQUFJLFFBQVEsS0FBSyxLQUFMLENBQVcsU0FBWCxDQUFxQixLQUFLLE1BQTFCLEVBQWtDLEtBQUssWUFBdkMsQ0FBWjtBQUNBLGFBQUssTUFBTCxJQUFlLENBQWY7QUFDQSxlQUFPLEtBQVA7QUFDSDs7QUFFRCxrQkFBYztBQUNWLFlBQUksUUFBUSxLQUFLLEtBQUwsQ0FBVyxVQUFYLENBQXNCLEtBQUssTUFBM0IsRUFBbUMsS0FBSyxZQUF4QyxDQUFaO0FBQ0EsYUFBSyxNQUFMLElBQWUsQ0FBZjtBQUNBLGVBQU8sS0FBUDtBQUNIOztBQUVELGtCQUFjO0FBQ1YsWUFBSSxRQUFRLEtBQUssS0FBTCxDQUFXLFVBQVgsQ0FBc0IsS0FBSyxNQUEzQixFQUFtQyxLQUFLLFlBQXhDLENBQVo7QUFDQSxhQUFLLE1BQUwsSUFBZSxDQUFmO0FBQ0EsZUFBTyxLQUFQO0FBQ0g7O0FBRUQsZUFBVztBQUNQLGVBQU8sT0FBTyxZQUFQLENBQW9CLEtBQUssUUFBTCxFQUFwQixDQUFQO0FBQ0g7O0FBRUQsY0FBVSxDQUFWLEVBQWE7QUFDVCxZQUFJLE1BQU0sU0FBVixFQUFxQixJQUFJLENBQUo7QUFDckIsa0JBQVUsTUFBVixHQUFtQixDQUFuQjtBQUNBLGFBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxDQUFwQixFQUF1QixHQUF2QixFQUE0QjtBQUN4QixzQkFBVSxDQUFWLElBQWUsS0FBSyxRQUFMLEVBQWY7QUFDSDtBQUNELGVBQU8sVUFBVSxJQUFWLENBQWUsRUFBZixDQUFQO0FBQ0g7O0FBRUQsaUJBQWEsSUFBYixFQUFtQjtBQUNmLGFBQUssVUFBTCxDQUFnQixPQUFPLElBQVAsR0FBYyxJQUE5QjtBQUNIOztBQUVELGNBQVUsS0FBVixFQUFpQjtBQUNiLGFBQUssZUFBTCxDQUFxQixDQUFyQjtBQUNBLGFBQUssS0FBTCxDQUFXLE9BQVgsQ0FBbUIsS0FBSyxNQUFMLEVBQW5CLEVBQWtDLEtBQWxDO0FBQ0g7O0FBRUQsZUFBVyxLQUFYLEVBQWtCO0FBQ2QsYUFBSyxlQUFMLENBQXFCLENBQXJCO0FBQ0EsYUFBSyxLQUFMLENBQVcsUUFBWCxDQUFvQixLQUFLLE1BQUwsRUFBcEIsRUFBbUMsS0FBbkM7QUFDSDs7QUFFRCxjQUFVLEtBQVYsRUFBaUI7QUFDYixhQUFLLFVBQUwsQ0FBZ0IsS0FBaEI7QUFDSDs7QUFFRCxlQUFXLEtBQVgsRUFBa0I7QUFDZCxhQUFLLGVBQUwsQ0FBcUIsTUFBTSxNQUEzQjtBQUNBLGFBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxNQUFNLE1BQTFCLEVBQWtDLEdBQWxDLEVBQXVDO0FBQ25DLGlCQUFLLEtBQUwsQ0FBVyxRQUFYLENBQW9CLEtBQUssTUFBTCxFQUFwQixFQUFtQyxNQUFNLENBQU4sQ0FBbkM7QUFDSDtBQUNKOztBQUVELGVBQVcsS0FBWCxFQUFrQjtBQUNkLGFBQUssZUFBTCxDQUFxQixDQUFyQjtBQUNBLGFBQUssS0FBTCxDQUFXLFFBQVgsQ0FBb0IsS0FBSyxNQUF6QixFQUFpQyxLQUFqQyxFQUF3QyxLQUFLLFlBQTdDO0FBQ0EsYUFBSyxNQUFMLElBQWUsQ0FBZjtBQUNIOztBQUVELGdCQUFZLEtBQVosRUFBbUI7QUFDZixhQUFLLGVBQUwsQ0FBcUIsQ0FBckI7QUFDQSxhQUFLLEtBQUwsQ0FBVyxTQUFYLENBQXFCLEtBQUssTUFBMUIsRUFBa0MsS0FBbEMsRUFBeUMsS0FBSyxZQUE5QztBQUNBLGFBQUssTUFBTCxJQUFlLENBQWY7QUFDSDs7QUFFRCxlQUFXLEtBQVgsRUFBa0I7QUFDZCxhQUFLLGVBQUwsQ0FBcUIsQ0FBckI7QUFDQSxhQUFLLEtBQUwsQ0FBVyxRQUFYLENBQW9CLEtBQUssTUFBekIsRUFBaUMsS0FBakMsRUFBd0MsS0FBSyxZQUE3QztBQUNBLGFBQUssTUFBTCxJQUFlLENBQWY7QUFDSDs7QUFFRCxnQkFBWSxLQUFaLEVBQW1CO0FBQ2YsYUFBSyxlQUFMLENBQXFCLENBQXJCO0FBQ0EsYUFBSyxLQUFMLENBQVcsU0FBWCxDQUFxQixLQUFLLE1BQTFCLEVBQWtDLEtBQWxDLEVBQXlDLEtBQUssWUFBOUM7QUFDQSxhQUFLLE1BQUwsSUFBZSxDQUFmO0FBQ0g7O0FBRUQsaUJBQWEsS0FBYixFQUFvQjtBQUNoQixhQUFLLGVBQUwsQ0FBcUIsQ0FBckI7QUFDQSxhQUFLLEtBQUwsQ0FBVyxVQUFYLENBQXNCLEtBQUssTUFBM0IsRUFBbUMsS0FBbkMsRUFBMEMsS0FBSyxZQUEvQztBQUNBLGFBQUssTUFBTCxJQUFlLENBQWY7QUFDSDs7QUFFRCxpQkFBYSxLQUFiLEVBQW9CO0FBQ2hCLGFBQUssZUFBTCxDQUFxQixDQUFyQjtBQUNBLGFBQUssS0FBTCxDQUFXLFVBQVgsQ0FBc0IsS0FBSyxNQUEzQixFQUFtQyxLQUFuQyxFQUEwQyxLQUFLLFlBQS9DO0FBQ0EsYUFBSyxNQUFMLElBQWUsQ0FBZjtBQUNIOztBQUVELGNBQVUsR0FBVixFQUFlO0FBQ1gsYUFBSyxVQUFMLENBQWdCLElBQUksVUFBSixDQUFlLENBQWYsQ0FBaEI7QUFDSDs7QUFFRCxlQUFXLEdBQVgsRUFBZ0I7QUFDWixhQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksSUFBSSxNQUF4QixFQUFnQyxHQUFoQyxFQUFxQztBQUNqQyxpQkFBSyxVQUFMLENBQWdCLElBQUksVUFBSixDQUFlLENBQWYsQ0FBaEI7QUFDSDtBQUNKOztBQUVELGNBQVU7QUFDTixlQUFPLElBQUksVUFBSixDQUFlLEtBQUssTUFBcEIsRUFBNEIsQ0FBNUIsRUFBK0IsS0FBSyxNQUFwQyxDQUFQO0FBQ0g7QUF2T1U7O0FBME9mLE9BQU8sT0FBUCxHQUFpQixRQUFqQjs7O0FDL09BOztBQUVBLElBQUksV0FBVyxPQUFPLFNBQVAsQ0FBaUIsUUFBaEM7O0FBRUEsT0FBTyxPQUFQLEdBQWlCLFNBQVMsV0FBVCxDQUFxQixLQUFyQixFQUE0QjtBQUN6QyxXQUFPLFNBQVMsSUFBVCxDQUFjLEtBQWQsRUFBcUIsTUFBckIsQ0FBNEIsQ0FBQyxDQUE3QixFQUFnQyxDQUFoQyxNQUF1QyxPQUE5QztBQUNILENBRkQ7OztBQ0pBOztBQUNBLElBQUksY0FBYyxRQUFRLGVBQVIsQ0FBbEI7O0FBRUEsT0FBTyxPQUFQLEdBQWlCLE9BQU8sUUFBUCxJQUFtQixVQUFVLEdBQVYsRUFBZTtBQUNsRCxRQUFPLEVBQUUsT0FBTyxHQUFQLEtBQWUsUUFBZixJQUEyQixZQUFZLEdBQVosQ0FBM0IsSUFBK0MsUUFBUSxRQUF2RCxJQUFtRSxRQUFRLENBQUMsUUFBOUUsQ0FBUDtBQUNBLENBRkQ7Ozs7Ozs7QUNEQSxJQUFJLFdBQVcsUUFBUSxXQUFSLENBQWY7QUFDQSxPQUFPLE9BQVAsR0FBaUIsT0FBTyxTQUFQLElBQW9CLFVBQVMsR0FBVCxFQUFjO0FBQ2pELFNBQU8sT0FBTyxHQUFQLEtBQWUsUUFBZixJQUNMLFNBQVMsR0FBVCxDQURLLElBRUwsS0FBSyxLQUFMLENBQVcsR0FBWCxNQUFvQixHQUZ0QjtBQUdELENBSkQ7OztBQ0hBOztBQUVBLFNBQVMsZ0JBQVQsQ0FBMEIsQ0FBMUIsRUFBNkIsQ0FBN0IsRUFBZ0M7QUFDNUIsUUFBSSxJQUFJLENBQVI7QUFDQSxTQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksRUFBRSxNQUF0QixFQUE4QixHQUE5QixFQUFtQztBQUMvQixhQUFLLENBQUMsRUFBRSxDQUFGLElBQU8sRUFBRSxDQUFGLENBQVIsS0FBaUIsRUFBRSxDQUFGLElBQU8sRUFBRSxDQUFGLENBQXhCLENBQUw7QUFDSDtBQUNELFdBQU8sQ0FBUDtBQUNIOztBQUVELFNBQVMsU0FBVCxDQUFtQixDQUFuQixFQUFzQixDQUF0QixFQUF5QjtBQUNyQixXQUFPLEtBQUssSUFBTCxDQUFVLGlCQUFpQixDQUFqQixFQUFvQixDQUFwQixDQUFWLENBQVA7QUFDSDs7QUFFRCxPQUFPLE9BQVAsR0FBaUIsU0FBakI7QUFDQSxVQUFVLE9BQVYsR0FBb0IsZ0JBQXBCOzs7QUNmQTs7QUFFQSxJQUFNLG1CQUFtQixRQUFRLHVCQUFSLEVBQWlDLE9BQTFEOztBQUVBLElBQU0saUJBQWlCO0FBQ25CLFdBQU87QUFEWSxDQUF2Qjs7QUFJQSxNQUFNLGNBQU4sQ0FBcUI7QUFDakIsZ0JBQVksT0FBWixFQUFxQjtBQUNqQixrQkFBVSxPQUFPLE1BQVAsQ0FBYyxFQUFkLEVBQWtCLGNBQWxCLEVBQWtDLE9BQWxDLENBQVY7QUFDQSxhQUFLLEtBQUwsR0FBYSxRQUFRLEtBQXJCO0FBQ0EsYUFBSyxPQUFMLEdBQWUsSUFBSSxRQUFRLEtBQVosR0FBb0IsUUFBUSxLQUEzQztBQUNIOztBQUVELFlBQVEsQ0FBUixFQUFXLENBQVgsRUFBYztBQUNWLFlBQU0sV0FBVyxpQkFBaUIsQ0FBakIsRUFBb0IsQ0FBcEIsQ0FBakI7QUFDQSxlQUFPLEtBQUssR0FBTCxDQUFTLENBQUMsUUFBRCxHQUFZLEtBQUssT0FBMUIsQ0FBUDtBQUNIO0FBVmdCOztBQWFyQixPQUFPLE9BQVAsR0FBaUIsY0FBakI7OztBQ3JCQTs7QUFFQSxJQUFNLFNBQVMsUUFBUSxXQUFSLENBQWY7O0FBRUEsSUFBTSxpQkFBaUIsUUFBUSxvQkFBUixDQUF2QjtBQUNBLElBQU0sbUJBQW1CLFFBQVEsc0JBQVIsQ0FBekI7QUFDQSxJQUFNLGNBQWMsUUFBUSx3QkFBUixDQUFwQjtBQUNBLElBQU0sZUFBZSxRQUFRLHlCQUFSLENBQXJCO0FBQ0EsSUFBTSxvQkFBb0IsUUFBUSw4QkFBUixDQUExQjtBQUNBLElBQU0sa0JBQWtCLFFBQVEseUNBQVIsQ0FBeEI7QUFDQSxJQUFNLGtCQUFrQixRQUFRLDRCQUFSLENBQXhCO0FBQ0EsSUFBTSx1QkFBdUIsUUFBUSxpQ0FBUixDQUE3QjtBQUNBLElBQU0saUJBQWlCLFFBQVEscUNBQVIsQ0FBdkI7O0FBRUEsSUFBTSxhQUFhO0FBQ2YsY0FBVSxjQURLO0FBRWYsU0FBSyxjQUZVO0FBR2YsZ0JBQVksZ0JBSEc7QUFJZixVQUFNLGdCQUpTO0FBS2YsV0FBTyxXQUxRO0FBTWYsWUFBUSxZQU5PO0FBT2YsaUJBQWEsaUJBUEU7QUFRZixlQUFXLGVBUkk7QUFTZixTQUFLLGVBVFU7QUFVZixlQUFXLGVBVkk7QUFXZixvQkFBZ0Isb0JBWEQ7QUFZZixjQUFVO0FBWkssQ0FBbkI7O0FBZUEsTUFBTSxNQUFOLENBQWE7QUFDVCxnQkFBWSxJQUFaLEVBQWtCLE9BQWxCLEVBQTJCO0FBQ3ZCLFlBQUksT0FBTyxJQUFQLEtBQWdCLFFBQXBCLEVBQThCO0FBQzFCLG1CQUFPLEtBQUssV0FBTCxFQUFQOztBQUVBLGdCQUFJLG9CQUFvQixXQUFXLElBQVgsQ0FBeEI7QUFDQSxnQkFBSSxpQkFBSixFQUF1QjtBQUNuQixxQkFBSyxjQUFMLEdBQXNCLElBQUksaUJBQUosQ0FBc0IsT0FBdEIsQ0FBdEI7QUFDSCxhQUZELE1BRU87QUFDSCxzQkFBTSxJQUFJLEtBQUosQ0FBVSw4QkFBOEIsSUFBeEMsQ0FBTjtBQUNIO0FBQ0osU0FURCxNQVNPLElBQUksT0FBTyxJQUFQLEtBQWdCLFFBQWhCLElBQTRCLE9BQU8sS0FBSyxPQUFaLEtBQXdCLFVBQXhELEVBQW9FO0FBQ3ZFLGlCQUFLLGNBQUwsR0FBc0IsSUFBdEI7QUFDSCxTQUZNLE1BRUE7QUFDSCxrQkFBTSxJQUFJLFNBQUosQ0FBYyx3REFBZCxDQUFOO0FBQ0g7QUFDSjs7QUFFRCxZQUFRLE1BQVIsRUFBZ0IsU0FBaEIsRUFBMkI7QUFDdkIsWUFBSSxjQUFjLFNBQWxCLEVBQTZCO0FBQ3pCLHdCQUFZLE1BQVo7QUFDSDtBQUNELFlBQU0sZUFBZSxJQUFJLE1BQUosQ0FBVyxPQUFPLE1BQWxCLEVBQTBCLFVBQVUsTUFBcEMsQ0FBckI7QUFDQSxZQUFJLENBQUosRUFBTyxDQUFQO0FBQ0EsWUFBSSxXQUFXLFNBQWYsRUFBMEI7O0FBQ3RCLGlCQUFLLElBQUksQ0FBVCxFQUFZLElBQUksT0FBTyxNQUF2QixFQUErQixHQUEvQixFQUFvQztBQUNoQyxxQkFBSyxJQUFJLENBQVQsRUFBWSxJQUFJLE9BQU8sTUFBdkIsRUFBK0IsR0FBL0IsRUFBb0M7QUFDaEMsaUNBQWEsQ0FBYixFQUFnQixDQUFoQixJQUFxQixhQUFhLENBQWIsRUFBZ0IsQ0FBaEIsSUFBcUIsS0FBSyxjQUFMLENBQW9CLE9BQXBCLENBQTRCLE9BQU8sQ0FBUCxDQUE1QixFQUF1QyxPQUFPLENBQVAsQ0FBdkMsQ0FBMUM7QUFDSDtBQUNKO0FBQ0osU0FORCxNQU1PO0FBQ0gsaUJBQUssSUFBSSxDQUFULEVBQVksSUFBSSxPQUFPLE1BQXZCLEVBQStCLEdBQS9CLEVBQW9DO0FBQ2hDLHFCQUFLLElBQUksQ0FBVCxFQUFZLElBQUksVUFBVSxNQUExQixFQUFrQyxHQUFsQyxFQUF1QztBQUNuQyxpQ0FBYSxDQUFiLEVBQWdCLENBQWhCLElBQXFCLEtBQUssY0FBTCxDQUFvQixPQUFwQixDQUE0QixPQUFPLENBQVAsQ0FBNUIsRUFBdUMsVUFBVSxDQUFWLENBQXZDLENBQXJCO0FBQ0g7QUFDSjtBQUNKO0FBQ0QsZUFBTyxZQUFQO0FBQ0g7QUF0Q1E7O0FBeUNiLE9BQU8sT0FBUCxHQUFpQixNQUFqQjs7O0FDdEVBOztBQUVBLElBQU0saUJBQWlCO0FBQ25CLFdBQU8sQ0FEWTtBQUVuQixZQUFRO0FBRlcsQ0FBdkI7O0FBS0EsTUFBTSxXQUFOLENBQWtCO0FBQ2QsZ0JBQVksT0FBWixFQUFxQjtBQUNqQixrQkFBVSxPQUFPLE1BQVAsQ0FBYyxFQUFkLEVBQWtCLGNBQWxCLEVBQWtDLE9BQWxDLENBQVY7QUFDQSxhQUFLLEtBQUwsR0FBYSxRQUFRLEtBQXJCO0FBQ0EsYUFBSyxNQUFMLEdBQWMsUUFBUSxNQUF0QjtBQUNIOztBQUVELFlBQVEsQ0FBUixFQUFXLENBQVgsRUFBYztBQUNWLFlBQUksTUFBTSxDQUFWO0FBQ0EsWUFBSSxNQUFNLEtBQUssR0FBTCxDQUFTLEVBQUUsTUFBWCxFQUFtQixFQUFFLE1BQXJCLENBQVY7QUFDQSxhQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLEtBQUssR0FBckIsRUFBMEIsRUFBRSxDQUE1QixFQUErQjtBQUMzQixtQkFBTyxLQUFLLEdBQUwsQ0FBUyxLQUFLLEdBQUwsQ0FBUyxDQUFDLEtBQUssS0FBTixHQUFjLEtBQUssR0FBTCxDQUFTLEtBQUssR0FBTCxDQUFTLEVBQUUsSUFBSSxDQUFOLENBQVQsRUFBbUIsQ0FBbkIsSUFDeEMsS0FBSyxHQUFMLENBQVMsRUFBRSxJQUFJLENBQU4sQ0FBVCxFQUFtQixDQUFuQixDQUQrQixFQUNSLENBRFEsQ0FBdkIsQ0FBVCxFQUM2QixLQUFLLE1BRGxDLENBQVA7QUFFSDtBQUNELGVBQU8sR0FBUDtBQUNIO0FBZmE7O0FBa0JsQixPQUFPLE9BQVAsR0FBaUIsV0FBakI7OztBQ3pCQTs7QUFFQSxJQUFNLG1CQUFtQixRQUFRLHVCQUFSLEVBQWlDLE9BQTFEOztBQUVBLElBQU0saUJBQWlCO0FBQ25CLFdBQU87QUFEWSxDQUF2Qjs7QUFJQSxNQUFNLFlBQU4sQ0FBbUI7QUFDZixnQkFBWSxPQUFaLEVBQXFCO0FBQ2pCLGtCQUFVLE9BQU8sTUFBUCxDQUFjLEVBQWQsRUFBa0IsY0FBbEIsRUFBa0MsT0FBbEMsQ0FBVjtBQUNBLGFBQUssS0FBTCxHQUFhLFFBQVEsS0FBckI7QUFDSDs7QUFFRCxZQUFRLENBQVIsRUFBVyxDQUFYLEVBQWM7QUFDVixlQUFPLEtBQUssSUFBSSxpQkFBaUIsQ0FBakIsRUFBb0IsQ0FBcEIsS0FBMEIsS0FBSyxLQUFMLEdBQWEsS0FBSyxLQUE1QyxDQUFULENBQVA7QUFDSDtBQVJjOztBQVduQixPQUFPLE9BQVAsR0FBaUIsWUFBakI7OztBQ25CQTs7QUFFQSxJQUFNLFlBQVksUUFBUSx1QkFBUixDQUFsQjs7QUFFQSxJQUFNLGlCQUFpQjtBQUNuQixXQUFPO0FBRFksQ0FBdkI7O0FBSUEsTUFBTSxpQkFBTixDQUF3QjtBQUNwQixnQkFBWSxPQUFaLEVBQXFCO0FBQ2pCLGtCQUFVLE9BQU8sTUFBUCxDQUFjLEVBQWQsRUFBa0IsY0FBbEIsRUFBa0MsT0FBbEMsQ0FBVjtBQUNBLGFBQUssS0FBTCxHQUFhLFFBQVEsS0FBckI7QUFDQSxhQUFLLE9BQUwsR0FBZSxJQUFJLFFBQVEsS0FBWixHQUFvQixRQUFRLEtBQTNDO0FBQ0g7O0FBRUQsWUFBUSxDQUFSLEVBQVcsQ0FBWCxFQUFjO0FBQ1YsWUFBTSxXQUFXLFVBQVUsQ0FBVixFQUFhLENBQWIsQ0FBakI7QUFDQSxlQUFPLEtBQUssR0FBTCxDQUFTLENBQUMsUUFBRCxHQUFZLEtBQUssT0FBMUIsQ0FBUDtBQUNIO0FBVm1COztBQWF4QixPQUFPLE9BQVAsR0FBaUIsaUJBQWpCOzs7QUNyQkE7O0FBRUEsTUFBTSwyQkFBTixDQUFrQztBQUM5QixZQUFRLENBQVIsRUFBVyxDQUFYLEVBQWM7QUFDVixZQUFJLE1BQU0sS0FBSyxHQUFMLENBQVMsRUFBRSxNQUFYLEVBQW1CLEVBQUUsTUFBckIsQ0FBVjtBQUNBLFlBQUksTUFBTSxDQUFWO0FBQ0EsYUFBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLEdBQXBCLEVBQXlCLEVBQUUsQ0FBM0I7QUFDSSxtQkFBTyxLQUFLLEdBQUwsQ0FBUyxFQUFFLENBQUYsQ0FBVCxFQUFlLEVBQUUsQ0FBRixDQUFmLENBQVA7QUFESixTQUdBLE9BQU8sR0FBUDtBQUNIO0FBUjZCOztBQVdsQyxPQUFPLE9BQVAsR0FBaUIsMkJBQWpCOzs7QUNiQTs7QUFFQSxJQUFNLFlBQVksUUFBUSx1QkFBUixDQUFsQjs7QUFFQSxJQUFNLGlCQUFpQjtBQUNuQixXQUFPO0FBRFksQ0FBdkI7O0FBSUEsTUFBTSxlQUFOLENBQXNCO0FBQ2xCLGdCQUFZLE9BQVosRUFBcUI7QUFDakIsa0JBQVUsT0FBTyxNQUFQLENBQWMsRUFBZCxFQUFrQixjQUFsQixFQUFrQyxPQUFsQyxDQUFWO0FBQ0EsYUFBSyxLQUFMLEdBQWEsUUFBUSxLQUFyQjtBQUNIOztBQUVELFlBQVEsQ0FBUixFQUFXLENBQVgsRUFBYztBQUNWLFlBQU0sV0FBVyxVQUFVLENBQVYsRUFBYSxDQUFiLENBQWpCO0FBQ0EsZUFBTyxLQUFLLEdBQUwsQ0FBUyxDQUFDLFFBQUQsR0FBWSxLQUFLLEtBQTFCLENBQVA7QUFDSDtBQVRpQjs7QUFZdEIsT0FBTyxPQUFQLEdBQWlCLGVBQWpCOzs7QUNwQkE7O0FBRUEsSUFBTSxtQkFBbUIsUUFBUSx1QkFBUixFQUFpQyxPQUExRDs7QUFFQSxJQUFNLGlCQUFpQjtBQUNuQixjQUFVO0FBRFMsQ0FBdkI7O0FBSUEsTUFBTSxvQkFBTixDQUEyQjtBQUN2QixnQkFBWSxPQUFaLEVBQXFCO0FBQ2pCLGtCQUFVLE9BQU8sTUFBUCxDQUFjLEVBQWQsRUFBa0IsY0FBbEIsRUFBa0MsT0FBbEMsQ0FBVjtBQUNBLGFBQUssUUFBTCxHQUFnQixRQUFRLFFBQXhCO0FBQ0g7O0FBRUQsWUFBUSxDQUFSLEVBQVcsQ0FBWCxFQUFjO0FBQ1YsZUFBTyxLQUFLLElBQUwsQ0FBVSxpQkFBaUIsQ0FBakIsRUFBb0IsQ0FBcEIsSUFBeUIsS0FBSyxRQUFMLEdBQWdCLEtBQUssUUFBeEQsQ0FBUDtBQUNIO0FBUnNCOztBQVczQixPQUFPLE9BQVAsR0FBaUIsb0JBQWpCOzs7QUNuQkE7O0FBRUEsSUFBTSxtQkFBbUIsUUFBUSx1QkFBUixFQUFpQyxPQUExRDs7QUFFQSxJQUFNLGlCQUFpQjtBQUNuQixjQUFVO0FBRFMsQ0FBdkI7O0FBSUEsTUFBTSx1QkFBTixDQUE4QjtBQUMxQixnQkFBWSxPQUFaLEVBQXFCO0FBQ2pCLGtCQUFVLE9BQU8sTUFBUCxDQUFjLEVBQWQsRUFBa0IsY0FBbEIsRUFBa0MsT0FBbEMsQ0FBVjtBQUNBLGFBQUssUUFBTCxHQUFnQixRQUFRLFFBQXhCO0FBQ0g7O0FBRUQsWUFBUSxDQUFSLEVBQVcsQ0FBWCxFQUFjO0FBQ1YsZUFBTyxJQUFLLGlCQUFpQixDQUFqQixFQUFvQixDQUFwQixLQUEwQixpQkFBaUIsQ0FBakIsRUFBb0IsQ0FBcEIsSUFBeUIsS0FBSyxRQUF4RCxDQUFaO0FBQ0g7QUFSeUI7O0FBVzlCLE9BQU8sT0FBUCxHQUFpQix1QkFBakI7OztBQ25CQTs7QUFFQSxJQUFJLFNBQVMsUUFBUSxXQUFSLENBQWI7OztBQUdBLFNBQVMscUJBQVQsQ0FBK0IsS0FBL0IsRUFBc0M7QUFDbEMsUUFBSSxFQUFFLGdCQUFnQixxQkFBbEIsQ0FBSixFQUE4QztBQUMxQyxlQUFPLElBQUkscUJBQUosQ0FBMEIsS0FBMUIsQ0FBUDtBQUNIO0FBQ0QsWUFBUSxPQUFPLFdBQVAsQ0FBbUIsS0FBbkIsQ0FBUjtBQUNBLFFBQUksQ0FBQyxNQUFNLFdBQU4sRUFBTCxFQUNJLE1BQU0sSUFBSSxLQUFKLENBQVUseUJBQVYsQ0FBTjs7QUFFSixRQUFJLElBQUksS0FBUjtBQUFBLFFBQ0ksWUFBWSxFQUFFLElBRGxCO0FBQUEsUUFFSSxJQUFJLElBQUksTUFBSixDQUFXLFNBQVgsRUFBc0IsU0FBdEIsQ0FGUjtBQUFBLFFBR0ksbUJBQW1CLElBSHZCO0FBQUEsUUFJSSxDQUpKO0FBQUEsUUFJTyxDQUpQO0FBQUEsUUFJVSxDQUpWOztBQU1BLFNBQUssSUFBSSxDQUFULEVBQVksSUFBSSxTQUFoQixFQUEyQixHQUEzQixFQUFnQztBQUM1QixZQUFJLFFBQVEsRUFBRSxDQUFGLENBQVo7QUFDQSxZQUFJLElBQUksQ0FBUjtBQUNBLGFBQUssSUFBSSxDQUFULEVBQVksSUFBSSxDQUFoQixFQUFtQixHQUFuQixFQUF3QjtBQUNwQixnQkFBSSxRQUFRLEVBQUUsQ0FBRixDQUFaO0FBQ0EsZ0JBQUksSUFBSSxDQUFSO0FBQ0EsaUJBQUssSUFBSSxDQUFULEVBQVksSUFBSSxDQUFoQixFQUFtQixHQUFuQixFQUF3QjtBQUNwQixxQkFBSyxNQUFNLENBQU4sSUFBVyxNQUFNLENBQU4sQ0FBaEI7QUFDSDtBQUNELGtCQUFNLENBQU4sSUFBVyxJQUFJLENBQUMsRUFBRSxDQUFGLEVBQUssQ0FBTCxJQUFVLENBQVgsSUFBZ0IsRUFBRSxDQUFGLEVBQUssQ0FBTCxDQUEvQjtBQUNBLGdCQUFJLElBQUksSUFBSSxDQUFaO0FBQ0g7O0FBRUQsWUFBSSxFQUFFLENBQUYsRUFBSyxDQUFMLElBQVUsQ0FBZDs7QUFFQSw0QkFBcUIsSUFBSSxDQUF6QjtBQUNBLFVBQUUsQ0FBRixFQUFLLENBQUwsSUFBVSxLQUFLLElBQUwsQ0FBVSxLQUFLLEdBQUwsQ0FBUyxDQUFULEVBQVksQ0FBWixDQUFWLENBQVY7QUFDQSxhQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksU0FBcEIsRUFBK0IsR0FBL0IsRUFBb0M7QUFDaEMsY0FBRSxDQUFGLEVBQUssQ0FBTCxJQUFVLENBQVY7QUFDSDtBQUNKOztBQUVELFFBQUksQ0FBQyxnQkFBTCxFQUF1QjtBQUNuQixjQUFNLElBQUksS0FBSixDQUFVLGlDQUFWLENBQU47QUFDSDs7QUFFRCxTQUFLLENBQUwsR0FBUyxDQUFUO0FBQ0g7O0FBRUQsc0JBQXNCLFNBQXRCLEdBQWtDO0FBQzlCLFFBQUkscUJBQUosR0FBNEI7QUFDeEIsZUFBTyxLQUFLLENBQVo7QUFDSCxLQUg2QjtBQUk5QixXQUFPLGVBQVUsS0FBVixFQUFpQjtBQUNwQixnQkFBUSxPQUFPLFdBQVAsQ0FBbUIsS0FBbkIsQ0FBUjs7QUFFQSxZQUFJLElBQUksS0FBSyxDQUFiO0FBQUEsWUFDSSxZQUFZLEVBQUUsSUFEbEI7O0FBR0EsWUFBSSxNQUFNLElBQU4sS0FBZSxTQUFuQixFQUE4QjtBQUMxQixrQkFBTSxJQUFJLEtBQUosQ0FBVSxnQ0FBVixDQUFOO0FBQ0g7O0FBRUQsWUFBSSxRQUFRLE1BQU0sT0FBbEI7QUFBQSxZQUNJLElBQUksTUFBTSxLQUFOLEVBRFI7QUFBQSxZQUVJLENBRko7QUFBQSxZQUVPLENBRlA7QUFBQSxZQUVVLENBRlY7O0FBSUEsYUFBSyxJQUFJLENBQVQsRUFBWSxJQUFJLFNBQWhCLEVBQTJCLEdBQTNCLEVBQWdDO0FBQzVCLGlCQUFLLElBQUksQ0FBVCxFQUFZLElBQUksS0FBaEIsRUFBdUIsR0FBdkIsRUFBNEI7QUFDeEIscUJBQUssSUFBSSxDQUFULEVBQVksSUFBSSxDQUFoQixFQUFtQixHQUFuQixFQUF3QjtBQUNwQixzQkFBRSxDQUFGLEVBQUssQ0FBTCxLQUFXLEVBQUUsQ0FBRixFQUFLLENBQUwsSUFBVSxFQUFFLENBQUYsRUFBSyxDQUFMLENBQXJCO0FBQ0g7QUFDRCxrQkFBRSxDQUFGLEVBQUssQ0FBTCxLQUFXLEVBQUUsQ0FBRixFQUFLLENBQUwsQ0FBWDtBQUNIO0FBQ0o7O0FBRUQsYUFBSyxJQUFJLFlBQVksQ0FBckIsRUFBd0IsS0FBSyxDQUE3QixFQUFnQyxHQUFoQyxFQUFxQztBQUNqQyxpQkFBSyxJQUFJLENBQVQsRUFBWSxJQUFJLEtBQWhCLEVBQXVCLEdBQXZCLEVBQTRCO0FBQ3hCLHFCQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksU0FBcEIsRUFBK0IsR0FBL0IsRUFBb0M7QUFDaEMsc0JBQUUsQ0FBRixFQUFLLENBQUwsS0FBVyxFQUFFLENBQUYsRUFBSyxDQUFMLElBQVUsRUFBRSxDQUFGLEVBQUssQ0FBTCxDQUFyQjtBQUNIO0FBQ0Qsa0JBQUUsQ0FBRixFQUFLLENBQUwsS0FBVyxFQUFFLENBQUYsRUFBSyxDQUFMLENBQVg7QUFDSDtBQUNKOztBQUVELGVBQU8sQ0FBUDtBQUNIO0FBckM2QixDQUFsQzs7QUF3Q0EsT0FBTyxPQUFQLEdBQWlCLHFCQUFqQjs7O0FDeEZBOztBQUVBLElBQU0sU0FBUyxRQUFRLFdBQVIsQ0FBZjtBQUNBLElBQU0sT0FBTyxRQUFRLFFBQVIsQ0FBYjtBQUNBLElBQU0sYUFBYSxLQUFLLFVBQXhCO0FBQ0EsSUFBTSxtQkFBbUIsS0FBSyxnQkFBOUI7O0FBRUEsSUFBTSxpQkFBaUI7QUFDbkIscUJBQWlCO0FBREUsQ0FBdkI7OztBQUtBLFNBQVMsdUJBQVQsQ0FBaUMsTUFBakMsRUFBeUMsT0FBekMsRUFBa0Q7QUFDOUMsY0FBVSxPQUFPLE1BQVAsQ0FBYyxFQUFkLEVBQWtCLGNBQWxCLEVBQWtDLE9BQWxDLENBQVY7QUFDQSxRQUFJLEVBQUUsZ0JBQWdCLHVCQUFsQixDQUFKLEVBQWdEO0FBQzVDLGVBQU8sSUFBSSx1QkFBSixDQUE0QixNQUE1QixFQUFvQyxPQUFwQyxDQUFQO0FBQ0g7QUFDRCxhQUFTLE9BQU8sV0FBUCxDQUFtQixNQUFuQixDQUFUO0FBQ0EsUUFBSSxDQUFDLE9BQU8sUUFBUCxFQUFMLEVBQXdCO0FBQ3BCLGNBQU0sSUFBSSxLQUFKLENBQVUsK0JBQVYsQ0FBTjtBQUNIOztBQUVELFFBQUksSUFBSSxPQUFPLE9BQWY7QUFBQSxRQUNJLElBQUksaUJBQWlCLENBQWpCLEVBQW9CLENBQXBCLEVBQXVCLENBQXZCLENBRFI7QUFBQSxRQUVJLElBQUksSUFBSSxLQUFKLENBQVUsQ0FBVixDQUZSO0FBQUEsUUFHSSxJQUFJLElBQUksS0FBSixDQUFVLENBQVYsQ0FIUjtBQUFBLFFBSUksUUFBUSxNQUpaO0FBQUEsUUFLSSxDQUxKO0FBQUEsUUFLTyxDQUxQOztBQU9BLFFBQUksY0FBYyxLQUFsQjtBQUNBLFFBQUksUUFBUSxlQUFaLEVBQTZCO0FBQ3pCLHNCQUFjLElBQWQ7QUFDSCxLQUZELE1BRU87QUFDSCxzQkFBYyxPQUFPLFdBQVAsRUFBZDtBQUNIOztBQUVELFFBQUksV0FBSixFQUFpQjtBQUNiLGFBQUssSUFBSSxDQUFULEVBQVksSUFBSSxDQUFoQixFQUFtQixHQUFuQixFQUF3QjtBQUNwQixpQkFBSyxJQUFJLENBQVQsRUFBWSxJQUFJLENBQWhCLEVBQW1CLEdBQW5CLEVBQXdCO0FBQ3BCLGtCQUFFLENBQUYsRUFBSyxDQUFMLElBQVUsTUFBTSxHQUFOLENBQVUsQ0FBVixFQUFhLENBQWIsQ0FBVjtBQUNIO0FBQ0o7QUFDRCxjQUFNLENBQU4sRUFBUyxDQUFULEVBQVksQ0FBWixFQUFlLENBQWY7QUFDQSxhQUFLLENBQUwsRUFBUSxDQUFSLEVBQVcsQ0FBWCxFQUFjLENBQWQ7QUFDSCxLQVJELE1BU0s7QUFDRCxZQUFJLElBQUksaUJBQWlCLENBQWpCLEVBQW9CLENBQXBCLEVBQXVCLENBQXZCLENBQVI7QUFBQSxZQUNJLE1BQU0sSUFBSSxLQUFKLENBQVUsQ0FBVixDQURWO0FBRUEsYUFBSyxJQUFJLENBQVQsRUFBWSxJQUFJLENBQWhCLEVBQW1CLEdBQW5CLEVBQXdCO0FBQ3BCLGlCQUFLLElBQUksQ0FBVCxFQUFZLElBQUksQ0FBaEIsRUFBbUIsR0FBbkIsRUFBd0I7QUFDcEIsa0JBQUUsQ0FBRixFQUFLLENBQUwsSUFBVSxNQUFNLEdBQU4sQ0FBVSxDQUFWLEVBQWEsQ0FBYixDQUFWO0FBQ0g7QUFDSjtBQUNELGVBQU8sQ0FBUCxFQUFVLENBQVYsRUFBYSxHQUFiLEVBQWtCLENBQWxCO0FBQ0EsYUFBSyxDQUFMLEVBQVEsQ0FBUixFQUFXLENBQVgsRUFBYyxDQUFkLEVBQWlCLENBQWpCO0FBQ0g7O0FBRUQsU0FBSyxDQUFMLEdBQVMsQ0FBVDtBQUNBLFNBQUssQ0FBTCxHQUFTLENBQVQ7QUFDQSxTQUFLLENBQUwsR0FBUyxDQUFUO0FBQ0EsU0FBSyxDQUFMLEdBQVMsQ0FBVDtBQUNIOztBQUVELHdCQUF3QixTQUF4QixHQUFvQztBQUNoQyxRQUFJLGVBQUosR0FBc0I7QUFDbEIsZUFBTyxLQUFLLENBQVo7QUFDSCxLQUgrQjtBQUloQyxRQUFJLG9CQUFKLEdBQTJCO0FBQ3ZCLGVBQU8sS0FBSyxDQUFaO0FBQ0gsS0FOK0I7QUFPaEMsUUFBSSxpQkFBSixHQUF3QjtBQUNwQixZQUFJLENBQUMsT0FBTyxRQUFQLENBQWdCLEtBQUssQ0FBckIsQ0FBTCxFQUE4QjtBQUMxQixpQkFBSyxDQUFMLEdBQVMsSUFBSSxNQUFKLENBQVcsS0FBSyxDQUFoQixDQUFUO0FBQ0g7QUFDRCxlQUFPLEtBQUssQ0FBWjtBQUNILEtBWitCO0FBYWhDLFFBQUksY0FBSixHQUFxQjtBQUNqQixZQUFJLElBQUksS0FBSyxDQUFiO0FBQUEsWUFDSSxJQUFJLEtBQUssQ0FEYjtBQUFBLFlBRUksSUFBSSxLQUFLLENBRmI7QUFBQSxZQUdJLElBQUksSUFBSSxNQUFKLENBQVcsQ0FBWCxFQUFjLENBQWQsQ0FIUjtBQUFBLFlBSUksQ0FKSjtBQUFBLFlBSU8sQ0FKUDtBQUtBLGFBQUssSUFBSSxDQUFULEVBQVksSUFBSSxDQUFoQixFQUFtQixHQUFuQixFQUF3QjtBQUNwQixpQkFBSyxJQUFJLENBQVQsRUFBWSxJQUFJLENBQWhCLEVBQW1CLEdBQW5CLEVBQXdCO0FBQ3BCLGtCQUFFLENBQUYsRUFBSyxDQUFMLElBQVUsQ0FBVjtBQUNIO0FBQ0QsY0FBRSxDQUFGLEVBQUssQ0FBTCxJQUFVLEVBQUUsQ0FBRixDQUFWO0FBQ0EsZ0JBQUksRUFBRSxDQUFGLElBQU8sQ0FBWCxFQUFjO0FBQ1Ysa0JBQUUsQ0FBRixFQUFLLElBQUksQ0FBVCxJQUFjLEVBQUUsQ0FBRixDQUFkO0FBQ0gsYUFGRCxNQUdLLElBQUksRUFBRSxDQUFGLElBQU8sQ0FBWCxFQUFjO0FBQ2Ysa0JBQUUsQ0FBRixFQUFLLElBQUksQ0FBVCxJQUFjLEVBQUUsQ0FBRixDQUFkO0FBQ0g7QUFDSjtBQUNELGVBQU8sQ0FBUDtBQUNIO0FBaEMrQixDQUFwQzs7QUFtQ0EsU0FBUyxLQUFULENBQWUsQ0FBZixFQUFrQixDQUFsQixFQUFxQixDQUFyQixFQUF3QixDQUF4QixFQUEyQjs7QUFFdkIsUUFBSSxDQUFKLEVBQU8sQ0FBUCxFQUFVLENBQVYsRUFBYSxDQUFiLEVBQWdCLENBQWhCLEVBQW1CLENBQW5CLEVBQ0ksRUFESixFQUNRLEtBRFI7O0FBR0EsU0FBSyxJQUFJLENBQVQsRUFBWSxJQUFJLENBQWhCLEVBQW1CLEdBQW5CLEVBQXdCO0FBQ3BCLFVBQUUsQ0FBRixJQUFPLEVBQUUsSUFBSSxDQUFOLEVBQVMsQ0FBVCxDQUFQO0FBQ0g7O0FBRUQsU0FBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLENBQXBCLEVBQXVCLEdBQXZCLEVBQTRCO0FBQ3hCLGdCQUFRLENBQVI7QUFDQSxZQUFJLENBQUo7QUFDQSxhQUFLLElBQUksQ0FBVCxFQUFZLElBQUksQ0FBaEIsRUFBbUIsR0FBbkIsRUFBd0I7QUFDcEIsb0JBQVEsUUFBUSxLQUFLLEdBQUwsQ0FBUyxFQUFFLENBQUYsQ0FBVCxDQUFoQjtBQUNIOztBQUVELFlBQUksVUFBVSxDQUFkLEVBQWlCO0FBQ2IsY0FBRSxDQUFGLElBQU8sRUFBRSxJQUFJLENBQU4sQ0FBUDtBQUNBLGlCQUFLLElBQUksQ0FBVCxFQUFZLElBQUksQ0FBaEIsRUFBbUIsR0FBbkIsRUFBd0I7QUFDcEIsa0JBQUUsQ0FBRixJQUFPLEVBQUUsSUFBSSxDQUFOLEVBQVMsQ0FBVCxDQUFQO0FBQ0Esa0JBQUUsQ0FBRixFQUFLLENBQUwsSUFBVSxDQUFWO0FBQ0Esa0JBQUUsQ0FBRixFQUFLLENBQUwsSUFBVSxDQUFWO0FBQ0g7QUFDSixTQVBELE1BT087QUFDSCxpQkFBSyxJQUFJLENBQVQsRUFBWSxJQUFJLENBQWhCLEVBQW1CLEdBQW5CLEVBQXdCO0FBQ3BCLGtCQUFFLENBQUYsS0FBUSxLQUFSO0FBQ0EscUJBQUssRUFBRSxDQUFGLElBQU8sRUFBRSxDQUFGLENBQVo7QUFDSDs7QUFFRCxnQkFBSSxFQUFFLElBQUksQ0FBTixDQUFKO0FBQ0EsZ0JBQUksS0FBSyxJQUFMLENBQVUsQ0FBVixDQUFKO0FBQ0EsZ0JBQUksSUFBSSxDQUFSLEVBQVc7QUFDUCxvQkFBSSxDQUFDLENBQUw7QUFDSDs7QUFFRCxjQUFFLENBQUYsSUFBTyxRQUFRLENBQWY7QUFDQSxnQkFBSSxJQUFJLElBQUksQ0FBWjtBQUNBLGNBQUUsSUFBSSxDQUFOLElBQVcsSUFBSSxDQUFmO0FBQ0EsaUJBQUssSUFBSSxDQUFULEVBQVksSUFBSSxDQUFoQixFQUFtQixHQUFuQixFQUF3QjtBQUNwQixrQkFBRSxDQUFGLElBQU8sQ0FBUDtBQUNIOztBQUVELGlCQUFLLElBQUksQ0FBVCxFQUFZLElBQUksQ0FBaEIsRUFBbUIsR0FBbkIsRUFBd0I7QUFDcEIsb0JBQUksRUFBRSxDQUFGLENBQUo7QUFDQSxrQkFBRSxDQUFGLEVBQUssQ0FBTCxJQUFVLENBQVY7QUFDQSxvQkFBSSxFQUFFLENBQUYsSUFBTyxFQUFFLENBQUYsRUFBSyxDQUFMLElBQVUsQ0FBckI7QUFDQSxxQkFBSyxJQUFJLElBQUksQ0FBYixFQUFnQixLQUFLLElBQUksQ0FBekIsRUFBNEIsR0FBNUIsRUFBaUM7QUFDN0IseUJBQUssRUFBRSxDQUFGLEVBQUssQ0FBTCxJQUFVLEVBQUUsQ0FBRixDQUFmO0FBQ0Esc0JBQUUsQ0FBRixLQUFRLEVBQUUsQ0FBRixFQUFLLENBQUwsSUFBVSxDQUFsQjtBQUNIO0FBQ0Qsa0JBQUUsQ0FBRixJQUFPLENBQVA7QUFDSDs7QUFFRCxnQkFBSSxDQUFKO0FBQ0EsaUJBQUssSUFBSSxDQUFULEVBQVksSUFBSSxDQUFoQixFQUFtQixHQUFuQixFQUF3QjtBQUNwQixrQkFBRSxDQUFGLEtBQVEsQ0FBUjtBQUNBLHFCQUFLLEVBQUUsQ0FBRixJQUFPLEVBQUUsQ0FBRixDQUFaO0FBQ0g7O0FBRUQsaUJBQUssS0FBSyxJQUFJLENBQVQsQ0FBTDtBQUNBLGlCQUFLLElBQUksQ0FBVCxFQUFZLElBQUksQ0FBaEIsRUFBbUIsR0FBbkIsRUFBd0I7QUFDcEIsa0JBQUUsQ0FBRixLQUFRLEtBQUssRUFBRSxDQUFGLENBQWI7QUFDSDs7QUFFRCxpQkFBSyxJQUFJLENBQVQsRUFBWSxJQUFJLENBQWhCLEVBQW1CLEdBQW5CLEVBQXdCO0FBQ3BCLG9CQUFJLEVBQUUsQ0FBRixDQUFKO0FBQ0Esb0JBQUksRUFBRSxDQUFGLENBQUo7QUFDQSxxQkFBSyxJQUFJLENBQVQsRUFBWSxLQUFLLElBQUksQ0FBckIsRUFBd0IsR0FBeEIsRUFBNkI7QUFDekIsc0JBQUUsQ0FBRixFQUFLLENBQUwsS0FBWSxJQUFJLEVBQUUsQ0FBRixDQUFKLEdBQVcsSUFBSSxFQUFFLENBQUYsQ0FBM0I7QUFDSDtBQUNELGtCQUFFLENBQUYsSUFBTyxFQUFFLElBQUksQ0FBTixFQUFTLENBQVQsQ0FBUDtBQUNBLGtCQUFFLENBQUYsRUFBSyxDQUFMLElBQVUsQ0FBVjtBQUNIO0FBQ0o7QUFDRCxVQUFFLENBQUYsSUFBTyxDQUFQO0FBQ0g7O0FBRUQsU0FBSyxJQUFJLENBQVQsRUFBWSxJQUFJLElBQUksQ0FBcEIsRUFBdUIsR0FBdkIsRUFBNEI7QUFDeEIsVUFBRSxJQUFJLENBQU4sRUFBUyxDQUFULElBQWMsRUFBRSxDQUFGLEVBQUssQ0FBTCxDQUFkO0FBQ0EsVUFBRSxDQUFGLEVBQUssQ0FBTCxJQUFVLENBQVY7QUFDQSxZQUFJLEVBQUUsSUFBSSxDQUFOLENBQUo7QUFDQSxZQUFJLE1BQU0sQ0FBVixFQUFhO0FBQ1QsaUJBQUssSUFBSSxDQUFULEVBQVksS0FBSyxDQUFqQixFQUFvQixHQUFwQixFQUF5QjtBQUNyQixrQkFBRSxDQUFGLElBQU8sRUFBRSxDQUFGLEVBQUssSUFBSSxDQUFULElBQWMsQ0FBckI7QUFDSDs7QUFFRCxpQkFBSyxJQUFJLENBQVQsRUFBWSxLQUFLLENBQWpCLEVBQW9CLEdBQXBCLEVBQXlCO0FBQ3JCLG9CQUFJLENBQUo7QUFDQSxxQkFBSyxJQUFJLENBQVQsRUFBWSxLQUFLLENBQWpCLEVBQW9CLEdBQXBCLEVBQXlCO0FBQ3JCLHlCQUFLLEVBQUUsQ0FBRixFQUFLLElBQUksQ0FBVCxJQUFjLEVBQUUsQ0FBRixFQUFLLENBQUwsQ0FBbkI7QUFDSDtBQUNELHFCQUFLLElBQUksQ0FBVCxFQUFZLEtBQUssQ0FBakIsRUFBb0IsR0FBcEIsRUFBeUI7QUFDckIsc0JBQUUsQ0FBRixFQUFLLENBQUwsS0FBVyxJQUFJLEVBQUUsQ0FBRixDQUFmO0FBQ0g7QUFDSjtBQUNKOztBQUVELGFBQUssSUFBSSxDQUFULEVBQVksS0FBSyxDQUFqQixFQUFvQixHQUFwQixFQUF5QjtBQUNyQixjQUFFLENBQUYsRUFBSyxJQUFJLENBQVQsSUFBYyxDQUFkO0FBQ0g7QUFDSjs7QUFFRCxTQUFLLElBQUksQ0FBVCxFQUFZLElBQUksQ0FBaEIsRUFBbUIsR0FBbkIsRUFBd0I7QUFDcEIsVUFBRSxDQUFGLElBQU8sRUFBRSxJQUFJLENBQU4sRUFBUyxDQUFULENBQVA7QUFDQSxVQUFFLElBQUksQ0FBTixFQUFTLENBQVQsSUFBYyxDQUFkO0FBQ0g7O0FBRUQsTUFBRSxJQUFJLENBQU4sRUFBUyxJQUFJLENBQWIsSUFBa0IsQ0FBbEI7QUFDQSxNQUFFLENBQUYsSUFBTyxDQUFQO0FBQ0g7O0FBRUQsU0FBUyxJQUFULENBQWMsQ0FBZCxFQUFpQixDQUFqQixFQUFvQixDQUFwQixFQUF1QixDQUF2QixFQUEwQjs7QUFFdEIsUUFBSSxDQUFKLEVBQU8sQ0FBUCxFQUFVLENBQVYsRUFBYSxDQUFiLEVBQWdCLENBQWhCLEVBQW1CLENBQW5CLEVBQXNCLENBQXRCLEVBQXlCLENBQXpCLEVBQTRCLENBQTVCLEVBQ0ksR0FESixFQUNTLENBRFQsRUFDWSxFQURaLEVBQ2dCLEVBRGhCLEVBQ29CLEdBRHBCLEVBQ3lCLENBRHpCLEVBQzRCLEVBRDVCLEVBRUksSUFGSjs7QUFJQSxTQUFLLElBQUksQ0FBVCxFQUFZLElBQUksQ0FBaEIsRUFBbUIsR0FBbkIsRUFBd0I7QUFDcEIsVUFBRSxJQUFJLENBQU4sSUFBVyxFQUFFLENBQUYsQ0FBWDtBQUNIOztBQUVELE1BQUUsSUFBSSxDQUFOLElBQVcsQ0FBWDs7QUFFQSxRQUFJLElBQUksQ0FBUjtBQUFBLFFBQ0ksT0FBTyxDQURYO0FBQUEsUUFFSSxNQUFNLEtBQUssR0FBTCxDQUFTLENBQVQsRUFBWSxDQUFDLEVBQWIsQ0FGVjs7QUFJQSxTQUFLLElBQUksQ0FBVCxFQUFZLElBQUksQ0FBaEIsRUFBbUIsR0FBbkIsRUFBd0I7QUFDcEIsZUFBTyxLQUFLLEdBQUwsQ0FBUyxJQUFULEVBQWUsS0FBSyxHQUFMLENBQVMsRUFBRSxDQUFGLENBQVQsSUFBaUIsS0FBSyxHQUFMLENBQVMsRUFBRSxDQUFGLENBQVQsQ0FBaEMsQ0FBUDtBQUNBLFlBQUksQ0FBSjtBQUNBLGVBQU8sSUFBSSxDQUFYLEVBQWM7QUFDVixnQkFBSSxLQUFLLEdBQUwsQ0FBUyxFQUFFLENBQUYsQ0FBVCxLQUFrQixNQUFNLElBQTVCLEVBQWtDO0FBQzlCO0FBQ0g7QUFDRDtBQUNIOztBQUVELFlBQUksSUFBSSxDQUFSLEVBQVc7QUFDUCxtQkFBTyxDQUFQO0FBQ0EsZUFBRztBQUNDLHVCQUFPLE9BQU8sQ0FBZDs7QUFFQSxvQkFBSSxFQUFFLENBQUYsQ0FBSjtBQUNBLG9CQUFJLENBQUMsRUFBRSxJQUFJLENBQU4sSUFBVyxDQUFaLEtBQWtCLElBQUksRUFBRSxDQUFGLENBQXRCLENBQUo7QUFDQSxvQkFBSSxXQUFXLENBQVgsRUFBYyxDQUFkLENBQUo7QUFDQSxvQkFBSSxJQUFJLENBQVIsRUFBVztBQUNQLHdCQUFJLENBQUMsQ0FBTDtBQUNIOztBQUVELGtCQUFFLENBQUYsSUFBTyxFQUFFLENBQUYsS0FBUSxJQUFJLENBQVosQ0FBUDtBQUNBLGtCQUFFLElBQUksQ0FBTixJQUFXLEVBQUUsQ0FBRixLQUFRLElBQUksQ0FBWixDQUFYO0FBQ0Esc0JBQU0sRUFBRSxJQUFJLENBQU4sQ0FBTjtBQUNBLG9CQUFJLElBQUksRUFBRSxDQUFGLENBQVI7QUFDQSxxQkFBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLENBQXBCLEVBQXVCLEdBQXZCLEVBQTRCO0FBQ3hCLHNCQUFFLENBQUYsS0FBUSxDQUFSO0FBQ0g7O0FBRUQsb0JBQUksSUFBSSxDQUFSOztBQUVBLG9CQUFJLEVBQUUsQ0FBRixDQUFKO0FBQ0Esb0JBQUksQ0FBSjtBQUNBLHFCQUFLLENBQUw7QUFDQSxxQkFBSyxDQUFMO0FBQ0Esc0JBQU0sRUFBRSxJQUFJLENBQU4sQ0FBTjtBQUNBLG9CQUFJLENBQUo7QUFDQSxxQkFBSyxDQUFMO0FBQ0EscUJBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsS0FBSyxDQUFyQixFQUF3QixHQUF4QixFQUE2QjtBQUN6Qix5QkFBSyxFQUFMO0FBQ0EseUJBQUssQ0FBTDtBQUNBLHlCQUFLLENBQUw7QUFDQSx3QkFBSSxJQUFJLEVBQUUsQ0FBRixDQUFSO0FBQ0Esd0JBQUksSUFBSSxDQUFSO0FBQ0Esd0JBQUksV0FBVyxDQUFYLEVBQWMsRUFBRSxDQUFGLENBQWQsQ0FBSjtBQUNBLHNCQUFFLElBQUksQ0FBTixJQUFXLElBQUksQ0FBZjtBQUNBLHdCQUFJLEVBQUUsQ0FBRixJQUFPLENBQVg7QUFDQSx3QkFBSSxJQUFJLENBQVI7QUFDQSx3QkFBSSxJQUFJLEVBQUUsQ0FBRixDQUFKLEdBQVcsSUFBSSxDQUFuQjtBQUNBLHNCQUFFLElBQUksQ0FBTixJQUFXLElBQUksS0FBSyxJQUFJLENBQUosR0FBUSxJQUFJLEVBQUUsQ0FBRixDQUFqQixDQUFmOztBQUVBLHlCQUFLLElBQUksQ0FBVCxFQUFZLElBQUksQ0FBaEIsRUFBbUIsR0FBbkIsRUFBd0I7QUFDcEIsNEJBQUksRUFBRSxDQUFGLEVBQUssSUFBSSxDQUFULENBQUo7QUFDQSwwQkFBRSxDQUFGLEVBQUssSUFBSSxDQUFULElBQWMsSUFBSSxFQUFFLENBQUYsRUFBSyxDQUFMLENBQUosR0FBYyxJQUFJLENBQWhDO0FBQ0EsMEJBQUUsQ0FBRixFQUFLLENBQUwsSUFBVSxJQUFJLEVBQUUsQ0FBRixFQUFLLENBQUwsQ0FBSixHQUFjLElBQUksQ0FBNUI7QUFDSDtBQUNKOztBQUVELG9CQUFJLENBQUMsQ0FBRCxHQUFLLEVBQUwsR0FBVSxFQUFWLEdBQWUsR0FBZixHQUFxQixFQUFFLENBQUYsQ0FBckIsR0FBNEIsR0FBaEM7QUFDQSxrQkFBRSxDQUFGLElBQU8sSUFBSSxDQUFYO0FBQ0Esa0JBQUUsQ0FBRixJQUFPLElBQUksQ0FBWDtBQUVILGFBbkRELFFBb0RPLEtBQUssR0FBTCxDQUFTLEVBQUUsQ0FBRixDQUFULElBQWlCLE1BQU0sSUFwRDlCO0FBcURIO0FBQ0QsVUFBRSxDQUFGLElBQU8sRUFBRSxDQUFGLElBQU8sQ0FBZDtBQUNBLFVBQUUsQ0FBRixJQUFPLENBQVA7QUFDSDs7QUFFRCxTQUFLLElBQUksQ0FBVCxFQUFZLElBQUksSUFBSSxDQUFwQixFQUF1QixHQUF2QixFQUE0QjtBQUN4QixZQUFJLENBQUo7QUFDQSxZQUFJLEVBQUUsQ0FBRixDQUFKO0FBQ0EsYUFBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLENBQXBCLEVBQXVCLEdBQXZCLEVBQTRCO0FBQ3hCLGdCQUFJLEVBQUUsQ0FBRixJQUFPLENBQVgsRUFBYztBQUNWLG9CQUFJLENBQUo7QUFDQSxvQkFBSSxFQUFFLENBQUYsQ0FBSjtBQUNIO0FBQ0o7O0FBRUQsWUFBSSxNQUFNLENBQVYsRUFBYTtBQUNULGNBQUUsQ0FBRixJQUFPLEVBQUUsQ0FBRixDQUFQO0FBQ0EsY0FBRSxDQUFGLElBQU8sQ0FBUDtBQUNBLGlCQUFLLElBQUksQ0FBVCxFQUFZLElBQUksQ0FBaEIsRUFBbUIsR0FBbkIsRUFBd0I7QUFDcEIsb0JBQUksRUFBRSxDQUFGLEVBQUssQ0FBTCxDQUFKO0FBQ0Esa0JBQUUsQ0FBRixFQUFLLENBQUwsSUFBVSxFQUFFLENBQUYsRUFBSyxDQUFMLENBQVY7QUFDQSxrQkFBRSxDQUFGLEVBQUssQ0FBTCxJQUFVLENBQVY7QUFDSDtBQUNKO0FBQ0o7QUFDSjs7QUFFRCxTQUFTLE1BQVQsQ0FBZ0IsQ0FBaEIsRUFBbUIsQ0FBbkIsRUFBc0IsR0FBdEIsRUFBMkIsQ0FBM0IsRUFBOEI7O0FBRTFCLFFBQUksTUFBTSxDQUFWO0FBQUEsUUFDSSxPQUFPLElBQUksQ0FEZjtBQUFBLFFBRUksQ0FGSjtBQUFBLFFBRU8sQ0FGUDtBQUFBLFFBRVUsQ0FGVjtBQUFBLFFBRWEsQ0FGYjtBQUFBLFFBRWdCLENBRmhCO0FBQUEsUUFFbUIsQ0FGbkI7QUFBQSxRQUdJLEtBSEo7O0FBS0EsU0FBSyxJQUFJLE1BQU0sQ0FBZixFQUFrQixLQUFLLE9BQU8sQ0FBOUIsRUFBaUMsR0FBakMsRUFBc0M7QUFDbEMsZ0JBQVEsQ0FBUjtBQUNBLGFBQUssSUFBSSxDQUFULEVBQVksS0FBSyxJQUFqQixFQUF1QixHQUF2QixFQUE0QjtBQUN4QixvQkFBUSxRQUFRLEtBQUssR0FBTCxDQUFTLEVBQUUsQ0FBRixFQUFLLElBQUksQ0FBVCxDQUFULENBQWhCO0FBQ0g7O0FBRUQsWUFBSSxVQUFVLENBQWQsRUFBaUI7QUFDYixnQkFBSSxDQUFKO0FBQ0EsaUJBQUssSUFBSSxJQUFULEVBQWUsS0FBSyxDQUFwQixFQUF1QixHQUF2QixFQUE0QjtBQUN4QixvQkFBSSxDQUFKLElBQVMsRUFBRSxDQUFGLEVBQUssSUFBSSxDQUFULElBQWMsS0FBdkI7QUFDQSxxQkFBSyxJQUFJLENBQUosSUFBUyxJQUFJLENBQUosQ0FBZDtBQUNIOztBQUVELGdCQUFJLEtBQUssSUFBTCxDQUFVLENBQVYsQ0FBSjtBQUNBLGdCQUFJLElBQUksQ0FBSixJQUFTLENBQWIsRUFBZ0I7QUFDWixvQkFBSSxDQUFDLENBQUw7QUFDSDs7QUFFRCxnQkFBSSxJQUFJLElBQUksQ0FBSixJQUFTLENBQWpCO0FBQ0EsZ0JBQUksQ0FBSixJQUFTLElBQUksQ0FBSixJQUFTLENBQWxCOztBQUVBLGlCQUFLLElBQUksQ0FBVCxFQUFZLElBQUksQ0FBaEIsRUFBbUIsR0FBbkIsRUFBd0I7QUFDcEIsb0JBQUksQ0FBSjtBQUNBLHFCQUFLLElBQUksSUFBVCxFQUFlLEtBQUssQ0FBcEIsRUFBdUIsR0FBdkIsRUFBNEI7QUFDeEIseUJBQUssSUFBSSxDQUFKLElBQVMsRUFBRSxDQUFGLEVBQUssQ0FBTCxDQUFkO0FBQ0g7O0FBRUQsb0JBQUksSUFBSSxDQUFSO0FBQ0EscUJBQUssSUFBSSxDQUFULEVBQVksS0FBSyxJQUFqQixFQUF1QixHQUF2QixFQUE0QjtBQUN4QixzQkFBRSxDQUFGLEVBQUssQ0FBTCxLQUFXLElBQUksSUFBSSxDQUFKLENBQWY7QUFDSDtBQUNKOztBQUVELGlCQUFLLElBQUksQ0FBVCxFQUFZLEtBQUssSUFBakIsRUFBdUIsR0FBdkIsRUFBNEI7QUFDeEIsb0JBQUksQ0FBSjtBQUNBLHFCQUFLLElBQUksSUFBVCxFQUFlLEtBQUssQ0FBcEIsRUFBdUIsR0FBdkIsRUFBNEI7QUFDeEIseUJBQUssSUFBSSxDQUFKLElBQVMsRUFBRSxDQUFGLEVBQUssQ0FBTCxDQUFkO0FBQ0g7O0FBRUQsb0JBQUksSUFBSSxDQUFSO0FBQ0EscUJBQUssSUFBSSxDQUFULEVBQVksS0FBSyxJQUFqQixFQUF1QixHQUF2QixFQUE0QjtBQUN4QixzQkFBRSxDQUFGLEVBQUssQ0FBTCxLQUFXLElBQUksSUFBSSxDQUFKLENBQWY7QUFDSDtBQUNKOztBQUVELGdCQUFJLENBQUosSUFBUyxRQUFRLElBQUksQ0FBSixDQUFqQjtBQUNBLGNBQUUsQ0FBRixFQUFLLElBQUksQ0FBVCxJQUFjLFFBQVEsQ0FBdEI7QUFDSDtBQUNKOztBQUVELFNBQUssSUFBSSxDQUFULEVBQVksSUFBSSxDQUFoQixFQUFtQixHQUFuQixFQUF3QjtBQUNwQixhQUFLLElBQUksQ0FBVCxFQUFZLElBQUksQ0FBaEIsRUFBbUIsR0FBbkIsRUFBd0I7QUFDcEIsY0FBRSxDQUFGLEVBQUssQ0FBTCxJQUFXLE1BQU0sQ0FBTixHQUFVLENBQVYsR0FBYyxDQUF6QjtBQUNIO0FBQ0o7O0FBRUQsU0FBSyxJQUFJLE9BQU8sQ0FBaEIsRUFBbUIsS0FBSyxNQUFNLENBQTlCLEVBQWlDLEdBQWpDLEVBQXNDO0FBQ2xDLFlBQUksRUFBRSxDQUFGLEVBQUssSUFBSSxDQUFULE1BQWdCLENBQXBCLEVBQXVCO0FBQ25CLGlCQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLEtBQUssSUFBckIsRUFBMkIsR0FBM0IsRUFBZ0M7QUFDNUIsb0JBQUksQ0FBSixJQUFTLEVBQUUsQ0FBRixFQUFLLElBQUksQ0FBVCxDQUFUO0FBQ0g7O0FBRUQsaUJBQUssSUFBSSxDQUFULEVBQVksS0FBSyxJQUFqQixFQUF1QixHQUF2QixFQUE0QjtBQUN4QixvQkFBSSxDQUFKO0FBQ0EscUJBQUssSUFBSSxDQUFULEVBQVksS0FBSyxJQUFqQixFQUF1QixHQUF2QixFQUE0QjtBQUN4Qix5QkFBSyxJQUFJLENBQUosSUFBUyxFQUFFLENBQUYsRUFBSyxDQUFMLENBQWQ7QUFDSDs7QUFFRCxvQkFBSyxJQUFJLElBQUksQ0FBSixDQUFMLEdBQWUsRUFBRSxDQUFGLEVBQUssSUFBSSxDQUFULENBQW5CO0FBQ0EscUJBQUssSUFBSSxDQUFULEVBQVksS0FBSyxJQUFqQixFQUF1QixHQUF2QixFQUE0QjtBQUN4QixzQkFBRSxDQUFGLEVBQUssQ0FBTCxLQUFXLElBQUksSUFBSSxDQUFKLENBQWY7QUFDSDtBQUNKO0FBQ0o7QUFDSjtBQUNKOztBQUVELFNBQVMsSUFBVCxDQUFjLEVBQWQsRUFBa0IsQ0FBbEIsRUFBcUIsQ0FBckIsRUFBd0IsQ0FBeEIsRUFBMkIsQ0FBM0IsRUFBOEI7QUFDMUIsUUFBSSxJQUFJLEtBQUssQ0FBYjtBQUFBLFFBQ0ksTUFBTSxDQURWO0FBQUEsUUFFSSxPQUFPLEtBQUssQ0FGaEI7QUFBQSxRQUdJLE1BQU0sS0FBSyxHQUFMLENBQVMsQ0FBVCxFQUFZLENBQUMsRUFBYixDQUhWO0FBQUEsUUFJSSxVQUFVLENBSmQ7QUFBQSxRQUtJLE9BQU8sQ0FMWDtBQUFBLFFBTUksSUFBSSxDQU5SO0FBQUEsUUFPSSxJQUFJLENBUFI7QUFBQSxRQVFJLElBQUksQ0FSUjtBQUFBLFFBU0ksSUFBSSxDQVRSO0FBQUEsUUFVSSxJQUFJLENBVlI7QUFBQSxRQVdJLE9BQU8sQ0FYWDtBQUFBLFFBWUksQ0FaSjtBQUFBLFFBWU8sQ0FaUDtBQUFBLFFBWVUsQ0FaVjtBQUFBLFFBWWEsQ0FaYjtBQUFBLFFBWWdCLENBWmhCO0FBQUEsUUFZbUIsQ0FabkI7QUFBQSxRQVlzQixDQVp0QjtBQUFBLFFBWXlCLENBWnpCO0FBQUEsUUFZNEIsQ0FaNUI7QUFBQSxRQWFJLEVBYko7QUFBQSxRQWFRLEVBYlI7QUFBQSxRQWFZLEVBYlo7QUFBQSxRQWFnQixFQWJoQjtBQUFBLFFBY0ksT0FkSjtBQUFBLFFBY2EsT0FkYjs7QUFnQkEsU0FBSyxJQUFJLENBQVQsRUFBWSxJQUFJLEVBQWhCLEVBQW9CLEdBQXBCLEVBQXlCO0FBQ3JCLFlBQUksSUFBSSxHQUFKLElBQVcsSUFBSSxJQUFuQixFQUF5QjtBQUNyQixjQUFFLENBQUYsSUFBTyxFQUFFLENBQUYsRUFBSyxDQUFMLENBQVA7QUFDQSxjQUFFLENBQUYsSUFBTyxDQUFQO0FBQ0g7O0FBRUQsYUFBSyxJQUFJLEtBQUssR0FBTCxDQUFTLElBQUksQ0FBYixFQUFnQixDQUFoQixDQUFULEVBQTZCLElBQUksRUFBakMsRUFBcUMsR0FBckMsRUFBMEM7QUFDdEMsbUJBQU8sT0FBTyxLQUFLLEdBQUwsQ0FBUyxFQUFFLENBQUYsRUFBSyxDQUFMLENBQVQsQ0FBZDtBQUNIO0FBQ0o7O0FBRUQsV0FBTyxLQUFLLEdBQVosRUFBaUI7QUFDYixZQUFJLENBQUo7QUFDQSxlQUFPLElBQUksR0FBWCxFQUFnQjtBQUNaLGdCQUFJLEtBQUssR0FBTCxDQUFTLEVBQUUsSUFBSSxDQUFOLEVBQVMsSUFBSSxDQUFiLENBQVQsSUFBNEIsS0FBSyxHQUFMLENBQVMsRUFBRSxDQUFGLEVBQUssQ0FBTCxDQUFULENBQWhDO0FBQ0EsZ0JBQUksTUFBTSxDQUFWLEVBQWE7QUFDVCxvQkFBSSxJQUFKO0FBQ0g7QUFDRCxnQkFBSSxLQUFLLEdBQUwsQ0FBUyxFQUFFLENBQUYsRUFBSyxJQUFJLENBQVQsQ0FBVCxJQUF3QixNQUFNLENBQWxDLEVBQXFDO0FBQ2pDO0FBQ0g7QUFDRDtBQUNIOztBQUVELFlBQUksTUFBTSxDQUFWLEVBQWE7QUFDVCxjQUFFLENBQUYsRUFBSyxDQUFMLElBQVUsRUFBRSxDQUFGLEVBQUssQ0FBTCxJQUFVLE9BQXBCO0FBQ0EsY0FBRSxDQUFGLElBQU8sRUFBRSxDQUFGLEVBQUssQ0FBTCxDQUFQO0FBQ0EsY0FBRSxDQUFGLElBQU8sQ0FBUDtBQUNBO0FBQ0EsbUJBQU8sQ0FBUDtBQUNILFNBTkQsTUFNTyxJQUFJLE1BQU0sSUFBSSxDQUFkLEVBQWlCO0FBQ3BCLGdCQUFJLEVBQUUsQ0FBRixFQUFLLElBQUksQ0FBVCxJQUFjLEVBQUUsSUFBSSxDQUFOLEVBQVMsQ0FBVCxDQUFsQjtBQUNBLGdCQUFJLENBQUMsRUFBRSxJQUFJLENBQU4sRUFBUyxJQUFJLENBQWIsSUFBa0IsRUFBRSxDQUFGLEVBQUssQ0FBTCxDQUFuQixJQUE4QixDQUFsQztBQUNBLGdCQUFJLElBQUksQ0FBSixHQUFRLENBQVo7QUFDQSxnQkFBSSxLQUFLLElBQUwsQ0FBVSxLQUFLLEdBQUwsQ0FBUyxDQUFULENBQVYsQ0FBSjtBQUNBLGNBQUUsQ0FBRixFQUFLLENBQUwsSUFBVSxFQUFFLENBQUYsRUFBSyxDQUFMLElBQVUsT0FBcEI7QUFDQSxjQUFFLElBQUksQ0FBTixFQUFTLElBQUksQ0FBYixJQUFrQixFQUFFLElBQUksQ0FBTixFQUFTLElBQUksQ0FBYixJQUFrQixPQUFwQztBQUNBLGdCQUFJLEVBQUUsQ0FBRixFQUFLLENBQUwsQ0FBSjs7QUFFQSxnQkFBSSxLQUFLLENBQVQsRUFBWTtBQUNSLG9CQUFLLEtBQUssQ0FBTixHQUFZLElBQUksQ0FBaEIsR0FBc0IsSUFBSSxDQUE5QjtBQUNBLGtCQUFFLElBQUksQ0FBTixJQUFXLElBQUksQ0FBZjtBQUNBLGtCQUFFLENBQUYsSUFBTyxFQUFFLElBQUksQ0FBTixDQUFQO0FBQ0Esb0JBQUksTUFBTSxDQUFWLEVBQWE7QUFDVCxzQkFBRSxDQUFGLElBQU8sSUFBSSxJQUFJLENBQWY7QUFDSDtBQUNELGtCQUFFLElBQUksQ0FBTixJQUFXLENBQVg7QUFDQSxrQkFBRSxDQUFGLElBQU8sQ0FBUDtBQUNBLG9CQUFJLEVBQUUsQ0FBRixFQUFLLElBQUksQ0FBVCxDQUFKO0FBQ0Esb0JBQUksS0FBSyxHQUFMLENBQVMsQ0FBVCxJQUFjLEtBQUssR0FBTCxDQUFTLENBQVQsQ0FBbEI7QUFDQSxvQkFBSSxJQUFJLENBQVI7QUFDQSxvQkFBSSxJQUFJLENBQVI7QUFDQSxvQkFBSSxLQUFLLElBQUwsQ0FBVSxJQUFJLENBQUosR0FBUSxJQUFJLENBQXRCLENBQUo7QUFDQSxvQkFBSSxJQUFJLENBQVI7QUFDQSxvQkFBSSxJQUFJLENBQVI7O0FBRUEscUJBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxFQUFwQixFQUF3QixHQUF4QixFQUE2QjtBQUN6Qix3QkFBSSxFQUFFLElBQUksQ0FBTixFQUFTLENBQVQsQ0FBSjtBQUNBLHNCQUFFLElBQUksQ0FBTixFQUFTLENBQVQsSUFBYyxJQUFJLENBQUosR0FBUSxJQUFJLEVBQUUsQ0FBRixFQUFLLENBQUwsQ0FBMUI7QUFDQSxzQkFBRSxDQUFGLEVBQUssQ0FBTCxJQUFVLElBQUksRUFBRSxDQUFGLEVBQUssQ0FBTCxDQUFKLEdBQWMsSUFBSSxDQUE1QjtBQUNIOztBQUVELHFCQUFLLElBQUksQ0FBVCxFQUFZLEtBQUssQ0FBakIsRUFBb0IsR0FBcEIsRUFBeUI7QUFDckIsd0JBQUksRUFBRSxDQUFGLEVBQUssSUFBSSxDQUFULENBQUo7QUFDQSxzQkFBRSxDQUFGLEVBQUssSUFBSSxDQUFULElBQWMsSUFBSSxDQUFKLEdBQVEsSUFBSSxFQUFFLENBQUYsRUFBSyxDQUFMLENBQTFCO0FBQ0Esc0JBQUUsQ0FBRixFQUFLLENBQUwsSUFBVSxJQUFJLEVBQUUsQ0FBRixFQUFLLENBQUwsQ0FBSixHQUFjLElBQUksQ0FBNUI7QUFDSDs7QUFFRCxxQkFBSyxJQUFJLEdBQVQsRUFBYyxLQUFLLElBQW5CLEVBQXlCLEdBQXpCLEVBQThCO0FBQzFCLHdCQUFJLEVBQUUsQ0FBRixFQUFLLElBQUksQ0FBVCxDQUFKO0FBQ0Esc0JBQUUsQ0FBRixFQUFLLElBQUksQ0FBVCxJQUFjLElBQUksQ0FBSixHQUFRLElBQUksRUFBRSxDQUFGLEVBQUssQ0FBTCxDQUExQjtBQUNBLHNCQUFFLENBQUYsRUFBSyxDQUFMLElBQVUsSUFBSSxFQUFFLENBQUYsRUFBSyxDQUFMLENBQUosR0FBYyxJQUFJLENBQTVCO0FBQ0g7QUFDSixhQWxDRCxNQWtDTztBQUNILGtCQUFFLElBQUksQ0FBTixJQUFXLElBQUksQ0FBZjtBQUNBLGtCQUFFLENBQUYsSUFBTyxJQUFJLENBQVg7QUFDQSxrQkFBRSxJQUFJLENBQU4sSUFBVyxDQUFYO0FBQ0Esa0JBQUUsQ0FBRixJQUFPLENBQUMsQ0FBUjtBQUNIOztBQUVELGdCQUFJLElBQUksQ0FBUjtBQUNBLG1CQUFPLENBQVA7QUFDSCxTQXBETSxNQW9EQTtBQUNILGdCQUFJLEVBQUUsQ0FBRixFQUFLLENBQUwsQ0FBSjtBQUNBLGdCQUFJLENBQUo7QUFDQSxnQkFBSSxDQUFKO0FBQ0EsZ0JBQUksSUFBSSxDQUFSLEVBQVc7QUFDUCxvQkFBSSxFQUFFLElBQUksQ0FBTixFQUFTLElBQUksQ0FBYixDQUFKO0FBQ0Esb0JBQUksRUFBRSxDQUFGLEVBQUssSUFBSSxDQUFULElBQWMsRUFBRSxJQUFJLENBQU4sRUFBUyxDQUFULENBQWxCO0FBQ0g7O0FBRUQsZ0JBQUksU0FBUyxFQUFiLEVBQWlCO0FBQ2IsMkJBQVcsQ0FBWDtBQUNBLHFCQUFLLElBQUksR0FBVCxFQUFjLEtBQUssQ0FBbkIsRUFBc0IsR0FBdEIsRUFBMkI7QUFDdkIsc0JBQUUsQ0FBRixFQUFLLENBQUwsS0FBVyxDQUFYO0FBQ0g7QUFDRCxvQkFBSSxLQUFLLEdBQUwsQ0FBUyxFQUFFLENBQUYsRUFBSyxJQUFJLENBQVQsQ0FBVCxJQUF3QixLQUFLLEdBQUwsQ0FBUyxFQUFFLElBQUksQ0FBTixFQUFTLElBQUksQ0FBYixDQUFULENBQTVCO0FBQ0Esb0JBQUksSUFBSSxPQUFPLENBQWY7QUFDQSxvQkFBSSxDQUFDLE1BQUQsR0FBVSxDQUFWLEdBQWMsQ0FBbEI7QUFDSDs7QUFFRCxnQkFBSSxTQUFTLEVBQWIsRUFBaUI7QUFDYixvQkFBSSxDQUFDLElBQUksQ0FBTCxJQUFVLENBQWQ7QUFDQSxvQkFBSSxJQUFJLENBQUosR0FBUSxDQUFaO0FBQ0Esb0JBQUksSUFBSSxDQUFSLEVBQVc7QUFDUCx3QkFBSSxLQUFLLElBQUwsQ0FBVSxDQUFWLENBQUo7QUFDQSx3QkFBSSxJQUFJLENBQVIsRUFBVztBQUNQLDRCQUFJLENBQUMsQ0FBTDtBQUNIO0FBQ0Qsd0JBQUksSUFBSSxLQUFLLENBQUMsSUFBSSxDQUFMLElBQVUsQ0FBVixHQUFjLENBQW5CLENBQVI7QUFDQSx5QkFBSyxJQUFJLEdBQVQsRUFBYyxLQUFLLENBQW5CLEVBQXNCLEdBQXRCLEVBQTJCO0FBQ3ZCLDBCQUFFLENBQUYsRUFBSyxDQUFMLEtBQVcsQ0FBWDtBQUNIO0FBQ0QsK0JBQVcsQ0FBWDtBQUNBLHdCQUFJLElBQUksSUFBSSxLQUFaO0FBQ0g7QUFDSjs7QUFFRCxtQkFBTyxPQUFPLENBQWQ7O0FBRUEsZ0JBQUksSUFBSSxDQUFSO0FBQ0EsbUJBQU8sS0FBSyxDQUFaLEVBQWU7QUFDWCxvQkFBSSxFQUFFLENBQUYsRUFBSyxDQUFMLENBQUo7QUFDQSxvQkFBSSxJQUFJLENBQVI7QUFDQSxvQkFBSSxJQUFJLENBQVI7QUFDQSxvQkFBSSxDQUFDLElBQUksQ0FBSixHQUFRLENBQVQsSUFBYyxFQUFFLElBQUksQ0FBTixFQUFTLENBQVQsQ0FBZCxHQUE0QixFQUFFLENBQUYsRUFBSyxJQUFJLENBQVQsQ0FBaEM7QUFDQSxvQkFBSSxFQUFFLElBQUksQ0FBTixFQUFTLElBQUksQ0FBYixJQUFrQixDQUFsQixHQUFzQixDQUF0QixHQUEwQixDQUE5QjtBQUNBLG9CQUFJLEVBQUUsSUFBSSxDQUFOLEVBQVMsSUFBSSxDQUFiLENBQUo7QUFDQSxvQkFBSSxLQUFLLEdBQUwsQ0FBUyxDQUFULElBQWMsS0FBSyxHQUFMLENBQVMsQ0FBVCxDQUFkLEdBQTRCLEtBQUssR0FBTCxDQUFTLENBQVQsQ0FBaEM7QUFDQSxvQkFBSSxJQUFJLENBQVI7QUFDQSxvQkFBSSxJQUFJLENBQVI7QUFDQSxvQkFBSSxJQUFJLENBQVI7QUFDQSxvQkFBSSxNQUFNLENBQVYsRUFBYTtBQUNUO0FBQ0g7QUFDRCxvQkFBSSxLQUFLLEdBQUwsQ0FBUyxFQUFFLENBQUYsRUFBSyxJQUFJLENBQVQsQ0FBVCxLQUF5QixLQUFLLEdBQUwsQ0FBUyxDQUFULElBQWMsS0FBSyxHQUFMLENBQVMsQ0FBVCxDQUF2QyxJQUFzRCxPQUFPLEtBQUssR0FBTCxDQUFTLENBQVQsS0FBZSxLQUFLLEdBQUwsQ0FBUyxFQUFFLElBQUksQ0FBTixFQUFTLElBQUksQ0FBYixDQUFULElBQTRCLEtBQUssR0FBTCxDQUFTLENBQVQsQ0FBNUIsR0FBMEMsS0FBSyxHQUFMLENBQVMsRUFBRSxJQUFJLENBQU4sRUFBUyxJQUFJLENBQWIsQ0FBVCxDQUF6RCxDQUFQLENBQTFELEVBQXVKO0FBQ25KO0FBQ0g7QUFDRDtBQUNIOztBQUVELGlCQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLEtBQUssQ0FBckIsRUFBd0IsR0FBeEIsRUFBNkI7QUFDekIsa0JBQUUsQ0FBRixFQUFLLElBQUksQ0FBVCxJQUFjLENBQWQ7QUFDQSxvQkFBSSxJQUFJLElBQUksQ0FBWixFQUFlO0FBQ1gsc0JBQUUsQ0FBRixFQUFLLElBQUksQ0FBVCxJQUFjLENBQWQ7QUFDSDtBQUNKOztBQUVELGlCQUFLLElBQUksQ0FBVCxFQUFZLEtBQUssSUFBSSxDQUFyQixFQUF3QixHQUF4QixFQUE2QjtBQUN6QiwwQkFBVyxNQUFNLElBQUksQ0FBckI7QUFDQSxvQkFBSSxNQUFNLENBQVYsRUFBYTtBQUNULHdCQUFJLEVBQUUsQ0FBRixFQUFLLElBQUksQ0FBVCxDQUFKO0FBQ0Esd0JBQUksRUFBRSxJQUFJLENBQU4sRUFBUyxJQUFJLENBQWIsQ0FBSjtBQUNBLHdCQUFLLFVBQVUsRUFBRSxJQUFJLENBQU4sRUFBUyxJQUFJLENBQWIsQ0FBVixHQUE0QixDQUFqQztBQUNBLHdCQUFJLEtBQUssR0FBTCxDQUFTLENBQVQsSUFBYyxLQUFLLEdBQUwsQ0FBUyxDQUFULENBQWQsR0FBNEIsS0FBSyxHQUFMLENBQVMsQ0FBVCxDQUFoQztBQUNBLHdCQUFJLE1BQU0sQ0FBVixFQUFhO0FBQ1QsNEJBQUksSUFBSSxDQUFSO0FBQ0EsNEJBQUksSUFBSSxDQUFSO0FBQ0EsNEJBQUksSUFBSSxDQUFSO0FBQ0g7QUFDSjs7QUFFRCxvQkFBSSxNQUFNLENBQVYsRUFBYTtBQUNUO0FBQ0g7O0FBRUQsb0JBQUksS0FBSyxJQUFMLENBQVUsSUFBSSxDQUFKLEdBQVEsSUFBSSxDQUFaLEdBQWdCLElBQUksQ0FBOUIsQ0FBSjtBQUNBLG9CQUFJLElBQUksQ0FBUixFQUFXO0FBQ1Asd0JBQUksQ0FBQyxDQUFMO0FBQ0g7O0FBRUQsb0JBQUksTUFBTSxDQUFWLEVBQWE7QUFDVCx3QkFBSSxNQUFNLENBQVYsRUFBYTtBQUNULDBCQUFFLENBQUYsRUFBSyxJQUFJLENBQVQsSUFBYyxDQUFDLENBQUQsR0FBSyxDQUFuQjtBQUNILHFCQUZELE1BRU8sSUFBSSxNQUFNLENBQVYsRUFBYTtBQUNoQiwwQkFBRSxDQUFGLEVBQUssSUFBSSxDQUFULElBQWMsQ0FBQyxFQUFFLENBQUYsRUFBSyxJQUFJLENBQVQsQ0FBZjtBQUNIOztBQUVELHdCQUFJLElBQUksQ0FBUjtBQUNBLHdCQUFJLElBQUksQ0FBUjtBQUNBLHdCQUFJLElBQUksQ0FBUjtBQUNBLHdCQUFJLElBQUksQ0FBUjtBQUNBLHdCQUFJLElBQUksQ0FBUjtBQUNBLHdCQUFJLElBQUksQ0FBUjs7QUFFQSx5QkFBSyxJQUFJLENBQVQsRUFBWSxJQUFJLEVBQWhCLEVBQW9CLEdBQXBCLEVBQXlCO0FBQ3JCLDRCQUFJLEVBQUUsQ0FBRixFQUFLLENBQUwsSUFBVSxJQUFJLEVBQUUsSUFBSSxDQUFOLEVBQVMsQ0FBVCxDQUFsQjtBQUNBLDRCQUFJLE9BQUosRUFBYTtBQUNULGdDQUFJLElBQUksSUFBSSxFQUFFLElBQUksQ0FBTixFQUFTLENBQVQsQ0FBWjtBQUNBLDhCQUFFLElBQUksQ0FBTixFQUFTLENBQVQsSUFBYyxFQUFFLElBQUksQ0FBTixFQUFTLENBQVQsSUFBYyxJQUFJLENBQWhDO0FBQ0g7O0FBRUQsMEJBQUUsQ0FBRixFQUFLLENBQUwsSUFBVSxFQUFFLENBQUYsRUFBSyxDQUFMLElBQVUsSUFBSSxDQUF4QjtBQUNBLDBCQUFFLElBQUksQ0FBTixFQUFTLENBQVQsSUFBYyxFQUFFLElBQUksQ0FBTixFQUFTLENBQVQsSUFBYyxJQUFJLENBQWhDO0FBQ0g7O0FBRUQseUJBQUssSUFBSSxDQUFULEVBQVksS0FBSyxLQUFLLEdBQUwsQ0FBUyxDQUFULEVBQVksSUFBSSxDQUFoQixDQUFqQixFQUFxQyxHQUFyQyxFQUEwQztBQUN0Qyw0QkFBSSxJQUFJLEVBQUUsQ0FBRixFQUFLLENBQUwsQ0FBSixHQUFjLElBQUksRUFBRSxDQUFGLEVBQUssSUFBSSxDQUFULENBQXRCO0FBQ0EsNEJBQUksT0FBSixFQUFhO0FBQ1QsZ0NBQUksSUFBSSxJQUFJLEVBQUUsQ0FBRixFQUFLLElBQUksQ0FBVCxDQUFaO0FBQ0EsOEJBQUUsQ0FBRixFQUFLLElBQUksQ0FBVCxJQUFjLEVBQUUsQ0FBRixFQUFLLElBQUksQ0FBVCxJQUFjLElBQUksQ0FBaEM7QUFDSDs7QUFFRCwwQkFBRSxDQUFGLEVBQUssQ0FBTCxJQUFVLEVBQUUsQ0FBRixFQUFLLENBQUwsSUFBVSxDQUFwQjtBQUNBLDBCQUFFLENBQUYsRUFBSyxJQUFJLENBQVQsSUFBYyxFQUFFLENBQUYsRUFBSyxJQUFJLENBQVQsSUFBYyxJQUFJLENBQWhDO0FBQ0g7O0FBRUQseUJBQUssSUFBSSxHQUFULEVBQWMsS0FBSyxJQUFuQixFQUF5QixHQUF6QixFQUE4QjtBQUMxQiw0QkFBSSxJQUFJLEVBQUUsQ0FBRixFQUFLLENBQUwsQ0FBSixHQUFjLElBQUksRUFBRSxDQUFGLEVBQUssSUFBSSxDQUFULENBQXRCO0FBQ0EsNEJBQUksT0FBSixFQUFhO0FBQ1QsZ0NBQUksSUFBSSxJQUFJLEVBQUUsQ0FBRixFQUFLLElBQUksQ0FBVCxDQUFaO0FBQ0EsOEJBQUUsQ0FBRixFQUFLLElBQUksQ0FBVCxJQUFjLEVBQUUsQ0FBRixFQUFLLElBQUksQ0FBVCxJQUFjLElBQUksQ0FBaEM7QUFDSDs7QUFFRCwwQkFBRSxDQUFGLEVBQUssQ0FBTCxJQUFVLEVBQUUsQ0FBRixFQUFLLENBQUwsSUFBVSxDQUFwQjtBQUNBLDBCQUFFLENBQUYsRUFBSyxJQUFJLENBQVQsSUFBYyxFQUFFLENBQUYsRUFBSyxJQUFJLENBQVQsSUFBYyxJQUFJLENBQWhDO0FBQ0g7QUFDSjtBQUNKO0FBQ0o7QUFDSjs7QUFFRCxRQUFJLFNBQVMsQ0FBYixFQUFnQjtBQUNaO0FBQ0g7O0FBRUQsU0FBSyxJQUFJLEtBQUssQ0FBZCxFQUFpQixLQUFLLENBQXRCLEVBQXlCLEdBQXpCLEVBQThCO0FBQzFCLFlBQUksRUFBRSxDQUFGLENBQUo7QUFDQSxZQUFJLEVBQUUsQ0FBRixDQUFKOztBQUVBLFlBQUksTUFBTSxDQUFWLEVBQWE7QUFDVCxnQkFBSSxDQUFKO0FBQ0EsY0FBRSxDQUFGLEVBQUssQ0FBTCxJQUFVLENBQVY7QUFDQSxpQkFBSyxJQUFJLElBQUksQ0FBYixFQUFnQixLQUFLLENBQXJCLEVBQXdCLEdBQXhCLEVBQTZCO0FBQ3pCLG9CQUFJLEVBQUUsQ0FBRixFQUFLLENBQUwsSUFBVSxDQUFkO0FBQ0Esb0JBQUksQ0FBSjtBQUNBLHFCQUFLLElBQUksQ0FBVCxFQUFZLEtBQUssQ0FBakIsRUFBb0IsR0FBcEIsRUFBeUI7QUFDckIsd0JBQUksSUFBSSxFQUFFLENBQUYsRUFBSyxDQUFMLElBQVUsRUFBRSxDQUFGLEVBQUssQ0FBTCxDQUFsQjtBQUNIOztBQUVELG9CQUFJLEVBQUUsQ0FBRixJQUFPLENBQVgsRUFBYztBQUNWLHdCQUFJLENBQUo7QUFDQSx3QkFBSSxDQUFKO0FBQ0gsaUJBSEQsTUFHTztBQUNILHdCQUFJLENBQUo7QUFDQSx3QkFBSSxFQUFFLENBQUYsTUFBUyxDQUFiLEVBQWdCO0FBQ1osMEJBQUUsQ0FBRixFQUFLLENBQUwsSUFBVyxNQUFNLENBQVAsR0FBYSxDQUFDLENBQUQsR0FBSyxDQUFsQixHQUF3QixDQUFDLENBQUQsSUFBTSxNQUFNLElBQVosQ0FBbEM7QUFDSCxxQkFGRCxNQUVPO0FBQ0gsNEJBQUksRUFBRSxDQUFGLEVBQUssSUFBSSxDQUFULENBQUo7QUFDQSw0QkFBSSxFQUFFLElBQUksQ0FBTixFQUFTLENBQVQsQ0FBSjtBQUNBLDRCQUFJLENBQUMsRUFBRSxDQUFGLElBQU8sQ0FBUixLQUFjLEVBQUUsQ0FBRixJQUFPLENBQXJCLElBQTBCLEVBQUUsQ0FBRixJQUFPLEVBQUUsQ0FBRixDQUFyQztBQUNBLDRCQUFJLENBQUMsSUFBSSxDQUFKLEdBQVEsSUFBSSxDQUFiLElBQWtCLENBQXRCO0FBQ0EsMEJBQUUsQ0FBRixFQUFLLENBQUwsSUFBVSxDQUFWO0FBQ0EsMEJBQUUsSUFBSSxDQUFOLEVBQVMsQ0FBVCxJQUFlLEtBQUssR0FBTCxDQUFTLENBQVQsSUFBYyxLQUFLLEdBQUwsQ0FBUyxDQUFULENBQWYsR0FBK0IsQ0FBQyxDQUFDLENBQUQsR0FBSyxJQUFJLENBQVYsSUFBZSxDQUE5QyxHQUFvRCxDQUFDLENBQUMsQ0FBRCxHQUFLLElBQUksQ0FBVixJQUFlLENBQWpGO0FBQ0g7O0FBRUQsd0JBQUksS0FBSyxHQUFMLENBQVMsRUFBRSxDQUFGLEVBQUssQ0FBTCxDQUFULENBQUo7QUFDQSx3QkFBSyxNQUFNLENBQVAsR0FBWSxDQUFaLEdBQWdCLENBQXBCLEVBQXVCO0FBQ25CLDZCQUFLLElBQUksQ0FBVCxFQUFZLEtBQUssQ0FBakIsRUFBb0IsR0FBcEIsRUFBeUI7QUFDckIsOEJBQUUsQ0FBRixFQUFLLENBQUwsSUFBVSxFQUFFLENBQUYsRUFBSyxDQUFMLElBQVUsQ0FBcEI7QUFDSDtBQUNKO0FBQ0o7QUFDSjtBQUNKLFNBbENELE1Ba0NPLElBQUksSUFBSSxDQUFSLEVBQVc7QUFDZCxnQkFBSSxJQUFJLENBQVI7O0FBRUEsZ0JBQUksS0FBSyxHQUFMLENBQVMsRUFBRSxDQUFGLEVBQUssSUFBSSxDQUFULENBQVQsSUFBd0IsS0FBSyxHQUFMLENBQVMsRUFBRSxJQUFJLENBQU4sRUFBUyxDQUFULENBQVQsQ0FBNUIsRUFBbUQ7QUFDL0Msa0JBQUUsSUFBSSxDQUFOLEVBQVMsSUFBSSxDQUFiLElBQWtCLElBQUksRUFBRSxDQUFGLEVBQUssSUFBSSxDQUFULENBQXRCO0FBQ0Esa0JBQUUsSUFBSSxDQUFOLEVBQVMsQ0FBVCxJQUFjLEVBQUUsRUFBRSxDQUFGLEVBQUssQ0FBTCxJQUFVLENBQVosSUFBaUIsRUFBRSxDQUFGLEVBQUssSUFBSSxDQUFULENBQS9CO0FBQ0gsYUFIRCxNQUdPO0FBQ0gsMEJBQVUsS0FBSyxDQUFMLEVBQVEsQ0FBQyxFQUFFLElBQUksQ0FBTixFQUFTLENBQVQsQ0FBVCxFQUFzQixFQUFFLElBQUksQ0FBTixFQUFTLElBQUksQ0FBYixJQUFrQixDQUF4QyxFQUEyQyxDQUEzQyxDQUFWO0FBQ0Esa0JBQUUsSUFBSSxDQUFOLEVBQVMsSUFBSSxDQUFiLElBQWtCLFFBQVEsQ0FBUixDQUFsQjtBQUNBLGtCQUFFLElBQUksQ0FBTixFQUFTLENBQVQsSUFBYyxRQUFRLENBQVIsQ0FBZDtBQUNIOztBQUVELGNBQUUsQ0FBRixFQUFLLElBQUksQ0FBVCxJQUFjLENBQWQ7QUFDQSxjQUFFLENBQUYsRUFBSyxDQUFMLElBQVUsQ0FBVjtBQUNBLGlCQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLEtBQUssQ0FBckIsRUFBd0IsR0FBeEIsRUFBNkI7QUFDekIscUJBQUssQ0FBTDtBQUNBLHFCQUFLLENBQUw7QUFDQSxxQkFBSyxJQUFJLENBQVQsRUFBWSxLQUFLLENBQWpCLEVBQW9CLEdBQXBCLEVBQXlCO0FBQ3JCLHlCQUFLLEtBQUssRUFBRSxDQUFGLEVBQUssQ0FBTCxJQUFVLEVBQUUsQ0FBRixFQUFLLElBQUksQ0FBVCxDQUFwQjtBQUNBLHlCQUFLLEtBQUssRUFBRSxDQUFGLEVBQUssQ0FBTCxJQUFVLEVBQUUsQ0FBRixFQUFLLENBQUwsQ0FBcEI7QUFDSDs7QUFFRCxvQkFBSSxFQUFFLENBQUYsRUFBSyxDQUFMLElBQVUsQ0FBZDs7QUFFQSxvQkFBSSxFQUFFLENBQUYsSUFBTyxDQUFYLEVBQWM7QUFDVix3QkFBSSxDQUFKO0FBQ0Esd0JBQUksRUFBSjtBQUNBLHdCQUFJLEVBQUo7QUFDSCxpQkFKRCxNQUlPO0FBQ0gsd0JBQUksQ0FBSjtBQUNBLHdCQUFJLEVBQUUsQ0FBRixNQUFTLENBQWIsRUFBZ0I7QUFDWixrQ0FBVSxLQUFLLENBQUMsRUFBTixFQUFVLENBQUMsRUFBWCxFQUFlLENBQWYsRUFBa0IsQ0FBbEIsQ0FBVjtBQUNBLDBCQUFFLENBQUYsRUFBSyxJQUFJLENBQVQsSUFBYyxRQUFRLENBQVIsQ0FBZDtBQUNBLDBCQUFFLENBQUYsRUFBSyxDQUFMLElBQVUsUUFBUSxDQUFSLENBQVY7QUFDSCxxQkFKRCxNQUlPO0FBQ0gsNEJBQUksRUFBRSxDQUFGLEVBQUssSUFBSSxDQUFULENBQUo7QUFDQSw0QkFBSSxFQUFFLElBQUksQ0FBTixFQUFTLENBQVQsQ0FBSjtBQUNBLDZCQUFLLENBQUMsRUFBRSxDQUFGLElBQU8sQ0FBUixLQUFjLEVBQUUsQ0FBRixJQUFPLENBQXJCLElBQTBCLEVBQUUsQ0FBRixJQUFPLEVBQUUsQ0FBRixDQUFqQyxHQUF3QyxJQUFJLENBQWpEO0FBQ0EsNkJBQUssQ0FBQyxFQUFFLENBQUYsSUFBTyxDQUFSLElBQWEsQ0FBYixHQUFpQixDQUF0QjtBQUNBLDRCQUFJLE9BQU8sQ0FBUCxJQUFZLE9BQU8sQ0FBdkIsRUFBMEI7QUFDdEIsaUNBQUssTUFBTSxJQUFOLElBQWMsS0FBSyxHQUFMLENBQVMsQ0FBVCxJQUFjLEtBQUssR0FBTCxDQUFTLENBQVQsQ0FBZCxHQUE0QixLQUFLLEdBQUwsQ0FBUyxDQUFULENBQTVCLEdBQTBDLEtBQUssR0FBTCxDQUFTLENBQVQsQ0FBMUMsR0FBd0QsS0FBSyxHQUFMLENBQVMsQ0FBVCxDQUF0RSxDQUFMO0FBQ0g7QUFDRCxrQ0FBVSxLQUFLLElBQUksQ0FBSixHQUFRLElBQUksRUFBWixHQUFpQixJQUFJLEVBQTFCLEVBQThCLElBQUksQ0FBSixHQUFRLElBQUksRUFBWixHQUFpQixJQUFJLEVBQW5ELEVBQXVELEVBQXZELEVBQTJELEVBQTNELENBQVY7QUFDQSwwQkFBRSxDQUFGLEVBQUssSUFBSSxDQUFULElBQWMsUUFBUSxDQUFSLENBQWQ7QUFDQSwwQkFBRSxDQUFGLEVBQUssQ0FBTCxJQUFVLFFBQVEsQ0FBUixDQUFWO0FBQ0EsNEJBQUksS0FBSyxHQUFMLENBQVMsQ0FBVCxJQUFlLEtBQUssR0FBTCxDQUFTLENBQVQsSUFBYyxLQUFLLEdBQUwsQ0FBUyxDQUFULENBQWpDLEVBQStDO0FBQzNDLDhCQUFFLElBQUksQ0FBTixFQUFTLElBQUksQ0FBYixJQUFrQixDQUFDLENBQUMsRUFBRCxHQUFNLElBQUksRUFBRSxDQUFGLEVBQUssSUFBSSxDQUFULENBQVYsR0FBd0IsSUFBSSxFQUFFLENBQUYsRUFBSyxDQUFMLENBQTdCLElBQXdDLENBQTFEO0FBQ0EsOEJBQUUsSUFBSSxDQUFOLEVBQVMsQ0FBVCxJQUFjLENBQUMsQ0FBQyxFQUFELEdBQU0sSUFBSSxFQUFFLENBQUYsRUFBSyxDQUFMLENBQVYsR0FBb0IsSUFBSSxFQUFFLENBQUYsRUFBSyxJQUFJLENBQVQsQ0FBekIsSUFBd0MsQ0FBdEQ7QUFDSCx5QkFIRCxNQUdPO0FBQ0gsc0NBQVUsS0FBSyxDQUFDLENBQUQsR0FBSyxJQUFJLEVBQUUsQ0FBRixFQUFLLElBQUksQ0FBVCxDQUFkLEVBQTJCLENBQUMsQ0FBRCxHQUFLLElBQUksRUFBRSxDQUFGLEVBQUssQ0FBTCxDQUFwQyxFQUE2QyxDQUE3QyxFQUFnRCxDQUFoRCxDQUFWO0FBQ0EsOEJBQUUsSUFBSSxDQUFOLEVBQVMsSUFBSSxDQUFiLElBQWtCLFFBQVEsQ0FBUixDQUFsQjtBQUNBLDhCQUFFLElBQUksQ0FBTixFQUFTLENBQVQsSUFBYyxRQUFRLENBQVIsQ0FBZDtBQUNIO0FBQ0o7O0FBRUQsd0JBQUksS0FBSyxHQUFMLENBQVMsS0FBSyxHQUFMLENBQVMsRUFBRSxDQUFGLEVBQUssSUFBSSxDQUFULENBQVQsQ0FBVCxFQUFnQyxLQUFLLEdBQUwsQ0FBUyxFQUFFLENBQUYsRUFBSyxDQUFMLENBQVQsQ0FBaEMsQ0FBSjtBQUNBLHdCQUFLLE1BQU0sQ0FBUCxHQUFZLENBQVosR0FBZ0IsQ0FBcEIsRUFBdUI7QUFDbkIsNkJBQUssSUFBSSxDQUFULEVBQVksS0FBSyxDQUFqQixFQUFvQixHQUFwQixFQUF5QjtBQUNyQiw4QkFBRSxDQUFGLEVBQUssSUFBSSxDQUFULElBQWMsRUFBRSxDQUFGLEVBQUssSUFBSSxDQUFULElBQWMsQ0FBNUI7QUFDQSw4QkFBRSxDQUFGLEVBQUssQ0FBTCxJQUFVLEVBQUUsQ0FBRixFQUFLLENBQUwsSUFBVSxDQUFwQjtBQUNIO0FBQ0o7QUFDSjtBQUNKO0FBQ0o7QUFDSjs7QUFFRCxTQUFLLElBQUksQ0FBVCxFQUFZLElBQUksRUFBaEIsRUFBb0IsR0FBcEIsRUFBeUI7QUFDckIsWUFBSSxJQUFJLEdBQUosSUFBVyxJQUFJLElBQW5CLEVBQXlCO0FBQ3JCLGlCQUFLLElBQUksQ0FBVCxFQUFZLElBQUksRUFBaEIsRUFBb0IsR0FBcEIsRUFBeUI7QUFDckIsa0JBQUUsQ0FBRixFQUFLLENBQUwsSUFBVSxFQUFFLENBQUYsRUFBSyxDQUFMLENBQVY7QUFDSDtBQUNKO0FBQ0o7O0FBRUQsU0FBSyxJQUFJLEtBQUssQ0FBZCxFQUFpQixLQUFLLEdBQXRCLEVBQTJCLEdBQTNCLEVBQWdDO0FBQzVCLGFBQUssSUFBSSxHQUFULEVBQWMsS0FBSyxJQUFuQixFQUF5QixHQUF6QixFQUE4QjtBQUMxQixnQkFBSSxDQUFKO0FBQ0EsaUJBQUssSUFBSSxHQUFULEVBQWMsS0FBSyxLQUFLLEdBQUwsQ0FBUyxDQUFULEVBQVksSUFBWixDQUFuQixFQUFzQyxHQUF0QyxFQUEyQztBQUN2QyxvQkFBSSxJQUFJLEVBQUUsQ0FBRixFQUFLLENBQUwsSUFBVSxFQUFFLENBQUYsRUFBSyxDQUFMLENBQWxCO0FBQ0g7QUFDRCxjQUFFLENBQUYsRUFBSyxDQUFMLElBQVUsQ0FBVjtBQUNIO0FBQ0o7QUFDSjs7QUFFRCxTQUFTLElBQVQsQ0FBYyxFQUFkLEVBQWtCLEVBQWxCLEVBQXNCLEVBQXRCLEVBQTBCLEVBQTFCLEVBQThCO0FBQzFCLFFBQUksQ0FBSixFQUFPLENBQVA7QUFDQSxRQUFJLEtBQUssR0FBTCxDQUFTLEVBQVQsSUFBZSxLQUFLLEdBQUwsQ0FBUyxFQUFULENBQW5CLEVBQWlDO0FBQzdCLFlBQUksS0FBSyxFQUFUO0FBQ0EsWUFBSSxLQUFLLElBQUksRUFBYjtBQUNBLGVBQU8sQ0FBQyxDQUFDLEtBQUssSUFBSSxFQUFWLElBQWdCLENBQWpCLEVBQW9CLENBQUMsS0FBSyxJQUFJLEVBQVYsSUFBZ0IsQ0FBcEMsQ0FBUDtBQUNILEtBSkQsTUFLSztBQUNELFlBQUksS0FBSyxFQUFUO0FBQ0EsWUFBSSxLQUFLLElBQUksRUFBYjtBQUNBLGVBQU8sQ0FBQyxDQUFDLElBQUksRUFBSixHQUFTLEVBQVYsSUFBZ0IsQ0FBakIsRUFBb0IsQ0FBQyxJQUFJLEVBQUosR0FBUyxFQUFWLElBQWdCLENBQXBDLENBQVA7QUFDSDtBQUNKOztBQUVELE9BQU8sT0FBUCxHQUFpQix1QkFBakI7OztBQzl3QkE7O0FBRUEsSUFBSSxTQUFTLFFBQVEsV0FBUixDQUFiOzs7QUFHQSxTQUFTLGVBQVQsQ0FBeUIsTUFBekIsRUFBaUM7QUFDN0IsUUFBSSxFQUFFLGdCQUFnQixlQUFsQixDQUFKLEVBQXdDO0FBQ3BDLGVBQU8sSUFBSSxlQUFKLENBQW9CLE1BQXBCLENBQVA7QUFDSDtBQUNELGFBQVMsT0FBTyxXQUFQLENBQW1CLE1BQW5CLENBQVQ7O0FBRUEsUUFBSSxLQUFLLE9BQU8sS0FBUCxFQUFUO0FBQUEsUUFDSSxPQUFPLEdBQUcsSUFEZDtBQUFBLFFBRUksVUFBVSxHQUFHLE9BRmpCO0FBQUEsUUFHSSxjQUFjLElBQUksS0FBSixDQUFVLElBQVYsQ0FIbEI7QUFBQSxRQUlJLFlBQVksQ0FKaEI7QUFBQSxRQUtJLENBTEo7QUFBQSxRQUtPLENBTFA7QUFBQSxRQUtVLENBTFY7QUFBQSxRQUthLENBTGI7QUFBQSxRQUtnQixDQUxoQjtBQUFBLFFBS21CLENBTG5CO0FBQUEsUUFLc0IsQ0FMdEI7QUFBQSxRQU1JLE1BTko7QUFBQSxRQU1ZLE1BTlo7QUFBQSxRQU1vQixJQU5wQjs7QUFRQSxTQUFLLElBQUksQ0FBVCxFQUFZLElBQUksSUFBaEIsRUFBc0IsR0FBdEIsRUFBMkI7QUFDdkIsb0JBQVksQ0FBWixJQUFpQixDQUFqQjtBQUNIOztBQUVELGFBQVMsSUFBSSxLQUFKLENBQVUsSUFBVixDQUFUOztBQUVBLFNBQUssSUFBSSxDQUFULEVBQVksSUFBSSxPQUFoQixFQUF5QixHQUF6QixFQUE4Qjs7QUFFMUIsYUFBSyxJQUFJLENBQVQsRUFBWSxJQUFJLElBQWhCLEVBQXNCLEdBQXRCLEVBQTJCO0FBQ3ZCLG1CQUFPLENBQVAsSUFBWSxHQUFHLENBQUgsRUFBTSxDQUFOLENBQVo7QUFDSDs7QUFFRCxhQUFLLElBQUksQ0FBVCxFQUFZLElBQUksSUFBaEIsRUFBc0IsR0FBdEIsRUFBMkI7QUFDdkIscUJBQVMsR0FBRyxDQUFILENBQVQ7QUFDQSxtQkFBTyxLQUFLLEdBQUwsQ0FBUyxDQUFULEVBQVksQ0FBWixDQUFQO0FBQ0EsZ0JBQUksQ0FBSjtBQUNBLGlCQUFLLElBQUksQ0FBVCxFQUFZLElBQUksSUFBaEIsRUFBc0IsR0FBdEIsRUFBMkI7QUFDdkIscUJBQUssT0FBTyxDQUFQLElBQVksT0FBTyxDQUFQLENBQWpCO0FBQ0g7QUFDRCxtQkFBTyxDQUFQLElBQVksT0FBTyxDQUFQLEtBQWEsQ0FBekI7QUFDSDs7QUFFRCxZQUFJLENBQUo7QUFDQSxhQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksSUFBcEIsRUFBMEIsR0FBMUIsRUFBK0I7QUFDM0IsZ0JBQUksS0FBSyxHQUFMLENBQVMsT0FBTyxDQUFQLENBQVQsSUFBc0IsS0FBSyxHQUFMLENBQVMsT0FBTyxDQUFQLENBQVQsQ0FBMUIsRUFBK0M7QUFDM0Msb0JBQUksQ0FBSjtBQUNIO0FBQ0o7O0FBRUQsWUFBSSxNQUFNLENBQVYsRUFBYTtBQUNULGlCQUFLLElBQUksQ0FBVCxFQUFZLElBQUksT0FBaEIsRUFBeUIsR0FBekIsRUFBOEI7QUFDMUIsb0JBQUksR0FBRyxDQUFILEVBQU0sQ0FBTixDQUFKO0FBQ0EsbUJBQUcsQ0FBSCxFQUFNLENBQU4sSUFBVyxHQUFHLENBQUgsRUFBTSxDQUFOLENBQVg7QUFDQSxtQkFBRyxDQUFILEVBQU0sQ0FBTixJQUFXLENBQVg7QUFDSDs7QUFFRCxnQkFBSSxZQUFZLENBQVosQ0FBSjtBQUNBLHdCQUFZLENBQVosSUFBaUIsWUFBWSxDQUFaLENBQWpCO0FBQ0Esd0JBQVksQ0FBWixJQUFpQixDQUFqQjs7QUFFQSx3QkFBWSxDQUFDLFNBQWI7QUFDSDs7QUFFRCxZQUFJLElBQUksSUFBSixJQUFZLEdBQUcsQ0FBSCxFQUFNLENBQU4sTUFBYSxDQUE3QixFQUFnQztBQUM1QixpQkFBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLElBQXBCLEVBQTBCLEdBQTFCLEVBQStCO0FBQzNCLG1CQUFHLENBQUgsRUFBTSxDQUFOLEtBQVksR0FBRyxDQUFILEVBQU0sQ0FBTixDQUFaO0FBQ0g7QUFDSjtBQUNKOztBQUVELFNBQUssRUFBTCxHQUFVLEVBQVY7QUFDQSxTQUFLLFdBQUwsR0FBbUIsV0FBbkI7QUFDQSxTQUFLLFNBQUwsR0FBaUIsU0FBakI7QUFDSDs7QUFFRCxnQkFBZ0IsU0FBaEIsR0FBNEI7QUFDeEIsZ0JBQVksc0JBQVk7QUFDcEIsWUFBSSxPQUFPLEtBQUssRUFBaEI7QUFBQSxZQUNJLE1BQU0sS0FBSyxPQURmO0FBRUEsYUFBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLEdBQXBCLEVBQXlCLEdBQXpCLEVBQThCO0FBQzFCLGdCQUFJLEtBQUssQ0FBTCxFQUFRLENBQVIsTUFBZSxDQUFuQixFQUFzQjtBQUNsQix1QkFBTyxJQUFQO0FBQ0g7QUFDSjtBQUNELGVBQU8sS0FBUDtBQUNILEtBVnVCO0FBV3hCLFFBQUksV0FBSixHQUFrQjtBQUNkLFlBQUksT0FBTyxLQUFLLEVBQWhCO0FBQ0EsWUFBSSxDQUFDLEtBQUssUUFBTCxFQUFMLEVBQ0ksTUFBTSxJQUFJLEtBQUosQ0FBVSx1QkFBVixDQUFOO0FBQ0osWUFBSSxjQUFjLEtBQUssU0FBdkI7QUFBQSxZQUFrQyxNQUFNLEtBQUssT0FBN0M7QUFDQSxhQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksR0FBcEIsRUFBeUIsR0FBekI7QUFDSSwyQkFBZSxLQUFLLENBQUwsRUFBUSxDQUFSLENBQWY7QUFESixTQUVBLE9BQU8sV0FBUDtBQUNILEtBbkJ1QjtBQW9CeEIsUUFBSSxxQkFBSixHQUE0QjtBQUN4QixZQUFJLE9BQU8sS0FBSyxFQUFoQjtBQUFBLFlBQ0ksT0FBTyxLQUFLLElBRGhCO0FBQUEsWUFFSSxVQUFVLEtBQUssT0FGbkI7QUFBQSxZQUdJLElBQUksSUFBSSxNQUFKLENBQVcsSUFBWCxFQUFpQixPQUFqQixDQUhSO0FBSUEsYUFBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLElBQXBCLEVBQTBCLEdBQTFCLEVBQStCO0FBQzNCLGlCQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksT0FBcEIsRUFBNkIsR0FBN0IsRUFBa0M7QUFDOUIsb0JBQUksSUFBSSxDQUFSLEVBQVc7QUFDUCxzQkFBRSxDQUFGLEVBQUssQ0FBTCxJQUFVLEtBQUssQ0FBTCxFQUFRLENBQVIsQ0FBVjtBQUNILGlCQUZELE1BRU8sSUFBSSxNQUFNLENBQVYsRUFBYTtBQUNoQixzQkFBRSxDQUFGLEVBQUssQ0FBTCxJQUFVLENBQVY7QUFDSCxpQkFGTSxNQUVBO0FBQ0gsc0JBQUUsQ0FBRixFQUFLLENBQUwsSUFBVSxDQUFWO0FBQ0g7QUFDSjtBQUNKO0FBQ0QsZUFBTyxDQUFQO0FBQ0gsS0FyQ3VCO0FBc0N4QixRQUFJLHFCQUFKLEdBQTRCO0FBQ3hCLFlBQUksT0FBTyxLQUFLLEVBQWhCO0FBQUEsWUFDSSxPQUFPLEtBQUssSUFEaEI7QUFBQSxZQUVJLFVBQVUsS0FBSyxPQUZuQjtBQUFBLFlBR0ksSUFBSSxJQUFJLE1BQUosQ0FBVyxJQUFYLEVBQWlCLE9BQWpCLENBSFI7QUFJQSxhQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksSUFBcEIsRUFBMEIsR0FBMUIsRUFBK0I7QUFDM0IsaUJBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxPQUFwQixFQUE2QixHQUE3QixFQUFrQztBQUM5QixvQkFBSSxLQUFLLENBQVQsRUFBWTtBQUNSLHNCQUFFLENBQUYsRUFBSyxDQUFMLElBQVUsS0FBSyxDQUFMLEVBQVEsQ0FBUixDQUFWO0FBQ0gsaUJBRkQsTUFFTztBQUNILHNCQUFFLENBQUYsRUFBSyxDQUFMLElBQVUsQ0FBVjtBQUNIO0FBQ0o7QUFDSjtBQUNELGVBQU8sQ0FBUDtBQUNILEtBckR1QjtBQXNEeEIsUUFBSSxzQkFBSixHQUE2QjtBQUN6QixlQUFPLEtBQUssV0FBTCxDQUFpQixLQUFqQixFQUFQO0FBQ0gsS0F4RHVCO0FBeUR4QixXQUFPLGVBQVUsS0FBVixFQUFpQjtBQUNwQixnQkFBUSxPQUFPLFdBQVAsQ0FBbUIsS0FBbkIsQ0FBUjs7QUFFQSxZQUFJLEtBQUssS0FBSyxFQUFkO0FBQUEsWUFDSSxPQUFPLEdBQUcsSUFEZDs7QUFHQSxZQUFJLFNBQVMsTUFBTSxJQUFuQixFQUNJLE1BQU0sSUFBSSxLQUFKLENBQVUsMkJBQVYsQ0FBTjtBQUNKLFlBQUksS0FBSyxVQUFMLEVBQUosRUFDSSxNQUFNLElBQUksS0FBSixDQUFVLHVCQUFWLENBQU47O0FBRUosWUFBSSxRQUFRLE1BQU0sT0FBbEI7QUFBQSxZQUNJLElBQUksTUFBTSxZQUFOLENBQW1CLEtBQUssV0FBeEIsRUFBcUMsQ0FBckMsRUFBd0MsUUFBUSxDQUFoRCxDQURSO0FBQUEsWUFFSSxVQUFVLEdBQUcsT0FGakI7QUFBQSxZQUdJLENBSEo7QUFBQSxZQUdPLENBSFA7QUFBQSxZQUdVLENBSFY7O0FBS0EsYUFBSyxJQUFJLENBQVQsRUFBWSxJQUFJLE9BQWhCLEVBQXlCLEdBQXpCLEVBQThCO0FBQzFCLGlCQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksT0FBcEIsRUFBNkIsR0FBN0IsRUFBa0M7QUFDOUIscUJBQUssSUFBSSxDQUFULEVBQVksSUFBSSxLQUFoQixFQUF1QixHQUF2QixFQUE0QjtBQUN4QixzQkFBRSxDQUFGLEVBQUssQ0FBTCxLQUFXLEVBQUUsQ0FBRixFQUFLLENBQUwsSUFBVSxHQUFHLENBQUgsRUFBTSxDQUFOLENBQXJCO0FBQ0g7QUFDSjtBQUNKO0FBQ0QsYUFBSyxJQUFJLFVBQVUsQ0FBbkIsRUFBc0IsS0FBSyxDQUEzQixFQUE4QixHQUE5QixFQUFtQztBQUMvQixpQkFBSyxJQUFJLENBQVQsRUFBWSxJQUFJLEtBQWhCLEVBQXVCLEdBQXZCLEVBQTRCO0FBQ3hCLGtCQUFFLENBQUYsRUFBSyxDQUFMLEtBQVcsR0FBRyxDQUFILEVBQU0sQ0FBTixDQUFYO0FBQ0g7QUFDRCxpQkFBSyxJQUFJLENBQVQsRUFBWSxJQUFJLENBQWhCLEVBQW1CLEdBQW5CLEVBQXdCO0FBQ3BCLHFCQUFLLElBQUksQ0FBVCxFQUFZLElBQUksS0FBaEIsRUFBdUIsR0FBdkIsRUFBNEI7QUFDeEIsc0JBQUUsQ0FBRixFQUFLLENBQUwsS0FBVyxFQUFFLENBQUYsRUFBSyxDQUFMLElBQVUsR0FBRyxDQUFILEVBQU0sQ0FBTixDQUFyQjtBQUNIO0FBQ0o7QUFDSjtBQUNELGVBQU8sQ0FBUDtBQUNIO0FBM0Z1QixDQUE1Qjs7QUE4RkEsT0FBTyxPQUFQLEdBQWlCLGVBQWpCOzs7QUN4S0E7O0FBRUEsSUFBSSxTQUFTLFFBQVEsV0FBUixDQUFiO0FBQ0EsSUFBSSxhQUFhLFFBQVEsUUFBUixFQUFrQixVQUFuQzs7O0FBR0EsU0FBUyxlQUFULENBQXlCLEtBQXpCLEVBQWdDO0FBQzVCLFFBQUksRUFBRSxnQkFBZ0IsZUFBbEIsQ0FBSixFQUF3QztBQUNwQyxlQUFPLElBQUksZUFBSixDQUFvQixLQUFwQixDQUFQO0FBQ0g7QUFDRCxZQUFRLE9BQU8sV0FBUCxDQUFtQixLQUFuQixDQUFSOztBQUVBLFFBQUksS0FBSyxNQUFNLEtBQU4sRUFBVDtBQUFBLFFBQ0ksSUFBSSxNQUFNLElBRGQ7QUFBQSxRQUVJLElBQUksTUFBTSxPQUZkO0FBQUEsUUFHSSxRQUFRLElBQUksS0FBSixDQUFVLENBQVYsQ0FIWjtBQUFBLFFBSUksQ0FKSjtBQUFBLFFBSU8sQ0FKUDtBQUFBLFFBSVUsQ0FKVjtBQUFBLFFBSWEsQ0FKYjs7QUFNQSxTQUFLLElBQUksQ0FBVCxFQUFZLElBQUksQ0FBaEIsRUFBbUIsR0FBbkIsRUFBd0I7QUFDcEIsWUFBSSxNQUFNLENBQVY7QUFDQSxhQUFLLElBQUksQ0FBVCxFQUFZLElBQUksQ0FBaEIsRUFBbUIsR0FBbkIsRUFBd0I7QUFDcEIsa0JBQU0sV0FBVyxHQUFYLEVBQWdCLEdBQUcsQ0FBSCxFQUFNLENBQU4sQ0FBaEIsQ0FBTjtBQUNIO0FBQ0QsWUFBSSxRQUFRLENBQVosRUFBZTtBQUNYLGdCQUFJLEdBQUcsQ0FBSCxFQUFNLENBQU4sSUFBVyxDQUFmLEVBQWtCO0FBQ2Qsc0JBQU0sQ0FBQyxHQUFQO0FBQ0g7QUFDRCxpQkFBSyxJQUFJLENBQVQsRUFBWSxJQUFJLENBQWhCLEVBQW1CLEdBQW5CLEVBQXdCO0FBQ3BCLG1CQUFHLENBQUgsRUFBTSxDQUFOLEtBQVksR0FBWjtBQUNIO0FBQ0QsZUFBRyxDQUFILEVBQU0sQ0FBTixLQUFZLENBQVo7QUFDQSxpQkFBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLENBQXBCLEVBQXVCLEdBQXZCLEVBQTRCO0FBQ3hCLG9CQUFJLENBQUo7QUFDQSxxQkFBSyxJQUFJLENBQVQsRUFBWSxJQUFJLENBQWhCLEVBQW1CLEdBQW5CLEVBQXdCO0FBQ3BCLHlCQUFLLEdBQUcsQ0FBSCxFQUFNLENBQU4sSUFBVyxHQUFHLENBQUgsRUFBTSxDQUFOLENBQWhCO0FBQ0g7QUFDRCxvQkFBSSxDQUFDLENBQUQsR0FBSyxHQUFHLENBQUgsRUFBTSxDQUFOLENBQVQ7QUFDQSxxQkFBSyxJQUFJLENBQVQsRUFBWSxJQUFJLENBQWhCLEVBQW1CLEdBQW5CLEVBQXdCO0FBQ3BCLHVCQUFHLENBQUgsRUFBTSxDQUFOLEtBQVksSUFBSSxHQUFHLENBQUgsRUFBTSxDQUFOLENBQWhCO0FBQ0g7QUFDSjtBQUNKO0FBQ0QsY0FBTSxDQUFOLElBQVcsQ0FBQyxHQUFaO0FBQ0g7O0FBRUQsU0FBSyxFQUFMLEdBQVUsRUFBVjtBQUNBLFNBQUssS0FBTCxHQUFhLEtBQWI7QUFDSDs7QUFFRCxnQkFBZ0IsU0FBaEIsR0FBNEI7QUFDeEIsV0FBTyxlQUFVLEtBQVYsRUFBaUI7QUFDcEIsZ0JBQVEsT0FBTyxXQUFQLENBQW1CLEtBQW5CLENBQVI7O0FBRUEsWUFBSSxLQUFLLEtBQUssRUFBZDtBQUFBLFlBQ0ksSUFBSSxHQUFHLElBRFg7O0FBR0EsWUFBSSxNQUFNLElBQU4sS0FBZSxDQUFuQixFQUNJLE1BQU0sSUFBSSxLQUFKLENBQVUsa0NBQVYsQ0FBTjtBQUNKLFlBQUksQ0FBQyxLQUFLLFVBQUwsRUFBTCxFQUNJLE1BQU0sSUFBSSxLQUFKLENBQVUsMEJBQVYsQ0FBTjs7QUFFSixZQUFJLFFBQVEsTUFBTSxPQUFsQjtBQUFBLFlBQ0ksSUFBSSxNQUFNLEtBQU4sRUFEUjtBQUFBLFlBRUksSUFBSSxHQUFHLE9BRlg7QUFBQSxZQUdJLENBSEo7QUFBQSxZQUdPLENBSFA7QUFBQSxZQUdVLENBSFY7QUFBQSxZQUdhLENBSGI7O0FBS0EsYUFBSyxJQUFJLENBQVQsRUFBWSxJQUFJLENBQWhCLEVBQW1CLEdBQW5CLEVBQXdCO0FBQ3BCLGlCQUFLLElBQUksQ0FBVCxFQUFZLElBQUksS0FBaEIsRUFBdUIsR0FBdkIsRUFBNEI7QUFDeEIsb0JBQUksQ0FBSjtBQUNBLHFCQUFLLElBQUksQ0FBVCxFQUFZLElBQUksQ0FBaEIsRUFBbUIsR0FBbkIsRUFBd0I7QUFDcEIseUJBQUssR0FBRyxDQUFILEVBQU0sQ0FBTixJQUFXLEVBQUUsQ0FBRixFQUFLLENBQUwsQ0FBaEI7QUFDSDtBQUNELG9CQUFJLENBQUMsQ0FBRCxHQUFLLEdBQUcsQ0FBSCxFQUFNLENBQU4sQ0FBVDtBQUNBLHFCQUFLLElBQUksQ0FBVCxFQUFZLElBQUksQ0FBaEIsRUFBbUIsR0FBbkIsRUFBd0I7QUFDcEIsc0JBQUUsQ0FBRixFQUFLLENBQUwsS0FBVyxJQUFJLEdBQUcsQ0FBSCxFQUFNLENBQU4sQ0FBZjtBQUNIO0FBQ0o7QUFDSjtBQUNELGFBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsS0FBSyxDQUFyQixFQUF3QixHQUF4QixFQUE2QjtBQUN6QixpQkFBSyxJQUFJLENBQVQsRUFBWSxJQUFJLEtBQWhCLEVBQXVCLEdBQXZCLEVBQTRCO0FBQ3hCLGtCQUFFLENBQUYsRUFBSyxDQUFMLEtBQVcsS0FBSyxLQUFMLENBQVcsQ0FBWCxDQUFYO0FBQ0g7QUFDRCxpQkFBSyxJQUFJLENBQVQsRUFBWSxJQUFJLENBQWhCLEVBQW1CLEdBQW5CLEVBQXdCO0FBQ3BCLHFCQUFLLElBQUksQ0FBVCxFQUFZLElBQUksS0FBaEIsRUFBdUIsR0FBdkIsRUFBNEI7QUFDeEIsc0JBQUUsQ0FBRixFQUFLLENBQUwsS0FBVyxFQUFFLENBQUYsRUFBSyxDQUFMLElBQVUsR0FBRyxDQUFILEVBQU0sQ0FBTixDQUFyQjtBQUNIO0FBQ0o7QUFDSjs7QUFFRCxlQUFPLEVBQUUsU0FBRixDQUFZLENBQVosRUFBZSxJQUFJLENBQW5CLEVBQXNCLENBQXRCLEVBQXlCLFFBQVEsQ0FBakMsQ0FBUDtBQUNILEtBekN1QjtBQTBDeEIsZ0JBQVksc0JBQVk7QUFDcEIsWUFBSSxVQUFVLEtBQUssRUFBTCxDQUFRLE9BQXRCO0FBQ0EsYUFBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLE9BQXBCLEVBQTZCLEdBQTdCLEVBQWtDO0FBQzlCLGdCQUFJLEtBQUssS0FBTCxDQUFXLENBQVgsTUFBa0IsQ0FBdEIsRUFBeUI7QUFDckIsdUJBQU8sS0FBUDtBQUNIO0FBQ0o7QUFDRCxlQUFPLElBQVA7QUFDSCxLQWxEdUI7QUFtRHhCLFFBQUkscUJBQUosR0FBNEI7QUFDeEIsWUFBSSxLQUFLLEtBQUssRUFBZDtBQUFBLFlBQ0ksSUFBSSxHQUFHLE9BRFg7QUFBQSxZQUVJLElBQUksSUFBSSxNQUFKLENBQVcsQ0FBWCxFQUFjLENBQWQsQ0FGUjtBQUFBLFlBR0ksQ0FISjtBQUFBLFlBR08sQ0FIUDtBQUlBLGFBQUssSUFBSSxDQUFULEVBQVksSUFBSSxDQUFoQixFQUFtQixHQUFuQixFQUF3QjtBQUNwQixpQkFBSyxJQUFJLENBQVQsRUFBWSxJQUFJLENBQWhCLEVBQW1CLEdBQW5CLEVBQXdCO0FBQ3BCLG9CQUFJLElBQUksQ0FBUixFQUFXO0FBQ1Asc0JBQUUsQ0FBRixFQUFLLENBQUwsSUFBVSxHQUFHLENBQUgsRUFBTSxDQUFOLENBQVY7QUFDSCxpQkFGRCxNQUVPLElBQUksTUFBTSxDQUFWLEVBQWE7QUFDaEIsc0JBQUUsQ0FBRixFQUFLLENBQUwsSUFBVSxLQUFLLEtBQUwsQ0FBVyxDQUFYLENBQVY7QUFDSCxpQkFGTSxNQUVBO0FBQ0gsc0JBQUUsQ0FBRixFQUFLLENBQUwsSUFBVSxDQUFWO0FBQ0g7QUFDSjtBQUNKO0FBQ0QsZUFBTyxDQUFQO0FBQ0gsS0FwRXVCO0FBcUV4QixRQUFJLGdCQUFKLEdBQXVCO0FBQ25CLFlBQUksS0FBSyxLQUFLLEVBQWQ7QUFBQSxZQUNJLE9BQU8sR0FBRyxJQURkO0FBQUEsWUFFSSxVQUFVLEdBQUcsT0FGakI7QUFBQSxZQUdJLElBQUksSUFBSSxNQUFKLENBQVcsSUFBWCxFQUFpQixPQUFqQixDQUhSO0FBQUEsWUFJSSxDQUpKO0FBQUEsWUFJTyxDQUpQO0FBQUEsWUFJVSxDQUpWO0FBQUEsWUFJYSxDQUpiOztBQU1BLGFBQUssSUFBSSxVQUFVLENBQW5CLEVBQXNCLEtBQUssQ0FBM0IsRUFBOEIsR0FBOUIsRUFBbUM7QUFDL0IsaUJBQUssSUFBSSxDQUFULEVBQVksSUFBSSxJQUFoQixFQUFzQixHQUF0QixFQUEyQjtBQUN2QixrQkFBRSxDQUFGLEVBQUssQ0FBTCxJQUFVLENBQVY7QUFDSDtBQUNELGNBQUUsQ0FBRixFQUFLLENBQUwsSUFBVSxDQUFWO0FBQ0EsaUJBQUssSUFBSSxDQUFULEVBQVksSUFBSSxPQUFoQixFQUF5QixHQUF6QixFQUE4QjtBQUMxQixvQkFBSSxHQUFHLENBQUgsRUFBTSxDQUFOLE1BQWEsQ0FBakIsRUFBb0I7QUFDaEIsd0JBQUksQ0FBSjtBQUNBLHlCQUFLLElBQUksQ0FBVCxFQUFZLElBQUksSUFBaEIsRUFBc0IsR0FBdEIsRUFBMkI7QUFDdkIsNkJBQUssR0FBRyxDQUFILEVBQU0sQ0FBTixJQUFXLEVBQUUsQ0FBRixFQUFLLENBQUwsQ0FBaEI7QUFDSDs7QUFFRCx3QkFBSSxDQUFDLENBQUQsR0FBSyxHQUFHLENBQUgsRUFBTSxDQUFOLENBQVQ7O0FBRUEseUJBQUssSUFBSSxDQUFULEVBQVksSUFBSSxJQUFoQixFQUFzQixHQUF0QixFQUEyQjtBQUN2QiwwQkFBRSxDQUFGLEVBQUssQ0FBTCxLQUFXLElBQUksR0FBRyxDQUFILEVBQU0sQ0FBTixDQUFmO0FBQ0g7QUFDSjtBQUNKO0FBQ0o7QUFDRCxlQUFPLENBQVA7QUFDSDtBQWpHdUIsQ0FBNUI7O0FBb0dBLE9BQU8sT0FBUCxHQUFpQixlQUFqQjs7O0FDckpBOztBQUVBLElBQUksU0FBUyxRQUFRLFdBQVIsQ0FBYjtBQUNBLElBQUksT0FBTyxRQUFRLFFBQVIsQ0FBWDtBQUNBLElBQUksYUFBYSxLQUFLLFVBQXRCO0FBQ0EsSUFBSSxtQkFBbUIsS0FBSyxnQkFBNUI7OztBQUdBLFNBQVMsMEJBQVQsQ0FBb0MsS0FBcEMsRUFBMkMsT0FBM0MsRUFBb0Q7QUFDaEQsUUFBSSxFQUFFLGdCQUFnQiwwQkFBbEIsQ0FBSixFQUFtRDtBQUMvQyxlQUFPLElBQUksMEJBQUosQ0FBK0IsS0FBL0IsRUFBc0MsT0FBdEMsQ0FBUDtBQUNIO0FBQ0QsWUFBUSxPQUFPLFdBQVAsQ0FBbUIsS0FBbkIsQ0FBUjs7QUFFQSxjQUFVLFdBQVcsRUFBckI7O0FBRUEsUUFBSSxJQUFJLE1BQU0sSUFBZDtBQUFBLFFBQ0ksSUFBSSxNQUFNLE9BRGQ7QUFBQSxRQUVJLEtBQUssS0FBSyxHQUFMLENBQVMsQ0FBVCxFQUFZLENBQVosQ0FGVDs7QUFJQSxRQUFJLFFBQVEsSUFBWjtBQUFBLFFBQWtCLFFBQVEsSUFBMUI7QUFDQSxRQUFJLFFBQVEsMEJBQVIsS0FBdUMsS0FBM0MsRUFDSSxRQUFRLEtBQVI7QUFDSixRQUFJLFFBQVEsMkJBQVIsS0FBd0MsS0FBNUMsRUFDSSxRQUFRLEtBQVI7QUFDSixRQUFJLGdCQUFnQixRQUFRLGFBQVIsS0FBMEIsSUFBOUM7O0FBRUEsUUFBSSxVQUFVLEtBQWQ7QUFDQSxRQUFJLENBQUo7QUFDQSxRQUFJLElBQUksQ0FBUixFQUFXO0FBQ1AsWUFBSSxDQUFDLGFBQUwsRUFBb0I7QUFDaEIsZ0JBQUksTUFBTSxLQUFOLEVBQUo7QUFDQSxvQkFBUSxJQUFSLENBQWEsd0ZBQWI7QUFDSCxTQUhELE1BR087QUFDSCxnQkFBSSxNQUFNLFNBQU4sRUFBSjtBQUNBLGdCQUFJLEVBQUUsSUFBTjtBQUNBLGdCQUFJLEVBQUUsT0FBTjtBQUNBLHNCQUFVLElBQVY7QUFDQSxnQkFBSSxNQUFNLEtBQVY7QUFDQSxvQkFBUSxLQUFSO0FBQ0Esb0JBQVEsR0FBUjtBQUNIO0FBQ0osS0FiRCxNQWFPO0FBQ0gsWUFBSSxNQUFNLEtBQU4sRUFBSjtBQUNIOztBQUVELFFBQUksSUFBSSxJQUFJLEtBQUosQ0FBVSxLQUFLLEdBQUwsQ0FBUyxJQUFJLENBQWIsRUFBZ0IsQ0FBaEIsQ0FBVixDQUFSO0FBQUEsUUFDSSxJQUFJLGlCQUFpQixDQUFqQixFQUFvQixFQUFwQixFQUF3QixDQUF4QixDQURSO0FBQUEsUUFFSSxJQUFJLGlCQUFpQixDQUFqQixFQUFvQixDQUFwQixFQUF1QixDQUF2QixDQUZSO0FBQUEsUUFHSSxJQUFJLElBQUksS0FBSixDQUFVLENBQVYsQ0FIUjtBQUFBLFFBSUksT0FBTyxJQUFJLEtBQUosQ0FBVSxDQUFWLENBSlg7O0FBTUEsUUFBSSxNQUFNLEtBQUssR0FBTCxDQUFTLElBQUksQ0FBYixFQUFnQixDQUFoQixDQUFWO0FBQ0EsUUFBSSxNQUFNLEtBQUssR0FBTCxDQUFTLENBQVQsRUFBWSxLQUFLLEdBQUwsQ0FBUyxJQUFJLENBQWIsRUFBZ0IsQ0FBaEIsQ0FBWixDQUFWOztBQUVBLFFBQUksQ0FBSixFQUFPLENBQVAsRUFBVSxDQUFWLEVBQWEsQ0FBYixFQUFnQixDQUFoQixFQUFtQixFQUFuQixFQUF1QixDQUF2QixFQUEwQixFQUExQixFQUE4QixFQUE5QixFQUFrQyxHQUFsQyxFQUF1QyxJQUF2QyxFQUNJLEtBREosRUFDVyxFQURYLEVBQ2UsSUFEZixFQUNxQixJQURyQixFQUMyQixFQUQzQixFQUMrQixFQUQvQixFQUNtQyxDQURuQyxFQUNzQyxDQUR0QyxFQUN5QyxLQUR6QyxFQUNnRCxDQURoRDs7QUFHQSxTQUFLLElBQUksQ0FBSixFQUFPLE1BQU0sS0FBSyxHQUFMLENBQVMsR0FBVCxFQUFjLEdBQWQsQ0FBbEIsRUFBc0MsSUFBSSxHQUExQyxFQUErQyxHQUEvQyxFQUFvRDtBQUNoRCxZQUFJLElBQUksR0FBUixFQUFhO0FBQ1QsY0FBRSxDQUFGLElBQU8sQ0FBUDtBQUNBLGlCQUFLLElBQUksQ0FBVCxFQUFZLElBQUksQ0FBaEIsRUFBbUIsR0FBbkIsRUFBd0I7QUFDcEIsa0JBQUUsQ0FBRixJQUFPLFdBQVcsRUFBRSxDQUFGLENBQVgsRUFBaUIsRUFBRSxDQUFGLEVBQUssQ0FBTCxDQUFqQixDQUFQO0FBQ0g7QUFDRCxnQkFBSSxFQUFFLENBQUYsTUFBUyxDQUFiLEVBQWdCO0FBQ1osb0JBQUksRUFBRSxDQUFGLEVBQUssQ0FBTCxJQUFVLENBQWQsRUFBaUI7QUFDYixzQkFBRSxDQUFGLElBQU8sQ0FBQyxFQUFFLENBQUYsQ0FBUjtBQUNIO0FBQ0QscUJBQUssSUFBSSxDQUFULEVBQVksSUFBSSxDQUFoQixFQUFtQixHQUFuQixFQUF3QjtBQUNwQixzQkFBRSxDQUFGLEVBQUssQ0FBTCxLQUFXLEVBQUUsQ0FBRixDQUFYO0FBQ0g7QUFDRCxrQkFBRSxDQUFGLEVBQUssQ0FBTCxLQUFXLENBQVg7QUFDSDtBQUNELGNBQUUsQ0FBRixJQUFPLENBQUMsRUFBRSxDQUFGLENBQVI7QUFDSDs7QUFFRCxhQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksQ0FBcEIsRUFBdUIsR0FBdkIsRUFBNEI7QUFDeEIsZ0JBQUssSUFBSSxHQUFMLElBQWMsRUFBRSxDQUFGLE1BQVMsQ0FBM0IsRUFBK0I7QUFDM0Isb0JBQUksQ0FBSjtBQUNBLHFCQUFLLElBQUksQ0FBVCxFQUFZLElBQUksQ0FBaEIsRUFBbUIsR0FBbkIsRUFBd0I7QUFDcEIseUJBQUssRUFBRSxDQUFGLEVBQUssQ0FBTCxJQUFVLEVBQUUsQ0FBRixFQUFLLENBQUwsQ0FBZjtBQUNIO0FBQ0Qsb0JBQUksQ0FBQyxDQUFELEdBQUssRUFBRSxDQUFGLEVBQUssQ0FBTCxDQUFUO0FBQ0EscUJBQUssSUFBSSxDQUFULEVBQVksSUFBSSxDQUFoQixFQUFtQixHQUFuQixFQUF3QjtBQUNwQixzQkFBRSxDQUFGLEVBQUssQ0FBTCxLQUFXLElBQUksRUFBRSxDQUFGLEVBQUssQ0FBTCxDQUFmO0FBQ0g7QUFDSjtBQUNELGNBQUUsQ0FBRixJQUFPLEVBQUUsQ0FBRixFQUFLLENBQUwsQ0FBUDtBQUNIOztBQUVELFlBQUksU0FBVSxJQUFJLEdBQWxCLEVBQXdCO0FBQ3BCLGlCQUFLLElBQUksQ0FBVCxFQUFZLElBQUksQ0FBaEIsRUFBbUIsR0FBbkIsRUFBd0I7QUFDcEIsa0JBQUUsQ0FBRixFQUFLLENBQUwsSUFBVSxFQUFFLENBQUYsRUFBSyxDQUFMLENBQVY7QUFDSDtBQUNKOztBQUVELFlBQUksSUFBSSxHQUFSLEVBQWE7QUFDVCxjQUFFLENBQUYsSUFBTyxDQUFQO0FBQ0EsaUJBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxDQUFwQixFQUF1QixHQUF2QixFQUE0QjtBQUN4QixrQkFBRSxDQUFGLElBQU8sV0FBVyxFQUFFLENBQUYsQ0FBWCxFQUFpQixFQUFFLENBQUYsQ0FBakIsQ0FBUDtBQUNIO0FBQ0QsZ0JBQUksRUFBRSxDQUFGLE1BQVMsQ0FBYixFQUFnQjtBQUNaLG9CQUFJLEVBQUUsSUFBSSxDQUFOLElBQVcsQ0FBZixFQUNJLEVBQUUsQ0FBRixJQUFPLENBQUMsRUFBRSxDQUFGLENBQVI7QUFDSixxQkFBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLENBQXBCLEVBQXVCLEdBQXZCLEVBQTRCO0FBQ3hCLHNCQUFFLENBQUYsS0FBUSxFQUFFLENBQUYsQ0FBUjtBQUNIO0FBQ0Qsa0JBQUUsSUFBSSxDQUFOLEtBQVksQ0FBWjtBQUNIO0FBQ0QsY0FBRSxDQUFGLElBQU8sQ0FBQyxFQUFFLENBQUYsQ0FBUjtBQUNBLGdCQUFLLElBQUksQ0FBSixHQUFRLENBQVQsSUFBZ0IsRUFBRSxDQUFGLE1BQVMsQ0FBN0IsRUFBaUM7QUFDN0IscUJBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxDQUFwQixFQUF1QixHQUF2QixFQUE0QjtBQUN4Qix5QkFBSyxDQUFMLElBQVUsQ0FBVjtBQUNIO0FBQ0QscUJBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxDQUFwQixFQUF1QixHQUF2QixFQUE0QjtBQUN4Qix5QkFBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLENBQXBCLEVBQXVCLEdBQXZCLEVBQTRCO0FBQ3hCLDZCQUFLLENBQUwsS0FBVyxFQUFFLENBQUYsSUFBTyxFQUFFLENBQUYsRUFBSyxDQUFMLENBQWxCO0FBQ0g7QUFDSjtBQUNELHFCQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksQ0FBcEIsRUFBdUIsR0FBdkIsRUFBNEI7QUFDeEIsd0JBQUksQ0FBQyxFQUFFLENBQUYsQ0FBRCxHQUFRLEVBQUUsSUFBSSxDQUFOLENBQVo7QUFDQSx5QkFBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLENBQXBCLEVBQXVCLEdBQXZCLEVBQTRCO0FBQ3hCLDBCQUFFLENBQUYsRUFBSyxDQUFMLEtBQVcsSUFBSSxLQUFLLENBQUwsQ0FBZjtBQUNIO0FBQ0o7QUFDSjtBQUNELGdCQUFJLEtBQUosRUFBVztBQUNQLHFCQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksQ0FBcEIsRUFBdUIsR0FBdkIsRUFBNEI7QUFDeEIsc0JBQUUsQ0FBRixFQUFLLENBQUwsSUFBVSxFQUFFLENBQUYsQ0FBVjtBQUNIO0FBQ0o7QUFDSjtBQUNKOztBQUVELFFBQUksS0FBSyxHQUFMLENBQVMsQ0FBVCxFQUFZLElBQUksQ0FBaEIsQ0FBSjtBQUNBLFFBQUksTUFBTSxDQUFWLEVBQWE7QUFDVCxVQUFFLEdBQUYsSUFBUyxFQUFFLEdBQUYsRUFBTyxHQUFQLENBQVQ7QUFDSDtBQUNELFFBQUksSUFBSSxDQUFSLEVBQVc7QUFDUCxVQUFFLElBQUksQ0FBTixJQUFXLENBQVg7QUFDSDtBQUNELFFBQUksTUFBTSxDQUFOLEdBQVUsQ0FBZCxFQUFpQjtBQUNiLFVBQUUsR0FBRixJQUFTLEVBQUUsR0FBRixFQUFPLElBQUksQ0FBWCxDQUFUO0FBQ0g7QUFDRCxNQUFFLElBQUksQ0FBTixJQUFXLENBQVg7O0FBRUEsUUFBSSxLQUFKLEVBQVc7QUFDUCxhQUFLLElBQUksR0FBVCxFQUFjLElBQUksRUFBbEIsRUFBc0IsR0FBdEIsRUFBMkI7QUFDdkIsaUJBQUssSUFBSSxDQUFULEVBQVksSUFBSSxDQUFoQixFQUFtQixHQUFuQixFQUF3QjtBQUNwQixrQkFBRSxDQUFGLEVBQUssQ0FBTCxJQUFVLENBQVY7QUFDSDtBQUNELGNBQUUsQ0FBRixFQUFLLENBQUwsSUFBVSxDQUFWO0FBQ0g7QUFDRCxhQUFLLElBQUksTUFBTSxDQUFmLEVBQWtCLEtBQUssQ0FBdkIsRUFBMEIsR0FBMUIsRUFBK0I7QUFDM0IsZ0JBQUksRUFBRSxDQUFGLE1BQVMsQ0FBYixFQUFnQjtBQUNaLHFCQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksRUFBcEIsRUFBd0IsR0FBeEIsRUFBNkI7QUFDekIsd0JBQUksQ0FBSjtBQUNBLHlCQUFLLElBQUksQ0FBVCxFQUFZLElBQUksQ0FBaEIsRUFBbUIsR0FBbkIsRUFBd0I7QUFDcEIsNkJBQUssRUFBRSxDQUFGLEVBQUssQ0FBTCxJQUFVLEVBQUUsQ0FBRixFQUFLLENBQUwsQ0FBZjtBQUNIO0FBQ0Qsd0JBQUksQ0FBQyxDQUFELEdBQUssRUFBRSxDQUFGLEVBQUssQ0FBTCxDQUFUO0FBQ0EseUJBQUssSUFBSSxDQUFULEVBQVksSUFBSSxDQUFoQixFQUFtQixHQUFuQixFQUF3QjtBQUNwQiwwQkFBRSxDQUFGLEVBQUssQ0FBTCxLQUFXLElBQUksRUFBRSxDQUFGLEVBQUssQ0FBTCxDQUFmO0FBQ0g7QUFDSjtBQUNELHFCQUFLLElBQUksQ0FBVCxFQUFZLElBQUksQ0FBaEIsRUFBbUIsR0FBbkIsRUFBd0I7QUFDcEIsc0JBQUUsQ0FBRixFQUFLLENBQUwsSUFBVSxDQUFDLEVBQUUsQ0FBRixFQUFLLENBQUwsQ0FBWDtBQUNIO0FBQ0Qsa0JBQUUsQ0FBRixFQUFLLENBQUwsSUFBVSxJQUFJLEVBQUUsQ0FBRixFQUFLLENBQUwsQ0FBZDtBQUNBLHFCQUFLLElBQUksQ0FBVCxFQUFZLElBQUksSUFBSSxDQUFwQixFQUF1QixHQUF2QixFQUE0QjtBQUN4QixzQkFBRSxDQUFGLEVBQUssQ0FBTCxJQUFVLENBQVY7QUFDSDtBQUNKLGFBbEJELE1Ba0JPO0FBQ0gscUJBQUssSUFBSSxDQUFULEVBQVksSUFBSSxDQUFoQixFQUFtQixHQUFuQixFQUF3QjtBQUNwQixzQkFBRSxDQUFGLEVBQUssQ0FBTCxJQUFVLENBQVY7QUFDSDtBQUNELGtCQUFFLENBQUYsRUFBSyxDQUFMLElBQVUsQ0FBVjtBQUNIO0FBQ0o7QUFDSjs7QUFFRCxRQUFJLEtBQUosRUFBVztBQUNQLGFBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsS0FBSyxDQUFyQixFQUF3QixHQUF4QixFQUE2QjtBQUN6QixnQkFBSyxJQUFJLEdBQUwsSUFBYyxFQUFFLENBQUYsTUFBUyxDQUEzQixFQUErQjtBQUMzQixxQkFBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLENBQXBCLEVBQXVCLEdBQXZCLEVBQTRCO0FBQ3hCLHdCQUFJLENBQUo7QUFDQSx5QkFBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLENBQXBCLEVBQXVCLEdBQXZCLEVBQTRCO0FBQ3hCLDZCQUFLLEVBQUUsQ0FBRixFQUFLLENBQUwsSUFBVSxFQUFFLENBQUYsRUFBSyxDQUFMLENBQWY7QUFDSDtBQUNELHdCQUFJLENBQUMsQ0FBRCxHQUFLLEVBQUUsSUFBSSxDQUFOLEVBQVMsQ0FBVCxDQUFUO0FBQ0EseUJBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxDQUFwQixFQUF1QixHQUF2QixFQUE0QjtBQUN4QiwwQkFBRSxDQUFGLEVBQUssQ0FBTCxLQUFXLElBQUksRUFBRSxDQUFGLEVBQUssQ0FBTCxDQUFmO0FBQ0g7QUFDSjtBQUNKO0FBQ0QsaUJBQUssSUFBSSxDQUFULEVBQVksSUFBSSxDQUFoQixFQUFtQixHQUFuQixFQUF3QjtBQUNwQixrQkFBRSxDQUFGLEVBQUssQ0FBTCxJQUFVLENBQVY7QUFDSDtBQUNELGNBQUUsQ0FBRixFQUFLLENBQUwsSUFBVSxDQUFWO0FBQ0g7QUFDSjs7QUFFRCxRQUFJLEtBQUssSUFBSSxDQUFiO0FBQUEsUUFDSSxPQUFPLENBRFg7QUFBQSxRQUVJLE1BQU0sS0FBSyxHQUFMLENBQVMsQ0FBVCxFQUFZLENBQUMsRUFBYixDQUZWO0FBR0EsV0FBTyxJQUFJLENBQVgsRUFBYztBQUNWLGFBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsS0FBSyxDQUFDLENBQXRCLEVBQXlCLEdBQXpCLEVBQThCO0FBQzFCLGdCQUFJLE1BQU0sQ0FBQyxDQUFYLEVBQWM7QUFDVjtBQUNIO0FBQ0QsZ0JBQUksS0FBSyxHQUFMLENBQVMsRUFBRSxDQUFGLENBQVQsS0FBa0IsT0FBTyxLQUFLLEdBQUwsQ0FBUyxFQUFFLENBQUYsQ0FBVCxJQUFpQixLQUFLLEdBQUwsQ0FBUyxFQUFFLElBQUksQ0FBTixDQUFULENBQXhCLENBQXRCLEVBQW1FO0FBQy9ELGtCQUFFLENBQUYsSUFBTyxDQUFQO0FBQ0E7QUFDSDtBQUNKO0FBQ0QsWUFBSSxNQUFNLElBQUksQ0FBZCxFQUFpQjtBQUNiLG1CQUFPLENBQVA7QUFDSCxTQUZELE1BRU87QUFDSCxpQkFBSyxLQUFLLElBQUksQ0FBZCxFQUFpQixNQUFNLENBQXZCLEVBQTBCLElBQTFCLEVBQWdDO0FBQzVCLG9CQUFJLE9BQU8sQ0FBWCxFQUFjO0FBQ1Y7QUFDSDtBQUNELG9CQUFJLENBQUMsT0FBTyxDQUFQLEdBQVcsS0FBSyxHQUFMLENBQVMsRUFBRSxFQUFGLENBQVQsQ0FBWCxHQUE2QixDQUE5QixLQUFvQyxPQUFPLElBQUksQ0FBWCxHQUFlLEtBQUssR0FBTCxDQUFTLEVBQUUsS0FBSyxDQUFQLENBQVQsQ0FBZixHQUFxQyxDQUF6RSxDQUFKO0FBQ0Esb0JBQUksS0FBSyxHQUFMLENBQVMsRUFBRSxFQUFGLENBQVQsS0FBbUIsTUFBTSxDQUE3QixFQUFnQztBQUM1QixzQkFBRSxFQUFGLElBQVEsQ0FBUjtBQUNBO0FBQ0g7QUFDSjtBQUNELGdCQUFJLE9BQU8sQ0FBWCxFQUFjO0FBQ1YsdUJBQU8sQ0FBUDtBQUNILGFBRkQsTUFFTyxJQUFJLE9BQU8sSUFBSSxDQUFmLEVBQWtCO0FBQ3JCLHVCQUFPLENBQVA7QUFDSCxhQUZNLE1BRUE7QUFDSCx1QkFBTyxDQUFQO0FBQ0Esb0JBQUksRUFBSjtBQUNIO0FBQ0o7O0FBRUQ7O0FBRUEsZ0JBQVEsSUFBUjtBQUNJLGlCQUFLLENBQUw7QUFBUTtBQUNKLHdCQUFJLEVBQUUsSUFBSSxDQUFOLENBQUo7QUFDQSxzQkFBRSxJQUFJLENBQU4sSUFBVyxDQUFYO0FBQ0EseUJBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsS0FBSyxDQUFyQixFQUF3QixHQUF4QixFQUE2QjtBQUN6Qiw0QkFBSSxXQUFXLEVBQUUsQ0FBRixDQUFYLEVBQWlCLENBQWpCLENBQUo7QUFDQSw2QkFBSyxFQUFFLENBQUYsSUFBTyxDQUFaO0FBQ0EsNkJBQUssSUFBSSxDQUFUO0FBQ0EsMEJBQUUsQ0FBRixJQUFPLENBQVA7QUFDQSw0QkFBSSxNQUFNLENBQVYsRUFBYTtBQUNULGdDQUFJLENBQUMsRUFBRCxHQUFNLEVBQUUsSUFBSSxDQUFOLENBQVY7QUFDQSw4QkFBRSxJQUFJLENBQU4sSUFBVyxLQUFLLEVBQUUsSUFBSSxDQUFOLENBQWhCO0FBQ0g7QUFDRCw0QkFBSSxLQUFKLEVBQVc7QUFDUCxpQ0FBSyxJQUFJLENBQVQsRUFBWSxJQUFJLENBQWhCLEVBQW1CLEdBQW5CLEVBQXdCO0FBQ3BCLG9DQUFJLEtBQUssRUFBRSxDQUFGLEVBQUssQ0FBTCxDQUFMLEdBQWUsS0FBSyxFQUFFLENBQUYsRUFBSyxJQUFJLENBQVQsQ0FBeEI7QUFDQSxrQ0FBRSxDQUFGLEVBQUssSUFBSSxDQUFULElBQWMsQ0FBQyxFQUFELEdBQU0sRUFBRSxDQUFGLEVBQUssQ0FBTCxDQUFOLEdBQWdCLEtBQUssRUFBRSxDQUFGLEVBQUssSUFBSSxDQUFULENBQW5DO0FBQ0Esa0NBQUUsQ0FBRixFQUFLLENBQUwsSUFBVSxDQUFWO0FBQ0g7QUFDSjtBQUNKO0FBQ0Q7QUFDSDtBQUNELGlCQUFLLENBQUw7QUFBUztBQUNMLHdCQUFJLEVBQUUsSUFBSSxDQUFOLENBQUo7QUFDQSxzQkFBRSxJQUFJLENBQU4sSUFBVyxDQUFYO0FBQ0EseUJBQUssSUFBSSxDQUFULEVBQVksSUFBSSxDQUFoQixFQUFtQixHQUFuQixFQUF3QjtBQUNwQiw0QkFBSSxXQUFXLEVBQUUsQ0FBRixDQUFYLEVBQWlCLENBQWpCLENBQUo7QUFDQSw2QkFBSyxFQUFFLENBQUYsSUFBTyxDQUFaO0FBQ0EsNkJBQUssSUFBSSxDQUFUO0FBQ0EsMEJBQUUsQ0FBRixJQUFPLENBQVA7QUFDQSw0QkFBSSxDQUFDLEVBQUQsR0FBTSxFQUFFLENBQUYsQ0FBVjtBQUNBLDBCQUFFLENBQUYsSUFBTyxLQUFLLEVBQUUsQ0FBRixDQUFaO0FBQ0EsNEJBQUksS0FBSixFQUFXO0FBQ1AsaUNBQUssSUFBSSxDQUFULEVBQVksSUFBSSxDQUFoQixFQUFtQixHQUFuQixFQUF3QjtBQUNwQixvQ0FBSSxLQUFLLEVBQUUsQ0FBRixFQUFLLENBQUwsQ0FBTCxHQUFlLEtBQUssRUFBRSxDQUFGLEVBQUssSUFBSSxDQUFULENBQXhCO0FBQ0Esa0NBQUUsQ0FBRixFQUFLLElBQUksQ0FBVCxJQUFjLENBQUMsRUFBRCxHQUFNLEVBQUUsQ0FBRixFQUFLLENBQUwsQ0FBTixHQUFnQixLQUFLLEVBQUUsQ0FBRixFQUFLLElBQUksQ0FBVCxDQUFuQztBQUNBLGtDQUFFLENBQUYsRUFBSyxDQUFMLElBQVUsQ0FBVjtBQUNIO0FBQ0o7QUFDSjtBQUNEO0FBQ0g7QUFDRCxpQkFBSyxDQUFMO0FBQVM7QUFDTCw0QkFBUSxLQUFLLEdBQUwsQ0FBUyxLQUFLLEdBQUwsQ0FBUyxLQUFLLEdBQUwsQ0FBUyxLQUFLLEdBQUwsQ0FBUyxLQUFLLEdBQUwsQ0FBUyxFQUFFLElBQUksQ0FBTixDQUFULENBQVQsRUFBNkIsS0FBSyxHQUFMLENBQVMsRUFBRSxJQUFJLENBQU4sQ0FBVCxDQUE3QixDQUFULEVBQTJELEtBQUssR0FBTCxDQUFTLEVBQUUsSUFBSSxDQUFOLENBQVQsQ0FBM0QsQ0FBVCxFQUF5RixLQUFLLEdBQUwsQ0FBUyxFQUFFLENBQUYsQ0FBVCxDQUF6RixDQUFULEVBQW1ILEtBQUssR0FBTCxDQUFTLEVBQUUsQ0FBRixDQUFULENBQW5ILENBQVI7QUFDQSx5QkFBSyxFQUFFLElBQUksQ0FBTixJQUFXLEtBQWhCO0FBQ0EsMkJBQU8sRUFBRSxJQUFJLENBQU4sSUFBVyxLQUFsQjtBQUNBLDJCQUFPLEVBQUUsSUFBSSxDQUFOLElBQVcsS0FBbEI7QUFDQSx5QkFBSyxFQUFFLENBQUYsSUFBTyxLQUFaO0FBQ0EseUJBQUssRUFBRSxDQUFGLElBQU8sS0FBWjtBQUNBLHdCQUFJLENBQUMsQ0FBQyxPQUFPLEVBQVIsS0FBZSxPQUFPLEVBQXRCLElBQTRCLE9BQU8sSUFBcEMsSUFBNEMsQ0FBaEQ7QUFDQSx3QkFBSyxLQUFLLElBQU4sSUFBZSxLQUFLLElBQXBCLENBQUo7QUFDQSw0QkFBUSxDQUFSO0FBQ0Esd0JBQUssTUFBTSxDQUFQLElBQWMsTUFBTSxDQUF4QixFQUE0QjtBQUN4QixnQ0FBUSxLQUFLLElBQUwsQ0FBVSxJQUFJLENBQUosR0FBUSxDQUFsQixDQUFSO0FBQ0EsNEJBQUksSUFBSSxDQUFSLEVBQVc7QUFDUCxvQ0FBUSxDQUFDLEtBQVQ7QUFDSDtBQUNELGdDQUFRLEtBQUssSUFBSSxLQUFULENBQVI7QUFDSDtBQUNELHdCQUFJLENBQUMsS0FBSyxFQUFOLEtBQWEsS0FBSyxFQUFsQixJQUF3QixLQUE1QjtBQUNBLHdCQUFJLEtBQUssRUFBVDtBQUNBLHlCQUFLLElBQUksQ0FBVCxFQUFZLElBQUksSUFBSSxDQUFwQixFQUF1QixHQUF2QixFQUE0QjtBQUN4Qiw0QkFBSSxXQUFXLENBQVgsRUFBYyxDQUFkLENBQUo7QUFDQSw2QkFBSyxJQUFJLENBQVQ7QUFDQSw2QkFBSyxJQUFJLENBQVQ7QUFDQSw0QkFBSSxNQUFNLENBQVYsRUFBYTtBQUNULDhCQUFFLElBQUksQ0FBTixJQUFXLENBQVg7QUFDSDtBQUNELDRCQUFJLEtBQUssRUFBRSxDQUFGLENBQUwsR0FBWSxLQUFLLEVBQUUsQ0FBRixDQUFyQjtBQUNBLDBCQUFFLENBQUYsSUFBTyxLQUFLLEVBQUUsQ0FBRixDQUFMLEdBQVksS0FBSyxFQUFFLENBQUYsQ0FBeEI7QUFDQSw0QkFBSSxLQUFLLEVBQUUsSUFBSSxDQUFOLENBQVQ7QUFDQSwwQkFBRSxJQUFJLENBQU4sSUFBVyxLQUFLLEVBQUUsSUFBSSxDQUFOLENBQWhCO0FBQ0EsNEJBQUksS0FBSixFQUFXO0FBQ1AsaUNBQUssSUFBSSxDQUFULEVBQVksSUFBSSxDQUFoQixFQUFtQixHQUFuQixFQUF3QjtBQUNwQixvQ0FBSSxLQUFLLEVBQUUsQ0FBRixFQUFLLENBQUwsQ0FBTCxHQUFlLEtBQUssRUFBRSxDQUFGLEVBQUssSUFBSSxDQUFULENBQXhCO0FBQ0Esa0NBQUUsQ0FBRixFQUFLLElBQUksQ0FBVCxJQUFjLENBQUMsRUFBRCxHQUFNLEVBQUUsQ0FBRixFQUFLLENBQUwsQ0FBTixHQUFnQixLQUFLLEVBQUUsQ0FBRixFQUFLLElBQUksQ0FBVCxDQUFuQztBQUNBLGtDQUFFLENBQUYsRUFBSyxDQUFMLElBQVUsQ0FBVjtBQUNIO0FBQ0o7QUFDRCw0QkFBSSxXQUFXLENBQVgsRUFBYyxDQUFkLENBQUo7QUFDQSw2QkFBSyxJQUFJLENBQVQ7QUFDQSw2QkFBSyxJQUFJLENBQVQ7QUFDQSwwQkFBRSxDQUFGLElBQU8sQ0FBUDtBQUNBLDRCQUFJLEtBQUssRUFBRSxDQUFGLENBQUwsR0FBWSxLQUFLLEVBQUUsSUFBSSxDQUFOLENBQXJCO0FBQ0EsMEJBQUUsSUFBSSxDQUFOLElBQVcsQ0FBQyxFQUFELEdBQU0sRUFBRSxDQUFGLENBQU4sR0FBYSxLQUFLLEVBQUUsSUFBSSxDQUFOLENBQTdCO0FBQ0EsNEJBQUksS0FBSyxFQUFFLElBQUksQ0FBTixDQUFUO0FBQ0EsMEJBQUUsSUFBSSxDQUFOLElBQVcsS0FBSyxFQUFFLElBQUksQ0FBTixDQUFoQjtBQUNBLDRCQUFJLFNBQVUsSUFBSSxJQUFJLENBQXRCLEVBQTBCO0FBQ3RCLGlDQUFLLElBQUksQ0FBVCxFQUFZLElBQUksQ0FBaEIsRUFBbUIsR0FBbkIsRUFBd0I7QUFDcEIsb0NBQUksS0FBSyxFQUFFLENBQUYsRUFBSyxDQUFMLENBQUwsR0FBZSxLQUFLLEVBQUUsQ0FBRixFQUFLLElBQUksQ0FBVCxDQUF4QjtBQUNBLGtDQUFFLENBQUYsRUFBSyxJQUFJLENBQVQsSUFBYyxDQUFDLEVBQUQsR0FBTSxFQUFFLENBQUYsRUFBSyxDQUFMLENBQU4sR0FBZ0IsS0FBSyxFQUFFLENBQUYsRUFBSyxJQUFJLENBQVQsQ0FBbkM7QUFDQSxrQ0FBRSxDQUFGLEVBQUssQ0FBTCxJQUFVLENBQVY7QUFDSDtBQUNKO0FBQ0o7QUFDRCxzQkFBRSxJQUFJLENBQU4sSUFBVyxDQUFYO0FBQ0EsMkJBQU8sT0FBTyxDQUFkO0FBQ0E7QUFDSDtBQUNELGlCQUFLLENBQUw7QUFBUTtBQUNKLHdCQUFJLEVBQUUsQ0FBRixLQUFRLENBQVosRUFBZTtBQUNYLDBCQUFFLENBQUYsSUFBUSxFQUFFLENBQUYsSUFBTyxDQUFQLEdBQVcsQ0FBQyxFQUFFLENBQUYsQ0FBWixHQUFtQixDQUEzQjtBQUNBLDRCQUFJLEtBQUosRUFBVztBQUNQLGlDQUFLLElBQUksQ0FBVCxFQUFZLEtBQUssRUFBakIsRUFBcUIsR0FBckIsRUFBMEI7QUFDdEIsa0NBQUUsQ0FBRixFQUFLLENBQUwsSUFBVSxDQUFDLEVBQUUsQ0FBRixFQUFLLENBQUwsQ0FBWDtBQUNIO0FBQ0o7QUFDSjtBQUNELDJCQUFPLElBQUksRUFBWCxFQUFlO0FBQ1gsNEJBQUksRUFBRSxDQUFGLEtBQVEsRUFBRSxJQUFJLENBQU4sQ0FBWixFQUFzQjtBQUNsQjtBQUNIO0FBQ0QsNEJBQUksRUFBRSxDQUFGLENBQUo7QUFDQSwwQkFBRSxDQUFGLElBQU8sRUFBRSxJQUFJLENBQU4sQ0FBUDtBQUNBLDBCQUFFLElBQUksQ0FBTixJQUFXLENBQVg7QUFDQSw0QkFBSSxTQUFVLElBQUksSUFBSSxDQUF0QixFQUEwQjtBQUN0QixpQ0FBSyxJQUFJLENBQVQsRUFBWSxJQUFJLENBQWhCLEVBQW1CLEdBQW5CLEVBQXdCO0FBQ3BCLG9DQUFJLEVBQUUsQ0FBRixFQUFLLElBQUksQ0FBVCxDQUFKO0FBQ0Esa0NBQUUsQ0FBRixFQUFLLElBQUksQ0FBVCxJQUFjLEVBQUUsQ0FBRixFQUFLLENBQUwsQ0FBZDtBQUNBLGtDQUFFLENBQUYsRUFBSyxDQUFMLElBQVUsQ0FBVjtBQUNIO0FBQ0o7QUFDRCw0QkFBSSxTQUFVLElBQUksSUFBSSxDQUF0QixFQUEwQjtBQUN0QixpQ0FBSyxJQUFJLENBQVQsRUFBWSxJQUFJLENBQWhCLEVBQW1CLEdBQW5CLEVBQXdCO0FBQ3BCLG9DQUFJLEVBQUUsQ0FBRixFQUFLLElBQUksQ0FBVCxDQUFKO0FBQ0Esa0NBQUUsQ0FBRixFQUFLLElBQUksQ0FBVCxJQUFjLEVBQUUsQ0FBRixFQUFLLENBQUwsQ0FBZDtBQUNBLGtDQUFFLENBQUYsRUFBSyxDQUFMLElBQVUsQ0FBVjtBQUNIO0FBQ0o7QUFDRDtBQUNIO0FBQ0QsMkJBQU8sQ0FBUDtBQUNBO0FBQ0E7QUFDSDtBQXZJTDtBQXlJSDs7QUFFRCxRQUFJLE9BQUosRUFBYTtBQUNULFlBQUksTUFBTSxDQUFWO0FBQ0EsWUFBSSxDQUFKO0FBQ0EsWUFBSSxHQUFKO0FBQ0g7O0FBRUQsU0FBSyxDQUFMLEdBQVMsQ0FBVDtBQUNBLFNBQUssQ0FBTCxHQUFTLENBQVQ7QUFDQSxTQUFLLENBQUwsR0FBUyxDQUFUO0FBQ0EsU0FBSyxDQUFMLEdBQVMsQ0FBVDtBQUNBLFNBQUssQ0FBTCxHQUFTLENBQVQ7QUFDSDs7QUFFRCwyQkFBMkIsU0FBM0IsR0FBdUM7QUFDbkMsUUFBSSxTQUFKLEdBQWdCO0FBQ1osZUFBTyxLQUFLLENBQUwsQ0FBTyxDQUFQLElBQVksS0FBSyxDQUFMLENBQU8sS0FBSyxHQUFMLENBQVMsS0FBSyxDQUFkLEVBQWlCLEtBQUssQ0FBdEIsSUFBMkIsQ0FBbEMsQ0FBbkI7QUFDSCxLQUhrQztBQUluQyxRQUFJLEtBQUosR0FBWTtBQUNSLGVBQU8sS0FBSyxDQUFMLENBQU8sQ0FBUCxDQUFQO0FBQ0gsS0FOa0M7QUFPbkMsUUFBSSxJQUFKLEdBQVc7QUFDUCxZQUFJLE1BQU0sS0FBSyxHQUFMLENBQVMsQ0FBVCxFQUFZLENBQUMsRUFBYixDQUFWO0FBQUEsWUFDSSxNQUFNLEtBQUssR0FBTCxDQUFTLEtBQUssQ0FBZCxFQUFpQixLQUFLLENBQXRCLElBQTJCLEtBQUssQ0FBTCxDQUFPLENBQVAsQ0FBM0IsR0FBdUMsR0FEakQ7QUFBQSxZQUVJLElBQUksQ0FGUjtBQUFBLFlBR0ksSUFBSSxLQUFLLENBSGI7QUFJQSxhQUFLLElBQUksSUFBSSxDQUFSLEVBQVcsS0FBSyxFQUFFLE1BQXZCLEVBQStCLElBQUksRUFBbkMsRUFBdUMsR0FBdkMsRUFBNEM7QUFDeEMsZ0JBQUksRUFBRSxDQUFGLElBQU8sR0FBWCxFQUFnQjtBQUNaO0FBQ0g7QUFDSjtBQUNELGVBQU8sQ0FBUDtBQUNILEtBbEJrQztBQW1CbkMsUUFBSSxRQUFKLEdBQWU7QUFDWCxlQUFPLEtBQUssQ0FBWjtBQUNILEtBckJrQzs7QUF1Qm5DLFFBQUksU0FBSixHQUFnQjtBQUNaLGVBQVEsS0FBSyxHQUFMLENBQVMsQ0FBVCxFQUFZLENBQUMsRUFBYixJQUFtQixDQUFwQixHQUF5QixLQUFLLEdBQUwsQ0FBUyxLQUFLLENBQWQsRUFBaUIsS0FBSyxDQUF0QixDQUF6QixHQUFvRCxLQUFLLENBQUwsQ0FBTyxDQUFQLENBQTNEO0FBQ0gsS0F6QmtDO0FBMEJuQyxRQUFJLG1CQUFKLEdBQTBCO0FBQ3RCLFlBQUksQ0FBQyxPQUFPLFFBQVAsQ0FBZ0IsS0FBSyxDQUFyQixDQUFMLEVBQThCO0FBQzFCLGlCQUFLLENBQUwsR0FBUyxJQUFJLE1BQUosQ0FBVyxLQUFLLENBQWhCLENBQVQ7QUFDSDtBQUNELGVBQU8sS0FBSyxDQUFaO0FBQ0gsS0EvQmtDO0FBZ0NuQyxRQUFJLG9CQUFKLEdBQTJCO0FBQ3ZCLFlBQUksQ0FBQyxPQUFPLFFBQVAsQ0FBZ0IsS0FBSyxDQUFyQixDQUFMLEVBQThCO0FBQzFCLGlCQUFLLENBQUwsR0FBUyxJQUFJLE1BQUosQ0FBVyxLQUFLLENBQWhCLENBQVQ7QUFDSDtBQUNELGVBQU8sS0FBSyxDQUFaO0FBQ0gsS0FyQ2tDO0FBc0NuQyxRQUFJLGNBQUosR0FBcUI7QUFDakIsZUFBTyxPQUFPLElBQVAsQ0FBWSxLQUFLLENBQWpCLENBQVA7QUFDSCxLQXhDa0M7QUF5Q25DLFdBQU8sZUFBVSxLQUFWLEVBQWlCOztBQUVwQixZQUFJLElBQUksS0FBUjtBQUFBLFlBQ0ksSUFBSSxLQUFLLFNBRGI7QUFBQSxZQUVJLFFBQVEsS0FBSyxDQUFMLENBQU8sTUFGbkI7QUFBQSxZQUdJLEtBQUssT0FBTyxLQUFQLENBQWEsS0FBYixFQUFvQixLQUFwQixDQUhUO0FBQUEsWUFJSSxDQUpKOztBQU1BLGFBQUssSUFBSSxDQUFULEVBQVksSUFBSSxLQUFoQixFQUF1QixHQUF2QixFQUE0QjtBQUN4QixnQkFBSSxLQUFLLEdBQUwsQ0FBUyxLQUFLLENBQUwsQ0FBTyxDQUFQLENBQVQsS0FBdUIsQ0FBM0IsRUFBOEI7QUFDMUIsbUJBQUcsQ0FBSCxFQUFNLENBQU4sSUFBVyxDQUFYO0FBQ0gsYUFGRCxNQUVPO0FBQ0gsbUJBQUcsQ0FBSCxFQUFNLENBQU4sSUFBVyxJQUFJLEtBQUssQ0FBTCxDQUFPLENBQVAsQ0FBZjtBQUNIO0FBQ0o7O0FBRUQsWUFBSSxJQUFJLEtBQUssQ0FBYjtBQUNBLFlBQUksSUFBSSxLQUFLLG9CQUFiOztBQUVBLFlBQUksS0FBSyxFQUFFLElBQUYsQ0FBTyxFQUFQLENBQVQ7QUFBQSxZQUNJLFFBQVEsRUFBRSxJQURkO0FBQUEsWUFFSSxRQUFRLEVBQUUsTUFGZDtBQUFBLFlBR0ksTUFBTSxPQUFPLEtBQVAsQ0FBYSxLQUFiLEVBQW9CLEtBQXBCLENBSFY7QUFBQSxZQUlJLENBSko7QUFBQSxZQUlPLENBSlA7QUFBQSxZQUlVLEdBSlY7O0FBTUEsYUFBSyxJQUFJLENBQVQsRUFBWSxJQUFJLEtBQWhCLEVBQXVCLEdBQXZCLEVBQTRCO0FBQ3hCLGlCQUFLLElBQUksQ0FBVCxFQUFZLElBQUksS0FBaEIsRUFBdUIsR0FBdkIsRUFBNEI7QUFDeEIsc0JBQU0sQ0FBTjtBQUNBLHFCQUFLLElBQUksQ0FBVCxFQUFZLElBQUksS0FBaEIsRUFBdUIsR0FBdkIsRUFBNEI7QUFDeEIsMkJBQU8sR0FBRyxDQUFILEVBQU0sQ0FBTixJQUFXLEVBQUUsQ0FBRixFQUFLLENBQUwsQ0FBbEI7QUFDSDtBQUNELG9CQUFJLENBQUosRUFBTyxDQUFQLElBQVksR0FBWjtBQUNIO0FBQ0o7O0FBRUQsZUFBTyxJQUFJLElBQUosQ0FBUyxDQUFULENBQVA7QUFDSCxLQTdFa0M7QUE4RW5DLHNCQUFrQiwwQkFBVSxLQUFWLEVBQWlCO0FBQy9CLGVBQU8sS0FBSyxLQUFMLENBQVcsT0FBTyxJQUFQLENBQVksS0FBWixDQUFYLENBQVA7QUFDSCxLQWhGa0M7QUFpRm5DLGFBQVMsbUJBQVk7QUFDakIsWUFBSSxJQUFJLEtBQUssQ0FBYjtBQUNBLFlBQUksSUFBSSxLQUFLLFNBQWI7QUFBQSxZQUNJLFFBQVEsRUFBRSxNQURkO0FBQUEsWUFFSSxRQUFRLEVBQUUsQ0FBRixFQUFLLE1BRmpCO0FBQUEsWUFHSSxJQUFJLElBQUksTUFBSixDQUFXLEtBQVgsRUFBa0IsS0FBSyxDQUFMLENBQU8sTUFBekIsQ0FIUjtBQUFBLFlBSUksQ0FKSjtBQUFBLFlBSU8sQ0FKUDs7QUFNQSxhQUFLLElBQUksQ0FBVCxFQUFZLElBQUksS0FBaEIsRUFBdUIsR0FBdkIsRUFBNEI7QUFDeEIsaUJBQUssSUFBSSxDQUFULEVBQVksSUFBSSxLQUFoQixFQUF1QixHQUF2QixFQUE0QjtBQUN4QixvQkFBSSxLQUFLLEdBQUwsQ0FBUyxLQUFLLENBQUwsQ0FBTyxDQUFQLENBQVQsSUFBc0IsQ0FBMUIsRUFBNkI7QUFDekIsc0JBQUUsQ0FBRixFQUFLLENBQUwsSUFBVSxFQUFFLENBQUYsRUFBSyxDQUFMLElBQVUsS0FBSyxDQUFMLENBQU8sQ0FBUCxDQUFwQjtBQUNILGlCQUZELE1BRU87QUFDSCxzQkFBRSxDQUFGLEVBQUssQ0FBTCxJQUFVLENBQVY7QUFDSDtBQUNKO0FBQ0o7O0FBRUQsWUFBSSxJQUFJLEtBQUssQ0FBYjs7QUFFQSxZQUFJLFFBQVEsRUFBRSxNQUFkO0FBQUEsWUFDSSxRQUFRLEVBQUUsQ0FBRixFQUFLLE1BRGpCO0FBQUEsWUFFSSxJQUFJLElBQUksTUFBSixDQUFXLEtBQVgsRUFBa0IsS0FBbEIsQ0FGUjtBQUFBLFlBR0ksQ0FISjtBQUFBLFlBR08sR0FIUDs7QUFLQSxhQUFLLElBQUksQ0FBVCxFQUFZLElBQUksS0FBaEIsRUFBdUIsR0FBdkIsRUFBNEI7QUFDeEIsaUJBQUssSUFBSSxDQUFULEVBQVksSUFBSSxLQUFoQixFQUF1QixHQUF2QixFQUE0QjtBQUN4QixzQkFBTSxDQUFOO0FBQ0EscUJBQUssSUFBSSxDQUFULEVBQVksSUFBSSxLQUFoQixFQUF1QixHQUF2QixFQUE0QjtBQUN4QiwyQkFBTyxFQUFFLENBQUYsRUFBSyxDQUFMLElBQVUsRUFBRSxDQUFGLEVBQUssQ0FBTCxDQUFqQjtBQUNIO0FBQ0Qsa0JBQUUsQ0FBRixFQUFLLENBQUwsSUFBVSxHQUFWO0FBQ0g7QUFDSjs7QUFFRCxlQUFPLENBQVA7QUFDSDtBQXJIa0MsQ0FBdkM7O0FBd0hBLE9BQU8sT0FBUCxHQUFpQiwwQkFBakI7OztBQ2hnQkE7O0FBRUEsUUFBUSxVQUFSLEdBQXFCLFNBQVMsVUFBVCxDQUFvQixDQUFwQixFQUF1QixDQUF2QixFQUEwQjtBQUMzQyxRQUFJLEtBQUssR0FBTCxDQUFTLENBQVQsSUFBYyxLQUFLLEdBQUwsQ0FBUyxDQUFULENBQWxCLEVBQStCO0FBQzNCLFlBQUksSUFBSSxJQUFJLENBQVo7QUFDQSxlQUFPLEtBQUssR0FBTCxDQUFTLENBQVQsSUFBYyxLQUFLLElBQUwsQ0FBVSxJQUFJLElBQUksQ0FBbEIsQ0FBckI7QUFDSDtBQUNELFFBQUksTUFBTSxDQUFWLEVBQWE7QUFDVCxZQUFJLElBQUksSUFBSSxDQUFaO0FBQ0EsZUFBTyxLQUFLLEdBQUwsQ0FBUyxDQUFULElBQWMsS0FBSyxJQUFMLENBQVUsSUFBSSxJQUFJLENBQWxCLENBQXJCO0FBQ0g7QUFDRCxXQUFPLENBQVA7QUFDSCxDQVZEOzs7Ozs7QUFnQkEsUUFBUSxlQUFSLEdBQTBCLFVBQVUsSUFBVixFQUFnQixPQUFoQixFQUF5QjtBQUMvQyxRQUFJLFFBQVEsSUFBSSxLQUFKLENBQVUsSUFBVixDQUFaO0FBQ0EsU0FBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLElBQXBCLEVBQTBCLEdBQTFCLEVBQStCO0FBQzNCLGNBQU0sQ0FBTixJQUFXLElBQUksS0FBSixDQUFVLE9BQVYsQ0FBWDtBQUNIO0FBQ0QsV0FBTyxLQUFQO0FBQ0gsQ0FORDs7QUFRQSxRQUFRLGdCQUFSLEdBQTJCLFVBQVUsSUFBVixFQUFnQixPQUFoQixFQUF5QixLQUF6QixFQUFnQztBQUN2RCxRQUFJLFFBQVEsSUFBSSxLQUFKLENBQVUsSUFBVixDQUFaO0FBQ0EsU0FBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLElBQXBCLEVBQTBCLEdBQTFCLEVBQStCO0FBQzNCLGNBQU0sQ0FBTixJQUFXLElBQUksS0FBSixDQUFVLE9BQVYsQ0FBWDtBQUNBLGFBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxPQUFwQixFQUE2QixHQUE3QixFQUFrQztBQUM5QixrQkFBTSxDQUFOLEVBQVMsQ0FBVCxJQUFjLEtBQWQ7QUFDSDtBQUNKO0FBQ0QsV0FBTyxLQUFQO0FBQ0gsQ0FURDs7O0FDMUJBOztBQUVBLElBQUksU0FBUyxRQUFRLFVBQVIsQ0FBYjs7QUFFQSxJQUFJLDZCQUE2QixRQUFRLFVBQVIsQ0FBakM7QUFDQSxJQUFJLDBCQUEwQixRQUFRLFVBQVIsQ0FBOUI7QUFDQSxJQUFJLGtCQUFrQixRQUFRLFNBQVIsQ0FBdEI7QUFDQSxJQUFJLGtCQUFrQixRQUFRLFNBQVIsQ0FBdEI7QUFDQSxJQUFJLHdCQUF3QixRQUFRLGVBQVIsQ0FBNUI7O0FBRUEsU0FBUyxPQUFULENBQWlCLE1BQWpCLEVBQXlCO0FBQ3JCLGFBQVMsT0FBTyxXQUFQLENBQW1CLE1BQW5CLENBQVQ7QUFDQSxXQUFPLE1BQU0sTUFBTixFQUFjLE9BQU8sR0FBUCxDQUFXLE9BQU8sSUFBbEIsQ0FBZCxDQUFQO0FBQ0g7O0FBRUQsT0FBTyxPQUFQLEdBQWlCLE9BQU8sR0FBUCxHQUFhLE9BQTlCO0FBQ0EsT0FBTyxTQUFQLENBQWlCLE9BQWpCLEdBQTJCLE9BQU8sU0FBUCxDQUFpQixHQUFqQixHQUF1QixZQUFZO0FBQzFELFdBQU8sUUFBUSxJQUFSLENBQVA7QUFDSCxDQUZEOztBQUlBLFNBQVMsS0FBVCxDQUFlLFlBQWYsRUFBNkIsYUFBN0IsRUFBNEM7QUFDeEMsbUJBQWUsT0FBTyxXQUFQLENBQW1CLFlBQW5CLENBQWY7QUFDQSxvQkFBZ0IsT0FBTyxXQUFQLENBQW1CLGFBQW5CLENBQWhCO0FBQ0EsV0FBTyxhQUFhLFFBQWIsS0FBMEIsSUFBSSxlQUFKLENBQW9CLFlBQXBCLEVBQWtDLEtBQWxDLENBQXdDLGFBQXhDLENBQTFCLEdBQW1GLElBQUksZUFBSixDQUFvQixZQUFwQixFQUFrQyxLQUFsQyxDQUF3QyxhQUF4QyxDQUExRjtBQUNIOztBQUVELE9BQU8sS0FBUCxHQUFlLEtBQWY7QUFDQSxPQUFPLFNBQVAsQ0FBaUIsS0FBakIsR0FBeUIsVUFBVSxLQUFWLEVBQWlCO0FBQ3RDLFdBQU8sTUFBTSxJQUFOLEVBQVksS0FBWixDQUFQO0FBQ0gsQ0FGRDs7QUFJQSxPQUFPLE9BQVAsR0FBaUI7QUFDYixnQ0FBNEIsMEJBRGY7QUFFYixTQUFLLDBCQUZRO0FBR2IsNkJBQXlCLHVCQUhaO0FBSWIsU0FBSyx1QkFKUTtBQUtiLHFCQUFpQixlQUxKO0FBTWIsUUFBSSxlQU5TO0FBT2IscUJBQWlCLGVBUEo7QUFRYixRQUFJLGVBUlM7QUFTYiwyQkFBdUIscUJBVFY7QUFVYixTQUFLLHFCQVZRO0FBV2IsYUFBUyxPQVhJO0FBWWIsV0FBTztBQVpNLENBQWpCOzs7QUMvQkE7O0FBRUEsT0FBTyxPQUFQLEdBQWlCLFFBQVEsVUFBUixDQUFqQjtBQUNBLE9BQU8sT0FBUCxDQUFlLGNBQWYsR0FBZ0MsT0FBTyxPQUFQLENBQWUsRUFBZixHQUFvQixRQUFRLGtCQUFSLENBQXBEOzs7QUNIQTs7Ozs7O0FBS0EsTUFBTSxNQUFOLFNBQXFCLEtBQXJCLENBQTJCOzs7Ozs7O0FBT3ZCLGdCQUFZLEtBQVosRUFBbUIsUUFBbkIsRUFBNkI7QUFDekIsWUFBSSxPQUFPLFFBQVAsQ0FBZ0IsS0FBaEIsQ0FBSixFQUE0QjtBQUN4QixtQkFBTyxNQUFNLEtBQU4sRUFBUDtBQUNILFNBRkQsTUFFTyxJQUFJLE9BQU8sU0FBUCxDQUFpQixLQUFqQixLQUEyQixRQUFRLENBQXZDLEVBQTBDOztBQUM3QyxrQkFBTSxLQUFOO0FBQ0EsZ0JBQUksT0FBTyxTQUFQLENBQWlCLFFBQWpCLEtBQThCLFdBQVcsQ0FBN0MsRUFBZ0Q7QUFDNUMscUJBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxLQUFwQixFQUEyQixHQUEzQixFQUFnQztBQUM1Qix5QkFBSyxDQUFMLElBQVUsSUFBSSxLQUFKLENBQVUsUUFBVixDQUFWO0FBQ0g7QUFDSixhQUpELE1BSU87QUFDSCxzQkFBTSxJQUFJLFNBQUosQ0FBYyxxQ0FBZCxDQUFOO0FBQ0g7QUFDSixTQVRNLE1BU0EsSUFBSSxNQUFNLE9BQU4sQ0FBYyxLQUFkLENBQUosRUFBMEI7O0FBQzdCLGdCQUFJLFNBQVMsS0FBYjtBQUNBLG9CQUFRLE9BQU8sTUFBZjtBQUNBLHVCQUFXLE9BQU8sQ0FBUCxFQUFVLE1BQXJCO0FBQ0EsZ0JBQUksT0FBTyxRQUFQLEtBQW9CLFFBQXBCLElBQWdDLGFBQWEsQ0FBakQsRUFBb0Q7QUFDaEQsc0JBQU0sSUFBSSxTQUFKLENBQWMsbURBQWQsQ0FBTjtBQUNIO0FBQ0Qsa0JBQU0sS0FBTjtBQUNBLGlCQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksS0FBcEIsRUFBMkIsR0FBM0IsRUFBZ0M7QUFDNUIsb0JBQUksT0FBTyxDQUFQLEVBQVUsTUFBVixLQUFxQixRQUF6QixFQUFtQztBQUMvQiwwQkFBTSxJQUFJLFVBQUosQ0FBZSwrQkFBZixDQUFOO0FBQ0g7QUFDRCxxQkFBSyxDQUFMLElBQVUsR0FBRyxNQUFILENBQVUsT0FBTyxDQUFQLENBQVYsQ0FBVjtBQUNIO0FBQ0osU0FkTSxNQWNBO0FBQ0gsa0JBQU0sSUFBSSxTQUFKLENBQWMsc0RBQWQsQ0FBTjtBQUNIO0FBQ0QsYUFBSyxJQUFMLEdBQVksS0FBWjtBQUNBLGFBQUssT0FBTCxHQUFlLFFBQWY7QUFDSDs7O0FBR0QsZ0JBQVksT0FBTyxPQUFuQixJQUE4QjtBQUMxQixlQUFPLEtBQVA7QUFDSDs7Ozs7Ozs7O0FBU0QsV0FBTyxXQUFQLENBQW1CLE9BQW5CLEVBQTRCLFVBQTVCLEVBQXdDLE9BQXhDLEVBQWlEO0FBQzdDLFlBQUksU0FBUyxVQUFVLFVBQXZCO0FBQ0EsWUFBSSxXQUFXLFFBQVEsTUFBdkIsRUFBK0I7QUFDM0Isa0JBQU0sSUFBSSxVQUFKLENBQWUsNkNBQWYsQ0FBTjtBQUNIO0FBQ0QsWUFBSSxZQUFZLElBQUksTUFBSixDQUFXLE9BQVgsRUFBb0IsVUFBcEIsQ0FBaEI7QUFDQSxhQUFLLElBQUksTUFBTSxDQUFmLEVBQWtCLE1BQU0sT0FBeEIsRUFBaUMsS0FBakMsRUFBd0M7QUFDcEMsaUJBQUssSUFBSSxTQUFTLENBQWxCLEVBQXFCLFNBQVMsVUFBOUIsRUFBMEMsUUFBMUMsRUFBb0Q7QUFDaEQsMEJBQVUsR0FBVixFQUFlLE1BQWYsSUFBeUIsUUFBUSxNQUFNLFVBQU4sR0FBbUIsTUFBM0IsQ0FBekI7QUFDSDtBQUNKO0FBQ0QsZUFBTyxTQUFQO0FBQ0g7Ozs7Ozs7QUFPRCxXQUFPLFNBQVAsQ0FBaUIsT0FBakIsRUFBMEI7QUFDdEIsWUFBSSxTQUFTLElBQUksTUFBSixDQUFXLENBQVgsRUFBYyxRQUFRLE1BQXRCLENBQWI7QUFDQSxhQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksUUFBUSxNQUE1QixFQUFvQyxHQUFwQyxFQUF5QztBQUNyQyxtQkFBTyxDQUFQLEVBQVUsQ0FBVixJQUFlLFFBQVEsQ0FBUixDQUFmO0FBQ0g7QUFDRCxlQUFPLE1BQVA7QUFDSDs7Ozs7OztBQU9ELFdBQU8sWUFBUCxDQUFvQixPQUFwQixFQUE2QjtBQUN6QixZQUFJLFNBQVMsSUFBSSxNQUFKLENBQVcsUUFBUSxNQUFuQixFQUEyQixDQUEzQixDQUFiO0FBQ0EsYUFBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLFFBQVEsTUFBNUIsRUFBb0MsR0FBcEMsRUFBeUM7QUFDckMsbUJBQU8sQ0FBUCxFQUFVLENBQVYsSUFBZSxRQUFRLENBQVIsQ0FBZjtBQUNIO0FBQ0QsZUFBTyxNQUFQO0FBQ0g7Ozs7Ozs7O0FBUUQsV0FBTyxLQUFQLENBQWEsSUFBYixFQUFtQixPQUFuQixFQUE0QjtBQUN4QixlQUFPLElBQUksTUFBSixDQUFXLElBQVgsRUFBaUIsT0FBakIsQ0FBUDtBQUNIOzs7Ozs7OztBQVFELFdBQU8sS0FBUCxDQUFhLElBQWIsRUFBbUIsT0FBbkIsRUFBNEI7QUFDeEIsZUFBTyxPQUFPLEtBQVAsQ0FBYSxJQUFiLEVBQW1CLE9BQW5CLEVBQTRCLElBQTVCLENBQWlDLENBQWpDLENBQVA7QUFDSDs7Ozs7Ozs7QUFRRCxXQUFPLElBQVAsQ0FBWSxJQUFaLEVBQWtCLE9BQWxCLEVBQTJCO0FBQ3ZCLGVBQU8sT0FBTyxLQUFQLENBQWEsSUFBYixFQUFtQixPQUFuQixFQUE0QixJQUE1QixDQUFpQyxDQUFqQyxDQUFQO0FBQ0g7Ozs7Ozs7OztBQVNELFdBQU8sSUFBUCxDQUFZLElBQVosRUFBa0IsT0FBbEIsRUFBMkIsR0FBM0IsRUFBZ0M7QUFDNUIsWUFBSSxRQUFRLFNBQVosRUFBdUIsTUFBTSxLQUFLLE1BQVg7QUFDdkIsWUFBSSxTQUFTLE9BQU8sS0FBUCxDQUFhLElBQWIsRUFBbUIsT0FBbkIsQ0FBYjtBQUNBLGFBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxJQUFwQixFQUEwQixHQUExQixFQUErQjtBQUMzQixpQkFBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLE9BQXBCLEVBQTZCLEdBQTdCLEVBQWtDO0FBQzlCLHVCQUFPLENBQVAsRUFBVSxDQUFWLElBQWUsS0FBZjtBQUNIO0FBQ0o7QUFDRCxlQUFPLE1BQVA7QUFDSDs7Ozs7Ozs7QUFRRCxXQUFPLEdBQVAsQ0FBVyxJQUFYLEVBQWlCLE9BQWpCLEVBQTBCO0FBQ3RCLFlBQUksWUFBWSxTQUFoQixFQUEyQixVQUFVLElBQVY7QUFDM0IsWUFBSSxNQUFNLEtBQUssR0FBTCxDQUFTLElBQVQsRUFBZSxPQUFmLENBQVY7QUFDQSxZQUFJLFNBQVMsT0FBTyxLQUFQLENBQWEsSUFBYixFQUFtQixPQUFuQixDQUFiO0FBQ0EsYUFBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLEdBQXBCLEVBQXlCLEdBQXpCLEVBQThCO0FBQzFCLG1CQUFPLENBQVAsRUFBVSxDQUFWLElBQWUsQ0FBZjtBQUNIO0FBQ0QsZUFBTyxNQUFQO0FBQ0g7Ozs7Ozs7OztBQVNELFdBQU8sSUFBUCxDQUFZLElBQVosRUFBa0IsSUFBbEIsRUFBd0IsT0FBeEIsRUFBaUM7QUFDN0IsWUFBSSxJQUFJLEtBQUssTUFBYjtBQUNBLFlBQUksU0FBUyxTQUFiLEVBQXdCLE9BQU8sQ0FBUDtBQUN4QixZQUFJLFlBQVksU0FBaEIsRUFBMkIsVUFBVSxJQUFWO0FBQzNCLFlBQUksTUFBTSxLQUFLLEdBQUwsQ0FBUyxDQUFULEVBQVksSUFBWixFQUFrQixPQUFsQixDQUFWO0FBQ0EsWUFBSSxTQUFTLE9BQU8sS0FBUCxDQUFhLElBQWIsRUFBbUIsT0FBbkIsQ0FBYjtBQUNBLGFBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxHQUFwQixFQUF5QixHQUF6QixFQUE4QjtBQUMxQixtQkFBTyxDQUFQLEVBQVUsQ0FBVixJQUFlLEtBQUssQ0FBTCxDQUFmO0FBQ0g7QUFDRCxlQUFPLE1BQVA7QUFDSDs7Ozs7Ozs7QUFRRCxXQUFPLEdBQVAsQ0FBVyxPQUFYLEVBQW9CLE9BQXBCLEVBQTZCO0FBQ3pCLFlBQUksT0FBTyxRQUFRLE1BQW5CO0FBQ0EsWUFBSSxVQUFVLFFBQVEsQ0FBUixFQUFXLE1BQXpCO0FBQ0EsWUFBSSxTQUFTLElBQUksTUFBSixDQUFXLElBQVgsRUFBaUIsT0FBakIsQ0FBYjtBQUNBLGFBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxJQUFwQixFQUEwQixHQUExQixFQUErQjtBQUMzQixpQkFBSSxJQUFJLElBQUksQ0FBWixFQUFlLElBQUksT0FBbkIsRUFBNEIsR0FBNUIsRUFBaUM7QUFDN0IsdUJBQU8sQ0FBUCxFQUFVLENBQVYsSUFBZSxLQUFLLEdBQUwsQ0FBUyxRQUFRLENBQVIsRUFBVyxDQUFYLENBQVQsRUFBd0IsUUFBUSxDQUFSLEVBQVcsQ0FBWCxDQUF4QixDQUFmO0FBQ0g7QUFDSjtBQUNELGVBQU8sTUFBUDtBQUNIOzs7Ozs7OztBQVFELFdBQU8sR0FBUCxDQUFXLE9BQVgsRUFBb0IsT0FBcEIsRUFBNkI7QUFDekIsWUFBSSxPQUFPLFFBQVEsTUFBbkI7QUFDQSxZQUFJLFVBQVUsUUFBUSxDQUFSLEVBQVcsTUFBekI7QUFDQSxZQUFJLFNBQVMsSUFBSSxNQUFKLENBQVcsSUFBWCxFQUFpQixPQUFqQixDQUFiO0FBQ0EsYUFBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLElBQXBCLEVBQTBCLEdBQTFCLEVBQStCO0FBQzNCLGlCQUFJLElBQUksSUFBSSxDQUFaLEVBQWUsSUFBSSxPQUFuQixFQUE0QixHQUE1QixFQUFpQztBQUM3Qix1QkFBTyxDQUFQLEVBQVUsQ0FBVixJQUFlLEtBQUssR0FBTCxDQUFTLFFBQVEsQ0FBUixFQUFXLENBQVgsQ0FBVCxFQUF3QixRQUFRLENBQVIsRUFBVyxDQUFYLENBQXhCLENBQWY7QUFDSDtBQUNKO0FBQ0QsZUFBTyxNQUFQO0FBQ0g7Ozs7Ozs7QUFPRCxXQUFPLFdBQVAsQ0FBbUIsS0FBbkIsRUFBMEI7QUFDdEIsZUFBTyxPQUFPLFFBQVAsQ0FBZ0IsS0FBaEIsSUFBeUIsS0FBekIsR0FBaUMsSUFBSSxNQUFKLENBQVcsS0FBWCxDQUF4QztBQUNIOzs7Ozs7O0FBT0QsV0FBTyxRQUFQLENBQWdCLEtBQWhCLEVBQXVCO0FBQ25CLGVBQVEsU0FBUyxJQUFWLElBQW9CLE1BQU0sS0FBTixLQUFnQixRQUEzQztBQUNIOzs7OztBQUtELFFBQUksSUFBSixHQUFXO0FBQ1AsZUFBTyxLQUFLLElBQUwsR0FBWSxLQUFLLE9BQXhCO0FBQ0g7Ozs7Ozs7QUFPRCxVQUFNLFFBQU4sRUFBZ0I7QUFDWixZQUFJLE9BQU8sUUFBUCxLQUFvQixVQUF4QixFQUFvQztBQUNoQyxrQkFBTSxJQUFJLFNBQUosQ0FBYyw2QkFBZCxDQUFOO0FBQ0g7QUFDRCxZQUFJLEtBQUssS0FBSyxJQUFkO0FBQ0EsWUFBSSxLQUFLLEtBQUssT0FBZDtBQUNBLGFBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxFQUFwQixFQUF3QixHQUF4QixFQUE2QjtBQUN6QixpQkFBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLEVBQXBCLEVBQXdCLEdBQXhCLEVBQTZCO0FBQ3pCLHlCQUFTLElBQVQsQ0FBYyxJQUFkLEVBQW9CLENBQXBCLEVBQXVCLENBQXZCO0FBQ0g7QUFDSjtBQUNELGVBQU8sSUFBUDtBQUNIOzs7Ozs7QUFNRCxZQUFRO0FBQ0osWUFBSSxZQUFZLElBQUksTUFBSixDQUFXLEtBQUssSUFBaEIsRUFBc0IsS0FBSyxPQUEzQixDQUFoQjtBQUNBLGFBQUssSUFBSSxNQUFNLENBQWYsRUFBa0IsTUFBTSxLQUFLLElBQTdCLEVBQW1DLEtBQW5DLEVBQTBDO0FBQ3RDLGlCQUFLLElBQUksU0FBUyxDQUFsQixFQUFxQixTQUFTLEtBQUssT0FBbkMsRUFBNEMsUUFBNUMsRUFBc0Q7QUFDbEQsMEJBQVUsR0FBVixFQUFlLE1BQWYsSUFBeUIsS0FBSyxHQUFMLEVBQVUsTUFBVixDQUF6QjtBQUNIO0FBQ0o7QUFDRCxlQUFPLFNBQVA7QUFDSDs7Ozs7O0FBTUQsZ0JBQVk7QUFDUixZQUFJLFFBQVEsSUFBSSxLQUFKLENBQVUsS0FBSyxJQUFmLENBQVo7QUFDQSxhQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksS0FBSyxJQUF6QixFQUErQixHQUEvQixFQUFvQztBQUNoQyxpQkFBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLEtBQUssT0FBekIsRUFBa0MsR0FBbEMsRUFBdUM7QUFDbkMsc0JBQU0sSUFBSSxLQUFLLE9BQVQsR0FBbUIsQ0FBekIsSUFBOEIsS0FBSyxDQUFMLEVBQVEsQ0FBUixDQUE5QjtBQUNIO0FBQ0o7QUFDRCxlQUFPLEtBQVA7QUFDSDs7Ozs7O0FBTUQsZ0JBQVk7QUFDUixZQUFJLE9BQU8sSUFBSSxLQUFKLENBQVUsS0FBSyxJQUFmLENBQVg7QUFDQSxhQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksS0FBSyxJQUF6QixFQUErQixHQUEvQixFQUFvQztBQUNoQyxpQkFBSyxDQUFMLElBQVUsR0FBRyxNQUFILENBQVUsS0FBSyxDQUFMLENBQVYsQ0FBVjtBQUNIO0FBQ0QsZUFBTyxJQUFQO0FBQ0g7Ozs7O0FBS0Qsa0JBQWM7QUFDVixlQUFPLEtBQUssSUFBTCxLQUFjLENBQXJCO0FBQ0g7Ozs7O0FBS0QscUJBQWlCO0FBQ2IsZUFBTyxLQUFLLE9BQUwsS0FBaUIsQ0FBeEI7QUFDSDs7Ozs7QUFLRCxlQUFXO0FBQ1AsZUFBUSxLQUFLLElBQUwsS0FBYyxDQUFmLElBQXNCLEtBQUssT0FBTCxLQUFpQixDQUE5QztBQUNIOzs7OztBQUtELGVBQVc7QUFDUCxlQUFPLEtBQUssSUFBTCxLQUFjLEtBQUssT0FBMUI7QUFDSDs7Ozs7QUFLRCxrQkFBYztBQUNWLFlBQUksS0FBSyxRQUFMLEVBQUosRUFBcUI7QUFDakIsaUJBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxLQUFLLElBQXpCLEVBQStCLEdBQS9CLEVBQW9DO0FBQ2hDLHFCQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLEtBQUssQ0FBckIsRUFBd0IsR0FBeEIsRUFBNkI7QUFDekIsd0JBQUksS0FBSyxDQUFMLEVBQVEsQ0FBUixNQUFlLEtBQUssQ0FBTCxFQUFRLENBQVIsQ0FBbkIsRUFBK0I7QUFDM0IsK0JBQU8sS0FBUDtBQUNIO0FBQ0o7QUFDSjtBQUNELG1CQUFPLElBQVA7QUFDSDtBQUNELGVBQU8sS0FBUDtBQUNIOzs7Ozs7Ozs7QUFTRCxRQUFJLFFBQUosRUFBYyxXQUFkLEVBQTJCLEtBQTNCLEVBQWtDO0FBQzlCLGFBQUssUUFBTCxFQUFlLFdBQWYsSUFBOEIsS0FBOUI7QUFDQSxlQUFPLElBQVA7QUFDSDs7Ozs7Ozs7QUFRRCxRQUFJLFFBQUosRUFBYyxXQUFkLEVBQTJCO0FBQ3ZCLGVBQU8sS0FBSyxRQUFMLEVBQWUsV0FBZixDQUFQO0FBQ0g7Ozs7Ozs7QUFPRCxTQUFLLEtBQUwsRUFBWTtBQUNSLGFBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxLQUFLLElBQXpCLEVBQStCLEdBQS9CLEVBQW9DO0FBQ2hDLGlCQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksS0FBSyxPQUF6QixFQUFrQyxHQUFsQyxFQUF1QztBQUNuQyxxQkFBSyxDQUFMLEVBQVEsQ0FBUixJQUFhLEtBQWI7QUFDSDtBQUNKO0FBQ0QsZUFBTyxJQUFQO0FBQ0g7Ozs7OztBQU1ELFVBQU07QUFDRixlQUFPLEtBQUssSUFBTCxDQUFVLENBQUMsQ0FBWCxDQUFQO0FBQ0g7Ozs7Ozs7QUFPRCxXQUFPLEtBQVAsRUFBYztBQUNWLHNCQUFjLElBQWQsRUFBb0IsS0FBcEI7QUFDQSxlQUFPLEdBQUcsTUFBSCxDQUFVLEtBQUssS0FBTCxDQUFWLENBQVA7QUFDSDs7Ozs7OztBQU9ELGlCQUFhLEtBQWIsRUFBb0I7QUFDaEIsZUFBTyxPQUFPLFNBQVAsQ0FBaUIsS0FBSyxNQUFMLENBQVksS0FBWixDQUFqQixDQUFQO0FBQ0g7Ozs7Ozs7O0FBUUQsV0FBTyxLQUFQLEVBQWMsS0FBZCxFQUFxQjtBQUNqQixzQkFBYyxJQUFkLEVBQW9CLEtBQXBCO0FBQ0EsZ0JBQVEsZUFBZSxJQUFmLEVBQXFCLEtBQXJCLEVBQTRCLElBQTVCLENBQVI7QUFDQSxhQUFLLEtBQUwsSUFBYyxLQUFkO0FBQ0EsZUFBTyxJQUFQO0FBQ0g7Ozs7Ozs7QUFPRCxjQUFVLEtBQVYsRUFBaUI7QUFDYixzQkFBYyxJQUFkLEVBQW9CLEtBQXBCO0FBQ0EsWUFBSSxLQUFLLElBQUwsS0FBYyxDQUFsQixFQUNJLE1BQU0sSUFBSSxVQUFKLENBQWUsd0NBQWYsQ0FBTjtBQUNKLGFBQUssTUFBTCxDQUFZLEtBQVosRUFBbUIsQ0FBbkI7QUFDQSxhQUFLLElBQUwsSUFBYSxDQUFiO0FBQ0EsZUFBTyxJQUFQO0FBQ0g7Ozs7Ozs7O0FBUUQsV0FBTyxLQUFQLEVBQWMsS0FBZCxFQUFxQjtBQUNqQixZQUFJLFVBQVUsU0FBZCxFQUF5QjtBQUNyQixvQkFBUSxLQUFSO0FBQ0Esb0JBQVEsS0FBSyxJQUFiO0FBQ0g7QUFDRCxzQkFBYyxJQUFkLEVBQW9CLEtBQXBCLEVBQTJCLElBQTNCO0FBQ0EsZ0JBQVEsZUFBZSxJQUFmLEVBQXFCLEtBQXJCLEVBQTRCLElBQTVCLENBQVI7QUFDQSxhQUFLLE1BQUwsQ0FBWSxLQUFaLEVBQW1CLENBQW5CLEVBQXNCLEtBQXRCO0FBQ0EsYUFBSyxJQUFMLElBQWEsQ0FBYjtBQUNBLGVBQU8sSUFBUDtBQUNIOzs7Ozs7OztBQVFELGFBQVMsSUFBVCxFQUFlLElBQWYsRUFBcUI7QUFDakIsc0JBQWMsSUFBZCxFQUFvQixJQUFwQjtBQUNBLHNCQUFjLElBQWQsRUFBb0IsSUFBcEI7QUFDQSxZQUFJLE9BQU8sS0FBSyxJQUFMLENBQVg7QUFDQSxhQUFLLElBQUwsSUFBYSxLQUFLLElBQUwsQ0FBYjtBQUNBLGFBQUssSUFBTCxJQUFhLElBQWI7QUFDQSxlQUFPLElBQVA7QUFDSDs7Ozs7OztBQU9ELGNBQVUsS0FBVixFQUFpQjtBQUNiLHlCQUFpQixJQUFqQixFQUF1QixLQUF2QjtBQUNBLFlBQUksU0FBUyxJQUFJLEtBQUosQ0FBVSxLQUFLLElBQWYsQ0FBYjtBQUNBLGFBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxLQUFLLElBQXpCLEVBQStCLEdBQS9CLEVBQW9DO0FBQ2hDLG1CQUFPLENBQVAsSUFBWSxLQUFLLENBQUwsRUFBUSxLQUFSLENBQVo7QUFDSDtBQUNELGVBQU8sTUFBUDtBQUNIOzs7Ozs7O0FBT0Qsb0JBQWdCLEtBQWhCLEVBQXVCO0FBQ25CLGVBQU8sT0FBTyxZQUFQLENBQW9CLEtBQUssU0FBTCxDQUFlLEtBQWYsQ0FBcEIsQ0FBUDtBQUNIOzs7Ozs7OztBQVFELGNBQVUsS0FBVixFQUFpQixLQUFqQixFQUF3QjtBQUNwQix5QkFBaUIsSUFBakIsRUFBdUIsS0FBdkI7QUFDQSxnQkFBUSxrQkFBa0IsSUFBbEIsRUFBd0IsS0FBeEIsQ0FBUjtBQUNBLGFBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxLQUFLLElBQXpCLEVBQStCLEdBQS9CLEVBQW9DO0FBQ2hDLGlCQUFLLENBQUwsRUFBUSxLQUFSLElBQWlCLE1BQU0sQ0FBTixDQUFqQjtBQUNIO0FBQ0QsZUFBTyxJQUFQO0FBQ0g7Ozs7Ozs7QUFPRCxpQkFBYSxLQUFiLEVBQW9CO0FBQ2hCLHlCQUFpQixJQUFqQixFQUF1QixLQUF2QjtBQUNBLFlBQUksS0FBSyxPQUFMLEtBQWlCLENBQXJCLEVBQ0ksTUFBTSxJQUFJLFVBQUosQ0FBZSwyQ0FBZixDQUFOO0FBQ0osYUFBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLEtBQUssSUFBekIsRUFBK0IsR0FBL0IsRUFBb0M7QUFDaEMsaUJBQUssQ0FBTCxFQUFRLE1BQVIsQ0FBZSxLQUFmLEVBQXNCLENBQXRCO0FBQ0g7QUFDRCxhQUFLLE9BQUwsSUFBZ0IsQ0FBaEI7QUFDQSxlQUFPLElBQVA7QUFDSDs7Ozs7Ozs7QUFRRCxjQUFVLEtBQVYsRUFBaUIsS0FBakIsRUFBd0I7QUFDcEIsWUFBSSxPQUFPLEtBQVAsS0FBaUIsV0FBckIsRUFBa0M7QUFDOUIsb0JBQVEsS0FBUjtBQUNBLG9CQUFRLEtBQUssT0FBYjtBQUNIO0FBQ0QseUJBQWlCLElBQWpCLEVBQXVCLEtBQXZCLEVBQThCLElBQTlCO0FBQ0EsZ0JBQVEsa0JBQWtCLElBQWxCLEVBQXdCLEtBQXhCLENBQVI7QUFDQSxhQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksS0FBSyxJQUF6QixFQUErQixHQUEvQixFQUFvQztBQUNoQyxpQkFBSyxDQUFMLEVBQVEsTUFBUixDQUFlLEtBQWYsRUFBc0IsQ0FBdEIsRUFBeUIsTUFBTSxDQUFOLENBQXpCO0FBQ0g7QUFDRCxhQUFLLE9BQUwsSUFBZ0IsQ0FBaEI7QUFDQSxlQUFPLElBQVA7QUFDSDs7Ozs7Ozs7QUFRRCxnQkFBWSxPQUFaLEVBQXFCLE9BQXJCLEVBQThCO0FBQzFCLHlCQUFpQixJQUFqQixFQUF1QixPQUF2QjtBQUNBLHlCQUFpQixJQUFqQixFQUF1QixPQUF2QjtBQUNBLFlBQUksSUFBSixFQUFVLEdBQVY7QUFDQSxhQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksS0FBSyxJQUF6QixFQUErQixHQUEvQixFQUFvQztBQUNoQyxrQkFBTSxLQUFLLENBQUwsQ0FBTjtBQUNBLG1CQUFPLElBQUksT0FBSixDQUFQO0FBQ0EsZ0JBQUksT0FBSixJQUFlLElBQUksT0FBSixDQUFmO0FBQ0EsZ0JBQUksT0FBSixJQUFlLElBQWY7QUFDSDtBQUNELGVBQU8sSUFBUDtBQUNIOzs7Ozs7O0FBT0QsaUJBQWEsTUFBYixFQUFxQjtBQUNqQixpQkFBUyxlQUFlLElBQWYsRUFBcUIsTUFBckIsQ0FBVDtBQUNBLGFBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxLQUFLLElBQXpCLEVBQStCLEdBQS9CLEVBQW9DO0FBQ2hDLGlCQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksS0FBSyxPQUF6QixFQUFrQyxHQUFsQyxFQUF1QztBQUNuQyxxQkFBSyxDQUFMLEVBQVEsQ0FBUixLQUFjLE9BQU8sQ0FBUCxDQUFkO0FBQ0g7QUFDSjtBQUNELGVBQU8sSUFBUDtBQUNIOzs7Ozs7O0FBT0QsaUJBQWEsTUFBYixFQUFxQjtBQUNqQixpQkFBUyxlQUFlLElBQWYsRUFBcUIsTUFBckIsQ0FBVDtBQUNBLGFBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxLQUFLLElBQXpCLEVBQStCLEdBQS9CLEVBQW9DO0FBQ2hDLGlCQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksS0FBSyxPQUF6QixFQUFrQyxHQUFsQyxFQUF1QztBQUNuQyxxQkFBSyxDQUFMLEVBQVEsQ0FBUixLQUFjLE9BQU8sQ0FBUCxDQUFkO0FBQ0g7QUFDSjtBQUNELGVBQU8sSUFBUDtBQUNIOzs7Ozs7O0FBT0QsaUJBQWEsTUFBYixFQUFxQjtBQUNqQixpQkFBUyxlQUFlLElBQWYsRUFBcUIsTUFBckIsQ0FBVDtBQUNBLGFBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxLQUFLLElBQXpCLEVBQStCLEdBQS9CLEVBQW9DO0FBQ2hDLGlCQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksS0FBSyxPQUF6QixFQUFrQyxHQUFsQyxFQUF1QztBQUNuQyxxQkFBSyxDQUFMLEVBQVEsQ0FBUixLQUFjLE9BQU8sQ0FBUCxDQUFkO0FBQ0g7QUFDSjtBQUNELGVBQU8sSUFBUDtBQUNIOzs7Ozs7O0FBT0QsaUJBQWEsTUFBYixFQUFxQjtBQUNqQixpQkFBUyxlQUFlLElBQWYsRUFBcUIsTUFBckIsQ0FBVDtBQUNBLGFBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxLQUFLLElBQXpCLEVBQStCLEdBQS9CLEVBQW9DO0FBQ2hDLGlCQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksS0FBSyxPQUF6QixFQUFrQyxHQUFsQyxFQUF1QztBQUNuQyxxQkFBSyxDQUFMLEVBQVEsQ0FBUixLQUFjLE9BQU8sQ0FBUCxDQUFkO0FBQ0g7QUFDSjtBQUNELGVBQU8sSUFBUDtBQUNIOzs7Ozs7O0FBT0Qsb0JBQWdCLE1BQWhCLEVBQXdCO0FBQ3BCLGlCQUFTLGtCQUFrQixJQUFsQixFQUF3QixNQUF4QixDQUFUO0FBQ0EsYUFBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLEtBQUssSUFBekIsRUFBK0IsR0FBL0IsRUFBb0M7QUFDaEMsaUJBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxLQUFLLE9BQXpCLEVBQWtDLEdBQWxDLEVBQXVDO0FBQ25DLHFCQUFLLENBQUwsRUFBUSxDQUFSLEtBQWMsT0FBTyxDQUFQLENBQWQ7QUFDSDtBQUNKO0FBQ0QsZUFBTyxJQUFQO0FBQ0g7Ozs7Ozs7QUFPRCxvQkFBZ0IsTUFBaEIsRUFBd0I7QUFDcEIsaUJBQVMsa0JBQWtCLElBQWxCLEVBQXdCLE1BQXhCLENBQVQ7QUFDQSxhQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksS0FBSyxJQUF6QixFQUErQixHQUEvQixFQUFvQztBQUNoQyxpQkFBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLEtBQUssT0FBekIsRUFBa0MsR0FBbEMsRUFBdUM7QUFDbkMscUJBQUssQ0FBTCxFQUFRLENBQVIsS0FBYyxPQUFPLENBQVAsQ0FBZDtBQUNIO0FBQ0o7QUFDRCxlQUFPLElBQVA7QUFDSDs7Ozs7OztBQU9ELG9CQUFnQixNQUFoQixFQUF3QjtBQUNwQixpQkFBUyxrQkFBa0IsSUFBbEIsRUFBd0IsTUFBeEIsQ0FBVDtBQUNBLGFBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxLQUFLLElBQXpCLEVBQStCLEdBQS9CLEVBQW9DO0FBQ2hDLGlCQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksS0FBSyxPQUF6QixFQUFrQyxHQUFsQyxFQUF1QztBQUNuQyxxQkFBSyxDQUFMLEVBQVEsQ0FBUixLQUFjLE9BQU8sQ0FBUCxDQUFkO0FBQ0g7QUFDSjtBQUNELGVBQU8sSUFBUDtBQUNIOzs7Ozs7O0FBT0Qsb0JBQWdCLE1BQWhCLEVBQXdCO0FBQ3BCLGlCQUFTLGtCQUFrQixJQUFsQixFQUF3QixNQUF4QixDQUFUO0FBQ0EsYUFBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLEtBQUssSUFBekIsRUFBK0IsR0FBL0IsRUFBb0M7QUFDaEMsaUJBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxLQUFLLE9BQXpCLEVBQWtDLEdBQWxDLEVBQXVDO0FBQ25DLHFCQUFLLENBQUwsRUFBUSxDQUFSLEtBQWMsT0FBTyxDQUFQLENBQWQ7QUFDSDtBQUNKO0FBQ0QsZUFBTyxJQUFQO0FBQ0g7Ozs7Ozs7O0FBUUQsV0FBTyxLQUFQLEVBQWMsS0FBZCxFQUFxQjtBQUNqQixzQkFBYyxJQUFkLEVBQW9CLEtBQXBCO0FBQ0EsYUFBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLEtBQUssT0FBekIsRUFBa0MsR0FBbEMsRUFBdUM7QUFDbkMsaUJBQUssS0FBTCxFQUFZLENBQVosS0FBa0IsS0FBbEI7QUFDSDtBQUNELGVBQU8sSUFBUDtBQUNIOzs7Ozs7OztBQVFELGNBQVUsS0FBVixFQUFpQixLQUFqQixFQUF3QjtBQUNwQix5QkFBaUIsSUFBakIsRUFBdUIsS0FBdkI7QUFDQSxhQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksS0FBSyxJQUF6QixFQUErQixHQUEvQixFQUFvQztBQUNoQyxpQkFBSyxDQUFMLEVBQVEsS0FBUixLQUFrQixLQUFsQjtBQUNIO0FBQ0o7Ozs7OztBQU1ELFVBQU07QUFDRixZQUFJLElBQUksS0FBSyxDQUFMLEVBQVEsQ0FBUixDQUFSO0FBQ0EsYUFBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLEtBQUssSUFBekIsRUFBK0IsR0FBL0IsRUFBb0M7QUFDaEMsaUJBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxLQUFLLE9BQXpCLEVBQWtDLEdBQWxDLEVBQXVDO0FBQ25DLG9CQUFJLEtBQUssQ0FBTCxFQUFRLENBQVIsSUFBYSxDQUFqQixFQUFvQjtBQUNoQix3QkFBSSxLQUFLLENBQUwsRUFBUSxDQUFSLENBQUo7QUFDSDtBQUNKO0FBQ0o7QUFDRCxlQUFPLENBQVA7QUFDSDs7Ozs7O0FBTUQsZUFBVztBQUNQLFlBQUksSUFBSSxLQUFLLENBQUwsRUFBUSxDQUFSLENBQVI7QUFDQSxZQUFJLE1BQU0sQ0FBQyxDQUFELEVBQUksQ0FBSixDQUFWO0FBQ0EsYUFBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLEtBQUssSUFBekIsRUFBK0IsR0FBL0IsRUFBb0M7QUFDaEMsaUJBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxLQUFLLE9BQXpCLEVBQWtDLEdBQWxDLEVBQXVDO0FBQ25DLG9CQUFJLEtBQUssQ0FBTCxFQUFRLENBQVIsSUFBYSxDQUFqQixFQUFvQjtBQUNoQix3QkFBSSxLQUFLLENBQUwsRUFBUSxDQUFSLENBQUo7QUFDQSx3QkFBSSxDQUFKLElBQVMsQ0FBVDtBQUNBLHdCQUFJLENBQUosSUFBUyxDQUFUO0FBQ0g7QUFDSjtBQUNKO0FBQ0QsZUFBTyxHQUFQO0FBQ0g7Ozs7OztBQU1ELFVBQU07QUFDRixZQUFJLElBQUksS0FBSyxDQUFMLEVBQVEsQ0FBUixDQUFSO0FBQ0EsYUFBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLEtBQUssSUFBekIsRUFBK0IsR0FBL0IsRUFBb0M7QUFDaEMsaUJBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxLQUFLLE9BQXpCLEVBQWtDLEdBQWxDLEVBQXVDO0FBQ25DLG9CQUFJLEtBQUssQ0FBTCxFQUFRLENBQVIsSUFBYSxDQUFqQixFQUFvQjtBQUNoQix3QkFBSSxLQUFLLENBQUwsRUFBUSxDQUFSLENBQUo7QUFDSDtBQUNKO0FBQ0o7QUFDRCxlQUFPLENBQVA7QUFDSDs7Ozs7O0FBTUQsZUFBVztBQUNQLFlBQUksSUFBSSxLQUFLLENBQUwsRUFBUSxDQUFSLENBQVI7QUFDQSxZQUFJLE1BQU0sQ0FBQyxDQUFELEVBQUksQ0FBSixDQUFWO0FBQ0EsYUFBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLEtBQUssSUFBekIsRUFBK0IsR0FBL0IsRUFBb0M7QUFDaEMsaUJBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxLQUFLLE9BQXpCLEVBQWtDLEdBQWxDLEVBQXVDO0FBQ25DLG9CQUFJLEtBQUssQ0FBTCxFQUFRLENBQVIsSUFBYSxDQUFqQixFQUFvQjtBQUNoQix3QkFBSSxLQUFLLENBQUwsRUFBUSxDQUFSLENBQUo7QUFDQSx3QkFBSSxDQUFKLElBQVMsQ0FBVDtBQUNBLHdCQUFJLENBQUosSUFBUyxDQUFUO0FBQ0g7QUFDSjtBQUNKO0FBQ0QsZUFBTyxHQUFQO0FBQ0g7Ozs7Ozs7QUFPRCxXQUFPLEdBQVAsRUFBWTtBQUNSLHNCQUFjLElBQWQsRUFBb0IsR0FBcEI7QUFDQSxZQUFJLElBQUksS0FBSyxHQUFMLEVBQVUsQ0FBVixDQUFSO0FBQ0EsYUFBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLEtBQUssT0FBekIsRUFBa0MsR0FBbEMsRUFBdUM7QUFDbkMsZ0JBQUksS0FBSyxHQUFMLEVBQVUsQ0FBVixJQUFlLENBQW5CLEVBQXNCO0FBQ2xCLG9CQUFJLEtBQUssR0FBTCxFQUFVLENBQVYsQ0FBSjtBQUNIO0FBQ0o7QUFDRCxlQUFPLENBQVA7QUFDSDs7Ozs7OztBQU9ELGdCQUFZLEdBQVosRUFBaUI7QUFDYixzQkFBYyxJQUFkLEVBQW9CLEdBQXBCO0FBQ0EsWUFBSSxJQUFJLEtBQUssR0FBTCxFQUFVLENBQVYsQ0FBUjtBQUNBLFlBQUksTUFBTSxDQUFDLEdBQUQsRUFBTSxDQUFOLENBQVY7QUFDQSxhQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksS0FBSyxPQUF6QixFQUFrQyxHQUFsQyxFQUF1QztBQUNuQyxnQkFBSSxLQUFLLEdBQUwsRUFBVSxDQUFWLElBQWUsQ0FBbkIsRUFBc0I7QUFDbEIsb0JBQUksS0FBSyxHQUFMLEVBQVUsQ0FBVixDQUFKO0FBQ0Esb0JBQUksQ0FBSixJQUFTLENBQVQ7QUFDSDtBQUNKO0FBQ0QsZUFBTyxHQUFQO0FBQ0g7Ozs7Ozs7QUFPRCxXQUFPLEdBQVAsRUFBWTtBQUNSLHNCQUFjLElBQWQsRUFBb0IsR0FBcEI7QUFDQSxZQUFJLElBQUksS0FBSyxHQUFMLEVBQVUsQ0FBVixDQUFSO0FBQ0EsYUFBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLEtBQUssT0FBekIsRUFBa0MsR0FBbEMsRUFBdUM7QUFDbkMsZ0JBQUksS0FBSyxHQUFMLEVBQVUsQ0FBVixJQUFlLENBQW5CLEVBQXNCO0FBQ2xCLG9CQUFJLEtBQUssR0FBTCxFQUFVLENBQVYsQ0FBSjtBQUNIO0FBQ0o7QUFDRCxlQUFPLENBQVA7QUFDSDs7Ozs7OztBQU9ELGdCQUFZLEdBQVosRUFBaUI7QUFDYixzQkFBYyxJQUFkLEVBQW9CLEdBQXBCO0FBQ0EsWUFBSSxJQUFJLEtBQUssR0FBTCxFQUFVLENBQVYsQ0FBUjtBQUNBLFlBQUksTUFBTSxDQUFDLEdBQUQsRUFBTSxDQUFOLENBQVY7QUFDQSxhQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksS0FBSyxPQUF6QixFQUFrQyxHQUFsQyxFQUF1QztBQUNuQyxnQkFBSSxLQUFLLEdBQUwsRUFBVSxDQUFWLElBQWUsQ0FBbkIsRUFBc0I7QUFDbEIsb0JBQUksS0FBSyxHQUFMLEVBQVUsQ0FBVixDQUFKO0FBQ0Esb0JBQUksQ0FBSixJQUFTLENBQVQ7QUFDSDtBQUNKO0FBQ0QsZUFBTyxHQUFQO0FBQ0g7Ozs7Ozs7QUFPRCxjQUFVLE1BQVYsRUFBa0I7QUFDZCx5QkFBaUIsSUFBakIsRUFBdUIsTUFBdkI7QUFDQSxZQUFJLElBQUksS0FBSyxDQUFMLEVBQVEsTUFBUixDQUFSO0FBQ0EsYUFBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLEtBQUssSUFBekIsRUFBK0IsR0FBL0IsRUFBb0M7QUFDaEMsZ0JBQUksS0FBSyxDQUFMLEVBQVEsTUFBUixJQUFrQixDQUF0QixFQUF5QjtBQUNyQixvQkFBSSxLQUFLLENBQUwsRUFBUSxNQUFSLENBQUo7QUFDSDtBQUNKO0FBQ0QsZUFBTyxDQUFQO0FBQ0g7Ozs7Ozs7QUFPRCxtQkFBZSxNQUFmLEVBQXVCO0FBQ25CLHlCQUFpQixJQUFqQixFQUF1QixNQUF2QjtBQUNBLFlBQUksSUFBSSxLQUFLLENBQUwsRUFBUSxNQUFSLENBQVI7QUFDQSxZQUFJLE1BQU0sQ0FBQyxDQUFELEVBQUksTUFBSixDQUFWO0FBQ0EsYUFBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLEtBQUssSUFBekIsRUFBK0IsR0FBL0IsRUFBb0M7QUFDaEMsZ0JBQUksS0FBSyxDQUFMLEVBQVEsTUFBUixJQUFrQixDQUF0QixFQUF5QjtBQUNyQixvQkFBSSxLQUFLLENBQUwsRUFBUSxNQUFSLENBQUo7QUFDQSxvQkFBSSxDQUFKLElBQVMsQ0FBVDtBQUNIO0FBQ0o7QUFDRCxlQUFPLEdBQVA7QUFDSDs7Ozs7OztBQU9ELGNBQVUsTUFBVixFQUFrQjtBQUNkLHlCQUFpQixJQUFqQixFQUF1QixNQUF2QjtBQUNBLFlBQUksSUFBSSxLQUFLLENBQUwsRUFBUSxNQUFSLENBQVI7QUFDQSxhQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksS0FBSyxJQUF6QixFQUErQixHQUEvQixFQUFvQztBQUNoQyxnQkFBSSxLQUFLLENBQUwsRUFBUSxNQUFSLElBQWtCLENBQXRCLEVBQXlCO0FBQ3JCLG9CQUFJLEtBQUssQ0FBTCxFQUFRLE1BQVIsQ0FBSjtBQUNIO0FBQ0o7QUFDRCxlQUFPLENBQVA7QUFDSDs7Ozs7OztBQU9ELG1CQUFlLE1BQWYsRUFBdUI7QUFDbkIseUJBQWlCLElBQWpCLEVBQXVCLE1BQXZCO0FBQ0EsWUFBSSxJQUFJLEtBQUssQ0FBTCxFQUFRLE1BQVIsQ0FBUjtBQUNBLFlBQUksTUFBTSxDQUFDLENBQUQsRUFBSSxNQUFKLENBQVY7QUFDQSxhQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksS0FBSyxJQUF6QixFQUErQixHQUEvQixFQUFvQztBQUNoQyxnQkFBSSxLQUFLLENBQUwsRUFBUSxNQUFSLElBQWtCLENBQXRCLEVBQXlCO0FBQ3JCLG9CQUFJLEtBQUssQ0FBTCxFQUFRLE1BQVIsQ0FBSjtBQUNBLG9CQUFJLENBQUosSUFBUyxDQUFUO0FBQ0g7QUFDSjtBQUNELGVBQU8sR0FBUDtBQUNIOzs7Ozs7QUFNRCxXQUFPO0FBQ0gsWUFBSSxNQUFNLEtBQUssR0FBTCxDQUFTLEtBQUssSUFBZCxFQUFvQixLQUFLLE9BQXpCLENBQVY7QUFDQSxZQUFJLE9BQU8sSUFBSSxLQUFKLENBQVUsR0FBVixDQUFYO0FBQ0EsYUFBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLEdBQXBCLEVBQXlCLEdBQXpCLEVBQThCO0FBQzFCLGlCQUFLLENBQUwsSUFBVSxLQUFLLENBQUwsRUFBUSxDQUFSLENBQVY7QUFDSDtBQUNELGVBQU8sSUFBUDtBQUNIOzs7Ozs7QUFNRCxVQUFNO0FBQ0YsWUFBSSxJQUFJLENBQVI7QUFDQSxhQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksS0FBSyxJQUF6QixFQUErQixHQUEvQixFQUFvQztBQUNoQyxpQkFBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLEtBQUssT0FBekIsRUFBa0MsR0FBbEMsRUFBdUM7QUFDbkMscUJBQUssS0FBSyxDQUFMLEVBQVEsQ0FBUixDQUFMO0FBQ0g7QUFDSjtBQUNELGVBQU8sQ0FBUDtBQUNIOzs7Ozs7QUFNRCxXQUFPO0FBQ0gsZUFBTyxLQUFLLEdBQUwsS0FBYSxLQUFLLElBQXpCO0FBQ0g7Ozs7OztBQU1ELFdBQU87QUFDSCxZQUFJLE9BQU8sQ0FBWDtBQUNBLGFBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxLQUFLLElBQXpCLEVBQStCLEdBQS9CLEVBQW9DO0FBQ2hDLGlCQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksS0FBSyxPQUF6QixFQUFrQyxHQUFsQyxFQUF1QztBQUNuQyx3QkFBUSxLQUFLLENBQUwsRUFBUSxDQUFSLENBQVI7QUFDSDtBQUNKO0FBQ0QsZUFBTyxJQUFQO0FBQ0g7Ozs7OztBQU1ELG9CQUFnQjtBQUNaLFlBQUksTUFBTSxDQUFWO0FBQ0EsYUFBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLEtBQUssSUFBekIsRUFBK0IsR0FBL0IsRUFBb0M7QUFDaEMsaUJBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxLQUFLLE9BQXpCLEVBQWtDLEdBQWxDLEVBQXVDO0FBQ25DLHVCQUFPLEtBQUssQ0FBTCxFQUFRLENBQVIsQ0FBUDtBQUNBLHFCQUFLLENBQUwsRUFBUSxDQUFSLElBQWEsR0FBYjtBQUNIO0FBQ0o7QUFDRCxlQUFPLElBQVA7QUFDSDs7Ozs7OztBQU9ELFFBQUksT0FBSixFQUFhO0FBQ1QsWUFBSSxPQUFPLFFBQVAsQ0FBZ0IsT0FBaEIsQ0FBSixFQUE4QixVQUFVLFFBQVEsU0FBUixFQUFWO0FBQzlCLFlBQUksVUFBVSxLQUFLLFNBQUwsRUFBZDtBQUNBLFlBQUksUUFBUSxNQUFSLEtBQW1CLFFBQVEsTUFBL0IsRUFBdUM7QUFDbkMsa0JBQU0sSUFBSSxVQUFKLENBQWUsbUNBQWYsQ0FBTjtBQUNIO0FBQ0QsWUFBSSxNQUFNLENBQVY7QUFDQSxhQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksUUFBUSxNQUE1QixFQUFvQyxHQUFwQyxFQUF5QztBQUNyQyxtQkFBTyxRQUFRLENBQVIsSUFBYSxRQUFRLENBQVIsQ0FBcEI7QUFDSDtBQUNELGVBQU8sR0FBUDtBQUNIOzs7Ozs7O0FBT0QsU0FBSyxLQUFMLEVBQVk7QUFDUixnQkFBUSxPQUFPLFdBQVAsQ0FBbUIsS0FBbkIsQ0FBUjtBQUNBLFlBQUksS0FBSyxPQUFMLEtBQWlCLE1BQU0sSUFBM0IsRUFDSSxRQUFRLElBQVIsQ0FBYSxtRkFBYjs7QUFFSixZQUFJLElBQUksS0FBSyxJQUFiO0FBQ0EsWUFBSSxJQUFJLEtBQUssT0FBYjtBQUNBLFlBQUksSUFBSSxNQUFNLE9BQWQ7O0FBRUEsWUFBSSxTQUFTLElBQUksTUFBSixDQUFXLENBQVgsRUFBYyxDQUFkLENBQWI7O0FBRUEsWUFBSSxRQUFRLElBQUksS0FBSixDQUFVLENBQVYsQ0FBWjtBQUNBLGFBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxDQUFwQixFQUF1QixHQUF2QixFQUE0QjtBQUN4QixpQkFBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLENBQXBCLEVBQXVCLEdBQXZCO0FBQ0ksc0JBQU0sQ0FBTixJQUFXLE1BQU0sQ0FBTixFQUFTLENBQVQsQ0FBWDtBQURKLGFBR0EsS0FBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLENBQXBCLEVBQXVCLEdBQXZCLEVBQTRCO0FBQ3hCLG9CQUFJLFFBQVEsS0FBSyxDQUFMLENBQVo7O0FBRUEsb0JBQUksSUFBSSxDQUFSO0FBQ0EscUJBQUssSUFBSSxDQUFULEVBQVksSUFBSSxDQUFoQixFQUFtQixHQUFuQjtBQUNJLHlCQUFLLE1BQU0sQ0FBTixJQUFXLE1BQU0sQ0FBTixDQUFoQjtBQURKLGlCQUdBLE9BQU8sQ0FBUCxFQUFVLENBQVYsSUFBZSxDQUFmO0FBQ0g7QUFDSjtBQUNELGVBQU8sTUFBUDtBQUNIOzs7Ozs7OztBQVFELHFCQUFpQixLQUFqQixFQUF3QjtBQUNwQixnQkFBUSxPQUFPLFdBQVAsQ0FBbUIsS0FBbkIsQ0FBUjs7QUFFQSxZQUFJLElBQUksS0FBSyxJQUFiO0FBQ0EsWUFBSSxJQUFJLEtBQUssT0FBYjtBQUNBLFlBQUksSUFBSSxNQUFNLElBQWQ7QUFDQSxZQUFJLElBQUksTUFBTSxPQUFkOztBQUVBLFlBQUksU0FBUyxJQUFJLE1BQUosQ0FBVyxJQUFJLENBQWYsRUFBa0IsSUFBSSxDQUF0QixDQUFiO0FBQ0EsYUFBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLENBQXBCLEVBQXVCLEdBQXZCLEVBQTRCO0FBQ3hCLGlCQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksQ0FBcEIsRUFBdUIsR0FBdkIsRUFBNEI7QUFDeEIscUJBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxDQUFwQixFQUF1QixHQUF2QixFQUE0QjtBQUN4Qix5QkFBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLENBQXBCLEVBQXVCLEdBQXZCLEVBQTRCO0FBQ3hCLCtCQUFPLElBQUksQ0FBSixHQUFRLENBQWYsRUFBa0IsSUFBSSxDQUFKLEdBQVEsQ0FBMUIsSUFBK0IsS0FBSyxDQUFMLEVBQVEsQ0FBUixJQUFhLE1BQU0sQ0FBTixFQUFTLENBQVQsQ0FBNUM7QUFDSDtBQUNKO0FBQ0o7QUFDSjtBQUNELGVBQU8sTUFBUDtBQUNIOzs7Ozs7QUFNRCxnQkFBWTtBQUNSLFlBQUksU0FBUyxJQUFJLE1BQUosQ0FBVyxLQUFLLE9BQWhCLEVBQXlCLEtBQUssSUFBOUIsQ0FBYjtBQUNBLGFBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxLQUFLLElBQXpCLEVBQStCLEdBQS9CLEVBQW9DO0FBQ2hDLGlCQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksS0FBSyxPQUF6QixFQUFrQyxHQUFsQyxFQUF1QztBQUNuQyx1QkFBTyxDQUFQLEVBQVUsQ0FBVixJQUFlLEtBQUssQ0FBTCxFQUFRLENBQVIsQ0FBZjtBQUNIO0FBQ0o7QUFDRCxlQUFPLE1BQVA7QUFDSDs7Ozs7OztBQU9ELGFBQVMsZUFBVCxFQUEwQjtBQUN0QixZQUFJLG9CQUFvQixTQUF4QixFQUFtQyxrQkFBa0IsY0FBbEI7QUFDbkMsYUFBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLEtBQUssSUFBekIsRUFBK0IsR0FBL0IsRUFBb0M7QUFDaEMsaUJBQUssQ0FBTCxFQUFRLElBQVIsQ0FBYSxlQUFiO0FBQ0g7QUFDRCxlQUFPLElBQVA7QUFDSDs7Ozs7OztBQU9ELGdCQUFZLGVBQVosRUFBNkI7QUFDekIsWUFBSSxvQkFBb0IsU0FBeEIsRUFBbUMsa0JBQWtCLGNBQWxCO0FBQ25DLGFBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxLQUFLLE9BQXpCLEVBQWtDLEdBQWxDLEVBQXVDO0FBQ25DLGlCQUFLLFNBQUwsQ0FBZSxDQUFmLEVBQWtCLEtBQUssU0FBTCxDQUFlLENBQWYsRUFBa0IsSUFBbEIsQ0FBdUIsZUFBdkIsQ0FBbEI7QUFDSDtBQUNELGVBQU8sSUFBUDtBQUNIOzs7Ozs7Ozs7O0FBVUQsY0FBVSxRQUFWLEVBQW9CLE1BQXBCLEVBQTRCLFdBQTVCLEVBQXlDLFNBQXpDLEVBQW9EO0FBQ2hELFlBQUssV0FBVyxNQUFaLElBQXdCLGNBQWMsU0FBdEMsSUFBcUQsV0FBVyxDQUFoRSxJQUF1RSxZQUFZLEtBQUssSUFBeEYsSUFBa0csU0FBUyxDQUEzRyxJQUFrSCxVQUFVLEtBQUssSUFBakksSUFBMkksY0FBYyxDQUF6SixJQUFnSyxlQUFlLEtBQUssT0FBcEwsSUFBaU0sWUFBWSxDQUE3TSxJQUFvTixhQUFhLEtBQUssT0FBMU8sRUFBb1A7QUFDaFAsa0JBQU0sSUFBSSxVQUFKLENBQWUsdUJBQWYsQ0FBTjtBQUNIO0FBQ0QsWUFBSSxZQUFZLElBQUksTUFBSixDQUFXLFNBQVMsUUFBVCxHQUFvQixDQUEvQixFQUFrQyxZQUFZLFdBQVosR0FBMEIsQ0FBNUQsQ0FBaEI7QUFDQSxhQUFLLElBQUksSUFBSSxRQUFiLEVBQXVCLEtBQUssTUFBNUIsRUFBb0MsR0FBcEMsRUFBeUM7QUFDckMsaUJBQUssSUFBSSxJQUFJLFdBQWIsRUFBMEIsS0FBSyxTQUEvQixFQUEwQyxHQUExQyxFQUErQztBQUMzQywwQkFBVSxJQUFJLFFBQWQsRUFBd0IsSUFBSSxXQUE1QixJQUEyQyxLQUFLLENBQUwsRUFBUSxDQUFSLENBQTNDO0FBQ0g7QUFDSjtBQUNELGVBQU8sU0FBUDtBQUNIOzs7Ozs7Ozs7QUFTRCxpQkFBYSxPQUFiLEVBQXNCLFdBQXRCLEVBQW1DLFNBQW5DLEVBQThDO0FBQzFDLFlBQUksZ0JBQWdCLFNBQXBCLEVBQStCLGNBQWMsQ0FBZDtBQUMvQixZQUFJLGNBQWMsU0FBbEIsRUFBNkIsWUFBWSxLQUFLLE9BQUwsR0FBZSxDQUEzQjtBQUM3QixZQUFLLGNBQWMsU0FBZixJQUE4QixjQUFjLENBQTVDLElBQW1ELGVBQWUsS0FBSyxPQUF2RSxJQUFvRixZQUFZLENBQWhHLElBQXVHLGFBQWEsS0FBSyxPQUE3SCxFQUF1STtBQUNuSSxrQkFBTSxJQUFJLFVBQUosQ0FBZSx1QkFBZixDQUFOO0FBQ0g7O0FBRUQsWUFBSSxZQUFZLElBQUksTUFBSixDQUFXLFFBQVEsTUFBbkIsRUFBMkIsWUFBWSxXQUFaLEdBQTBCLENBQXJELENBQWhCO0FBQ0EsYUFBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLFFBQVEsTUFBNUIsRUFBb0MsR0FBcEMsRUFBeUM7QUFDckMsaUJBQUssSUFBSSxJQUFJLFdBQWIsRUFBMEIsS0FBSyxTQUEvQixFQUEwQyxHQUExQyxFQUErQztBQUMzQyxvQkFBSSxRQUFRLENBQVIsSUFBYSxDQUFiLElBQWtCLFFBQVEsQ0FBUixLQUFjLEtBQUssSUFBekMsRUFBK0M7QUFDM0MsMEJBQU0sSUFBSSxVQUFKLENBQWUsNkJBQTZCLFFBQVEsQ0FBUixDQUE1QyxDQUFOO0FBQ0g7QUFDRCwwQkFBVSxDQUFWLEVBQWEsSUFBSSxXQUFqQixJQUFnQyxLQUFLLFFBQVEsQ0FBUixDQUFMLEVBQWlCLENBQWpCLENBQWhDO0FBQ0g7QUFDSjtBQUNELGVBQU8sU0FBUDtBQUNIOzs7Ozs7Ozs7QUFTRCxvQkFBZ0IsT0FBaEIsRUFBeUIsUUFBekIsRUFBbUMsTUFBbkMsRUFBMkM7QUFDdkMsWUFBSSxhQUFhLFNBQWpCLEVBQTRCLFdBQVcsQ0FBWDtBQUM1QixZQUFJLFdBQVcsU0FBZixFQUEwQixTQUFTLEtBQUssSUFBTCxHQUFZLENBQXJCO0FBQzFCLFlBQUssV0FBVyxNQUFaLElBQXdCLFdBQVcsQ0FBbkMsSUFBMEMsWUFBWSxLQUFLLElBQTNELElBQXFFLFNBQVMsQ0FBOUUsSUFBcUYsVUFBVSxLQUFLLElBQXhHLEVBQStHO0FBQzNHLGtCQUFNLElBQUksVUFBSixDQUFlLHVCQUFmLENBQU47QUFDSDs7QUFFRCxZQUFJLFlBQVksSUFBSSxNQUFKLENBQVcsU0FBUyxRQUFULEdBQW9CLENBQS9CLEVBQWtDLFFBQVEsTUFBMUMsQ0FBaEI7QUFDQSxhQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksUUFBUSxNQUE1QixFQUFvQyxHQUFwQyxFQUF5QztBQUNyQyxpQkFBSyxJQUFJLElBQUksUUFBYixFQUF1QixLQUFLLE1BQTVCLEVBQW9DLEdBQXBDLEVBQXlDO0FBQ3JDLG9CQUFJLFFBQVEsQ0FBUixJQUFhLENBQWIsSUFBa0IsUUFBUSxDQUFSLEtBQWMsS0FBSyxPQUF6QyxFQUFrRDtBQUM5QywwQkFBTSxJQUFJLFVBQUosQ0FBZSxnQ0FBZ0MsUUFBUSxDQUFSLENBQS9DLENBQU47QUFDSDtBQUNELDBCQUFVLElBQUksUUFBZCxFQUF3QixDQUF4QixJQUE2QixLQUFLLENBQUwsRUFBUSxRQUFRLENBQVIsQ0FBUixDQUE3QjtBQUNIO0FBQ0o7QUFDRCxlQUFPLFNBQVA7QUFDSDs7Ozs7O0FBTUQsWUFBUTtBQUNKLFlBQUksTUFBTSxLQUFLLEdBQUwsQ0FBUyxLQUFLLElBQWQsRUFBb0IsS0FBSyxPQUF6QixDQUFWO0FBQ0EsWUFBSSxRQUFRLENBQVo7QUFDQSxhQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksR0FBcEIsRUFBeUIsR0FBekIsRUFBOEI7QUFDMUIscUJBQVMsS0FBSyxDQUFMLEVBQVEsQ0FBUixDQUFUO0FBQ0g7QUFDRCxlQUFPLEtBQVA7QUFDSDtBQXhwQ3NCOztBQTJwQzNCLE9BQU8sU0FBUCxDQUFpQixLQUFqQixHQUF5QixRQUF6Qjs7QUFFQSxPQUFPLE9BQVAsR0FBaUIsTUFBakI7Ozs7Ozs7OztBQVNBLFNBQVMsYUFBVCxDQUF1QixNQUF2QixFQUErQixLQUEvQixFQUFzQyxLQUF0QyxFQUE2QztBQUN6QyxRQUFJLE1BQU0sUUFBUSxPQUFPLElBQWYsR0FBc0IsT0FBTyxJQUFQLEdBQWMsQ0FBOUM7QUFDQSxRQUFJLFFBQVEsQ0FBUixJQUFhLFFBQVEsR0FBekIsRUFDSSxNQUFNLElBQUksVUFBSixDQUFlLHdCQUFmLENBQU47QUFDUDs7Ozs7Ozs7Ozs7QUFXRCxTQUFTLGNBQVQsQ0FBd0IsTUFBeEIsRUFBZ0MsTUFBaEMsRUFBd0MsSUFBeEMsRUFBOEM7QUFDMUMsUUFBSSxPQUFPLFFBQVAsQ0FBZ0IsTUFBaEIsQ0FBSixFQUE2QjtBQUN6QixpQkFBUyxPQUFPLFNBQVAsRUFBVDtBQUNILEtBRkQsTUFFTyxJQUFJLElBQUosRUFBVTtBQUNiLGlCQUFTLEdBQUcsTUFBSCxDQUFVLE1BQVYsQ0FBVDtBQUNIO0FBQ0QsUUFBSSxPQUFPLE1BQVAsS0FBa0IsT0FBTyxPQUE3QixFQUNJLE1BQU0sSUFBSSxVQUFKLENBQWUsdURBQWYsQ0FBTjtBQUNKLFdBQU8sTUFBUDtBQUNIOzs7Ozs7Ozs7OztBQVdELFNBQVMsaUJBQVQsQ0FBMkIsTUFBM0IsRUFBbUMsTUFBbkMsRUFBMkMsSUFBM0MsRUFBaUQ7QUFDN0MsUUFBSSxPQUFPLFFBQVAsQ0FBZ0IsTUFBaEIsQ0FBSixFQUE2QjtBQUN6QixpQkFBUyxPQUFPLFNBQVAsRUFBVDtBQUNILEtBRkQsTUFFTyxJQUFJLElBQUosRUFBVTtBQUNiLGlCQUFTLEdBQUcsTUFBSCxDQUFVLE1BQVYsQ0FBVDtBQUNIO0FBQ0QsUUFBSSxPQUFPLE1BQVAsS0FBa0IsT0FBTyxJQUE3QixFQUNJLE1BQU0sSUFBSSxVQUFKLENBQWUsb0RBQWYsQ0FBTjtBQUNKLFdBQU8sTUFBUDtBQUNIOzs7Ozs7Ozs7QUFTRCxTQUFTLGdCQUFULENBQTBCLE1BQTFCLEVBQWtDLEtBQWxDLEVBQXlDLEtBQXpDLEVBQWdEO0FBQzVDLFFBQUksTUFBTSxRQUFRLE9BQU8sT0FBZixHQUF5QixPQUFPLE9BQVAsR0FBaUIsQ0FBcEQ7QUFDQSxRQUFJLFFBQVEsQ0FBUixJQUFhLFFBQVEsR0FBekIsRUFDSSxNQUFNLElBQUksVUFBSixDQUFlLDJCQUFmLENBQU47QUFDUDs7Ozs7Ozs7QUFRRCxTQUFTLGVBQVQsQ0FBeUIsTUFBekIsRUFBaUMsV0FBakMsRUFBOEM7QUFDMUMsUUFBSSxPQUFPLElBQVAsS0FBZ0IsWUFBWSxNQUE1QixJQUNBLE9BQU8sT0FBUCxLQUFtQixZQUFZLENBQVosRUFBZSxNQUR0QyxFQUM4QztBQUMxQyxjQUFNLElBQUksVUFBSixDQUFlLG1DQUFmLENBQU47QUFDSDtBQUNKOztBQUVELFNBQVMsY0FBVCxDQUF3QixDQUF4QixFQUEyQixDQUEzQixFQUE4QjtBQUMxQixXQUFPLElBQUksQ0FBWDtBQUNIOzs7Ozs7QUFNRCxPQUFPLE1BQVAsR0FBZ0IsT0FBTyxJQUF2QjtBQUNBLE9BQU8sUUFBUCxHQUFrQixPQUFPLElBQXpCO0FBQ0EsT0FBTyxTQUFQLENBQWlCLFFBQWpCLEdBQTRCLE9BQU8sU0FBUCxDQUFpQixJQUE3QztBQUNBLE9BQU8sUUFBUCxHQUFrQixPQUFPLEdBQXpCO0FBQ0EsT0FBTyxTQUFQLENBQWlCLE1BQWpCLEdBQTBCLE9BQU8sU0FBUCxDQUFpQixHQUEzQztBQUNBLE9BQU8sU0FBUCxDQUFpQixhQUFqQixHQUFpQyxPQUFPLFNBQVAsQ0FBaUIsZ0JBQWxEOzs7Ozs7QUFNQSxJQUFJLGtCQUFtQjs7Ozs7Q0FBdkI7O0FBT0EsSUFBSSx3QkFBeUI7Ozs7Ozs7OztDQUE3Qjs7QUFXQSxJQUFJLHdCQUF5Qjs7Ozs7Ozs7OztDQUE3Qjs7QUFZQSxJQUFJLGlCQUFrQjs7Ozs7Q0FBdEI7O0FBT0EsSUFBSSxnQkFBaUI7Ozs7Ozs7OztDQUFyQjs7QUFXQSxJQUFJLGVBQWdCOzs7OztDQUFwQjs7QUFPQSxJQUFJLFlBQVk7O0FBRVosQ0FBQyxHQUFELEVBQU0sS0FBTixDQUZZLEVBR1osQ0FBQyxHQUFELEVBQU0sS0FBTixFQUFhLFVBQWIsQ0FIWSxFQUlaLENBQUMsR0FBRCxFQUFNLEtBQU4sRUFBYSxVQUFiLENBSlksRUFLWixDQUFDLEdBQUQsRUFBTSxLQUFOLEVBQWEsUUFBYixDQUxZLEVBTVosQ0FBQyxHQUFELEVBQU0sS0FBTixFQUFhLFNBQWIsQ0FOWTs7QUFRWixDQUFDLEdBQUQsRUFBTSxLQUFOLENBUlksRUFTWixDQUFDLEdBQUQsRUFBTSxJQUFOLENBVFksRUFVWixDQUFDLEdBQUQsRUFBTSxLQUFOLENBVlksRUFXWixDQUFDLElBQUQsRUFBTyxXQUFQLENBWFksRUFZWixDQUFDLElBQUQsRUFBTywyQkFBUCxDQVpZLEVBYVosQ0FBQyxLQUFELEVBQVEsWUFBUixFQUFzQixvQkFBdEIsQ0FiWSxDQUFoQjs7QUFnQkEsS0FBSyxJQUFJLFFBQVQsSUFBcUIsU0FBckIsRUFBZ0M7QUFDNUIsU0FBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLFNBQVMsTUFBN0IsRUFBcUMsR0FBckMsRUFBMEM7QUFDdEMsZUFBTyxTQUFQLENBQWlCLFNBQVMsQ0FBVCxDQUFqQixJQUFnQyxLQUFLLHFCQUFxQixlQUFyQixFQUFzQyxFQUFDLE1BQU0sU0FBUyxDQUFULENBQVAsRUFBb0IsSUFBSSxTQUFTLENBQVQsQ0FBeEIsRUFBdEMsQ0FBTCxDQUFoQztBQUNBLGVBQU8sU0FBUCxDQUFpQixTQUFTLENBQVQsSUFBYyxHQUEvQixJQUFzQyxLQUFLLHFCQUFxQixxQkFBckIsRUFBNEMsRUFBQyxNQUFNLFNBQVMsQ0FBVCxJQUFjLEdBQXJCLEVBQTBCLElBQUksU0FBUyxDQUFULENBQTlCLEVBQTVDLENBQUwsQ0FBdEM7QUFDQSxlQUFPLFNBQVAsQ0FBaUIsU0FBUyxDQUFULElBQWMsR0FBL0IsSUFBc0MsS0FBSyxxQkFBcUIscUJBQXJCLEVBQTRDLEVBQUMsTUFBTSxTQUFTLENBQVQsSUFBYyxHQUFyQixFQUEwQixJQUFJLFNBQVMsQ0FBVCxDQUE5QixFQUE1QyxDQUFMLENBQXRDOztBQUVBLGVBQU8sU0FBUyxDQUFULENBQVAsSUFBc0IsS0FBSyxxQkFBcUIsY0FBckIsRUFBcUMsRUFBQyxNQUFNLFNBQVMsQ0FBVCxDQUFQLEVBQXJDLENBQUwsQ0FBdEI7QUFDSDtBQUNKOztBQUVELElBQUksVUFBVSxDQUNWLENBQUMsR0FBRCxFQUFNLEtBQU4sQ0FEVSxDQUFkOztBQUlBLENBQ0ksS0FESixFQUNXLE1BRFgsRUFDbUIsT0FEbkIsRUFDNEIsTUFENUIsRUFDb0MsT0FEcEMsRUFDNkMsTUFEN0MsRUFDcUQsT0FEckQsRUFDOEQsTUFEOUQsRUFDc0UsTUFEdEUsRUFFSSxPQUZKLEVBRWEsS0FGYixFQUVvQixNQUZwQixFQUU0QixLQUY1QixFQUVtQyxPQUZuQyxFQUU0QyxPQUY1QyxFQUVxRCxRQUZyRCxFQUUrRCxLQUYvRCxFQUVzRSxPQUZ0RSxFQUdJLE9BSEosRUFHYSxNQUhiLEVBR3FCLE9BSHJCLEVBRzhCLE1BSDlCLEVBR3NDLEtBSHRDLEVBRzZDLE1BSDdDLEVBR3FELE1BSHJELEVBRzZELEtBSDdELEVBR29FLE1BSHBFLEVBRzRFLE9BSDVFLEVBSUUsT0FKRixDQUlVLFVBQVUsVUFBVixFQUFzQjtBQUM1QixZQUFRLElBQVIsQ0FBYSxDQUFDLFVBQVUsVUFBWCxFQUF1QixVQUF2QixDQUFiO0FBQ0gsQ0FORDs7QUFRQSxLQUFLLElBQUksTUFBVCxJQUFtQixPQUFuQixFQUE0QjtBQUN4QixTQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksT0FBTyxNQUEzQixFQUFtQyxHQUFuQyxFQUF3QztBQUNwQyxlQUFPLFNBQVAsQ0FBaUIsT0FBTyxDQUFQLENBQWpCLElBQThCLEtBQUsscUJBQXFCLGFBQXJCLEVBQW9DLEVBQUMsTUFBTSxPQUFPLENBQVAsQ0FBUCxFQUFrQixRQUFRLE9BQU8sQ0FBUCxDQUExQixFQUFwQyxDQUFMLENBQTlCO0FBQ0EsZUFBTyxPQUFPLENBQVAsQ0FBUCxJQUFvQixLQUFLLHFCQUFxQixZQUFyQixFQUFtQyxFQUFDLE1BQU0sT0FBTyxDQUFQLENBQVAsRUFBbkMsQ0FBTCxDQUFwQjtBQUNIO0FBQ0o7O0FBRUQsU0FBUyxvQkFBVCxDQUE4QixRQUE5QixFQUF3QyxNQUF4QyxFQUFnRDtBQUM1QyxTQUFLLElBQUksQ0FBVCxJQUFjLE1BQWQsRUFBc0I7QUFDbEIsbUJBQVcsU0FBUyxPQUFULENBQWlCLElBQUksTUFBSixDQUFXLE1BQU0sQ0FBTixHQUFVLEdBQXJCLEVBQTBCLEdBQTFCLENBQWpCLEVBQWlELE9BQU8sQ0FBUCxDQUFqRCxDQUFYO0FBQ0g7QUFDRCxXQUFPLFFBQVA7QUFDSDs7O0FDLzJDRDs7QUFFQSxJQUFNLGlCQUFpQjtBQUNuQixZQUFRLENBRFc7QUFFbkIsY0FBVSxDQUZTO0FBR25CLFdBQU87QUFIWSxDQUF2Qjs7QUFNQSxNQUFNLGdCQUFOLENBQXVCO0FBQ25CLGdCQUFZLE9BQVosRUFBcUI7QUFDakIsa0JBQVUsT0FBTyxNQUFQLENBQWMsRUFBZCxFQUFrQixjQUFsQixFQUFrQyxPQUFsQyxDQUFWOztBQUVBLGFBQUssTUFBTCxHQUFjLFFBQVEsTUFBdEI7QUFDQSxhQUFLLFFBQUwsR0FBZ0IsUUFBUSxRQUF4QjtBQUNBLGFBQUssS0FBTCxHQUFhLFFBQVEsS0FBckI7QUFDSDs7QUFFRCxZQUFRLENBQVIsRUFBVyxDQUFYLEVBQWM7QUFDVixZQUFJLE1BQU0sQ0FBVjtBQUNBLGFBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxFQUFFLE1BQXRCLEVBQThCLEdBQTlCLEVBQW1DO0FBQy9CLG1CQUFPLEVBQUUsQ0FBRixJQUFPLEVBQUUsQ0FBRixDQUFkO0FBQ0g7QUFDRCxlQUFPLEtBQUssR0FBTCxDQUFTLEtBQUssS0FBTCxHQUFhLEdBQWIsR0FBbUIsS0FBSyxRQUFqQyxFQUEyQyxLQUFLLE1BQWhELENBQVA7QUFDSDtBQWZrQjs7QUFrQnZCLE9BQU8sT0FBUCxHQUFpQixnQkFBakI7OztBQzFCQTs7QUFFQSxRQUFRLHNCQUFSLEdBQWlDLFFBQVEsR0FBUixHQUFjLFFBQVEsdUNBQVIsQ0FBL0M7QUFDQSxRQUFRLHFCQUFSLEdBQWdDLFFBQVEsR0FBUixHQUFjLFFBQVEsc0NBQVIsQ0FBOUM7Ozs7O0FDSEE7O0FBRUEsSUFBTSxTQUFTLFFBQVEsV0FBUixDQUFmO0FBQ0EsSUFBTSxTQUFTLFFBQVEsV0FBUixDQUFmOztBQUVBLElBQU0saUJBQWlCO0FBQ25CLFlBQVEsR0FEVztBQUVuQixnQkFBWSxVQUZPO0FBR25CLG1CQUFlO0FBSEksQ0FBdkI7Ozs7QUFRQSxNQUFNLHFCQUFOLENBQTRCO0FBQ3hCLGdCQUFZLE1BQVosRUFBb0IsT0FBcEIsRUFBNkIsT0FBN0IsRUFBc0M7QUFDbEMsWUFBSSxXQUFXLElBQWYsRUFBcUI7O0FBQ2pCLGlCQUFLLEtBQUwsR0FBYSxRQUFRLEtBQXJCO0FBQ0EsaUJBQUssTUFBTCxHQUFjLFFBQVEsTUFBdEI7QUFDQSxpQkFBSyxVQUFMLEdBQWtCLFFBQVEsVUFBMUI7QUFDQSxpQkFBSyxhQUFMLEdBQXFCLFFBQVEsYUFBN0I7QUFDQSxpQkFBSyxNQUFMLEdBQWMsSUFBSSxNQUFKLENBQVcsUUFBUSxVQUFuQixFQUErQixRQUFRLGFBQXZDLENBQWQ7QUFDSCxTQU5ELE1BTU87QUFDSCxzQkFBVSxPQUFPLE1BQVAsQ0FBYyxFQUFkLEVBQWtCLGNBQWxCLEVBQWtDLE9BQWxDLENBQVY7O0FBRUEsZ0JBQU0saUJBQWlCLElBQUksTUFBSixDQUFXLFFBQVEsVUFBbkIsRUFBK0IsUUFBUSxhQUF2QyxDQUF2QjtBQUNBLGdCQUFNLElBQUksZUFBZSxPQUFmLENBQXVCLE1BQXZCLENBQVY7QUFDQSxnQkFBTSxJQUFJLE9BQU8sTUFBakI7QUFDQSxjQUFFLEdBQUYsQ0FBTSxPQUFPLEdBQVAsQ0FBVyxDQUFYLEVBQWMsQ0FBZCxFQUFpQixHQUFqQixDQUFxQixRQUFRLE1BQTdCLENBQU47O0FBRUEsaUJBQUssS0FBTCxHQUFhLEVBQUUsS0FBRixDQUFRLE9BQVIsQ0FBYjtBQUNBLGlCQUFLLE1BQUwsR0FBYyxNQUFkO0FBQ0EsaUJBQUssVUFBTCxHQUFrQixRQUFRLFVBQTFCO0FBQ0EsaUJBQUssYUFBTCxHQUFxQixRQUFRLGFBQTdCO0FBQ0EsaUJBQUssTUFBTCxHQUFjLGNBQWQ7QUFDSDtBQUNKOztBQUVELFlBQVEsU0FBUixFQUFtQjtBQUNmLGVBQU8sS0FBSyxNQUFMLENBQVksT0FBWixDQUFvQixTQUFwQixFQUErQixLQUFLLE1BQXBDLEVBQTRDLElBQTVDLENBQWlELEtBQUssS0FBdEQsQ0FBUDtBQUNIOztBQUVELGFBQVM7QUFDTCxlQUFPO0FBQ0gsa0JBQU0sdUJBREg7QUFFSCxtQkFBTyxLQUFLLEtBRlQ7QUFHSCxvQkFBUSxLQUFLLE1BSFY7QUFJSCx3QkFBWSxLQUFLLFVBSmQ7QUFLSCwyQkFBZSxLQUFLO0FBTGpCLFNBQVA7QUFPSDs7QUFFRCxXQUFPLElBQVAsQ0FBWSxJQUFaLEVBQWtCO0FBQ2QsWUFBSSxLQUFLLElBQUwsS0FBYyx1QkFBbEIsRUFBMkM7QUFDdkMsa0JBQU0sSUFBSSxTQUFKLENBQWMsaUJBQWQsQ0FBTjtBQUNIO0FBQ0QsZUFBTyxJQUFJLHFCQUFKLENBQTBCLElBQTFCLEVBQWdDLElBQWhDLENBQVA7QUFDSDtBQTNDdUI7O0FBOEM1QixPQUFPLE9BQVAsR0FBaUIscUJBQWpCOzs7QUMzREE7O0FBRUEsSUFBSSxtQkFBbUIsUUFBUSxRQUFSLEVBQWtCLGdCQUF6Qzs7QUFFQSxTQUFTLHNCQUFULENBQWdDLENBQWhDLEVBQW1DLENBQW5DLEVBQXNDO0FBQ2xDLFFBQUksRUFBRSxnQkFBZ0Isc0JBQWxCLENBQUosRUFBK0M7QUFDM0MsZUFBTyxJQUFJLHNCQUFKLENBQTJCLENBQTNCLEVBQThCLENBQTlCLENBQVA7QUFDSDs7QUFFRCxRQUFJLElBQUksRUFBRSxNQUFWO0FBQ0EsUUFBSSxNQUFNLEVBQUUsTUFBWixFQUFvQjtBQUNoQixjQUFNLElBQUksVUFBSixDQUFlLGdEQUFmLENBQU47QUFDSDs7QUFFRCxRQUFJLE9BQU8sQ0FBWDtBQUNBLFFBQUksT0FBTyxDQUFYOztBQUVBLFFBQUksV0FBVyxDQUFmO0FBQ0EsUUFBSSxXQUFXLENBQWY7QUFDQSxRQUFJLEtBQUssQ0FBVDs7QUFFQSxTQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksQ0FBcEIsRUFBdUIsR0FBdkIsRUFBNEI7QUFDeEIsZ0JBQVEsRUFBRSxDQUFGLENBQVI7QUFDQSxnQkFBUSxFQUFFLENBQUYsQ0FBUjtBQUNBLG9CQUFZLEVBQUUsQ0FBRixJQUFPLEVBQUUsQ0FBRixDQUFuQjtBQUNBLG9CQUFZLEVBQUUsQ0FBRixJQUFPLEVBQUUsQ0FBRixDQUFuQjtBQUNBLGNBQU0sRUFBRSxDQUFGLElBQU8sRUFBRSxDQUFGLENBQWI7QUFDSDs7QUFFRCxRQUFJLFlBQWEsSUFBSSxFQUFKLEdBQVMsT0FBTyxJQUFqQzs7QUFFQSxTQUFLLEtBQUwsR0FBYSxhQUFhLElBQUksUUFBSixHQUFlLE9BQU8sSUFBbkMsQ0FBYjtBQUNBLFNBQUssU0FBTCxHQUFrQixJQUFJLENBQUwsR0FBVSxJQUFWLEdBQWlCLEtBQUssS0FBTCxJQUFjLElBQUksQ0FBbEIsSUFBdUIsSUFBekQ7QUFDQSxTQUFLLFlBQUwsR0FBb0IsQ0FBQyxLQUFLLFNBQU4sRUFBaUIsS0FBSyxLQUF0QixDQUFwQjs7QUFFQSxTQUFLLENBQUwsR0FBUyxZQUFZLEtBQUssSUFBTCxDQUFVLENBQUMsSUFBSSxRQUFKLEdBQWUsT0FBTyxJQUF2QixLQUFnQyxJQUFJLFFBQUosR0FBZSxPQUFPLElBQXRELENBQVYsQ0FBckI7QUFDQSxTQUFLLDBCQUFMLEdBQWtDLEtBQUssRUFBTCxHQUFVLEtBQUssQ0FBTCxHQUFTLEtBQUssQ0FBMUQ7QUFDSDs7QUFFRCx1QkFBdUIsU0FBdkIsQ0FBaUMsT0FBakMsR0FBMkMsU0FBUyxPQUFULENBQWlCLEtBQWpCLEVBQXdCO0FBQy9ELFdBQU8sS0FBSyxLQUFMLEdBQWEsS0FBYixHQUFxQixLQUFLLFNBQWpDO0FBQ0gsQ0FGRDs7QUFJQSx1QkFBdUIsU0FBdkIsQ0FBaUMsUUFBakMsR0FBNEMsU0FBUyxRQUFULENBQWtCLEtBQWxCLEVBQXlCO0FBQ2pFLFdBQU8sQ0FBQyxRQUFRLEtBQUssU0FBZCxJQUEyQixLQUFLLEtBQXZDO0FBQ0gsQ0FGRDs7QUFJQSx1QkFBdUIsU0FBdkIsQ0FBaUMsUUFBakMsR0FBNEMsU0FBUyxRQUFULENBQWtCLFNBQWxCLEVBQTZCO0FBQ3JFLFFBQUksU0FBUyxNQUFiO0FBQ0EsUUFBSSxLQUFLLEtBQVQsRUFBZ0I7QUFDWixZQUFJLFVBQVUsaUJBQWlCLEtBQUssS0FBdEIsRUFBNkIsU0FBN0IsQ0FBZDtBQUNBLGtCQUFVLENBQUMsV0FBVyxDQUFYLEdBQWUsRUFBZixHQUFvQixPQUFyQixJQUFnQyxHQUExQztBQUNBLFlBQUksS0FBSyxTQUFULEVBQW9CO0FBQ2hCLGdCQUFJLGVBQWUsS0FBSyxHQUFMLENBQVMsS0FBSyxTQUFkLENBQW5CO0FBQ0EsZ0JBQUksV0FBVyxpQkFBaUIsS0FBSyxTQUF0QixHQUFrQyxHQUFsQyxHQUF3QyxHQUF2RDtBQUNBLHNCQUFVLE1BQU0sUUFBTixHQUFpQixHQUFqQixHQUF1QixpQkFBaUIsWUFBakIsRUFBK0IsU0FBL0IsQ0FBakM7QUFDSDtBQUNKLEtBUkQsTUFRTztBQUNILGtCQUFVLGlCQUFpQixLQUFLLFNBQXRCLEVBQWlDLFNBQWpDLENBQVY7QUFDSDtBQUNELFdBQU8sTUFBUDtBQUNILENBZEQ7O0FBZ0JBLE9BQU8sT0FBUCxHQUFpQixzQkFBakI7OztBQy9EQTs7QUFFQSxRQUFRLGdCQUFSLEdBQTJCLFNBQVMsZ0JBQVQsQ0FBMEIsS0FBMUIsRUFBaUMsTUFBakMsRUFBeUM7QUFDaEUsUUFBSSxNQUFKLEVBQVksT0FBTyxNQUFNLFdBQU4sQ0FBa0IsTUFBbEIsQ0FBUCxDQUFaLEtBQ0ssT0FBTyxNQUFNLFFBQU4sRUFBUDtBQUNSLENBSEQ7Ozs7O0FDRkEsT0FBTyxPQUFQLEdBQWlCLFFBQWpCOztBQUVBLFNBQVMsUUFBVCxDQUFtQixDQUFuQixFQUFzQixLQUF0QixFQUE2QjtBQUMzQixNQUFJLEtBQUssQ0FBVDtBQUNBLE1BQUksUUFBUSxJQUFJLEtBQUosQ0FBVSxDQUFWLENBQVo7QUFDQSxPQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksQ0FBcEIsRUFBdUIsR0FBdkIsRUFBNEI7QUFDMUIsVUFBTSxDQUFOLElBQVcsS0FBWDtBQUNEO0FBQ0QsU0FBTyxLQUFQO0FBQ0Q7OztBQ1REOztBQUNBLE9BQU8sT0FBUCxHQUFpQixPQUFPLEtBQVAsSUFBZ0IsVUFBVSxDQUFWLEVBQWE7QUFDN0MsUUFBTyxNQUFNLENBQWI7QUFDQSxDQUZEOzs7O0FDQUE7O0FBRUEsSUFBSSxTQUFZLFFBQVEsb0JBQVIsRUFBOEIsTUFBOUM7O0FBRUEsSUFBSSxVQUFZLFFBQVEsZUFBUixDQUFoQjtBQUNBLElBQUksVUFBWSxRQUFRLGVBQVIsQ0FBaEI7QUFDQSxJQUFJLFlBQVksUUFBUSxzQkFBUixDQUFoQjs7QUFFQSxJQUFJLE9BQU8sRUFBWDs7QUFFQSxPQUFPLElBQVAsRUFBYSxPQUFiLEVBQXNCLE9BQXRCLEVBQStCLFNBQS9COztBQUVBLE9BQU8sT0FBUCxHQUFpQixJQUFqQjs7O0FDYkE7O0FBR0EsSUFBSSxlQUFlLFFBQVEsZ0JBQVIsQ0FBbkI7QUFDQSxJQUFJLFFBQWUsUUFBUSxnQkFBUixDQUFuQjtBQUNBLElBQUksVUFBZSxRQUFRLGlCQUFSLENBQW5CO0FBQ0EsSUFBSSxNQUFlLFFBQVEsaUJBQVIsQ0FBbkI7QUFDQSxJQUFJLFVBQWUsUUFBUSxnQkFBUixDQUFuQjs7QUFFQSxJQUFJLFdBQVcsT0FBTyxTQUFQLENBQWlCLFFBQWhDOzs7OztBQUtBLElBQUksYUFBa0IsQ0FBdEI7QUFDQSxJQUFJLFdBQWtCLENBQXRCOztBQUVBLElBQUksT0FBa0IsQ0FBdEI7QUFDQSxJQUFJLGVBQWtCLENBQXRCO0FBQ0EsSUFBSSxlQUFrQixDQUF0Qjs7QUFFQSxJQUFJLHdCQUF3QixDQUFDLENBQTdCOztBQUVBLElBQUkscUJBQXdCLENBQTVCOztBQUVBLElBQUksYUFBYyxDQUFsQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUE4RkEsU0FBUyxPQUFULENBQWlCLE9BQWpCLEVBQTBCO0FBQ3hCLE1BQUksRUFBRSxnQkFBZ0IsT0FBbEIsQ0FBSixFQUFnQyxPQUFPLElBQUksT0FBSixDQUFZLE9BQVosQ0FBUDs7QUFFaEMsT0FBSyxPQUFMLEdBQWUsTUFBTSxNQUFOLENBQWE7QUFDMUIsV0FBTyxxQkFEbUI7QUFFMUIsWUFBUSxVQUZrQjtBQUcxQixlQUFXLEtBSGU7QUFJMUIsZ0JBQVksRUFKYztBQUsxQixjQUFVLENBTGdCO0FBTTFCLGNBQVUsa0JBTmdCO0FBTzFCLFFBQUk7QUFQc0IsR0FBYixFQVFaLFdBQVcsRUFSQyxDQUFmOztBQVVBLE1BQUksTUFBTSxLQUFLLE9BQWY7O0FBRUEsTUFBSSxJQUFJLEdBQUosSUFBWSxJQUFJLFVBQUosR0FBaUIsQ0FBakMsRUFBcUM7QUFDbkMsUUFBSSxVQUFKLEdBQWlCLENBQUMsSUFBSSxVQUF0QjtBQUNELEdBRkQsTUFJSyxJQUFJLElBQUksSUFBSixJQUFhLElBQUksVUFBSixHQUFpQixDQUE5QixJQUFxQyxJQUFJLFVBQUosR0FBaUIsRUFBMUQsRUFBK0Q7QUFDbEUsUUFBSSxVQUFKLElBQWtCLEVBQWxCO0FBQ0Q7O0FBRUQsT0FBSyxHQUFMLEdBQWMsQ0FBZCxDO0FBQ0EsT0FBSyxHQUFMLEdBQWMsRUFBZCxDO0FBQ0EsT0FBSyxLQUFMLEdBQWMsS0FBZCxDO0FBQ0EsT0FBSyxNQUFMLEdBQWMsRUFBZCxDOztBQUVBLE9BQUssSUFBTCxHQUFZLElBQUksT0FBSixFQUFaO0FBQ0EsT0FBSyxJQUFMLENBQVUsU0FBVixHQUFzQixDQUF0Qjs7QUFFQSxNQUFJLFNBQVMsYUFBYSxZQUFiLENBQ1gsS0FBSyxJQURNLEVBRVgsSUFBSSxLQUZPLEVBR1gsSUFBSSxNQUhPLEVBSVgsSUFBSSxVQUpPLEVBS1gsSUFBSSxRQUxPLEVBTVgsSUFBSSxRQU5PLENBQWI7O0FBU0EsTUFBSSxXQUFXLElBQWYsRUFBcUI7QUFDbkIsVUFBTSxJQUFJLEtBQUosQ0FBVSxJQUFJLE1BQUosQ0FBVixDQUFOO0FBQ0Q7O0FBRUQsTUFBSSxJQUFJLE1BQVIsRUFBZ0I7QUFDZCxpQkFBYSxnQkFBYixDQUE4QixLQUFLLElBQW5DLEVBQXlDLElBQUksTUFBN0M7QUFDRDs7QUFFRCxNQUFJLElBQUksVUFBUixFQUFvQjtBQUNsQixRQUFJLElBQUo7O0FBRUEsUUFBSSxPQUFPLElBQUksVUFBWCxLQUEwQixRQUE5QixFQUF3Qzs7QUFFdEMsYUFBTyxRQUFRLFVBQVIsQ0FBbUIsSUFBSSxVQUF2QixDQUFQO0FBQ0QsS0FIRCxNQUdPLElBQUksU0FBUyxJQUFULENBQWMsSUFBSSxVQUFsQixNQUFrQyxzQkFBdEMsRUFBOEQ7QUFDbkUsYUFBTyxJQUFJLFVBQUosQ0FBZSxJQUFJLFVBQW5CLENBQVA7QUFDRCxLQUZNLE1BRUE7QUFDTCxhQUFPLElBQUksVUFBWDtBQUNEOztBQUVELGFBQVMsYUFBYSxvQkFBYixDQUFrQyxLQUFLLElBQXZDLEVBQTZDLElBQTdDLENBQVQ7O0FBRUEsUUFBSSxXQUFXLElBQWYsRUFBcUI7QUFDbkIsWUFBTSxJQUFJLEtBQUosQ0FBVSxJQUFJLE1BQUosQ0FBVixDQUFOO0FBQ0Q7O0FBRUQsU0FBSyxTQUFMLEdBQWlCLElBQWpCO0FBQ0Q7QUFDRjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQStCRCxRQUFRLFNBQVIsQ0FBa0IsSUFBbEIsR0FBeUIsVUFBVSxJQUFWLEVBQWdCLElBQWhCLEVBQXNCO0FBQzdDLE1BQUksT0FBTyxLQUFLLElBQWhCO0FBQ0EsTUFBSSxZQUFZLEtBQUssT0FBTCxDQUFhLFNBQTdCO0FBQ0EsTUFBSSxNQUFKLEVBQVksS0FBWjs7QUFFQSxNQUFJLEtBQUssS0FBVCxFQUFnQjtBQUFFLFdBQU8sS0FBUDtBQUFlOztBQUVqQyxVQUFTLFNBQVMsQ0FBQyxDQUFDLElBQVosR0FBb0IsSUFBcEIsR0FBNkIsU0FBUyxJQUFWLEdBQWtCLFFBQWxCLEdBQTZCLFVBQWpFOzs7QUFHQSxNQUFJLE9BQU8sSUFBUCxLQUFnQixRQUFwQixFQUE4Qjs7QUFFNUIsU0FBSyxLQUFMLEdBQWEsUUFBUSxVQUFSLENBQW1CLElBQW5CLENBQWI7QUFDRCxHQUhELE1BR08sSUFBSSxTQUFTLElBQVQsQ0FBYyxJQUFkLE1BQXdCLHNCQUE1QixFQUFvRDtBQUN6RCxTQUFLLEtBQUwsR0FBYSxJQUFJLFVBQUosQ0FBZSxJQUFmLENBQWI7QUFDRCxHQUZNLE1BRUE7QUFDTCxTQUFLLEtBQUwsR0FBYSxJQUFiO0FBQ0Q7O0FBRUQsT0FBSyxPQUFMLEdBQWUsQ0FBZjtBQUNBLE9BQUssUUFBTCxHQUFnQixLQUFLLEtBQUwsQ0FBVyxNQUEzQjs7QUFFQSxLQUFHO0FBQ0QsUUFBSSxLQUFLLFNBQUwsS0FBbUIsQ0FBdkIsRUFBMEI7QUFDeEIsV0FBSyxNQUFMLEdBQWMsSUFBSSxNQUFNLElBQVYsQ0FBZSxTQUFmLENBQWQ7QUFDQSxXQUFLLFFBQUwsR0FBZ0IsQ0FBaEI7QUFDQSxXQUFLLFNBQUwsR0FBaUIsU0FBakI7QUFDRDtBQUNELGFBQVMsYUFBYSxPQUFiLENBQXFCLElBQXJCLEVBQTJCLEtBQTNCLENBQVQsQzs7QUFFQSxRQUFJLFdBQVcsWUFBWCxJQUEyQixXQUFXLElBQTFDLEVBQWdEO0FBQzlDLFdBQUssS0FBTCxDQUFXLE1BQVg7QUFDQSxXQUFLLEtBQUwsR0FBYSxJQUFiO0FBQ0EsYUFBTyxLQUFQO0FBQ0Q7QUFDRCxRQUFJLEtBQUssU0FBTCxLQUFtQixDQUFuQixJQUF5QixLQUFLLFFBQUwsS0FBa0IsQ0FBbEIsS0FBd0IsVUFBVSxRQUFWLElBQXNCLFVBQVUsWUFBeEQsQ0FBN0IsRUFBcUc7QUFDbkcsVUFBSSxLQUFLLE9BQUwsQ0FBYSxFQUFiLEtBQW9CLFFBQXhCLEVBQWtDO0FBQ2hDLGFBQUssTUFBTCxDQUFZLFFBQVEsYUFBUixDQUFzQixNQUFNLFNBQU4sQ0FBZ0IsS0FBSyxNQUFyQixFQUE2QixLQUFLLFFBQWxDLENBQXRCLENBQVo7QUFDRCxPQUZELE1BRU87QUFDTCxhQUFLLE1BQUwsQ0FBWSxNQUFNLFNBQU4sQ0FBZ0IsS0FBSyxNQUFyQixFQUE2QixLQUFLLFFBQWxDLENBQVo7QUFDRDtBQUNGO0FBQ0YsR0FwQkQsUUFvQlMsQ0FBQyxLQUFLLFFBQUwsR0FBZ0IsQ0FBaEIsSUFBcUIsS0FBSyxTQUFMLEtBQW1CLENBQXpDLEtBQStDLFdBQVcsWUFwQm5FOzs7QUF1QkEsTUFBSSxVQUFVLFFBQWQsRUFBd0I7QUFDdEIsYUFBUyxhQUFhLFVBQWIsQ0FBd0IsS0FBSyxJQUE3QixDQUFUO0FBQ0EsU0FBSyxLQUFMLENBQVcsTUFBWDtBQUNBLFNBQUssS0FBTCxHQUFhLElBQWI7QUFDQSxXQUFPLFdBQVcsSUFBbEI7QUFDRDs7O0FBR0QsTUFBSSxVQUFVLFlBQWQsRUFBNEI7QUFDMUIsU0FBSyxLQUFMLENBQVcsSUFBWDtBQUNBLFNBQUssU0FBTCxHQUFpQixDQUFqQjtBQUNBLFdBQU8sSUFBUDtBQUNEOztBQUVELFNBQU8sSUFBUDtBQUNELENBNUREOzs7Ozs7Ozs7OztBQXdFQSxRQUFRLFNBQVIsQ0FBa0IsTUFBbEIsR0FBMkIsVUFBVSxLQUFWLEVBQWlCO0FBQzFDLE9BQUssTUFBTCxDQUFZLElBQVosQ0FBaUIsS0FBakI7QUFDRCxDQUZEOzs7Ozs7Ozs7Ozs7QUFlQSxRQUFRLFNBQVIsQ0FBa0IsS0FBbEIsR0FBMEIsVUFBVSxNQUFWLEVBQWtCOztBQUUxQyxNQUFJLFdBQVcsSUFBZixFQUFxQjtBQUNuQixRQUFJLEtBQUssT0FBTCxDQUFhLEVBQWIsS0FBb0IsUUFBeEIsRUFBa0M7QUFDaEMsV0FBSyxNQUFMLEdBQWMsS0FBSyxNQUFMLENBQVksSUFBWixDQUFpQixFQUFqQixDQUFkO0FBQ0QsS0FGRCxNQUVPO0FBQ0wsV0FBSyxNQUFMLEdBQWMsTUFBTSxhQUFOLENBQW9CLEtBQUssTUFBekIsQ0FBZDtBQUNEO0FBQ0Y7QUFDRCxPQUFLLE1BQUwsR0FBYyxFQUFkO0FBQ0EsT0FBSyxHQUFMLEdBQVcsTUFBWDtBQUNBLE9BQUssR0FBTCxHQUFXLEtBQUssSUFBTCxDQUFVLEdBQXJCO0FBQ0QsQ0FaRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBaURBLFNBQVMsT0FBVCxDQUFpQixLQUFqQixFQUF3QixPQUF4QixFQUFpQztBQUMvQixNQUFJLFdBQVcsSUFBSSxPQUFKLENBQVksT0FBWixDQUFmOztBQUVBLFdBQVMsSUFBVCxDQUFjLEtBQWQsRUFBcUIsSUFBckI7OztBQUdBLE1BQUksU0FBUyxHQUFiLEVBQWtCO0FBQUUsVUFBTSxTQUFTLEdBQWY7QUFBcUI7O0FBRXpDLFNBQU8sU0FBUyxNQUFoQjtBQUNEOzs7Ozs7Ozs7O0FBV0QsU0FBUyxVQUFULENBQW9CLEtBQXBCLEVBQTJCLE9BQTNCLEVBQW9DO0FBQ2xDLFlBQVUsV0FBVyxFQUFyQjtBQUNBLFVBQVEsR0FBUixHQUFjLElBQWQ7QUFDQSxTQUFPLFFBQVEsS0FBUixFQUFlLE9BQWYsQ0FBUDtBQUNEOzs7Ozs7Ozs7O0FBV0QsU0FBUyxJQUFULENBQWMsS0FBZCxFQUFxQixPQUFyQixFQUE4QjtBQUM1QixZQUFVLFdBQVcsRUFBckI7QUFDQSxVQUFRLElBQVIsR0FBZSxJQUFmO0FBQ0EsU0FBTyxRQUFRLEtBQVIsRUFBZSxPQUFmLENBQVA7QUFDRDs7QUFHRCxRQUFRLE9BQVIsR0FBa0IsT0FBbEI7QUFDQSxRQUFRLE9BQVIsR0FBa0IsT0FBbEI7QUFDQSxRQUFRLFVBQVIsR0FBcUIsVUFBckI7QUFDQSxRQUFRLElBQVIsR0FBZSxJQUFmOzs7QUMvWUE7O0FBR0EsSUFBSSxlQUFlLFFBQVEsZ0JBQVIsQ0FBbkI7QUFDQSxJQUFJLFFBQWUsUUFBUSxnQkFBUixDQUFuQjtBQUNBLElBQUksVUFBZSxRQUFRLGlCQUFSLENBQW5CO0FBQ0EsSUFBSSxJQUFlLFFBQVEsa0JBQVIsQ0FBbkI7QUFDQSxJQUFJLE1BQWUsUUFBUSxpQkFBUixDQUFuQjtBQUNBLElBQUksVUFBZSxRQUFRLGdCQUFSLENBQW5CO0FBQ0EsSUFBSSxXQUFlLFFBQVEsaUJBQVIsQ0FBbkI7O0FBRUEsSUFBSSxXQUFXLE9BQU8sU0FBUCxDQUFpQixRQUFoQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFpRkEsU0FBUyxPQUFULENBQWlCLE9BQWpCLEVBQTBCO0FBQ3hCLE1BQUksRUFBRSxnQkFBZ0IsT0FBbEIsQ0FBSixFQUFnQyxPQUFPLElBQUksT0FBSixDQUFZLE9BQVosQ0FBUDs7QUFFaEMsT0FBSyxPQUFMLEdBQWUsTUFBTSxNQUFOLENBQWE7QUFDMUIsZUFBVyxLQURlO0FBRTFCLGdCQUFZLENBRmM7QUFHMUIsUUFBSTtBQUhzQixHQUFiLEVBSVosV0FBVyxFQUpDLENBQWY7O0FBTUEsTUFBSSxNQUFNLEtBQUssT0FBZjs7OztBQUlBLE1BQUksSUFBSSxHQUFKLElBQVksSUFBSSxVQUFKLElBQWtCLENBQTlCLElBQXFDLElBQUksVUFBSixHQUFpQixFQUExRCxFQUErRDtBQUM3RCxRQUFJLFVBQUosR0FBaUIsQ0FBQyxJQUFJLFVBQXRCO0FBQ0EsUUFBSSxJQUFJLFVBQUosS0FBbUIsQ0FBdkIsRUFBMEI7QUFBRSxVQUFJLFVBQUosR0FBaUIsQ0FBQyxFQUFsQjtBQUF1QjtBQUNwRDs7O0FBR0QsTUFBSyxJQUFJLFVBQUosSUFBa0IsQ0FBbkIsSUFBMEIsSUFBSSxVQUFKLEdBQWlCLEVBQTNDLElBQ0EsRUFBRSxXQUFXLFFBQVEsVUFBckIsQ0FESixFQUNzQztBQUNwQyxRQUFJLFVBQUosSUFBa0IsRUFBbEI7QUFDRDs7OztBQUlELE1BQUssSUFBSSxVQUFKLEdBQWlCLEVBQWxCLElBQTBCLElBQUksVUFBSixHQUFpQixFQUEvQyxFQUFvRDs7O0FBR2xELFFBQUksQ0FBQyxJQUFJLFVBQUosR0FBaUIsRUFBbEIsTUFBMEIsQ0FBOUIsRUFBaUM7QUFDL0IsVUFBSSxVQUFKLElBQWtCLEVBQWxCO0FBQ0Q7QUFDRjs7QUFFRCxPQUFLLEdBQUwsR0FBYyxDQUFkLEM7QUFDQSxPQUFLLEdBQUwsR0FBYyxFQUFkLEM7QUFDQSxPQUFLLEtBQUwsR0FBYyxLQUFkLEM7QUFDQSxPQUFLLE1BQUwsR0FBYyxFQUFkLEM7O0FBRUEsT0FBSyxJQUFMLEdBQWMsSUFBSSxPQUFKLEVBQWQ7QUFDQSxPQUFLLElBQUwsQ0FBVSxTQUFWLEdBQXNCLENBQXRCOztBQUVBLE1BQUksU0FBVSxhQUFhLFlBQWIsQ0FDWixLQUFLLElBRE8sRUFFWixJQUFJLFVBRlEsQ0FBZDs7QUFLQSxNQUFJLFdBQVcsRUFBRSxJQUFqQixFQUF1QjtBQUNyQixVQUFNLElBQUksS0FBSixDQUFVLElBQUksTUFBSixDQUFWLENBQU47QUFDRDs7QUFFRCxPQUFLLE1BQUwsR0FBYyxJQUFJLFFBQUosRUFBZDs7QUFFQSxlQUFhLGdCQUFiLENBQThCLEtBQUssSUFBbkMsRUFBeUMsS0FBSyxNQUE5QztBQUNEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUE4QkQsUUFBUSxTQUFSLENBQWtCLElBQWxCLEdBQXlCLFVBQVUsSUFBVixFQUFnQixJQUFoQixFQUFzQjtBQUM3QyxNQUFJLE9BQU8sS0FBSyxJQUFoQjtBQUNBLE1BQUksWUFBWSxLQUFLLE9BQUwsQ0FBYSxTQUE3QjtBQUNBLE1BQUksYUFBYSxLQUFLLE9BQUwsQ0FBYSxVQUE5QjtBQUNBLE1BQUksTUFBSixFQUFZLEtBQVo7QUFDQSxNQUFJLGFBQUosRUFBbUIsSUFBbkIsRUFBeUIsT0FBekI7QUFDQSxNQUFJLElBQUo7Ozs7QUFJQSxNQUFJLGdCQUFnQixLQUFwQjs7QUFFQSxNQUFJLEtBQUssS0FBVCxFQUFnQjtBQUFFLFdBQU8sS0FBUDtBQUFlO0FBQ2pDLFVBQVMsU0FBUyxDQUFDLENBQUMsSUFBWixHQUFvQixJQUFwQixHQUE2QixTQUFTLElBQVYsR0FBa0IsRUFBRSxRQUFwQixHQUErQixFQUFFLFVBQXJFOzs7QUFHQSxNQUFJLE9BQU8sSUFBUCxLQUFnQixRQUFwQixFQUE4Qjs7QUFFNUIsU0FBSyxLQUFMLEdBQWEsUUFBUSxhQUFSLENBQXNCLElBQXRCLENBQWI7QUFDRCxHQUhELE1BR08sSUFBSSxTQUFTLElBQVQsQ0FBYyxJQUFkLE1BQXdCLHNCQUE1QixFQUFvRDtBQUN6RCxTQUFLLEtBQUwsR0FBYSxJQUFJLFVBQUosQ0FBZSxJQUFmLENBQWI7QUFDRCxHQUZNLE1BRUE7QUFDTCxTQUFLLEtBQUwsR0FBYSxJQUFiO0FBQ0Q7O0FBRUQsT0FBSyxPQUFMLEdBQWUsQ0FBZjtBQUNBLE9BQUssUUFBTCxHQUFnQixLQUFLLEtBQUwsQ0FBVyxNQUEzQjs7QUFFQSxLQUFHO0FBQ0QsUUFBSSxLQUFLLFNBQUwsS0FBbUIsQ0FBdkIsRUFBMEI7QUFDeEIsV0FBSyxNQUFMLEdBQWMsSUFBSSxNQUFNLElBQVYsQ0FBZSxTQUFmLENBQWQ7QUFDQSxXQUFLLFFBQUwsR0FBZ0IsQ0FBaEI7QUFDQSxXQUFLLFNBQUwsR0FBaUIsU0FBakI7QUFDRDs7QUFFRCxhQUFTLGFBQWEsT0FBYixDQUFxQixJQUFyQixFQUEyQixFQUFFLFVBQTdCLENBQVQsQzs7QUFFQSxRQUFJLFdBQVcsRUFBRSxXQUFiLElBQTRCLFVBQWhDLEVBQTRDOztBQUUxQyxVQUFJLE9BQU8sVUFBUCxLQUFzQixRQUExQixFQUFvQztBQUNsQyxlQUFPLFFBQVEsVUFBUixDQUFtQixVQUFuQixDQUFQO0FBQ0QsT0FGRCxNQUVPLElBQUksU0FBUyxJQUFULENBQWMsVUFBZCxNQUE4QixzQkFBbEMsRUFBMEQ7QUFDL0QsZUFBTyxJQUFJLFVBQUosQ0FBZSxVQUFmLENBQVA7QUFDRCxPQUZNLE1BRUE7QUFDTCxlQUFPLFVBQVA7QUFDRDs7QUFFRCxlQUFTLGFBQWEsb0JBQWIsQ0FBa0MsS0FBSyxJQUF2QyxFQUE2QyxJQUE3QyxDQUFUO0FBRUQ7O0FBRUQsUUFBSSxXQUFXLEVBQUUsV0FBYixJQUE0QixrQkFBa0IsSUFBbEQsRUFBd0Q7QUFDdEQsZUFBUyxFQUFFLElBQVg7QUFDQSxzQkFBZ0IsS0FBaEI7QUFDRDs7QUFFRCxRQUFJLFdBQVcsRUFBRSxZQUFiLElBQTZCLFdBQVcsRUFBRSxJQUE5QyxFQUFvRDtBQUNsRCxXQUFLLEtBQUwsQ0FBVyxNQUFYO0FBQ0EsV0FBSyxLQUFMLEdBQWEsSUFBYjtBQUNBLGFBQU8sS0FBUDtBQUNEOztBQUVELFFBQUksS0FBSyxRQUFULEVBQW1CO0FBQ2pCLFVBQUksS0FBSyxTQUFMLEtBQW1CLENBQW5CLElBQXdCLFdBQVcsRUFBRSxZQUFyQyxJQUFzRCxLQUFLLFFBQUwsS0FBa0IsQ0FBbEIsS0FBd0IsVUFBVSxFQUFFLFFBQVosSUFBd0IsVUFBVSxFQUFFLFlBQTVELENBQTFELEVBQXNJOztBQUVwSSxZQUFJLEtBQUssT0FBTCxDQUFhLEVBQWIsS0FBb0IsUUFBeEIsRUFBa0M7O0FBRWhDLDBCQUFnQixRQUFRLFVBQVIsQ0FBbUIsS0FBSyxNQUF4QixFQUFnQyxLQUFLLFFBQXJDLENBQWhCOztBQUVBLGlCQUFPLEtBQUssUUFBTCxHQUFnQixhQUF2QjtBQUNBLG9CQUFVLFFBQVEsVUFBUixDQUFtQixLQUFLLE1BQXhCLEVBQWdDLGFBQWhDLENBQVY7OztBQUdBLGVBQUssUUFBTCxHQUFnQixJQUFoQjtBQUNBLGVBQUssU0FBTCxHQUFpQixZQUFZLElBQTdCO0FBQ0EsY0FBSSxJQUFKLEVBQVU7QUFBRSxrQkFBTSxRQUFOLENBQWUsS0FBSyxNQUFwQixFQUE0QixLQUFLLE1BQWpDLEVBQXlDLGFBQXpDLEVBQXdELElBQXhELEVBQThELENBQTlEO0FBQW1FOztBQUUvRSxlQUFLLE1BQUwsQ0FBWSxPQUFaO0FBRUQsU0FkRCxNQWNPO0FBQ0wsZUFBSyxNQUFMLENBQVksTUFBTSxTQUFOLENBQWdCLEtBQUssTUFBckIsRUFBNkIsS0FBSyxRQUFsQyxDQUFaO0FBQ0Q7QUFDRjtBQUNGOzs7Ozs7Ozs7QUFTRCxRQUFJLEtBQUssUUFBTCxLQUFrQixDQUFsQixJQUF1QixLQUFLLFNBQUwsS0FBbUIsQ0FBOUMsRUFBaUQ7QUFDL0Msc0JBQWdCLElBQWhCO0FBQ0Q7QUFFRixHQXBFRCxRQW9FUyxDQUFDLEtBQUssUUFBTCxHQUFnQixDQUFoQixJQUFxQixLQUFLLFNBQUwsS0FBbUIsQ0FBekMsS0FBK0MsV0FBVyxFQUFFLFlBcEVyRTs7QUFzRUEsTUFBSSxXQUFXLEVBQUUsWUFBakIsRUFBK0I7QUFDN0IsWUFBUSxFQUFFLFFBQVY7QUFDRDs7O0FBR0QsTUFBSSxVQUFVLEVBQUUsUUFBaEIsRUFBMEI7QUFDeEIsYUFBUyxhQUFhLFVBQWIsQ0FBd0IsS0FBSyxJQUE3QixDQUFUO0FBQ0EsU0FBSyxLQUFMLENBQVcsTUFBWDtBQUNBLFNBQUssS0FBTCxHQUFhLElBQWI7QUFDQSxXQUFPLFdBQVcsRUFBRSxJQUFwQjtBQUNEOzs7QUFHRCxNQUFJLFVBQVUsRUFBRSxZQUFoQixFQUE4QjtBQUM1QixTQUFLLEtBQUwsQ0FBVyxFQUFFLElBQWI7QUFDQSxTQUFLLFNBQUwsR0FBaUIsQ0FBakI7QUFDQSxXQUFPLElBQVA7QUFDRDs7QUFFRCxTQUFPLElBQVA7QUFDRCxDQXRIRDs7Ozs7Ozs7Ozs7QUFrSUEsUUFBUSxTQUFSLENBQWtCLE1BQWxCLEdBQTJCLFVBQVUsS0FBVixFQUFpQjtBQUMxQyxPQUFLLE1BQUwsQ0FBWSxJQUFaLENBQWlCLEtBQWpCO0FBQ0QsQ0FGRDs7Ozs7Ozs7Ozs7O0FBZUEsUUFBUSxTQUFSLENBQWtCLEtBQWxCLEdBQTBCLFVBQVUsTUFBVixFQUFrQjs7QUFFMUMsTUFBSSxXQUFXLEVBQUUsSUFBakIsRUFBdUI7QUFDckIsUUFBSSxLQUFLLE9BQUwsQ0FBYSxFQUFiLEtBQW9CLFFBQXhCLEVBQWtDOzs7QUFHaEMsV0FBSyxNQUFMLEdBQWMsS0FBSyxNQUFMLENBQVksSUFBWixDQUFpQixFQUFqQixDQUFkO0FBQ0QsS0FKRCxNQUlPO0FBQ0wsV0FBSyxNQUFMLEdBQWMsTUFBTSxhQUFOLENBQW9CLEtBQUssTUFBekIsQ0FBZDtBQUNEO0FBQ0Y7QUFDRCxPQUFLLE1BQUwsR0FBYyxFQUFkO0FBQ0EsT0FBSyxHQUFMLEdBQVcsTUFBWDtBQUNBLE9BQUssR0FBTCxHQUFXLEtBQUssSUFBTCxDQUFVLEdBQXJCO0FBQ0QsQ0FkRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUF3REEsU0FBUyxPQUFULENBQWlCLEtBQWpCLEVBQXdCLE9BQXhCLEVBQWlDO0FBQy9CLE1BQUksV0FBVyxJQUFJLE9BQUosQ0FBWSxPQUFaLENBQWY7O0FBRUEsV0FBUyxJQUFULENBQWMsS0FBZCxFQUFxQixJQUFyQjs7O0FBR0EsTUFBSSxTQUFTLEdBQWIsRUFBa0I7QUFBRSxVQUFNLFNBQVMsR0FBZjtBQUFxQjs7QUFFekMsU0FBTyxTQUFTLE1BQWhCO0FBQ0Q7Ozs7Ozs7Ozs7QUFXRCxTQUFTLFVBQVQsQ0FBb0IsS0FBcEIsRUFBMkIsT0FBM0IsRUFBb0M7QUFDbEMsWUFBVSxXQUFXLEVBQXJCO0FBQ0EsVUFBUSxHQUFSLEdBQWMsSUFBZDtBQUNBLFNBQU8sUUFBUSxLQUFSLEVBQWUsT0FBZixDQUFQO0FBQ0Q7Ozs7Ozs7Ozs7O0FBYUQsUUFBUSxPQUFSLEdBQWtCLE9BQWxCO0FBQ0EsUUFBUSxPQUFSLEdBQWtCLE9BQWxCO0FBQ0EsUUFBUSxVQUFSLEdBQXFCLFVBQXJCO0FBQ0EsUUFBUSxNQUFSLEdBQWtCLE9BQWxCOzs7QUNqYUE7O0FBR0EsSUFBSSxXQUFhLE9BQU8sVUFBUCxLQUFzQixXQUF2QixJQUNDLE9BQU8sV0FBUCxLQUF1QixXQUR4QixJQUVDLE9BQU8sVUFBUCxLQUFzQixXQUZ2Qzs7QUFLQSxRQUFRLE1BQVIsR0FBaUIsVUFBVSxHLDZCQUFWLEVBQTRDO0FBQzNELE1BQUksVUFBVSxNQUFNLFNBQU4sQ0FBZ0IsS0FBaEIsQ0FBc0IsSUFBdEIsQ0FBMkIsU0FBM0IsRUFBc0MsQ0FBdEMsQ0FBZDtBQUNBLFNBQU8sUUFBUSxNQUFmLEVBQXVCO0FBQ3JCLFFBQUksU0FBUyxRQUFRLEtBQVIsRUFBYjtBQUNBLFFBQUksQ0FBQyxNQUFMLEVBQWE7QUFBRTtBQUFXOztBQUUxQixRQUFJLE9BQU8sTUFBUCxLQUFrQixRQUF0QixFQUFnQztBQUM5QixZQUFNLElBQUksU0FBSixDQUFjLFNBQVMsb0JBQXZCLENBQU47QUFDRDs7QUFFRCxTQUFLLElBQUksQ0FBVCxJQUFjLE1BQWQsRUFBc0I7QUFDcEIsVUFBSSxPQUFPLGNBQVAsQ0FBc0IsQ0FBdEIsQ0FBSixFQUE4QjtBQUM1QixZQUFJLENBQUosSUFBUyxPQUFPLENBQVAsQ0FBVDtBQUNEO0FBQ0Y7QUFDRjs7QUFFRCxTQUFPLEdBQVA7QUFDRCxDQWxCRDs7O0FBc0JBLFFBQVEsU0FBUixHQUFvQixVQUFVLEdBQVYsRUFBZSxJQUFmLEVBQXFCO0FBQ3ZDLE1BQUksSUFBSSxNQUFKLEtBQWUsSUFBbkIsRUFBeUI7QUFBRSxXQUFPLEdBQVA7QUFBYTtBQUN4QyxNQUFJLElBQUksUUFBUixFQUFrQjtBQUFFLFdBQU8sSUFBSSxRQUFKLENBQWEsQ0FBYixFQUFnQixJQUFoQixDQUFQO0FBQStCO0FBQ25ELE1BQUksTUFBSixHQUFhLElBQWI7QUFDQSxTQUFPLEdBQVA7QUFDRCxDQUxEOztBQVFBLElBQUksVUFBVTtBQUNaLFlBQVUsa0JBQVUsSUFBVixFQUFnQixHQUFoQixFQUFxQixRQUFyQixFQUErQixHQUEvQixFQUFvQyxTQUFwQyxFQUErQztBQUN2RCxRQUFJLElBQUksUUFBSixJQUFnQixLQUFLLFFBQXpCLEVBQW1DO0FBQ2pDLFdBQUssR0FBTCxDQUFTLElBQUksUUFBSixDQUFhLFFBQWIsRUFBdUIsV0FBVyxHQUFsQyxDQUFULEVBQWlELFNBQWpEO0FBQ0E7QUFDRDs7QUFFRCxTQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksR0FBcEIsRUFBeUIsR0FBekIsRUFBOEI7QUFDNUIsV0FBSyxZQUFZLENBQWpCLElBQXNCLElBQUksV0FBVyxDQUFmLENBQXRCO0FBQ0Q7QUFDRixHQVZXOztBQVlaLGlCQUFlLHVCQUFVLE1BQVYsRUFBa0I7QUFDL0IsUUFBSSxDQUFKLEVBQU8sQ0FBUCxFQUFVLEdBQVYsRUFBZSxHQUFmLEVBQW9CLEtBQXBCLEVBQTJCLE1BQTNCOzs7QUFHQSxVQUFNLENBQU47QUFDQSxTQUFLLElBQUksQ0FBSixFQUFPLElBQUksT0FBTyxNQUF2QixFQUErQixJQUFJLENBQW5DLEVBQXNDLEdBQXRDLEVBQTJDO0FBQ3pDLGFBQU8sT0FBTyxDQUFQLEVBQVUsTUFBakI7QUFDRDs7O0FBR0QsYUFBUyxJQUFJLFVBQUosQ0FBZSxHQUFmLENBQVQ7QUFDQSxVQUFNLENBQU47QUFDQSxTQUFLLElBQUksQ0FBSixFQUFPLElBQUksT0FBTyxNQUF2QixFQUErQixJQUFJLENBQW5DLEVBQXNDLEdBQXRDLEVBQTJDO0FBQ3pDLGNBQVEsT0FBTyxDQUFQLENBQVI7QUFDQSxhQUFPLEdBQVAsQ0FBVyxLQUFYLEVBQWtCLEdBQWxCO0FBQ0EsYUFBTyxNQUFNLE1BQWI7QUFDRDs7QUFFRCxXQUFPLE1BQVA7QUFDRDtBQS9CVyxDQUFkOztBQWtDQSxJQUFJLFlBQVk7QUFDZCxZQUFVLGtCQUFVLElBQVYsRUFBZ0IsR0FBaEIsRUFBcUIsUUFBckIsRUFBK0IsR0FBL0IsRUFBb0MsU0FBcEMsRUFBK0M7QUFDdkQsU0FBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLEdBQXBCLEVBQXlCLEdBQXpCLEVBQThCO0FBQzVCLFdBQUssWUFBWSxDQUFqQixJQUFzQixJQUFJLFdBQVcsQ0FBZixDQUF0QjtBQUNEO0FBQ0YsR0FMYTs7QUFPZCxpQkFBZSx1QkFBVSxNQUFWLEVBQWtCO0FBQy9CLFdBQU8sR0FBRyxNQUFILENBQVUsS0FBVixDQUFnQixFQUFoQixFQUFvQixNQUFwQixDQUFQO0FBQ0Q7QUFUYSxDQUFoQjs7OztBQWVBLFFBQVEsUUFBUixHQUFtQixVQUFVLEVBQVYsRUFBYztBQUMvQixNQUFJLEVBQUosRUFBUTtBQUNOLFlBQVEsSUFBUixHQUFnQixVQUFoQjtBQUNBLFlBQVEsS0FBUixHQUFnQixXQUFoQjtBQUNBLFlBQVEsS0FBUixHQUFnQixVQUFoQjtBQUNBLFlBQVEsTUFBUixDQUFlLE9BQWYsRUFBd0IsT0FBeEI7QUFDRCxHQUxELE1BS087QUFDTCxZQUFRLElBQVIsR0FBZ0IsS0FBaEI7QUFDQSxZQUFRLEtBQVIsR0FBZ0IsS0FBaEI7QUFDQSxZQUFRLEtBQVIsR0FBZ0IsS0FBaEI7QUFDQSxZQUFRLE1BQVIsQ0FBZSxPQUFmLEVBQXdCLFNBQXhCO0FBQ0Q7QUFDRixDQVpEOztBQWNBLFFBQVEsUUFBUixDQUFpQixRQUFqQjs7OztBQ3BHQTs7QUFHQSxJQUFJLFFBQVEsUUFBUSxVQUFSLENBQVo7Ozs7Ozs7QUFRQSxJQUFJLGVBQWUsSUFBbkI7QUFDQSxJQUFJLG1CQUFtQixJQUF2Qjs7QUFFQSxJQUFJO0FBQUUsU0FBTyxZQUFQLENBQW9CLEtBQXBCLENBQTBCLElBQTFCLEVBQWdDLENBQUUsQ0FBRixDQUFoQztBQUF5QyxDQUEvQyxDQUFnRCxPQUFPLEVBQVAsRUFBVztBQUFFLGlCQUFlLEtBQWY7QUFBdUI7QUFDcEYsSUFBSTtBQUFFLFNBQU8sWUFBUCxDQUFvQixLQUFwQixDQUEwQixJQUExQixFQUFnQyxJQUFJLFVBQUosQ0FBZSxDQUFmLENBQWhDO0FBQXFELENBQTNELENBQTRELE9BQU8sRUFBUCxFQUFXO0FBQUUscUJBQW1CLEtBQW5CO0FBQTJCOzs7OztBQU1wRyxJQUFJLFdBQVcsSUFBSSxNQUFNLElBQVYsQ0FBZSxHQUFmLENBQWY7QUFDQSxLQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksR0FBcEIsRUFBeUIsR0FBekIsRUFBOEI7QUFDNUIsV0FBUyxDQUFULElBQWUsS0FBSyxHQUFMLEdBQVcsQ0FBWCxHQUFlLEtBQUssR0FBTCxHQUFXLENBQVgsR0FBZSxLQUFLLEdBQUwsR0FBVyxDQUFYLEdBQWUsS0FBSyxHQUFMLEdBQVcsQ0FBWCxHQUFlLEtBQUssR0FBTCxHQUFXLENBQVgsR0FBZSxDQUExRjtBQUNEO0FBQ0QsU0FBUyxHQUFULElBQWdCLFNBQVMsR0FBVCxJQUFnQixDQUFoQyxDOzs7QUFJQSxRQUFRLFVBQVIsR0FBcUIsVUFBVSxHQUFWLEVBQWU7QUFDbEMsTUFBSSxHQUFKO0FBQUEsTUFBUyxDQUFUO0FBQUEsTUFBWSxFQUFaO0FBQUEsTUFBZ0IsS0FBaEI7QUFBQSxNQUF1QixDQUF2QjtBQUFBLE1BQTBCLFVBQVUsSUFBSSxNQUF4QztBQUFBLE1BQWdELFVBQVUsQ0FBMUQ7OztBQUdBLE9BQUssUUFBUSxDQUFiLEVBQWdCLFFBQVEsT0FBeEIsRUFBaUMsT0FBakMsRUFBMEM7QUFDeEMsUUFBSSxJQUFJLFVBQUosQ0FBZSxLQUFmLENBQUo7QUFDQSxRQUFJLENBQUMsSUFBSSxNQUFMLE1BQWlCLE1BQWpCLElBQTRCLFFBQVEsQ0FBUixHQUFZLE9BQTVDLEVBQXNEO0FBQ3BELFdBQUssSUFBSSxVQUFKLENBQWUsUUFBUSxDQUF2QixDQUFMO0FBQ0EsVUFBSSxDQUFDLEtBQUssTUFBTixNQUFrQixNQUF0QixFQUE4QjtBQUM1QixZQUFJLFdBQVksSUFBSSxNQUFMLElBQWdCLEVBQTNCLEtBQWtDLEtBQUssTUFBdkMsQ0FBSjtBQUNBO0FBQ0Q7QUFDRjtBQUNELGVBQVcsSUFBSSxJQUFKLEdBQVcsQ0FBWCxHQUFlLElBQUksS0FBSixHQUFZLENBQVosR0FBZ0IsSUFBSSxPQUFKLEdBQWMsQ0FBZCxHQUFrQixDQUE1RDtBQUNEOzs7QUFHRCxRQUFNLElBQUksTUFBTSxJQUFWLENBQWUsT0FBZixDQUFOOzs7QUFHQSxPQUFLLElBQUksQ0FBSixFQUFPLFFBQVEsQ0FBcEIsRUFBdUIsSUFBSSxPQUEzQixFQUFvQyxPQUFwQyxFQUE2QztBQUMzQyxRQUFJLElBQUksVUFBSixDQUFlLEtBQWYsQ0FBSjtBQUNBLFFBQUksQ0FBQyxJQUFJLE1BQUwsTUFBaUIsTUFBakIsSUFBNEIsUUFBUSxDQUFSLEdBQVksT0FBNUMsRUFBc0Q7QUFDcEQsV0FBSyxJQUFJLFVBQUosQ0FBZSxRQUFRLENBQXZCLENBQUw7QUFDQSxVQUFJLENBQUMsS0FBSyxNQUFOLE1BQWtCLE1BQXRCLEVBQThCO0FBQzVCLFlBQUksV0FBWSxJQUFJLE1BQUwsSUFBZ0IsRUFBM0IsS0FBa0MsS0FBSyxNQUF2QyxDQUFKO0FBQ0E7QUFDRDtBQUNGO0FBQ0QsUUFBSSxJQUFJLElBQVIsRUFBYzs7QUFFWixVQUFJLEdBQUosSUFBVyxDQUFYO0FBQ0QsS0FIRCxNQUdPLElBQUksSUFBSSxLQUFSLEVBQWU7O0FBRXBCLFVBQUksR0FBSixJQUFXLE9BQVEsTUFBTSxDQUF6QjtBQUNBLFVBQUksR0FBSixJQUFXLE9BQVEsSUFBSSxJQUF2QjtBQUNELEtBSk0sTUFJQSxJQUFJLElBQUksT0FBUixFQUFpQjs7QUFFdEIsVUFBSSxHQUFKLElBQVcsT0FBUSxNQUFNLEVBQXpCO0FBQ0EsVUFBSSxHQUFKLElBQVcsT0FBUSxNQUFNLENBQU4sR0FBVSxJQUE3QjtBQUNBLFVBQUksR0FBSixJQUFXLE9BQVEsSUFBSSxJQUF2QjtBQUNELEtBTE0sTUFLQTs7QUFFTCxVQUFJLEdBQUosSUFBVyxPQUFRLE1BQU0sRUFBekI7QUFDQSxVQUFJLEdBQUosSUFBVyxPQUFRLE1BQU0sRUFBTixHQUFXLElBQTlCO0FBQ0EsVUFBSSxHQUFKLElBQVcsT0FBUSxNQUFNLENBQU4sR0FBVSxJQUE3QjtBQUNBLFVBQUksR0FBSixJQUFXLE9BQVEsSUFBSSxJQUF2QjtBQUNEO0FBQ0Y7O0FBRUQsU0FBTyxHQUFQO0FBQ0QsQ0FuREQ7OztBQXNEQSxTQUFTLGFBQVQsQ0FBdUIsR0FBdkIsRUFBNEIsR0FBNUIsRUFBaUM7O0FBRS9CLE1BQUksTUFBTSxLQUFWLEVBQWlCO0FBQ2YsUUFBSyxJQUFJLFFBQUosSUFBZ0IsZ0JBQWpCLElBQXVDLENBQUMsSUFBSSxRQUFMLElBQWlCLFlBQTVELEVBQTJFO0FBQ3pFLGFBQU8sT0FBTyxZQUFQLENBQW9CLEtBQXBCLENBQTBCLElBQTFCLEVBQWdDLE1BQU0sU0FBTixDQUFnQixHQUFoQixFQUFxQixHQUFyQixDQUFoQyxDQUFQO0FBQ0Q7QUFDRjs7QUFFRCxNQUFJLFNBQVMsRUFBYjtBQUNBLE9BQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxHQUFwQixFQUF5QixHQUF6QixFQUE4QjtBQUM1QixjQUFVLE9BQU8sWUFBUCxDQUFvQixJQUFJLENBQUosQ0FBcEIsQ0FBVjtBQUNEO0FBQ0QsU0FBTyxNQUFQO0FBQ0Q7OztBQUlELFFBQVEsYUFBUixHQUF3QixVQUFVLEdBQVYsRUFBZTtBQUNyQyxTQUFPLGNBQWMsR0FBZCxFQUFtQixJQUFJLE1BQXZCLENBQVA7QUFDRCxDQUZEOzs7QUFNQSxRQUFRLGFBQVIsR0FBd0IsVUFBVSxHQUFWLEVBQWU7QUFDckMsTUFBSSxNQUFNLElBQUksTUFBTSxJQUFWLENBQWUsSUFBSSxNQUFuQixDQUFWO0FBQ0EsT0FBSyxJQUFJLElBQUksQ0FBUixFQUFXLE1BQU0sSUFBSSxNQUExQixFQUFrQyxJQUFJLEdBQXRDLEVBQTJDLEdBQTNDLEVBQWdEO0FBQzlDLFFBQUksQ0FBSixJQUFTLElBQUksVUFBSixDQUFlLENBQWYsQ0FBVDtBQUNEO0FBQ0QsU0FBTyxHQUFQO0FBQ0QsQ0FORDs7O0FBVUEsUUFBUSxVQUFSLEdBQXFCLFVBQVUsR0FBVixFQUFlLEdBQWYsRUFBb0I7QUFDdkMsTUFBSSxDQUFKLEVBQU8sR0FBUCxFQUFZLENBQVosRUFBZSxLQUFmO0FBQ0EsTUFBSSxNQUFNLE9BQU8sSUFBSSxNQUFyQjs7Ozs7QUFLQSxNQUFJLFdBQVcsSUFBSSxLQUFKLENBQVUsTUFBTSxDQUFoQixDQUFmOztBQUVBLE9BQUssTUFBTSxDQUFOLEVBQVMsSUFBSSxDQUFsQixFQUFxQixJQUFJLEdBQXpCLEdBQStCO0FBQzdCLFFBQUksSUFBSSxHQUFKLENBQUo7O0FBRUEsUUFBSSxJQUFJLElBQVIsRUFBYztBQUFFLGVBQVMsS0FBVCxJQUFrQixDQUFsQixDQUFxQjtBQUFXOztBQUVoRCxZQUFRLFNBQVMsQ0FBVCxDQUFSOztBQUVBLFFBQUksUUFBUSxDQUFaLEVBQWU7QUFBRSxlQUFTLEtBQVQsSUFBa0IsTUFBbEIsQ0FBMEIsS0FBSyxRQUFRLENBQWIsQ0FBZ0I7QUFBVzs7O0FBR3RFLFNBQUssVUFBVSxDQUFWLEdBQWMsSUFBZCxHQUFxQixVQUFVLENBQVYsR0FBYyxJQUFkLEdBQXFCLElBQS9DOztBQUVBLFdBQU8sUUFBUSxDQUFSLElBQWEsSUFBSSxHQUF4QixFQUE2QjtBQUMzQixVQUFLLEtBQUssQ0FBTixHQUFZLElBQUksR0FBSixJQUFXLElBQTNCO0FBQ0E7QUFDRDs7O0FBR0QsUUFBSSxRQUFRLENBQVosRUFBZTtBQUFFLGVBQVMsS0FBVCxJQUFrQixNQUFsQixDQUEwQjtBQUFXOztBQUV0RCxRQUFJLElBQUksT0FBUixFQUFpQjtBQUNmLGVBQVMsS0FBVCxJQUFrQixDQUFsQjtBQUNELEtBRkQsTUFFTztBQUNMLFdBQUssT0FBTDtBQUNBLGVBQVMsS0FBVCxJQUFrQixTQUFXLEtBQUssRUFBTixHQUFZLEtBQXhDO0FBQ0EsZUFBUyxLQUFULElBQWtCLFNBQVUsSUFBSSxLQUFoQztBQUNEO0FBQ0Y7O0FBRUQsU0FBTyxjQUFjLFFBQWQsRUFBd0IsR0FBeEIsQ0FBUDtBQUNELENBdkNEOzs7Ozs7OztBQWdEQSxRQUFRLFVBQVIsR0FBcUIsVUFBVSxHQUFWLEVBQWUsR0FBZixFQUFvQjtBQUN2QyxNQUFJLEdBQUo7O0FBRUEsUUFBTSxPQUFPLElBQUksTUFBakI7QUFDQSxNQUFJLE1BQU0sSUFBSSxNQUFkLEVBQXNCO0FBQUUsVUFBTSxJQUFJLE1BQVY7QUFBbUI7OztBQUczQyxRQUFNLE1BQU0sQ0FBWjtBQUNBLFNBQU8sT0FBTyxDQUFQLElBQVksQ0FBQyxJQUFJLEdBQUosSUFBVyxJQUFaLE1BQXNCLElBQXpDLEVBQStDO0FBQUU7QUFBUTs7OztBQUl6RCxNQUFJLE1BQU0sQ0FBVixFQUFhO0FBQUUsV0FBTyxHQUFQO0FBQWE7Ozs7QUFJNUIsTUFBSSxRQUFRLENBQVosRUFBZTtBQUFFLFdBQU8sR0FBUDtBQUFhOztBQUU5QixTQUFRLE1BQU0sU0FBUyxJQUFJLEdBQUosQ0FBVCxDQUFOLEdBQTJCLEdBQTVCLEdBQW1DLEdBQW5DLEdBQXlDLEdBQWhEO0FBQ0QsQ0FuQkQ7OztBQ3JLQTs7Ozs7O0FBTUEsU0FBUyxPQUFULENBQWlCLEtBQWpCLEVBQXdCLEdBQXhCLEVBQTZCLEdBQTdCLEVBQWtDLEdBQWxDLEVBQXVDO0FBQ3JDLE1BQUksS0FBTSxRQUFRLE1BQVQsR0FBa0IsQ0FBM0I7QUFBQSxNQUNJLEtBQU8sVUFBVSxFQUFYLEdBQWlCLE1BQWxCLEdBQTJCLENBRHBDO0FBQUEsTUFFSSxJQUFJLENBRlI7O0FBSUEsU0FBTyxRQUFRLENBQWYsRUFBa0I7Ozs7QUFJaEIsUUFBSSxNQUFNLElBQU4sR0FBYSxJQUFiLEdBQW9CLEdBQXhCO0FBQ0EsV0FBTyxDQUFQOztBQUVBLE9BQUc7QUFDRCxXQUFNLEtBQUssSUFBSSxLQUFKLENBQU4sR0FBbUIsQ0FBeEI7QUFDQSxXQUFNLEtBQUssRUFBTixHQUFXLENBQWhCO0FBQ0QsS0FIRCxRQUdTLEVBQUUsQ0FIWDs7QUFLQSxVQUFNLEtBQU47QUFDQSxVQUFNLEtBQU47QUFDRDs7QUFFRCxTQUFRLEtBQU0sTUFBTSxFQUFiLEdBQW1CLENBQTFCO0FBQ0Q7O0FBR0QsT0FBTyxPQUFQLEdBQWlCLE9BQWpCOzs7QUMvQkE7O0FBR0EsT0FBTyxPQUFQLEdBQWlCOzs7QUFHZixjQUFvQixDQUhMO0FBSWYsbUJBQW9CLENBSkw7QUFLZixnQkFBb0IsQ0FMTDtBQU1mLGdCQUFvQixDQU5MO0FBT2YsWUFBb0IsQ0FQTDtBQVFmLFdBQW9CLENBUkw7QUFTZixXQUFvQixDQVRMOzs7OztBQWNmLFFBQW9CLENBZEw7QUFlZixnQkFBb0IsQ0FmTDtBQWdCZixlQUFvQixDQWhCTDtBQWlCZixXQUFtQixDQUFDLENBakJMO0FBa0JmLGtCQUFtQixDQUFDLENBbEJMO0FBbUJmLGdCQUFtQixDQUFDLENBbkJMOztBQXFCZixlQUFtQixDQUFDLENBckJMOzs7O0FBeUJmLG9CQUEwQixDQXpCWDtBQTBCZixnQkFBMEIsQ0ExQlg7QUEyQmYsc0JBQTBCLENBM0JYO0FBNEJmLHlCQUF5QixDQUFDLENBNUJYOztBQStCZixjQUEwQixDQS9CWDtBQWdDZixrQkFBMEIsQ0FoQ1g7QUFpQ2YsU0FBMEIsQ0FqQ1g7QUFrQ2YsV0FBMEIsQ0FsQ1g7QUFtQ2Ysc0JBQTBCLENBbkNYOzs7QUFzQ2YsWUFBMEIsQ0F0Q1g7QUF1Q2YsVUFBMEIsQ0F2Q1g7O0FBeUNmLGFBQTBCLENBekNYOzs7QUE0Q2YsY0FBMEI7O0FBNUNYLENBQWpCOzs7QUNIQTs7Ozs7Ozs7QUFRQSxTQUFTLFNBQVQsR0FBcUI7QUFDbkIsTUFBSSxDQUFKO0FBQUEsTUFBTyxRQUFRLEVBQWY7O0FBRUEsT0FBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLEdBQXBCLEVBQXlCLEdBQXpCLEVBQThCO0FBQzVCLFFBQUksQ0FBSjtBQUNBLFNBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxDQUFwQixFQUF1QixHQUF2QixFQUE0QjtBQUMxQixVQUFNLElBQUksQ0FBTCxHQUFXLGFBQWMsTUFBTSxDQUEvQixHQUFzQyxNQUFNLENBQWpEO0FBQ0Q7QUFDRCxVQUFNLENBQU4sSUFBVyxDQUFYO0FBQ0Q7O0FBRUQsU0FBTyxLQUFQO0FBQ0Q7OztBQUdELElBQUksV0FBVyxXQUFmOztBQUdBLFNBQVMsS0FBVCxDQUFlLEdBQWYsRUFBb0IsR0FBcEIsRUFBeUIsR0FBekIsRUFBOEIsR0FBOUIsRUFBbUM7QUFDakMsTUFBSSxJQUFJLFFBQVI7QUFBQSxNQUNJLE1BQU0sTUFBTSxHQURoQjs7QUFHQSxTQUFPLENBQUMsQ0FBUjs7QUFFQSxPQUFLLElBQUksSUFBSSxHQUFiLEVBQWtCLElBQUksR0FBdEIsRUFBMkIsR0FBM0IsRUFBZ0M7QUFDOUIsVUFBTyxRQUFRLENBQVQsR0FBYyxFQUFFLENBQUMsTUFBTSxJQUFJLENBQUosQ0FBUCxJQUFpQixJQUFuQixDQUFwQjtBQUNEOztBQUVELFNBQVEsTUFBTyxDQUFDLENBQWhCLEM7QUFDRDs7QUFHRCxPQUFPLE9BQVAsR0FBaUIsS0FBakI7OztBQ3hDQTs7QUFFQSxJQUFJLFFBQVUsUUFBUSxpQkFBUixDQUFkO0FBQ0EsSUFBSSxRQUFVLFFBQVEsU0FBUixDQUFkO0FBQ0EsSUFBSSxVQUFVLFFBQVEsV0FBUixDQUFkO0FBQ0EsSUFBSSxRQUFVLFFBQVEsU0FBUixDQUFkO0FBQ0EsSUFBSSxNQUFVLFFBQVEsWUFBUixDQUFkOzs7Ozs7QUFPQSxJQUFJLGFBQWtCLENBQXRCO0FBQ0EsSUFBSSxrQkFBa0IsQ0FBdEI7O0FBRUEsSUFBSSxlQUFrQixDQUF0QjtBQUNBLElBQUksV0FBa0IsQ0FBdEI7QUFDQSxJQUFJLFVBQWtCLENBQXRCOzs7Ozs7QUFPQSxJQUFJLE9BQWtCLENBQXRCO0FBQ0EsSUFBSSxlQUFrQixDQUF0Qjs7O0FBR0EsSUFBSSxpQkFBa0IsQ0FBQyxDQUF2QjtBQUNBLElBQUksZUFBa0IsQ0FBQyxDQUF2Qjs7QUFFQSxJQUFJLGNBQWtCLENBQUMsQ0FBdkI7Ozs7Ozs7QUFRQSxJQUFJLHdCQUF3QixDQUFDLENBQTdCOztBQUdBLElBQUksYUFBd0IsQ0FBNUI7QUFDQSxJQUFJLGlCQUF3QixDQUE1QjtBQUNBLElBQUksUUFBd0IsQ0FBNUI7QUFDQSxJQUFJLFVBQXdCLENBQTVCO0FBQ0EsSUFBSSxxQkFBd0IsQ0FBNUI7Ozs7OztBQU1BLElBQUksWUFBd0IsQ0FBNUI7OztBQUlBLElBQUksYUFBYyxDQUFsQjs7OztBQUtBLElBQUksZ0JBQWdCLENBQXBCOztBQUVBLElBQUksWUFBWSxFQUFoQjs7QUFFQSxJQUFJLGdCQUFnQixDQUFwQjs7QUFHQSxJQUFJLGVBQWdCLEVBQXBCOztBQUVBLElBQUksV0FBZ0IsR0FBcEI7O0FBRUEsSUFBSSxVQUFnQixXQUFXLENBQVgsR0FBZSxZQUFuQzs7QUFFQSxJQUFJLFVBQWdCLEVBQXBCOztBQUVBLElBQUksV0FBZ0IsRUFBcEI7O0FBRUEsSUFBSSxZQUFnQixJQUFJLE9BQUosR0FBYyxDQUFsQzs7QUFFQSxJQUFJLFdBQVksRUFBaEI7OztBQUdBLElBQUksWUFBWSxDQUFoQjtBQUNBLElBQUksWUFBWSxHQUFoQjtBQUNBLElBQUksZ0JBQWlCLFlBQVksU0FBWixHQUF3QixDQUE3Qzs7QUFFQSxJQUFJLGNBQWMsSUFBbEI7O0FBRUEsSUFBSSxhQUFhLEVBQWpCO0FBQ0EsSUFBSSxjQUFjLEVBQWxCO0FBQ0EsSUFBSSxhQUFhLEVBQWpCO0FBQ0EsSUFBSSxnQkFBZ0IsRUFBcEI7QUFDQSxJQUFJLGFBQWEsR0FBakI7QUFDQSxJQUFJLGFBQWEsR0FBakI7QUFDQSxJQUFJLGVBQWUsR0FBbkI7O0FBRUEsSUFBSSxlQUFvQixDQUF4QixDO0FBQ0EsSUFBSSxnQkFBb0IsQ0FBeEIsQztBQUNBLElBQUksb0JBQW9CLENBQXhCLEM7QUFDQSxJQUFJLGlCQUFvQixDQUF4QixDOztBQUVBLElBQUksVUFBVSxJQUFkLEM7O0FBRUEsU0FBUyxHQUFULENBQWEsSUFBYixFQUFtQixTQUFuQixFQUE4QjtBQUM1QixPQUFLLEdBQUwsR0FBVyxJQUFJLFNBQUosQ0FBWDtBQUNBLFNBQU8sU0FBUDtBQUNEOztBQUVELFNBQVMsSUFBVCxDQUFjLENBQWQsRUFBaUI7QUFDZixTQUFPLENBQUUsQ0FBRCxJQUFPLENBQVIsS0FBZSxDQUFELEdBQU0sQ0FBTixHQUFVLENBQVYsR0FBYyxDQUE1QixDQUFQO0FBQ0Q7O0FBRUQsU0FBUyxJQUFULENBQWMsR0FBZCxFQUFtQjtBQUFFLE1BQUksTUFBTSxJQUFJLE1BQWQsQ0FBc0IsT0FBTyxFQUFFLEdBQUYsSUFBUyxDQUFoQixFQUFtQjtBQUFFLFFBQUksR0FBSixJQUFXLENBQVg7QUFBZTtBQUFFOzs7Ozs7OztBQVNqRixTQUFTLGFBQVQsQ0FBdUIsSUFBdkIsRUFBNkI7QUFDM0IsTUFBSSxJQUFJLEtBQUssS0FBYjs7O0FBR0EsTUFBSSxNQUFNLEVBQUUsT0FBWjtBQUNBLE1BQUksTUFBTSxLQUFLLFNBQWYsRUFBMEI7QUFDeEIsVUFBTSxLQUFLLFNBQVg7QUFDRDtBQUNELE1BQUksUUFBUSxDQUFaLEVBQWU7QUFBRTtBQUFTOztBQUUxQixRQUFNLFFBQU4sQ0FBZSxLQUFLLE1BQXBCLEVBQTRCLEVBQUUsV0FBOUIsRUFBMkMsRUFBRSxXQUE3QyxFQUEwRCxHQUExRCxFQUErRCxLQUFLLFFBQXBFO0FBQ0EsT0FBSyxRQUFMLElBQWlCLEdBQWpCO0FBQ0EsSUFBRSxXQUFGLElBQWlCLEdBQWpCO0FBQ0EsT0FBSyxTQUFMLElBQWtCLEdBQWxCO0FBQ0EsT0FBSyxTQUFMLElBQWtCLEdBQWxCO0FBQ0EsSUFBRSxPQUFGLElBQWEsR0FBYjtBQUNBLE1BQUksRUFBRSxPQUFGLEtBQWMsQ0FBbEIsRUFBcUI7QUFDbkIsTUFBRSxXQUFGLEdBQWdCLENBQWhCO0FBQ0Q7QUFDRjs7QUFHRCxTQUFTLGdCQUFULENBQTBCLENBQTFCLEVBQTZCLElBQTdCLEVBQW1DO0FBQ2pDLFFBQU0sZUFBTixDQUFzQixDQUF0QixFQUEwQixFQUFFLFdBQUYsSUFBaUIsQ0FBakIsR0FBcUIsRUFBRSxXQUF2QixHQUFxQyxDQUFDLENBQWhFLEVBQW9FLEVBQUUsUUFBRixHQUFhLEVBQUUsV0FBbkYsRUFBZ0csSUFBaEc7QUFDQSxJQUFFLFdBQUYsR0FBZ0IsRUFBRSxRQUFsQjtBQUNBLGdCQUFjLEVBQUUsSUFBaEI7QUFDRDs7QUFHRCxTQUFTLFFBQVQsQ0FBa0IsQ0FBbEIsRUFBcUIsQ0FBckIsRUFBd0I7QUFDdEIsSUFBRSxXQUFGLENBQWMsRUFBRSxPQUFGLEVBQWQsSUFBNkIsQ0FBN0I7QUFDRDs7Ozs7OztBQVFELFNBQVMsV0FBVCxDQUFxQixDQUFyQixFQUF3QixDQUF4QixFQUEyQjs7O0FBR3pCLElBQUUsV0FBRixDQUFjLEVBQUUsT0FBRixFQUFkLElBQThCLE1BQU0sQ0FBUCxHQUFZLElBQXpDO0FBQ0EsSUFBRSxXQUFGLENBQWMsRUFBRSxPQUFGLEVBQWQsSUFBNkIsSUFBSSxJQUFqQztBQUNEOzs7Ozs7Ozs7QUFVRCxTQUFTLFFBQVQsQ0FBa0IsSUFBbEIsRUFBd0IsR0FBeEIsRUFBNkIsS0FBN0IsRUFBb0MsSUFBcEMsRUFBMEM7QUFDeEMsTUFBSSxNQUFNLEtBQUssUUFBZjs7QUFFQSxNQUFJLE1BQU0sSUFBVixFQUFnQjtBQUFFLFVBQU0sSUFBTjtBQUFhO0FBQy9CLE1BQUksUUFBUSxDQUFaLEVBQWU7QUFBRSxXQUFPLENBQVA7QUFBVzs7QUFFNUIsT0FBSyxRQUFMLElBQWlCLEdBQWpCOzs7QUFHQSxRQUFNLFFBQU4sQ0FBZSxHQUFmLEVBQW9CLEtBQUssS0FBekIsRUFBZ0MsS0FBSyxPQUFyQyxFQUE4QyxHQUE5QyxFQUFtRCxLQUFuRDtBQUNBLE1BQUksS0FBSyxLQUFMLENBQVcsSUFBWCxLQUFvQixDQUF4QixFQUEyQjtBQUN6QixTQUFLLEtBQUwsR0FBYSxRQUFRLEtBQUssS0FBYixFQUFvQixHQUFwQixFQUF5QixHQUF6QixFQUE4QixLQUE5QixDQUFiO0FBQ0QsR0FGRCxNQUlLLElBQUksS0FBSyxLQUFMLENBQVcsSUFBWCxLQUFvQixDQUF4QixFQUEyQjtBQUM5QixTQUFLLEtBQUwsR0FBYSxNQUFNLEtBQUssS0FBWCxFQUFrQixHQUFsQixFQUF1QixHQUF2QixFQUE0QixLQUE1QixDQUFiO0FBQ0Q7O0FBRUQsT0FBSyxPQUFMLElBQWdCLEdBQWhCO0FBQ0EsT0FBSyxRQUFMLElBQWlCLEdBQWpCOztBQUVBLFNBQU8sR0FBUDtBQUNEOzs7Ozs7Ozs7OztBQVlELFNBQVMsYUFBVCxDQUF1QixDQUF2QixFQUEwQixTQUExQixFQUFxQztBQUNuQyxNQUFJLGVBQWUsRUFBRSxnQkFBckIsQztBQUNBLE1BQUksT0FBTyxFQUFFLFFBQWIsQztBQUNBLE1BQUksS0FBSixDO0FBQ0EsTUFBSSxHQUFKLEM7QUFDQSxNQUFJLFdBQVcsRUFBRSxXQUFqQixDO0FBQ0EsTUFBSSxhQUFhLEVBQUUsVUFBbkIsQztBQUNBLE1BQUksUUFBUyxFQUFFLFFBQUYsR0FBYyxFQUFFLE1BQUYsR0FBVyxhQUExQixHQUNSLEVBQUUsUUFBRixJQUFjLEVBQUUsTUFBRixHQUFXLGFBQXpCLENBRFEsR0FDa0MsQyxRQUQ5Qzs7QUFHQSxNQUFJLE9BQU8sRUFBRSxNQUFiLEM7O0FBRUEsTUFBSSxRQUFRLEVBQUUsTUFBZDtBQUNBLE1BQUksT0FBUSxFQUFFLElBQWQ7Ozs7OztBQU1BLE1BQUksU0FBUyxFQUFFLFFBQUYsR0FBYSxTQUExQjtBQUNBLE1BQUksWUFBYSxLQUFLLE9BQU8sUUFBUCxHQUFrQixDQUF2QixDQUFqQjtBQUNBLE1BQUksV0FBYSxLQUFLLE9BQU8sUUFBWixDQUFqQjs7Ozs7Ozs7QUFRQSxNQUFJLEVBQUUsV0FBRixJQUFpQixFQUFFLFVBQXZCLEVBQW1DO0FBQ2pDLHFCQUFpQixDQUFqQjtBQUNEOzs7O0FBSUQsTUFBSSxhQUFhLEVBQUUsU0FBbkIsRUFBOEI7QUFBRSxpQkFBYSxFQUFFLFNBQWY7QUFBMkI7Ozs7QUFJM0QsS0FBRzs7QUFFRCxZQUFRLFNBQVI7Ozs7Ozs7Ozs7O0FBV0EsUUFBSSxLQUFLLFFBQVEsUUFBYixNQUErQixRQUEvQixJQUNBLEtBQUssUUFBUSxRQUFSLEdBQW1CLENBQXhCLE1BQStCLFNBRC9CLElBRUEsS0FBSyxLQUFMLE1BQStCLEtBQUssSUFBTCxDQUYvQixJQUdBLEtBQUssRUFBRSxLQUFQLE1BQStCLEtBQUssT0FBTyxDQUFaLENBSG5DLEVBR21EO0FBQ2pEO0FBQ0Q7Ozs7Ozs7O0FBUUQsWUFBUSxDQUFSO0FBQ0E7Ozs7OztBQU1BLE9BQUc7O0FBRUYsS0FGRCxRQUVTLEtBQUssRUFBRSxJQUFQLE1BQWlCLEtBQUssRUFBRSxLQUFQLENBQWpCLElBQWtDLEtBQUssRUFBRSxJQUFQLE1BQWlCLEtBQUssRUFBRSxLQUFQLENBQW5ELElBQ0EsS0FBSyxFQUFFLElBQVAsTUFBaUIsS0FBSyxFQUFFLEtBQVAsQ0FEakIsSUFDa0MsS0FBSyxFQUFFLElBQVAsTUFBaUIsS0FBSyxFQUFFLEtBQVAsQ0FEbkQsSUFFQSxLQUFLLEVBQUUsSUFBUCxNQUFpQixLQUFLLEVBQUUsS0FBUCxDQUZqQixJQUVrQyxLQUFLLEVBQUUsSUFBUCxNQUFpQixLQUFLLEVBQUUsS0FBUCxDQUZuRCxJQUdBLEtBQUssRUFBRSxJQUFQLE1BQWlCLEtBQUssRUFBRSxLQUFQLENBSGpCLElBR2tDLEtBQUssRUFBRSxJQUFQLE1BQWlCLEtBQUssRUFBRSxLQUFQLENBSG5ELElBSUEsT0FBTyxNQU5oQjs7OztBQVVBLFVBQU0sYUFBYSxTQUFTLElBQXRCLENBQU47QUFDQSxXQUFPLFNBQVMsU0FBaEI7O0FBRUEsUUFBSSxNQUFNLFFBQVYsRUFBb0I7QUFDbEIsUUFBRSxXQUFGLEdBQWdCLFNBQWhCO0FBQ0EsaUJBQVcsR0FBWDtBQUNBLFVBQUksT0FBTyxVQUFYLEVBQXVCO0FBQ3JCO0FBQ0Q7QUFDRCxrQkFBYSxLQUFLLE9BQU8sUUFBUCxHQUFrQixDQUF2QixDQUFiO0FBQ0EsaUJBQWEsS0FBSyxPQUFPLFFBQVosQ0FBYjtBQUNEO0FBQ0YsR0F2REQsUUF1RFMsQ0FBQyxZQUFZLEtBQUssWUFBWSxLQUFqQixDQUFiLElBQXdDLEtBQXhDLElBQWlELEVBQUUsWUFBRixLQUFtQixDQXZEN0U7O0FBeURBLE1BQUksWUFBWSxFQUFFLFNBQWxCLEVBQTZCO0FBQzNCLFdBQU8sUUFBUDtBQUNEO0FBQ0QsU0FBTyxFQUFFLFNBQVQ7QUFDRDs7Ozs7Ozs7Ozs7O0FBYUQsU0FBUyxXQUFULENBQXFCLENBQXJCLEVBQXdCO0FBQ3RCLE1BQUksVUFBVSxFQUFFLE1BQWhCO0FBQ0EsTUFBSSxDQUFKLEVBQU8sQ0FBUCxFQUFVLENBQVYsRUFBYSxJQUFiLEVBQW1CLEdBQW5COzs7O0FBSUEsS0FBRztBQUNELFdBQU8sRUFBRSxXQUFGLEdBQWdCLEVBQUUsU0FBbEIsR0FBOEIsRUFBRSxRQUF2Qzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQW9CQSxRQUFJLEVBQUUsUUFBRixJQUFjLFdBQVcsVUFBVSxhQUFyQixDQUFsQixFQUF1RDs7QUFFckQsWUFBTSxRQUFOLENBQWUsRUFBRSxNQUFqQixFQUF5QixFQUFFLE1BQTNCLEVBQW1DLE9BQW5DLEVBQTRDLE9BQTVDLEVBQXFELENBQXJEO0FBQ0EsUUFBRSxXQUFGLElBQWlCLE9BQWpCO0FBQ0EsUUFBRSxRQUFGLElBQWMsT0FBZDs7QUFFQSxRQUFFLFdBQUYsSUFBaUIsT0FBakI7Ozs7Ozs7OztBQVNBLFVBQUksRUFBRSxTQUFOO0FBQ0EsVUFBSSxDQUFKO0FBQ0EsU0FBRztBQUNELFlBQUksRUFBRSxJQUFGLENBQU8sRUFBRSxDQUFULENBQUo7QUFDQSxVQUFFLElBQUYsQ0FBTyxDQUFQLElBQWEsS0FBSyxPQUFMLEdBQWUsSUFBSSxPQUFuQixHQUE2QixDQUExQztBQUNELE9BSEQsUUFHUyxFQUFFLENBSFg7O0FBS0EsVUFBSSxPQUFKO0FBQ0EsVUFBSSxDQUFKO0FBQ0EsU0FBRztBQUNELFlBQUksRUFBRSxJQUFGLENBQU8sRUFBRSxDQUFULENBQUo7QUFDQSxVQUFFLElBQUYsQ0FBTyxDQUFQLElBQWEsS0FBSyxPQUFMLEdBQWUsSUFBSSxPQUFuQixHQUE2QixDQUExQzs7OztBQUlELE9BTkQsUUFNUyxFQUFFLENBTlg7O0FBUUEsY0FBUSxPQUFSO0FBQ0Q7QUFDRCxRQUFJLEVBQUUsSUFBRixDQUFPLFFBQVAsS0FBb0IsQ0FBeEIsRUFBMkI7QUFDekI7QUFDRDs7Ozs7Ozs7Ozs7Ozs7QUFjRCxRQUFJLFNBQVMsRUFBRSxJQUFYLEVBQWlCLEVBQUUsTUFBbkIsRUFBMkIsRUFBRSxRQUFGLEdBQWEsRUFBRSxTQUExQyxFQUFxRCxJQUFyRCxDQUFKO0FBQ0EsTUFBRSxTQUFGLElBQWUsQ0FBZjs7O0FBR0EsUUFBSSxFQUFFLFNBQUYsR0FBYyxFQUFFLE1BQWhCLElBQTBCLFNBQTlCLEVBQXlDO0FBQ3ZDLFlBQU0sRUFBRSxRQUFGLEdBQWEsRUFBRSxNQUFyQjtBQUNBLFFBQUUsS0FBRixHQUFVLEVBQUUsTUFBRixDQUFTLEdBQVQsQ0FBVjs7O0FBR0EsUUFBRSxLQUFGLEdBQVUsQ0FBRSxFQUFFLEtBQUYsSUFBVyxFQUFFLFVBQWQsR0FBNEIsRUFBRSxNQUFGLENBQVMsTUFBTSxDQUFmLENBQTdCLElBQWtELEVBQUUsU0FBOUQ7Ozs7QUFJQSxhQUFPLEVBQUUsTUFBVCxFQUFpQjs7QUFFZixVQUFFLEtBQUYsR0FBVSxDQUFFLEVBQUUsS0FBRixJQUFXLEVBQUUsVUFBZCxHQUE0QixFQUFFLE1BQUYsQ0FBUyxNQUFNLFNBQU4sR0FBa0IsQ0FBM0IsQ0FBN0IsSUFBOEQsRUFBRSxTQUExRTs7QUFFQSxVQUFFLElBQUYsQ0FBTyxNQUFNLEVBQUUsTUFBZixJQUF5QixFQUFFLElBQUYsQ0FBTyxFQUFFLEtBQVQsQ0FBekI7QUFDQSxVQUFFLElBQUYsQ0FBTyxFQUFFLEtBQVQsSUFBa0IsR0FBbEI7QUFDQTtBQUNBLFVBQUUsTUFBRjtBQUNBLFlBQUksRUFBRSxTQUFGLEdBQWMsRUFBRSxNQUFoQixHQUF5QixTQUE3QixFQUF3QztBQUN0QztBQUNEO0FBQ0Y7QUFDRjs7OztBQUtGLEdBckdELFFBcUdTLEVBQUUsU0FBRixHQUFjLGFBQWQsSUFBK0IsRUFBRSxJQUFGLENBQU8sUUFBUCxLQUFvQixDQXJHNUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBMklEOzs7Ozs7Ozs7OztBQVdELFNBQVMsY0FBVCxDQUF3QixDQUF4QixFQUEyQixLQUEzQixFQUFrQzs7OztBQUloQyxNQUFJLGlCQUFpQixNQUFyQjs7QUFFQSxNQUFJLGlCQUFpQixFQUFFLGdCQUFGLEdBQXFCLENBQTFDLEVBQTZDO0FBQzNDLHFCQUFpQixFQUFFLGdCQUFGLEdBQXFCLENBQXRDO0FBQ0Q7OztBQUdELFdBQVM7O0FBRVAsUUFBSSxFQUFFLFNBQUYsSUFBZSxDQUFuQixFQUFzQjs7Ozs7Ozs7O0FBU3BCLGtCQUFZLENBQVo7QUFDQSxVQUFJLEVBQUUsU0FBRixLQUFnQixDQUFoQixJQUFxQixVQUFVLFVBQW5DLEVBQStDO0FBQzdDLGVBQU8sWUFBUDtBQUNEOztBQUVELFVBQUksRUFBRSxTQUFGLEtBQWdCLENBQXBCLEVBQXVCO0FBQ3JCO0FBQ0Q7O0FBRUY7Ozs7QUFJRCxNQUFFLFFBQUYsSUFBYyxFQUFFLFNBQWhCO0FBQ0EsTUFBRSxTQUFGLEdBQWMsQ0FBZDs7O0FBR0EsUUFBSSxZQUFZLEVBQUUsV0FBRixHQUFnQixjQUFoQzs7QUFFQSxRQUFJLEVBQUUsUUFBRixLQUFlLENBQWYsSUFBb0IsRUFBRSxRQUFGLElBQWMsU0FBdEMsRUFBaUQ7O0FBRS9DLFFBQUUsU0FBRixHQUFjLEVBQUUsUUFBRixHQUFhLFNBQTNCO0FBQ0EsUUFBRSxRQUFGLEdBQWEsU0FBYjs7QUFFQSx1QkFBaUIsQ0FBakIsRUFBb0IsS0FBcEI7QUFDQSxVQUFJLEVBQUUsSUFBRixDQUFPLFNBQVAsS0FBcUIsQ0FBekIsRUFBNEI7QUFDMUIsZUFBTyxZQUFQO0FBQ0Q7O0FBSUY7Ozs7QUFJRCxRQUFJLEVBQUUsUUFBRixHQUFhLEVBQUUsV0FBZixJQUErQixFQUFFLE1BQUYsR0FBVyxhQUE5QyxFQUE4RDs7QUFFNUQsdUJBQWlCLENBQWpCLEVBQW9CLEtBQXBCO0FBQ0EsVUFBSSxFQUFFLElBQUYsQ0FBTyxTQUFQLEtBQXFCLENBQXpCLEVBQTRCO0FBQzFCLGVBQU8sWUFBUDtBQUNEOztBQUVGO0FBQ0Y7O0FBRUQsSUFBRSxNQUFGLEdBQVcsQ0FBWDs7QUFFQSxNQUFJLFVBQVUsUUFBZCxFQUF3Qjs7QUFFdEIscUJBQWlCLENBQWpCLEVBQW9CLElBQXBCO0FBQ0EsUUFBSSxFQUFFLElBQUYsQ0FBTyxTQUFQLEtBQXFCLENBQXpCLEVBQTRCO0FBQzFCLGFBQU8saUJBQVA7QUFDRDs7QUFFRCxXQUFPLGNBQVA7QUFDRDs7QUFFRCxNQUFJLEVBQUUsUUFBRixHQUFhLEVBQUUsV0FBbkIsRUFBZ0M7O0FBRTlCLHFCQUFpQixDQUFqQixFQUFvQixLQUFwQjtBQUNBLFFBQUksRUFBRSxJQUFGLENBQU8sU0FBUCxLQUFxQixDQUF6QixFQUE0QjtBQUMxQixhQUFPLFlBQVA7QUFDRDs7QUFFRjs7QUFFRCxTQUFPLFlBQVA7QUFDRDs7Ozs7Ozs7O0FBU0QsU0FBUyxZQUFULENBQXNCLENBQXRCLEVBQXlCLEtBQXpCLEVBQWdDO0FBQzlCLE1BQUksU0FBSixDO0FBQ0EsTUFBSSxNQUFKLEM7O0FBRUEsV0FBUzs7Ozs7O0FBTVAsUUFBSSxFQUFFLFNBQUYsR0FBYyxhQUFsQixFQUFpQztBQUMvQixrQkFBWSxDQUFaO0FBQ0EsVUFBSSxFQUFFLFNBQUYsR0FBYyxhQUFkLElBQStCLFVBQVUsVUFBN0MsRUFBeUQ7QUFDdkQsZUFBTyxZQUFQO0FBQ0Q7QUFDRCxVQUFJLEVBQUUsU0FBRixLQUFnQixDQUFwQixFQUF1QjtBQUNyQixjO0FBQ0Q7QUFDRjs7Ozs7QUFLRCxnQkFBWSxDLFFBQVo7QUFDQSxRQUFJLEVBQUUsU0FBRixJQUFlLFNBQW5CLEVBQThCOztBQUU1QixRQUFFLEtBQUYsR0FBVSxDQUFFLEVBQUUsS0FBRixJQUFXLEVBQUUsVUFBZCxHQUE0QixFQUFFLE1BQUYsQ0FBUyxFQUFFLFFBQUYsR0FBYSxTQUFiLEdBQXlCLENBQWxDLENBQTdCLElBQXFFLEVBQUUsU0FBakY7QUFDQSxrQkFBWSxFQUFFLElBQUYsQ0FBTyxFQUFFLFFBQUYsR0FBYSxFQUFFLE1BQXRCLElBQWdDLEVBQUUsSUFBRixDQUFPLEVBQUUsS0FBVCxDQUE1QztBQUNBLFFBQUUsSUFBRixDQUFPLEVBQUUsS0FBVCxJQUFrQixFQUFFLFFBQXBCOztBQUVEOzs7OztBQUtELFFBQUksY0FBYyxDLFFBQWQsSUFBNEIsRUFBRSxRQUFGLEdBQWEsU0FBZCxJQUE2QixFQUFFLE1BQUYsR0FBVyxhQUF2RSxFQUF3Rjs7Ozs7QUFLdEYsUUFBRSxZQUFGLEdBQWlCLGNBQWMsQ0FBZCxFQUFpQixTQUFqQixDQUFqQjs7QUFFRDtBQUNELFFBQUksRUFBRSxZQUFGLElBQWtCLFNBQXRCLEVBQWlDOzs7OztBQUsvQixlQUFTLE1BQU0sU0FBTixDQUFnQixDQUFoQixFQUFtQixFQUFFLFFBQUYsR0FBYSxFQUFFLFdBQWxDLEVBQStDLEVBQUUsWUFBRixHQUFpQixTQUFoRSxDQUFUOztBQUVBLFFBQUUsU0FBRixJQUFlLEVBQUUsWUFBakI7Ozs7O0FBS0EsVUFBSSxFQUFFLFlBQUYsSUFBa0IsRUFBRSxjLHNCQUFwQixJQUEyRCxFQUFFLFNBQUYsSUFBZSxTQUE5RSxFQUF5RjtBQUN2RixVQUFFLFlBQUYsRztBQUNBLFdBQUc7QUFDRCxZQUFFLFFBQUY7O0FBRUEsWUFBRSxLQUFGLEdBQVUsQ0FBRSxFQUFFLEtBQUYsSUFBVyxFQUFFLFVBQWQsR0FBNEIsRUFBRSxNQUFGLENBQVMsRUFBRSxRQUFGLEdBQWEsU0FBYixHQUF5QixDQUFsQyxDQUE3QixJQUFxRSxFQUFFLFNBQWpGO0FBQ0Esc0JBQVksRUFBRSxJQUFGLENBQU8sRUFBRSxRQUFGLEdBQWEsRUFBRSxNQUF0QixJQUFnQyxFQUFFLElBQUYsQ0FBTyxFQUFFLEtBQVQsQ0FBNUM7QUFDQSxZQUFFLElBQUYsQ0FBTyxFQUFFLEtBQVQsSUFBa0IsRUFBRSxRQUFwQjs7Ozs7QUFLRCxTQVZELFFBVVMsRUFBRSxFQUFFLFlBQUosS0FBcUIsQ0FWOUI7QUFXQSxVQUFFLFFBQUY7QUFDRCxPQWRELE1BZUE7QUFDRSxVQUFFLFFBQUYsSUFBYyxFQUFFLFlBQWhCO0FBQ0EsVUFBRSxZQUFGLEdBQWlCLENBQWpCO0FBQ0EsVUFBRSxLQUFGLEdBQVUsRUFBRSxNQUFGLENBQVMsRUFBRSxRQUFYLENBQVY7O0FBRUEsVUFBRSxLQUFGLEdBQVUsQ0FBRSxFQUFFLEtBQUYsSUFBVyxFQUFFLFVBQWQsR0FBNEIsRUFBRSxNQUFGLENBQVMsRUFBRSxRQUFGLEdBQWEsQ0FBdEIsQ0FBN0IsSUFBeUQsRUFBRSxTQUFyRTs7Ozs7Ozs7QUFRRDtBQUNGLEtBekNELE1BeUNPOzs7O0FBSUwsZUFBUyxNQUFNLFNBQU4sQ0FBZ0IsQ0FBaEIsRUFBbUIsQ0FBbkIsRUFBc0IsRUFBRSxNQUFGLENBQVMsRUFBRSxRQUFYLENBQXRCLENBQVQ7O0FBRUEsUUFBRSxTQUFGO0FBQ0EsUUFBRSxRQUFGO0FBQ0Q7QUFDRCxRQUFJLE1BQUosRUFBWTs7QUFFVix1QkFBaUIsQ0FBakIsRUFBb0IsS0FBcEI7QUFDQSxVQUFJLEVBQUUsSUFBRixDQUFPLFNBQVAsS0FBcUIsQ0FBekIsRUFBNEI7QUFDMUIsZUFBTyxZQUFQO0FBQ0Q7O0FBRUY7QUFDRjtBQUNELElBQUUsTUFBRixHQUFhLEVBQUUsUUFBRixHQUFjLFlBQVksQ0FBM0IsR0FBaUMsRUFBRSxRQUFuQyxHQUE4QyxZQUFZLENBQXRFO0FBQ0EsTUFBSSxVQUFVLFFBQWQsRUFBd0I7O0FBRXRCLHFCQUFpQixDQUFqQixFQUFvQixJQUFwQjtBQUNBLFFBQUksRUFBRSxJQUFGLENBQU8sU0FBUCxLQUFxQixDQUF6QixFQUE0QjtBQUMxQixhQUFPLGlCQUFQO0FBQ0Q7O0FBRUQsV0FBTyxjQUFQO0FBQ0Q7QUFDRCxNQUFJLEVBQUUsUUFBTixFQUFnQjs7QUFFZCxxQkFBaUIsQ0FBakIsRUFBb0IsS0FBcEI7QUFDQSxRQUFJLEVBQUUsSUFBRixDQUFPLFNBQVAsS0FBcUIsQ0FBekIsRUFBNEI7QUFDMUIsYUFBTyxZQUFQO0FBQ0Q7O0FBRUY7QUFDRCxTQUFPLGFBQVA7QUFDRDs7Ozs7OztBQU9ELFNBQVMsWUFBVCxDQUFzQixDQUF0QixFQUF5QixLQUF6QixFQUFnQztBQUM5QixNQUFJLFNBQUosQztBQUNBLE1BQUksTUFBSixDOztBQUVBLE1BQUksVUFBSjs7O0FBR0EsV0FBUzs7Ozs7O0FBTVAsUUFBSSxFQUFFLFNBQUYsR0FBYyxhQUFsQixFQUFpQztBQUMvQixrQkFBWSxDQUFaO0FBQ0EsVUFBSSxFQUFFLFNBQUYsR0FBYyxhQUFkLElBQStCLFVBQVUsVUFBN0MsRUFBeUQ7QUFDdkQsZUFBTyxZQUFQO0FBQ0Q7QUFDRCxVQUFJLEVBQUUsU0FBRixLQUFnQixDQUFwQixFQUF1QjtBQUFFO0FBQVEsTztBQUNsQzs7Ozs7QUFLRCxnQkFBWSxDLFFBQVo7QUFDQSxRQUFJLEVBQUUsU0FBRixJQUFlLFNBQW5CLEVBQThCOztBQUU1QixRQUFFLEtBQUYsR0FBVSxDQUFFLEVBQUUsS0FBRixJQUFXLEVBQUUsVUFBZCxHQUE0QixFQUFFLE1BQUYsQ0FBUyxFQUFFLFFBQUYsR0FBYSxTQUFiLEdBQXlCLENBQWxDLENBQTdCLElBQXFFLEVBQUUsU0FBakY7QUFDQSxrQkFBWSxFQUFFLElBQUYsQ0FBTyxFQUFFLFFBQUYsR0FBYSxFQUFFLE1BQXRCLElBQWdDLEVBQUUsSUFBRixDQUFPLEVBQUUsS0FBVCxDQUE1QztBQUNBLFFBQUUsSUFBRixDQUFPLEVBQUUsS0FBVCxJQUFrQixFQUFFLFFBQXBCOztBQUVEOzs7O0FBSUQsTUFBRSxXQUFGLEdBQWdCLEVBQUUsWUFBbEI7QUFDQSxNQUFFLFVBQUYsR0FBZSxFQUFFLFdBQWpCO0FBQ0EsTUFBRSxZQUFGLEdBQWlCLFlBQVksQ0FBN0I7O0FBRUEsUUFBSSxjQUFjLEMsUUFBZCxJQUEwQixFQUFFLFdBQUYsR0FBZ0IsRUFBRSxjQUE1QyxJQUNBLEVBQUUsUUFBRixHQUFhLFNBQWIsSUFBMkIsRUFBRSxNQUFGLEdBQVcsYSxnQkFEMUMsRUFDeUU7Ozs7O0FBS3ZFLFVBQUUsWUFBRixHQUFpQixjQUFjLENBQWQsRUFBaUIsU0FBakIsQ0FBakI7OztBQUdBLFlBQUksRUFBRSxZQUFGLElBQWtCLENBQWxCLEtBQ0EsRUFBRSxRQUFGLEtBQWUsVUFBZixJQUE4QixFQUFFLFlBQUYsS0FBbUIsU0FBbkIsSUFBZ0MsRUFBRSxRQUFGLEdBQWEsRUFBRSxXQUFmLEdBQTZCLEksWUFEM0YsQ0FBSixFQUNrSDs7Ozs7QUFLaEgsWUFBRSxZQUFGLEdBQWlCLFlBQVksQ0FBN0I7QUFDRDtBQUNGOzs7O0FBSUQsUUFBSSxFQUFFLFdBQUYsSUFBaUIsU0FBakIsSUFBOEIsRUFBRSxZQUFGLElBQWtCLEVBQUUsV0FBdEQsRUFBbUU7QUFDakUsbUJBQWEsRUFBRSxRQUFGLEdBQWEsRUFBRSxTQUFmLEdBQTJCLFNBQXhDOzs7Ozs7O0FBT0EsZUFBUyxNQUFNLFNBQU4sQ0FBZ0IsQ0FBaEIsRUFBbUIsRUFBRSxRQUFGLEdBQWEsQ0FBYixHQUFpQixFQUFFLFVBQXRDLEVBQWtELEVBQUUsV0FBRixHQUFnQixTQUFsRSxDQUFUOzs7Ozs7QUFNQSxRQUFFLFNBQUYsSUFBZSxFQUFFLFdBQUYsR0FBZ0IsQ0FBL0I7QUFDQSxRQUFFLFdBQUYsSUFBaUIsQ0FBakI7QUFDQSxTQUFHO0FBQ0QsWUFBSSxFQUFFLEVBQUUsUUFBSixJQUFnQixVQUFwQixFQUFnQzs7QUFFOUIsWUFBRSxLQUFGLEdBQVUsQ0FBRSxFQUFFLEtBQUYsSUFBVyxFQUFFLFVBQWQsR0FBNEIsRUFBRSxNQUFGLENBQVMsRUFBRSxRQUFGLEdBQWEsU0FBYixHQUF5QixDQUFsQyxDQUE3QixJQUFxRSxFQUFFLFNBQWpGO0FBQ0Esc0JBQVksRUFBRSxJQUFGLENBQU8sRUFBRSxRQUFGLEdBQWEsRUFBRSxNQUF0QixJQUFnQyxFQUFFLElBQUYsQ0FBTyxFQUFFLEtBQVQsQ0FBNUM7QUFDQSxZQUFFLElBQUYsQ0FBTyxFQUFFLEtBQVQsSUFBa0IsRUFBRSxRQUFwQjs7QUFFRDtBQUNGLE9BUkQsUUFRUyxFQUFFLEVBQUUsV0FBSixLQUFvQixDQVI3QjtBQVNBLFFBQUUsZUFBRixHQUFvQixDQUFwQjtBQUNBLFFBQUUsWUFBRixHQUFpQixZQUFZLENBQTdCO0FBQ0EsUUFBRSxRQUFGOztBQUVBLFVBQUksTUFBSixFQUFZOztBQUVWLHlCQUFpQixDQUFqQixFQUFvQixLQUFwQjtBQUNBLFlBQUksRUFBRSxJQUFGLENBQU8sU0FBUCxLQUFxQixDQUF6QixFQUE0QjtBQUMxQixpQkFBTyxZQUFQO0FBQ0Q7O0FBRUY7QUFFRixLQXRDRCxNQXNDTyxJQUFJLEVBQUUsZUFBTixFQUF1Qjs7Ozs7OztBQU81QixlQUFTLE1BQU0sU0FBTixDQUFnQixDQUFoQixFQUFtQixDQUFuQixFQUFzQixFQUFFLE1BQUYsQ0FBUyxFQUFFLFFBQUYsR0FBYSxDQUF0QixDQUF0QixDQUFUOztBQUVBLFVBQUksTUFBSixFQUFZOztBQUVWLHlCQUFpQixDQUFqQixFQUFvQixLQUFwQjs7QUFFRDtBQUNELFFBQUUsUUFBRjtBQUNBLFFBQUUsU0FBRjtBQUNBLFVBQUksRUFBRSxJQUFGLENBQU8sU0FBUCxLQUFxQixDQUF6QixFQUE0QjtBQUMxQixlQUFPLFlBQVA7QUFDRDtBQUNGLEtBbkJNLE1BbUJBOzs7O0FBSUwsUUFBRSxlQUFGLEdBQW9CLENBQXBCO0FBQ0EsUUFBRSxRQUFGO0FBQ0EsUUFBRSxTQUFGO0FBQ0Q7QUFDRjs7QUFFRCxNQUFJLEVBQUUsZUFBTixFQUF1Qjs7O0FBR3JCLGFBQVMsTUFBTSxTQUFOLENBQWdCLENBQWhCLEVBQW1CLENBQW5CLEVBQXNCLEVBQUUsTUFBRixDQUFTLEVBQUUsUUFBRixHQUFhLENBQXRCLENBQXRCLENBQVQ7O0FBRUEsTUFBRSxlQUFGLEdBQW9CLENBQXBCO0FBQ0Q7QUFDRCxJQUFFLE1BQUYsR0FBVyxFQUFFLFFBQUYsR0FBYSxZQUFZLENBQXpCLEdBQTZCLEVBQUUsUUFBL0IsR0FBMEMsWUFBWSxDQUFqRTtBQUNBLE1BQUksVUFBVSxRQUFkLEVBQXdCOztBQUV0QixxQkFBaUIsQ0FBakIsRUFBb0IsSUFBcEI7QUFDQSxRQUFJLEVBQUUsSUFBRixDQUFPLFNBQVAsS0FBcUIsQ0FBekIsRUFBNEI7QUFDMUIsYUFBTyxpQkFBUDtBQUNEOztBQUVELFdBQU8sY0FBUDtBQUNEO0FBQ0QsTUFBSSxFQUFFLFFBQU4sRUFBZ0I7O0FBRWQscUJBQWlCLENBQWpCLEVBQW9CLEtBQXBCO0FBQ0EsUUFBSSxFQUFFLElBQUYsQ0FBTyxTQUFQLEtBQXFCLENBQXpCLEVBQTRCO0FBQzFCLGFBQU8sWUFBUDtBQUNEOztBQUVGOztBQUVELFNBQU8sYUFBUDtBQUNEOzs7Ozs7O0FBUUQsU0FBUyxXQUFULENBQXFCLENBQXJCLEVBQXdCLEtBQXhCLEVBQStCO0FBQzdCLE1BQUksTUFBSixDO0FBQ0EsTUFBSSxJQUFKLEM7QUFDQSxNQUFJLElBQUosRUFBVSxNQUFWLEM7O0FBRUEsTUFBSSxPQUFPLEVBQUUsTUFBYjs7QUFFQSxXQUFTOzs7OztBQUtQLFFBQUksRUFBRSxTQUFGLElBQWUsU0FBbkIsRUFBOEI7QUFDNUIsa0JBQVksQ0FBWjtBQUNBLFVBQUksRUFBRSxTQUFGLElBQWUsU0FBZixJQUE0QixVQUFVLFVBQTFDLEVBQXNEO0FBQ3BELGVBQU8sWUFBUDtBQUNEO0FBQ0QsVUFBSSxFQUFFLFNBQUYsS0FBZ0IsQ0FBcEIsRUFBdUI7QUFBRTtBQUFRLE87QUFDbEM7OztBQUdELE1BQUUsWUFBRixHQUFpQixDQUFqQjtBQUNBLFFBQUksRUFBRSxTQUFGLElBQWUsU0FBZixJQUE0QixFQUFFLFFBQUYsR0FBYSxDQUE3QyxFQUFnRDtBQUM5QyxhQUFPLEVBQUUsUUFBRixHQUFhLENBQXBCO0FBQ0EsYUFBTyxLQUFLLElBQUwsQ0FBUDtBQUNBLFVBQUksU0FBUyxLQUFLLEVBQUUsSUFBUCxDQUFULElBQXlCLFNBQVMsS0FBSyxFQUFFLElBQVAsQ0FBbEMsSUFBa0QsU0FBUyxLQUFLLEVBQUUsSUFBUCxDQUEvRCxFQUE2RTtBQUMzRSxpQkFBUyxFQUFFLFFBQUYsR0FBYSxTQUF0QjtBQUNBLFdBQUc7O0FBRUYsU0FGRCxRQUVTLFNBQVMsS0FBSyxFQUFFLElBQVAsQ0FBVCxJQUF5QixTQUFTLEtBQUssRUFBRSxJQUFQLENBQWxDLElBQ0EsU0FBUyxLQUFLLEVBQUUsSUFBUCxDQURULElBQ3lCLFNBQVMsS0FBSyxFQUFFLElBQVAsQ0FEbEMsSUFFQSxTQUFTLEtBQUssRUFBRSxJQUFQLENBRlQsSUFFeUIsU0FBUyxLQUFLLEVBQUUsSUFBUCxDQUZsQyxJQUdBLFNBQVMsS0FBSyxFQUFFLElBQVAsQ0FIVCxJQUd5QixTQUFTLEtBQUssRUFBRSxJQUFQLENBSGxDLElBSUEsT0FBTyxNQU5oQjtBQU9BLFVBQUUsWUFBRixHQUFpQixhQUFhLFNBQVMsSUFBdEIsQ0FBakI7QUFDQSxZQUFJLEVBQUUsWUFBRixHQUFpQixFQUFFLFNBQXZCLEVBQWtDO0FBQ2hDLFlBQUUsWUFBRixHQUFpQixFQUFFLFNBQW5CO0FBQ0Q7QUFDRjs7QUFFRjs7O0FBR0QsUUFBSSxFQUFFLFlBQUYsSUFBa0IsU0FBdEIsRUFBaUM7Ozs7QUFJL0IsZUFBUyxNQUFNLFNBQU4sQ0FBZ0IsQ0FBaEIsRUFBbUIsQ0FBbkIsRUFBc0IsRUFBRSxZQUFGLEdBQWlCLFNBQXZDLENBQVQ7O0FBRUEsUUFBRSxTQUFGLElBQWUsRUFBRSxZQUFqQjtBQUNBLFFBQUUsUUFBRixJQUFjLEVBQUUsWUFBaEI7QUFDQSxRQUFFLFlBQUYsR0FBaUIsQ0FBakI7QUFDRCxLQVRELE1BU087Ozs7QUFJTCxlQUFTLE1BQU0sU0FBTixDQUFnQixDQUFoQixFQUFtQixDQUFuQixFQUFzQixFQUFFLE1BQUYsQ0FBUyxFQUFFLFFBQVgsQ0FBdEIsQ0FBVDs7QUFFQSxRQUFFLFNBQUY7QUFDQSxRQUFFLFFBQUY7QUFDRDtBQUNELFFBQUksTUFBSixFQUFZOztBQUVWLHVCQUFpQixDQUFqQixFQUFvQixLQUFwQjtBQUNBLFVBQUksRUFBRSxJQUFGLENBQU8sU0FBUCxLQUFxQixDQUF6QixFQUE0QjtBQUMxQixlQUFPLFlBQVA7QUFDRDs7QUFFRjtBQUNGO0FBQ0QsSUFBRSxNQUFGLEdBQVcsQ0FBWDtBQUNBLE1BQUksVUFBVSxRQUFkLEVBQXdCOztBQUV0QixxQkFBaUIsQ0FBakIsRUFBb0IsSUFBcEI7QUFDQSxRQUFJLEVBQUUsSUFBRixDQUFPLFNBQVAsS0FBcUIsQ0FBekIsRUFBNEI7QUFDMUIsYUFBTyxpQkFBUDtBQUNEOztBQUVELFdBQU8sY0FBUDtBQUNEO0FBQ0QsTUFBSSxFQUFFLFFBQU4sRUFBZ0I7O0FBRWQscUJBQWlCLENBQWpCLEVBQW9CLEtBQXBCO0FBQ0EsUUFBSSxFQUFFLElBQUYsQ0FBTyxTQUFQLEtBQXFCLENBQXpCLEVBQTRCO0FBQzFCLGFBQU8sWUFBUDtBQUNEOztBQUVGO0FBQ0QsU0FBTyxhQUFQO0FBQ0Q7Ozs7OztBQU1ELFNBQVMsWUFBVCxDQUFzQixDQUF0QixFQUF5QixLQUF6QixFQUFnQztBQUM5QixNQUFJLE1BQUosQzs7QUFFQSxXQUFTOztBQUVQLFFBQUksRUFBRSxTQUFGLEtBQWdCLENBQXBCLEVBQXVCO0FBQ3JCLGtCQUFZLENBQVo7QUFDQSxVQUFJLEVBQUUsU0FBRixLQUFnQixDQUFwQixFQUF1QjtBQUNyQixZQUFJLFVBQVUsVUFBZCxFQUEwQjtBQUN4QixpQkFBTyxZQUFQO0FBQ0Q7QUFDRCxjO0FBQ0Q7QUFDRjs7O0FBR0QsTUFBRSxZQUFGLEdBQWlCLENBQWpCOzs7QUFHQSxhQUFTLE1BQU0sU0FBTixDQUFnQixDQUFoQixFQUFtQixDQUFuQixFQUFzQixFQUFFLE1BQUYsQ0FBUyxFQUFFLFFBQVgsQ0FBdEIsQ0FBVDtBQUNBLE1BQUUsU0FBRjtBQUNBLE1BQUUsUUFBRjtBQUNBLFFBQUksTUFBSixFQUFZOztBQUVWLHVCQUFpQixDQUFqQixFQUFvQixLQUFwQjtBQUNBLFVBQUksRUFBRSxJQUFGLENBQU8sU0FBUCxLQUFxQixDQUF6QixFQUE0QjtBQUMxQixlQUFPLFlBQVA7QUFDRDs7QUFFRjtBQUNGO0FBQ0QsSUFBRSxNQUFGLEdBQVcsQ0FBWDtBQUNBLE1BQUksVUFBVSxRQUFkLEVBQXdCOztBQUV0QixxQkFBaUIsQ0FBakIsRUFBb0IsSUFBcEI7QUFDQSxRQUFJLEVBQUUsSUFBRixDQUFPLFNBQVAsS0FBcUIsQ0FBekIsRUFBNEI7QUFDMUIsYUFBTyxpQkFBUDtBQUNEOztBQUVELFdBQU8sY0FBUDtBQUNEO0FBQ0QsTUFBSSxFQUFFLFFBQU4sRUFBZ0I7O0FBRWQscUJBQWlCLENBQWpCLEVBQW9CLEtBQXBCO0FBQ0EsUUFBSSxFQUFFLElBQUYsQ0FBTyxTQUFQLEtBQXFCLENBQXpCLEVBQTRCO0FBQzFCLGFBQU8sWUFBUDtBQUNEOztBQUVGO0FBQ0QsU0FBTyxhQUFQO0FBQ0Q7Ozs7Ozs7QUFPRCxTQUFTLE1BQVQsQ0FBZ0IsV0FBaEIsRUFBNkIsUUFBN0IsRUFBdUMsV0FBdkMsRUFBb0QsU0FBcEQsRUFBK0QsSUFBL0QsRUFBcUU7QUFDbkUsT0FBSyxXQUFMLEdBQW1CLFdBQW5CO0FBQ0EsT0FBSyxRQUFMLEdBQWdCLFFBQWhCO0FBQ0EsT0FBSyxXQUFMLEdBQW1CLFdBQW5CO0FBQ0EsT0FBSyxTQUFMLEdBQWlCLFNBQWpCO0FBQ0EsT0FBSyxJQUFMLEdBQVksSUFBWjtBQUNEOztBQUVELElBQUksbUJBQUo7O0FBRUEsc0JBQXNCOztBQUVwQixJQUFJLE1BQUosQ0FBVyxDQUFYLEVBQWMsQ0FBZCxFQUFpQixDQUFqQixFQUFvQixDQUFwQixFQUF1QixjQUF2QixDQUZvQixFO0FBR3BCLElBQUksTUFBSixDQUFXLENBQVgsRUFBYyxDQUFkLEVBQWlCLENBQWpCLEVBQW9CLENBQXBCLEVBQXVCLFlBQXZCLENBSG9CLEU7QUFJcEIsSUFBSSxNQUFKLENBQVcsQ0FBWCxFQUFjLENBQWQsRUFBaUIsRUFBakIsRUFBcUIsQ0FBckIsRUFBd0IsWUFBeEIsQ0FKb0IsRTtBQUtwQixJQUFJLE1BQUosQ0FBVyxDQUFYLEVBQWMsQ0FBZCxFQUFpQixFQUFqQixFQUFxQixFQUFyQixFQUF5QixZQUF6QixDQUxvQixFOztBQU9wQixJQUFJLE1BQUosQ0FBVyxDQUFYLEVBQWMsQ0FBZCxFQUFpQixFQUFqQixFQUFxQixFQUFyQixFQUF5QixZQUF6QixDQVBvQixFO0FBUXBCLElBQUksTUFBSixDQUFXLENBQVgsRUFBYyxFQUFkLEVBQWtCLEVBQWxCLEVBQXNCLEVBQXRCLEVBQTBCLFlBQTFCLENBUm9CLEU7QUFTcEIsSUFBSSxNQUFKLENBQVcsQ0FBWCxFQUFjLEVBQWQsRUFBa0IsR0FBbEIsRUFBdUIsR0FBdkIsRUFBNEIsWUFBNUIsQ0FUb0IsRTtBQVVwQixJQUFJLE1BQUosQ0FBVyxDQUFYLEVBQWMsRUFBZCxFQUFrQixHQUFsQixFQUF1QixHQUF2QixFQUE0QixZQUE1QixDQVZvQixFO0FBV3BCLElBQUksTUFBSixDQUFXLEVBQVgsRUFBZSxHQUFmLEVBQW9CLEdBQXBCLEVBQXlCLElBQXpCLEVBQStCLFlBQS9CLENBWG9CLEU7QUFZcEIsSUFBSSxNQUFKLENBQVcsRUFBWCxFQUFlLEdBQWYsRUFBb0IsR0FBcEIsRUFBeUIsSUFBekIsRUFBK0IsWUFBL0IsQztBQVpvQixDQUF0Qjs7Ozs7QUFtQkEsU0FBUyxPQUFULENBQWlCLENBQWpCLEVBQW9CO0FBQ2xCLElBQUUsV0FBRixHQUFnQixJQUFJLEVBQUUsTUFBdEI7OztBQUdBLE9BQUssRUFBRSxJQUFQLEU7Ozs7QUFJQSxJQUFFLGNBQUYsR0FBbUIsb0JBQW9CLEVBQUUsS0FBdEIsRUFBNkIsUUFBaEQ7QUFDQSxJQUFFLFVBQUYsR0FBZSxvQkFBb0IsRUFBRSxLQUF0QixFQUE2QixXQUE1QztBQUNBLElBQUUsVUFBRixHQUFlLG9CQUFvQixFQUFFLEtBQXRCLEVBQTZCLFdBQTVDO0FBQ0EsSUFBRSxnQkFBRixHQUFxQixvQkFBb0IsRUFBRSxLQUF0QixFQUE2QixTQUFsRDs7QUFFQSxJQUFFLFFBQUYsR0FBYSxDQUFiO0FBQ0EsSUFBRSxXQUFGLEdBQWdCLENBQWhCO0FBQ0EsSUFBRSxTQUFGLEdBQWMsQ0FBZDtBQUNBLElBQUUsTUFBRixHQUFXLENBQVg7QUFDQSxJQUFFLFlBQUYsR0FBaUIsRUFBRSxXQUFGLEdBQWdCLFlBQVksQ0FBN0M7QUFDQSxJQUFFLGVBQUYsR0FBb0IsQ0FBcEI7QUFDQSxJQUFFLEtBQUYsR0FBVSxDQUFWO0FBQ0Q7O0FBR0QsU0FBUyxZQUFULEdBQXdCO0FBQ3RCLE9BQUssSUFBTCxHQUFZLElBQVosQztBQUNBLE9BQUssTUFBTCxHQUFjLENBQWQsQztBQUNBLE9BQUssV0FBTCxHQUFtQixJQUFuQixDO0FBQ0EsT0FBSyxnQkFBTCxHQUF3QixDQUF4QixDO0FBQ0EsT0FBSyxXQUFMLEdBQW1CLENBQW5CLEM7QUFDQSxPQUFLLE9BQUwsR0FBZSxDQUFmLEM7QUFDQSxPQUFLLElBQUwsR0FBWSxDQUFaLEM7QUFDQSxPQUFLLE1BQUwsR0FBYyxJQUFkLEM7QUFDQSxPQUFLLE9BQUwsR0FBZSxDQUFmLEM7QUFDQSxPQUFLLE1BQUwsR0FBYyxVQUFkLEM7QUFDQSxPQUFLLFVBQUwsR0FBa0IsQ0FBQyxDQUFuQixDOztBQUVBLE9BQUssTUFBTCxHQUFjLENBQWQsQztBQUNBLE9BQUssTUFBTCxHQUFjLENBQWQsQztBQUNBLE9BQUssTUFBTCxHQUFjLENBQWQsQzs7QUFFQSxPQUFLLE1BQUwsR0FBYyxJQUFkOzs7Ozs7OztBQVFBLE9BQUssV0FBTCxHQUFtQixDQUFuQjs7Ozs7QUFLQSxPQUFLLElBQUwsR0FBWSxJQUFaOzs7Ozs7QUFNQSxPQUFLLElBQUwsR0FBWSxJQUFaLEM7O0FBRUEsT0FBSyxLQUFMLEdBQWEsQ0FBYixDO0FBQ0EsT0FBSyxTQUFMLEdBQWlCLENBQWpCLEM7QUFDQSxPQUFLLFNBQUwsR0FBaUIsQ0FBakIsQztBQUNBLE9BQUssU0FBTCxHQUFpQixDQUFqQixDOztBQUVBLE9BQUssVUFBTCxHQUFrQixDQUFsQjs7Ozs7OztBQU9BLE9BQUssV0FBTCxHQUFtQixDQUFuQjs7Ozs7QUFLQSxPQUFLLFlBQUwsR0FBb0IsQ0FBcEIsQztBQUNBLE9BQUssVUFBTCxHQUFrQixDQUFsQixDO0FBQ0EsT0FBSyxlQUFMLEdBQXVCLENBQXZCLEM7QUFDQSxPQUFLLFFBQUwsR0FBZ0IsQ0FBaEIsQztBQUNBLE9BQUssV0FBTCxHQUFtQixDQUFuQixDO0FBQ0EsT0FBSyxTQUFMLEdBQWlCLENBQWpCLEM7O0FBRUEsT0FBSyxXQUFMLEdBQW1CLENBQW5COzs7OztBQUtBLE9BQUssZ0JBQUwsR0FBd0IsQ0FBeEI7Ozs7OztBQU1BLE9BQUssY0FBTCxHQUFzQixDQUF0Qjs7Ozs7Ozs7Ozs7O0FBWUEsT0FBSyxLQUFMLEdBQWEsQ0FBYixDO0FBQ0EsT0FBSyxRQUFMLEdBQWdCLENBQWhCLEM7O0FBRUEsT0FBSyxVQUFMLEdBQWtCLENBQWxCOzs7QUFHQSxPQUFLLFVBQUwsR0FBa0IsQ0FBbEIsQzs7Ozs7Ozs7Ozs7O0FBWUEsT0FBSyxTQUFMLEdBQWtCLElBQUksTUFBTSxLQUFWLENBQWdCLFlBQVksQ0FBNUIsQ0FBbEI7QUFDQSxPQUFLLFNBQUwsR0FBa0IsSUFBSSxNQUFNLEtBQVYsQ0FBZ0IsQ0FBQyxJQUFJLE9BQUosR0FBYyxDQUFmLElBQW9CLENBQXBDLENBQWxCO0FBQ0EsT0FBSyxPQUFMLEdBQWtCLElBQUksTUFBTSxLQUFWLENBQWdCLENBQUMsSUFBSSxRQUFKLEdBQWUsQ0FBaEIsSUFBcUIsQ0FBckMsQ0FBbEI7QUFDQSxPQUFLLEtBQUssU0FBVjtBQUNBLE9BQUssS0FBSyxTQUFWO0FBQ0EsT0FBSyxLQUFLLE9BQVY7O0FBRUEsT0FBSyxNQUFMLEdBQWdCLElBQWhCLEM7QUFDQSxPQUFLLE1BQUwsR0FBZ0IsSUFBaEIsQztBQUNBLE9BQUssT0FBTCxHQUFnQixJQUFoQixDOzs7QUFHQSxPQUFLLFFBQUwsR0FBZ0IsSUFBSSxNQUFNLEtBQVYsQ0FBZ0IsV0FBVyxDQUEzQixDQUFoQjs7OztBQUlBLE9BQUssSUFBTCxHQUFZLElBQUksTUFBTSxLQUFWLENBQWdCLElBQUksT0FBSixHQUFjLENBQTlCLENBQVosQztBQUNBLE9BQUssS0FBSyxJQUFWOztBQUVBLE9BQUssUUFBTCxHQUFnQixDQUFoQixDO0FBQ0EsT0FBSyxRQUFMLEdBQWdCLENBQWhCLEM7Ozs7O0FBS0EsT0FBSyxLQUFMLEdBQWEsSUFBSSxNQUFNLEtBQVYsQ0FBZ0IsSUFBSSxPQUFKLEdBQWMsQ0FBOUIsQ0FBYixDO0FBQ0EsT0FBSyxLQUFLLEtBQVY7Ozs7QUFJQSxPQUFLLEtBQUwsR0FBYSxDQUFiLEM7O0FBRUEsT0FBSyxXQUFMLEdBQW1CLENBQW5COzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQW9CQSxPQUFLLFFBQUwsR0FBZ0IsQ0FBaEIsQzs7QUFFQSxPQUFLLEtBQUwsR0FBYSxDQUFiOzs7Ozs7QUFNQSxPQUFLLE9BQUwsR0FBZSxDQUFmLEM7QUFDQSxPQUFLLFVBQUwsR0FBa0IsQ0FBbEIsQztBQUNBLE9BQUssT0FBTCxHQUFlLENBQWYsQztBQUNBLE9BQUssTUFBTCxHQUFjLENBQWQsQzs7QUFHQSxPQUFLLE1BQUwsR0FBYyxDQUFkOzs7O0FBSUEsT0FBSyxRQUFMLEdBQWdCLENBQWhCOzs7Ozs7Ozs7Ozs7O0FBYUQ7O0FBR0QsU0FBUyxnQkFBVCxDQUEwQixJQUExQixFQUFnQztBQUM5QixNQUFJLENBQUo7O0FBRUEsTUFBSSxDQUFDLElBQUQsSUFBUyxDQUFDLEtBQUssS0FBbkIsRUFBMEI7QUFDeEIsV0FBTyxJQUFJLElBQUosRUFBVSxjQUFWLENBQVA7QUFDRDs7QUFFRCxPQUFLLFFBQUwsR0FBZ0IsS0FBSyxTQUFMLEdBQWlCLENBQWpDO0FBQ0EsT0FBSyxTQUFMLEdBQWlCLFNBQWpCOztBQUVBLE1BQUksS0FBSyxLQUFUO0FBQ0EsSUFBRSxPQUFGLEdBQVksQ0FBWjtBQUNBLElBQUUsV0FBRixHQUFnQixDQUFoQjs7QUFFQSxNQUFJLEVBQUUsSUFBRixHQUFTLENBQWIsRUFBZ0I7QUFDZCxNQUFFLElBQUYsR0FBUyxDQUFDLEVBQUUsSUFBWjs7QUFFRDtBQUNELElBQUUsTUFBRixHQUFZLEVBQUUsSUFBRixHQUFTLFVBQVQsR0FBc0IsVUFBbEM7QUFDQSxPQUFLLEtBQUwsR0FBYyxFQUFFLElBQUYsS0FBVyxDQUFaLEdBQ1gsQztBQURXLElBR1gsQ0FIRixDO0FBSUEsSUFBRSxVQUFGLEdBQWUsVUFBZjtBQUNBLFFBQU0sUUFBTixDQUFlLENBQWY7QUFDQSxTQUFPLElBQVA7QUFDRDs7QUFHRCxTQUFTLFlBQVQsQ0FBc0IsSUFBdEIsRUFBNEI7QUFDMUIsTUFBSSxNQUFNLGlCQUFpQixJQUFqQixDQUFWO0FBQ0EsTUFBSSxRQUFRLElBQVosRUFBa0I7QUFDaEIsWUFBUSxLQUFLLEtBQWI7QUFDRDtBQUNELFNBQU8sR0FBUDtBQUNEOztBQUdELFNBQVMsZ0JBQVQsQ0FBMEIsSUFBMUIsRUFBZ0MsSUFBaEMsRUFBc0M7QUFDcEMsTUFBSSxDQUFDLElBQUQsSUFBUyxDQUFDLEtBQUssS0FBbkIsRUFBMEI7QUFBRSxXQUFPLGNBQVA7QUFBd0I7QUFDcEQsTUFBSSxLQUFLLEtBQUwsQ0FBVyxJQUFYLEtBQW9CLENBQXhCLEVBQTJCO0FBQUUsV0FBTyxjQUFQO0FBQXdCO0FBQ3JELE9BQUssS0FBTCxDQUFXLE1BQVgsR0FBb0IsSUFBcEI7QUFDQSxTQUFPLElBQVA7QUFDRDs7QUFHRCxTQUFTLFlBQVQsQ0FBc0IsSUFBdEIsRUFBNEIsS0FBNUIsRUFBbUMsTUFBbkMsRUFBMkMsVUFBM0MsRUFBdUQsUUFBdkQsRUFBaUUsUUFBakUsRUFBMkU7QUFDekUsTUFBSSxDQUFDLElBQUwsRUFBVzs7QUFDVCxXQUFPLGNBQVA7QUFDRDtBQUNELE1BQUksT0FBTyxDQUFYOztBQUVBLE1BQUksVUFBVSxxQkFBZCxFQUFxQztBQUNuQyxZQUFRLENBQVI7QUFDRDs7QUFFRCxNQUFJLGFBQWEsQ0FBakIsRUFBb0I7O0FBQ2xCLFdBQU8sQ0FBUDtBQUNBLGlCQUFhLENBQUMsVUFBZDtBQUNELEdBSEQsTUFLSyxJQUFJLGFBQWEsRUFBakIsRUFBcUI7QUFDeEIsV0FBTyxDQUFQLEM7QUFDQSxrQkFBYyxFQUFkO0FBQ0Q7O0FBR0QsTUFBSSxXQUFXLENBQVgsSUFBZ0IsV0FBVyxhQUEzQixJQUE0QyxXQUFXLFVBQXZELElBQ0YsYUFBYSxDQURYLElBQ2dCLGFBQWEsRUFEN0IsSUFDbUMsUUFBUSxDQUQzQyxJQUNnRCxRQUFRLENBRHhELElBRUYsV0FBVyxDQUZULElBRWMsV0FBVyxPQUY3QixFQUVzQztBQUNwQyxXQUFPLElBQUksSUFBSixFQUFVLGNBQVYsQ0FBUDtBQUNEOztBQUdELE1BQUksZUFBZSxDQUFuQixFQUFzQjtBQUNwQixpQkFBYSxDQUFiO0FBQ0Q7OztBQUdELE1BQUksSUFBSSxJQUFJLFlBQUosRUFBUjs7QUFFQSxPQUFLLEtBQUwsR0FBYSxDQUFiO0FBQ0EsSUFBRSxJQUFGLEdBQVMsSUFBVDs7QUFFQSxJQUFFLElBQUYsR0FBUyxJQUFUO0FBQ0EsSUFBRSxNQUFGLEdBQVcsSUFBWDtBQUNBLElBQUUsTUFBRixHQUFXLFVBQVg7QUFDQSxJQUFFLE1BQUYsR0FBVyxLQUFLLEVBQUUsTUFBbEI7QUFDQSxJQUFFLE1BQUYsR0FBVyxFQUFFLE1BQUYsR0FBVyxDQUF0Qjs7QUFFQSxJQUFFLFNBQUYsR0FBYyxXQUFXLENBQXpCO0FBQ0EsSUFBRSxTQUFGLEdBQWMsS0FBSyxFQUFFLFNBQXJCO0FBQ0EsSUFBRSxTQUFGLEdBQWMsRUFBRSxTQUFGLEdBQWMsQ0FBNUI7QUFDQSxJQUFFLFVBQUYsR0FBZSxDQUFDLEVBQUUsQ0FBQyxFQUFFLFNBQUYsR0FBYyxTQUFkLEdBQTBCLENBQTNCLElBQWdDLFNBQWxDLENBQWhCOztBQUVBLElBQUUsTUFBRixHQUFXLElBQUksTUFBTSxJQUFWLENBQWUsRUFBRSxNQUFGLEdBQVcsQ0FBMUIsQ0FBWDtBQUNBLElBQUUsSUFBRixHQUFTLElBQUksTUFBTSxLQUFWLENBQWdCLEVBQUUsU0FBbEIsQ0FBVDtBQUNBLElBQUUsSUFBRixHQUFTLElBQUksTUFBTSxLQUFWLENBQWdCLEVBQUUsTUFBbEIsQ0FBVDs7Ozs7QUFLQSxJQUFFLFdBQUYsR0FBZ0IsS0FBTSxXQUFXLENBQWpDLEM7O0FBRUEsSUFBRSxnQkFBRixHQUFxQixFQUFFLFdBQUYsR0FBZ0IsQ0FBckM7QUFDQSxJQUFFLFdBQUYsR0FBZ0IsSUFBSSxNQUFNLElBQVYsQ0FBZSxFQUFFLGdCQUFqQixDQUFoQjs7QUFFQSxJQUFFLEtBQUYsR0FBVSxFQUFFLFdBQUYsSUFBaUIsQ0FBM0I7QUFDQSxJQUFFLEtBQUYsR0FBVSxDQUFDLElBQUksQ0FBTCxJQUFVLEVBQUUsV0FBdEI7O0FBRUEsSUFBRSxLQUFGLEdBQVUsS0FBVjtBQUNBLElBQUUsUUFBRixHQUFhLFFBQWI7QUFDQSxJQUFFLE1BQUYsR0FBVyxNQUFYOztBQUVBLFNBQU8sYUFBYSxJQUFiLENBQVA7QUFDRDs7QUFFRCxTQUFTLFdBQVQsQ0FBcUIsSUFBckIsRUFBMkIsS0FBM0IsRUFBa0M7QUFDaEMsU0FBTyxhQUFhLElBQWIsRUFBbUIsS0FBbkIsRUFBMEIsVUFBMUIsRUFBc0MsU0FBdEMsRUFBaUQsYUFBakQsRUFBZ0Usa0JBQWhFLENBQVA7QUFDRDs7QUFHRCxTQUFTLE9BQVQsQ0FBaUIsSUFBakIsRUFBdUIsS0FBdkIsRUFBOEI7QUFDNUIsTUFBSSxTQUFKLEVBQWUsQ0FBZjtBQUNBLE1BQUksR0FBSixFQUFTLEdBQVQsQzs7QUFFQSxNQUFJLENBQUMsSUFBRCxJQUFTLENBQUMsS0FBSyxLQUFmLElBQ0YsUUFBUSxPQUROLElBQ2lCLFFBQVEsQ0FEN0IsRUFDZ0M7QUFDOUIsV0FBTyxPQUFPLElBQUksSUFBSixFQUFVLGNBQVYsQ0FBUCxHQUFtQyxjQUExQztBQUNEOztBQUVELE1BQUksS0FBSyxLQUFUOztBQUVBLE1BQUksQ0FBQyxLQUFLLE1BQU4sSUFDQyxDQUFDLEtBQUssS0FBTixJQUFlLEtBQUssUUFBTCxLQUFrQixDQURsQyxJQUVDLEVBQUUsTUFBRixLQUFhLFlBQWIsSUFBNkIsVUFBVSxRQUY1QyxFQUV1RDtBQUNyRCxXQUFPLElBQUksSUFBSixFQUFXLEtBQUssU0FBTCxLQUFtQixDQUFwQixHQUF5QixXQUF6QixHQUF1QyxjQUFqRCxDQUFQO0FBQ0Q7O0FBRUQsSUFBRSxJQUFGLEdBQVMsSUFBVCxDO0FBQ0EsY0FBWSxFQUFFLFVBQWQ7QUFDQSxJQUFFLFVBQUYsR0FBZSxLQUFmOzs7QUFHQSxNQUFJLEVBQUUsTUFBRixLQUFhLFVBQWpCLEVBQTZCOztBQUUzQixRQUFJLEVBQUUsSUFBRixLQUFXLENBQWYsRUFBa0I7O0FBQ2hCLFdBQUssS0FBTCxHQUFhLENBQWIsQztBQUNBLGVBQVMsQ0FBVCxFQUFZLEVBQVo7QUFDQSxlQUFTLENBQVQsRUFBWSxHQUFaO0FBQ0EsZUFBUyxDQUFULEVBQVksQ0FBWjtBQUNBLFVBQUksQ0FBQyxFQUFFLE1BQVAsRUFBZTs7QUFDYixpQkFBUyxDQUFULEVBQVksQ0FBWjtBQUNBLGlCQUFTLENBQVQsRUFBWSxDQUFaO0FBQ0EsaUJBQVMsQ0FBVCxFQUFZLENBQVo7QUFDQSxpQkFBUyxDQUFULEVBQVksQ0FBWjtBQUNBLGlCQUFTLENBQVQsRUFBWSxDQUFaO0FBQ0EsaUJBQVMsQ0FBVCxFQUFZLEVBQUUsS0FBRixLQUFZLENBQVosR0FBZ0IsQ0FBaEIsR0FDQyxFQUFFLFFBQUYsSUFBYyxjQUFkLElBQWdDLEVBQUUsS0FBRixHQUFVLENBQTFDLEdBQ0EsQ0FEQSxHQUNJLENBRmpCO0FBR0EsaUJBQVMsQ0FBVCxFQUFZLE9BQVo7QUFDQSxVQUFFLE1BQUYsR0FBVyxVQUFYO0FBQ0QsT0FYRCxNQVlLO0FBQ0gsaUJBQVMsQ0FBVCxFQUFZLENBQUMsRUFBRSxNQUFGLENBQVMsSUFBVCxHQUFnQixDQUFoQixHQUFvQixDQUFyQixLQUNDLEVBQUUsTUFBRixDQUFTLElBQVQsR0FBZ0IsQ0FBaEIsR0FBb0IsQ0FEckIsS0FFQyxDQUFDLEVBQUUsTUFBRixDQUFTLEtBQVYsR0FBa0IsQ0FBbEIsR0FBc0IsQ0FGdkIsS0FHQyxDQUFDLEVBQUUsTUFBRixDQUFTLElBQVYsR0FBaUIsQ0FBakIsR0FBcUIsQ0FIdEIsS0FJQyxDQUFDLEVBQUUsTUFBRixDQUFTLE9BQVYsR0FBb0IsQ0FBcEIsR0FBd0IsRUFKekIsQ0FBWjtBQU1BLGlCQUFTLENBQVQsRUFBWSxFQUFFLE1BQUYsQ0FBUyxJQUFULEdBQWdCLElBQTVCO0FBQ0EsaUJBQVMsQ0FBVCxFQUFhLEVBQUUsTUFBRixDQUFTLElBQVQsSUFBaUIsQ0FBbEIsR0FBdUIsSUFBbkM7QUFDQSxpQkFBUyxDQUFULEVBQWEsRUFBRSxNQUFGLENBQVMsSUFBVCxJQUFpQixFQUFsQixHQUF3QixJQUFwQztBQUNBLGlCQUFTLENBQVQsRUFBYSxFQUFFLE1BQUYsQ0FBUyxJQUFULElBQWlCLEVBQWxCLEdBQXdCLElBQXBDO0FBQ0EsaUJBQVMsQ0FBVCxFQUFZLEVBQUUsS0FBRixLQUFZLENBQVosR0FBZ0IsQ0FBaEIsR0FDQyxFQUFFLFFBQUYsSUFBYyxjQUFkLElBQWdDLEVBQUUsS0FBRixHQUFVLENBQTFDLEdBQ0EsQ0FEQSxHQUNJLENBRmpCO0FBR0EsaUJBQVMsQ0FBVCxFQUFZLEVBQUUsTUFBRixDQUFTLEVBQVQsR0FBYyxJQUExQjtBQUNBLFlBQUksRUFBRSxNQUFGLENBQVMsS0FBVCxJQUFrQixFQUFFLE1BQUYsQ0FBUyxLQUFULENBQWUsTUFBckMsRUFBNkM7QUFDM0MsbUJBQVMsQ0FBVCxFQUFZLEVBQUUsTUFBRixDQUFTLEtBQVQsQ0FBZSxNQUFmLEdBQXdCLElBQXBDO0FBQ0EsbUJBQVMsQ0FBVCxFQUFhLEVBQUUsTUFBRixDQUFTLEtBQVQsQ0FBZSxNQUFmLElBQXlCLENBQTFCLEdBQStCLElBQTNDO0FBQ0Q7QUFDRCxZQUFJLEVBQUUsTUFBRixDQUFTLElBQWIsRUFBbUI7QUFDakIsZUFBSyxLQUFMLEdBQWEsTUFBTSxLQUFLLEtBQVgsRUFBa0IsRUFBRSxXQUFwQixFQUFpQyxFQUFFLE9BQW5DLEVBQTRDLENBQTVDLENBQWI7QUFDRDtBQUNELFVBQUUsT0FBRixHQUFZLENBQVo7QUFDQSxVQUFFLE1BQUYsR0FBVyxXQUFYO0FBQ0Q7QUFDRixLQTFDRCxNO0FBNENBO0FBQ0UsWUFBSSxTQUFVLGNBQWUsRUFBRSxNQUFGLEdBQVcsQ0FBWixJQUFrQixDQUFoQyxDQUFELElBQXdDLENBQXJEO0FBQ0EsWUFBSSxjQUFjLENBQUMsQ0FBbkI7O0FBRUEsWUFBSSxFQUFFLFFBQUYsSUFBYyxjQUFkLElBQWdDLEVBQUUsS0FBRixHQUFVLENBQTlDLEVBQWlEO0FBQy9DLHdCQUFjLENBQWQ7QUFDRCxTQUZELE1BRU8sSUFBSSxFQUFFLEtBQUYsR0FBVSxDQUFkLEVBQWlCO0FBQ3RCLHdCQUFjLENBQWQ7QUFDRCxTQUZNLE1BRUEsSUFBSSxFQUFFLEtBQUYsS0FBWSxDQUFoQixFQUFtQjtBQUN4Qix3QkFBYyxDQUFkO0FBQ0QsU0FGTSxNQUVBO0FBQ0wsd0JBQWMsQ0FBZDtBQUNEO0FBQ0Qsa0JBQVcsZUFBZSxDQUExQjtBQUNBLFlBQUksRUFBRSxRQUFGLEtBQWUsQ0FBbkIsRUFBc0I7QUFBRSxvQkFBVSxXQUFWO0FBQXdCO0FBQ2hELGtCQUFVLEtBQU0sU0FBUyxFQUF6Qjs7QUFFQSxVQUFFLE1BQUYsR0FBVyxVQUFYO0FBQ0Esb0JBQVksQ0FBWixFQUFlLE1BQWY7OztBQUdBLFlBQUksRUFBRSxRQUFGLEtBQWUsQ0FBbkIsRUFBc0I7QUFDcEIsc0JBQVksQ0FBWixFQUFlLEtBQUssS0FBTCxLQUFlLEVBQTlCO0FBQ0Esc0JBQVksQ0FBWixFQUFlLEtBQUssS0FBTCxHQUFhLE1BQTVCO0FBQ0Q7QUFDRCxhQUFLLEtBQUwsR0FBYSxDQUFiLEM7QUFDRDtBQUNGOzs7QUFHRCxNQUFJLEVBQUUsTUFBRixLQUFhLFdBQWpCLEVBQThCO0FBQzVCLFFBQUksRUFBRSxNQUFGLENBQVMsSyxlQUFiLEVBQWtDO0FBQ2hDLGNBQU0sRUFBRSxPQUFSLEM7O0FBRUEsZUFBTyxFQUFFLE9BQUYsSUFBYSxFQUFFLE1BQUYsQ0FBUyxLQUFULENBQWUsTUFBZixHQUF3QixNQUFyQyxDQUFQLEVBQXFEO0FBQ25ELGNBQUksRUFBRSxPQUFGLEtBQWMsRUFBRSxnQkFBcEIsRUFBc0M7QUFDcEMsZ0JBQUksRUFBRSxNQUFGLENBQVMsSUFBVCxJQUFpQixFQUFFLE9BQUYsR0FBWSxHQUFqQyxFQUFzQztBQUNwQyxtQkFBSyxLQUFMLEdBQWEsTUFBTSxLQUFLLEtBQVgsRUFBa0IsRUFBRSxXQUFwQixFQUFpQyxFQUFFLE9BQUYsR0FBWSxHQUE3QyxFQUFrRCxHQUFsRCxDQUFiO0FBQ0Q7QUFDRCwwQkFBYyxJQUFkO0FBQ0Esa0JBQU0sRUFBRSxPQUFSO0FBQ0EsZ0JBQUksRUFBRSxPQUFGLEtBQWMsRUFBRSxnQkFBcEIsRUFBc0M7QUFDcEM7QUFDRDtBQUNGO0FBQ0QsbUJBQVMsQ0FBVCxFQUFZLEVBQUUsTUFBRixDQUFTLEtBQVQsQ0FBZSxFQUFFLE9BQWpCLElBQTRCLElBQXhDO0FBQ0EsWUFBRSxPQUFGO0FBQ0Q7QUFDRCxZQUFJLEVBQUUsTUFBRixDQUFTLElBQVQsSUFBaUIsRUFBRSxPQUFGLEdBQVksR0FBakMsRUFBc0M7QUFDcEMsZUFBSyxLQUFMLEdBQWEsTUFBTSxLQUFLLEtBQVgsRUFBa0IsRUFBRSxXQUFwQixFQUFpQyxFQUFFLE9BQUYsR0FBWSxHQUE3QyxFQUFrRCxHQUFsRCxDQUFiO0FBQ0Q7QUFDRCxZQUFJLEVBQUUsT0FBRixLQUFjLEVBQUUsTUFBRixDQUFTLEtBQVQsQ0FBZSxNQUFqQyxFQUF5QztBQUN2QyxZQUFFLE9BQUYsR0FBWSxDQUFaO0FBQ0EsWUFBRSxNQUFGLEdBQVcsVUFBWDtBQUNEO0FBQ0YsT0F4QkQsTUF5Qks7QUFDSCxRQUFFLE1BQUYsR0FBVyxVQUFYO0FBQ0Q7QUFDRjtBQUNELE1BQUksRUFBRSxNQUFGLEtBQWEsVUFBakIsRUFBNkI7QUFDM0IsUUFBSSxFQUFFLE1BQUYsQ0FBUyxJLGVBQWIsRUFBaUM7QUFDL0IsY0FBTSxFQUFFLE9BQVIsQzs7O0FBR0EsV0FBRztBQUNELGNBQUksRUFBRSxPQUFGLEtBQWMsRUFBRSxnQkFBcEIsRUFBc0M7QUFDcEMsZ0JBQUksRUFBRSxNQUFGLENBQVMsSUFBVCxJQUFpQixFQUFFLE9BQUYsR0FBWSxHQUFqQyxFQUFzQztBQUNwQyxtQkFBSyxLQUFMLEdBQWEsTUFBTSxLQUFLLEtBQVgsRUFBa0IsRUFBRSxXQUFwQixFQUFpQyxFQUFFLE9BQUYsR0FBWSxHQUE3QyxFQUFrRCxHQUFsRCxDQUFiO0FBQ0Q7QUFDRCwwQkFBYyxJQUFkO0FBQ0Esa0JBQU0sRUFBRSxPQUFSO0FBQ0EsZ0JBQUksRUFBRSxPQUFGLEtBQWMsRUFBRSxnQkFBcEIsRUFBc0M7QUFDcEMsb0JBQU0sQ0FBTjtBQUNBO0FBQ0Q7QUFDRjs7QUFFRCxjQUFJLEVBQUUsT0FBRixHQUFZLEVBQUUsTUFBRixDQUFTLElBQVQsQ0FBYyxNQUE5QixFQUFzQztBQUNwQyxrQkFBTSxFQUFFLE1BQUYsQ0FBUyxJQUFULENBQWMsVUFBZCxDQUF5QixFQUFFLE9BQUYsRUFBekIsSUFBd0MsSUFBOUM7QUFDRCxXQUZELE1BRU87QUFDTCxrQkFBTSxDQUFOO0FBQ0Q7QUFDRCxtQkFBUyxDQUFULEVBQVksR0FBWjtBQUNELFNBbkJELFFBbUJTLFFBQVEsQ0FuQmpCOztBQXFCQSxZQUFJLEVBQUUsTUFBRixDQUFTLElBQVQsSUFBaUIsRUFBRSxPQUFGLEdBQVksR0FBakMsRUFBc0M7QUFDcEMsZUFBSyxLQUFMLEdBQWEsTUFBTSxLQUFLLEtBQVgsRUFBa0IsRUFBRSxXQUFwQixFQUFpQyxFQUFFLE9BQUYsR0FBWSxHQUE3QyxFQUFrRCxHQUFsRCxDQUFiO0FBQ0Q7QUFDRCxZQUFJLFFBQVEsQ0FBWixFQUFlO0FBQ2IsWUFBRSxPQUFGLEdBQVksQ0FBWjtBQUNBLFlBQUUsTUFBRixHQUFXLGFBQVg7QUFDRDtBQUNGLE9BaENELE1BaUNLO0FBQ0gsUUFBRSxNQUFGLEdBQVcsYUFBWDtBQUNEO0FBQ0Y7QUFDRCxNQUFJLEVBQUUsTUFBRixLQUFhLGFBQWpCLEVBQWdDO0FBQzlCLFFBQUksRUFBRSxNQUFGLENBQVMsTyxlQUFiLEVBQW9DO0FBQ2xDLGNBQU0sRUFBRSxPQUFSLEM7OztBQUdBLFdBQUc7QUFDRCxjQUFJLEVBQUUsT0FBRixLQUFjLEVBQUUsZ0JBQXBCLEVBQXNDO0FBQ3BDLGdCQUFJLEVBQUUsTUFBRixDQUFTLElBQVQsSUFBaUIsRUFBRSxPQUFGLEdBQVksR0FBakMsRUFBc0M7QUFDcEMsbUJBQUssS0FBTCxHQUFhLE1BQU0sS0FBSyxLQUFYLEVBQWtCLEVBQUUsV0FBcEIsRUFBaUMsRUFBRSxPQUFGLEdBQVksR0FBN0MsRUFBa0QsR0FBbEQsQ0FBYjtBQUNEO0FBQ0QsMEJBQWMsSUFBZDtBQUNBLGtCQUFNLEVBQUUsT0FBUjtBQUNBLGdCQUFJLEVBQUUsT0FBRixLQUFjLEVBQUUsZ0JBQXBCLEVBQXNDO0FBQ3BDLG9CQUFNLENBQU47QUFDQTtBQUNEO0FBQ0Y7O0FBRUQsY0FBSSxFQUFFLE9BQUYsR0FBWSxFQUFFLE1BQUYsQ0FBUyxPQUFULENBQWlCLE1BQWpDLEVBQXlDO0FBQ3ZDLGtCQUFNLEVBQUUsTUFBRixDQUFTLE9BQVQsQ0FBaUIsVUFBakIsQ0FBNEIsRUFBRSxPQUFGLEVBQTVCLElBQTJDLElBQWpEO0FBQ0QsV0FGRCxNQUVPO0FBQ0wsa0JBQU0sQ0FBTjtBQUNEO0FBQ0QsbUJBQVMsQ0FBVCxFQUFZLEdBQVo7QUFDRCxTQW5CRCxRQW1CUyxRQUFRLENBbkJqQjs7QUFxQkEsWUFBSSxFQUFFLE1BQUYsQ0FBUyxJQUFULElBQWlCLEVBQUUsT0FBRixHQUFZLEdBQWpDLEVBQXNDO0FBQ3BDLGVBQUssS0FBTCxHQUFhLE1BQU0sS0FBSyxLQUFYLEVBQWtCLEVBQUUsV0FBcEIsRUFBaUMsRUFBRSxPQUFGLEdBQVksR0FBN0MsRUFBa0QsR0FBbEQsQ0FBYjtBQUNEO0FBQ0QsWUFBSSxRQUFRLENBQVosRUFBZTtBQUNiLFlBQUUsTUFBRixHQUFXLFVBQVg7QUFDRDtBQUNGLE9BL0JELE1BZ0NLO0FBQ0gsUUFBRSxNQUFGLEdBQVcsVUFBWDtBQUNEO0FBQ0Y7QUFDRCxNQUFJLEVBQUUsTUFBRixLQUFhLFVBQWpCLEVBQTZCO0FBQzNCLFFBQUksRUFBRSxNQUFGLENBQVMsSUFBYixFQUFtQjtBQUNqQixVQUFJLEVBQUUsT0FBRixHQUFZLENBQVosR0FBZ0IsRUFBRSxnQkFBdEIsRUFBd0M7QUFDdEMsc0JBQWMsSUFBZDtBQUNEO0FBQ0QsVUFBSSxFQUFFLE9BQUYsR0FBWSxDQUFaLElBQWlCLEVBQUUsZ0JBQXZCLEVBQXlDO0FBQ3ZDLGlCQUFTLENBQVQsRUFBWSxLQUFLLEtBQUwsR0FBYSxJQUF6QjtBQUNBLGlCQUFTLENBQVQsRUFBYSxLQUFLLEtBQUwsSUFBYyxDQUFmLEdBQW9CLElBQWhDO0FBQ0EsYUFBSyxLQUFMLEdBQWEsQ0FBYixDO0FBQ0EsVUFBRSxNQUFGLEdBQVcsVUFBWDtBQUNEO0FBQ0YsS0FWRCxNQVdLO0FBQ0gsUUFBRSxNQUFGLEdBQVcsVUFBWDtBQUNEO0FBQ0Y7Ozs7QUFJRCxNQUFJLEVBQUUsT0FBRixLQUFjLENBQWxCLEVBQXFCO0FBQ25CLGtCQUFjLElBQWQ7QUFDQSxRQUFJLEtBQUssU0FBTCxLQUFtQixDQUF2QixFQUEwQjs7Ozs7OztBQU94QixRQUFFLFVBQUYsR0FBZSxDQUFDLENBQWhCO0FBQ0EsYUFBTyxJQUFQO0FBQ0Q7Ozs7OztBQU1GLEdBakJELE1BaUJPLElBQUksS0FBSyxRQUFMLEtBQWtCLENBQWxCLElBQXVCLEtBQUssS0FBTCxLQUFlLEtBQUssU0FBTCxDQUF0QyxJQUNULFVBQVUsUUFETCxFQUNlO0FBQ3BCLFdBQU8sSUFBSSxJQUFKLEVBQVUsV0FBVixDQUFQO0FBQ0Q7OztBQUdELE1BQUksRUFBRSxNQUFGLEtBQWEsWUFBYixJQUE2QixLQUFLLFFBQUwsS0FBa0IsQ0FBbkQsRUFBc0Q7QUFDcEQsV0FBTyxJQUFJLElBQUosRUFBVSxXQUFWLENBQVA7QUFDRDs7OztBQUlELE1BQUksS0FBSyxRQUFMLEtBQWtCLENBQWxCLElBQXVCLEVBQUUsU0FBRixLQUFnQixDQUF2QyxJQUNELFVBQVUsVUFBVixJQUF3QixFQUFFLE1BQUYsS0FBYSxZQUR4QyxFQUN1RDtBQUNyRCxRQUFJLFNBQVUsRUFBRSxRQUFGLEtBQWUsY0FBaEIsR0FBa0MsYUFBYSxDQUFiLEVBQWdCLEtBQWhCLENBQWxDLEdBQ1YsRUFBRSxRQUFGLEtBQWUsS0FBZixHQUF1QixZQUFZLENBQVosRUFBZSxLQUFmLENBQXZCLEdBQ0Msb0JBQW9CLEVBQUUsS0FBdEIsRUFBNkIsSUFBN0IsQ0FBa0MsQ0FBbEMsRUFBcUMsS0FBckMsQ0FGSjs7QUFJQSxRQUFJLFdBQVcsaUJBQVgsSUFBZ0MsV0FBVyxjQUEvQyxFQUErRDtBQUM3RCxRQUFFLE1BQUYsR0FBVyxZQUFYO0FBQ0Q7QUFDRCxRQUFJLFdBQVcsWUFBWCxJQUEyQixXQUFXLGlCQUExQyxFQUE2RDtBQUMzRCxVQUFJLEtBQUssU0FBTCxLQUFtQixDQUF2QixFQUEwQjtBQUN4QixVQUFFLFVBQUYsR0FBZSxDQUFDLENBQWhCOztBQUVEO0FBQ0QsYUFBTyxJQUFQOzs7Ozs7OztBQVFEO0FBQ0QsUUFBSSxXQUFXLGFBQWYsRUFBOEI7QUFDNUIsVUFBSSxVQUFVLGVBQWQsRUFBK0I7QUFDN0IsY0FBTSxTQUFOLENBQWdCLENBQWhCO0FBQ0QsT0FGRCxNQUdLLElBQUksVUFBVSxPQUFkLEVBQXVCOzs7QUFFMUIsY0FBTSxnQkFBTixDQUF1QixDQUF2QixFQUEwQixDQUExQixFQUE2QixDQUE3QixFQUFnQyxLQUFoQzs7OztBQUlBLFlBQUksVUFBVSxZQUFkLEVBQTRCOztBQUUxQixlQUFLLEVBQUUsSUFBUCxFOztBQUVBLGNBQUksRUFBRSxTQUFGLEtBQWdCLENBQXBCLEVBQXVCO0FBQ3JCLGNBQUUsUUFBRixHQUFhLENBQWI7QUFDQSxjQUFFLFdBQUYsR0FBZ0IsQ0FBaEI7QUFDQSxjQUFFLE1BQUYsR0FBVyxDQUFYO0FBQ0Q7QUFDRjtBQUNGO0FBQ0Qsb0JBQWMsSUFBZDtBQUNBLFVBQUksS0FBSyxTQUFMLEtBQW1CLENBQXZCLEVBQTBCO0FBQ3hCLFVBQUUsVUFBRixHQUFlLENBQUMsQ0FBaEIsQztBQUNBLGVBQU8sSUFBUDtBQUNEO0FBQ0Y7QUFDRjs7OztBQUlELE1BQUksVUFBVSxRQUFkLEVBQXdCO0FBQUUsV0FBTyxJQUFQO0FBQWM7QUFDeEMsTUFBSSxFQUFFLElBQUYsSUFBVSxDQUFkLEVBQWlCO0FBQUUsV0FBTyxZQUFQO0FBQXNCOzs7QUFHekMsTUFBSSxFQUFFLElBQUYsS0FBVyxDQUFmLEVBQWtCO0FBQ2hCLGFBQVMsQ0FBVCxFQUFZLEtBQUssS0FBTCxHQUFhLElBQXpCO0FBQ0EsYUFBUyxDQUFULEVBQWEsS0FBSyxLQUFMLElBQWMsQ0FBZixHQUFvQixJQUFoQztBQUNBLGFBQVMsQ0FBVCxFQUFhLEtBQUssS0FBTCxJQUFjLEVBQWYsR0FBcUIsSUFBakM7QUFDQSxhQUFTLENBQVQsRUFBYSxLQUFLLEtBQUwsSUFBYyxFQUFmLEdBQXFCLElBQWpDO0FBQ0EsYUFBUyxDQUFULEVBQVksS0FBSyxRQUFMLEdBQWdCLElBQTVCO0FBQ0EsYUFBUyxDQUFULEVBQWEsS0FBSyxRQUFMLElBQWlCLENBQWxCLEdBQXVCLElBQW5DO0FBQ0EsYUFBUyxDQUFULEVBQWEsS0FBSyxRQUFMLElBQWlCLEVBQWxCLEdBQXdCLElBQXBDO0FBQ0EsYUFBUyxDQUFULEVBQWEsS0FBSyxRQUFMLElBQWlCLEVBQWxCLEdBQXdCLElBQXBDO0FBQ0QsR0FURCxNQVdBO0FBQ0UsZ0JBQVksQ0FBWixFQUFlLEtBQUssS0FBTCxLQUFlLEVBQTlCO0FBQ0EsZ0JBQVksQ0FBWixFQUFlLEtBQUssS0FBTCxHQUFhLE1BQTVCO0FBQ0Q7O0FBRUQsZ0JBQWMsSUFBZDs7OztBQUlBLE1BQUksRUFBRSxJQUFGLEdBQVMsQ0FBYixFQUFnQjtBQUFFLE1BQUUsSUFBRixHQUFTLENBQUMsRUFBRSxJQUFaO0FBQW1COztBQUVyQyxTQUFPLEVBQUUsT0FBRixLQUFjLENBQWQsR0FBa0IsSUFBbEIsR0FBeUIsWUFBaEM7QUFDRDs7QUFFRCxTQUFTLFVBQVQsQ0FBb0IsSUFBcEIsRUFBMEI7QUFDeEIsTUFBSSxNQUFKOztBQUVBLE1BQUksQ0FBQyxJLGNBQUQsSUFBc0IsQ0FBQyxLQUFLLEssY0FBaEMsRUFBb0Q7QUFDbEQsYUFBTyxjQUFQO0FBQ0Q7O0FBRUQsV0FBUyxLQUFLLEtBQUwsQ0FBVyxNQUFwQjtBQUNBLE1BQUksV0FBVyxVQUFYLElBQ0YsV0FBVyxXQURULElBRUYsV0FBVyxVQUZULElBR0YsV0FBVyxhQUhULElBSUYsV0FBVyxVQUpULElBS0YsV0FBVyxVQUxULElBTUYsV0FBVyxZQU5iLEVBT0U7QUFDQSxXQUFPLElBQUksSUFBSixFQUFVLGNBQVYsQ0FBUDtBQUNEOztBQUVELE9BQUssS0FBTCxHQUFhLElBQWI7O0FBRUEsU0FBTyxXQUFXLFVBQVgsR0FBd0IsSUFBSSxJQUFKLEVBQVUsWUFBVixDQUF4QixHQUFrRCxJQUF6RDtBQUNEOzs7Ozs7QUFPRCxTQUFTLG9CQUFULENBQThCLElBQTlCLEVBQW9DLFVBQXBDLEVBQWdEO0FBQzlDLE1BQUksYUFBYSxXQUFXLE1BQTVCOztBQUVBLE1BQUksQ0FBSjtBQUNBLE1BQUksR0FBSixFQUFTLENBQVQ7QUFDQSxNQUFJLElBQUo7QUFDQSxNQUFJLEtBQUo7QUFDQSxNQUFJLElBQUo7QUFDQSxNQUFJLEtBQUo7QUFDQSxNQUFJLE9BQUo7O0FBRUEsTUFBSSxDQUFDLEksY0FBRCxJQUFzQixDQUFDLEtBQUssSyxjQUFoQyxFQUFvRDtBQUNsRCxhQUFPLGNBQVA7QUFDRDs7QUFFRCxNQUFJLEtBQUssS0FBVDtBQUNBLFNBQU8sRUFBRSxJQUFUOztBQUVBLE1BQUksU0FBUyxDQUFULElBQWUsU0FBUyxDQUFULElBQWMsRUFBRSxNQUFGLEtBQWEsVUFBMUMsSUFBeUQsRUFBRSxTQUEvRCxFQUEwRTtBQUN4RSxXQUFPLGNBQVA7QUFDRDs7O0FBR0QsTUFBSSxTQUFTLENBQWIsRUFBZ0I7O0FBRWQsU0FBSyxLQUFMLEdBQWEsUUFBUSxLQUFLLEtBQWIsRUFBb0IsVUFBcEIsRUFBZ0MsVUFBaEMsRUFBNEMsQ0FBNUMsQ0FBYjtBQUNEOztBQUVELElBQUUsSUFBRixHQUFTLENBQVQsQzs7O0FBR0EsTUFBSSxjQUFjLEVBQUUsTUFBcEIsRUFBNEI7QUFDMUIsUUFBSSxTQUFTLENBQWIsRUFBZ0I7OztBQUVkLFdBQUssRUFBRSxJQUFQLEU7QUFDQSxRQUFFLFFBQUYsR0FBYSxDQUFiO0FBQ0EsUUFBRSxXQUFGLEdBQWdCLENBQWhCO0FBQ0EsUUFBRSxNQUFGLEdBQVcsQ0FBWDtBQUNEOzs7QUFHRCxjQUFVLElBQUksTUFBTSxJQUFWLENBQWUsRUFBRSxNQUFqQixDQUFWO0FBQ0EsVUFBTSxRQUFOLENBQWUsT0FBZixFQUF3QixVQUF4QixFQUFvQyxhQUFhLEVBQUUsTUFBbkQsRUFBMkQsRUFBRSxNQUE3RCxFQUFxRSxDQUFyRTtBQUNBLGlCQUFhLE9BQWI7QUFDQSxpQkFBYSxFQUFFLE1BQWY7QUFDRDs7QUFFRCxVQUFRLEtBQUssUUFBYjtBQUNBLFNBQU8sS0FBSyxPQUFaO0FBQ0EsVUFBUSxLQUFLLEtBQWI7QUFDQSxPQUFLLFFBQUwsR0FBZ0IsVUFBaEI7QUFDQSxPQUFLLE9BQUwsR0FBZSxDQUFmO0FBQ0EsT0FBSyxLQUFMLEdBQWEsVUFBYjtBQUNBLGNBQVksQ0FBWjtBQUNBLFNBQU8sRUFBRSxTQUFGLElBQWUsU0FBdEIsRUFBaUM7QUFDL0IsVUFBTSxFQUFFLFFBQVI7QUFDQSxRQUFJLEVBQUUsU0FBRixJQUFlLFlBQVksQ0FBM0IsQ0FBSjtBQUNBLE9BQUc7O0FBRUQsUUFBRSxLQUFGLEdBQVUsQ0FBRSxFQUFFLEtBQUYsSUFBVyxFQUFFLFVBQWQsR0FBNEIsRUFBRSxNQUFGLENBQVMsTUFBTSxTQUFOLEdBQWtCLENBQTNCLENBQTdCLElBQThELEVBQUUsU0FBMUU7O0FBRUEsUUFBRSxJQUFGLENBQU8sTUFBTSxFQUFFLE1BQWYsSUFBeUIsRUFBRSxJQUFGLENBQU8sRUFBRSxLQUFULENBQXpCOztBQUVBLFFBQUUsSUFBRixDQUFPLEVBQUUsS0FBVCxJQUFrQixHQUFsQjtBQUNBO0FBQ0QsS0FSRCxRQVFTLEVBQUUsQ0FSWDtBQVNBLE1BQUUsUUFBRixHQUFhLEdBQWI7QUFDQSxNQUFFLFNBQUYsR0FBYyxZQUFZLENBQTFCO0FBQ0EsZ0JBQVksQ0FBWjtBQUNEO0FBQ0QsSUFBRSxRQUFGLElBQWMsRUFBRSxTQUFoQjtBQUNBLElBQUUsV0FBRixHQUFnQixFQUFFLFFBQWxCO0FBQ0EsSUFBRSxNQUFGLEdBQVcsRUFBRSxTQUFiO0FBQ0EsSUFBRSxTQUFGLEdBQWMsQ0FBZDtBQUNBLElBQUUsWUFBRixHQUFpQixFQUFFLFdBQUYsR0FBZ0IsWUFBWSxDQUE3QztBQUNBLElBQUUsZUFBRixHQUFvQixDQUFwQjtBQUNBLE9BQUssT0FBTCxHQUFlLElBQWY7QUFDQSxPQUFLLEtBQUwsR0FBYSxLQUFiO0FBQ0EsT0FBSyxRQUFMLEdBQWdCLEtBQWhCO0FBQ0EsSUFBRSxJQUFGLEdBQVMsSUFBVDtBQUNBLFNBQU8sSUFBUDtBQUNEOztBQUdELFFBQVEsV0FBUixHQUFzQixXQUF0QjtBQUNBLFFBQVEsWUFBUixHQUF1QixZQUF2QjtBQUNBLFFBQVEsWUFBUixHQUF1QixZQUF2QjtBQUNBLFFBQVEsZ0JBQVIsR0FBMkIsZ0JBQTNCO0FBQ0EsUUFBUSxnQkFBUixHQUEyQixnQkFBM0I7QUFDQSxRQUFRLE9BQVIsR0FBa0IsT0FBbEI7QUFDQSxRQUFRLFVBQVIsR0FBcUIsVUFBckI7QUFDQSxRQUFRLG9CQUFSLEdBQStCLG9CQUEvQjtBQUNBLFFBQVEsV0FBUixHQUFzQixvQ0FBdEI7Ozs7Ozs7Ozs7OztBQzl5REE7O0FBR0EsU0FBUyxRQUFULEdBQW9COztBQUVsQixPQUFLLElBQUwsR0FBa0IsQ0FBbEI7O0FBRUEsT0FBSyxJQUFMLEdBQWtCLENBQWxCOztBQUVBLE9BQUssTUFBTCxHQUFrQixDQUFsQjs7QUFFQSxPQUFLLEVBQUwsR0FBa0IsQ0FBbEI7O0FBRUEsT0FBSyxLQUFMLEdBQWtCLElBQWxCOztBQUVBLE9BQUssU0FBTCxHQUFrQixDQUFsQixDOzs7Ozs7Ozs7OztBQVdBLE9BQUssSUFBTCxHQUFrQixFQUFsQjs7OztBQUlBLE9BQUssT0FBTCxHQUFrQixFQUFsQjs7OztBQUlBLE9BQUssSUFBTCxHQUFrQixDQUFsQjs7QUFFQSxPQUFLLElBQUwsR0FBa0IsS0FBbEI7QUFDRDs7QUFFRCxPQUFPLE9BQVAsR0FBaUIsUUFBakI7OztBQ3ZDQTs7OztBQUdBLElBQUksTUFBTSxFQUFWLEM7QUFDQSxJQUFJLE9BQU8sRUFBWCxDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBcUNBLE9BQU8sT0FBUCxHQUFpQixTQUFTLFlBQVQsQ0FBc0IsSUFBdEIsRUFBNEIsS0FBNUIsRUFBbUM7QUFDbEQsTUFBSSxLQUFKO0FBQ0EsTUFBSSxHQUFKLEM7QUFDQSxNQUFJLElBQUosQztBQUNBLE1BQUksSUFBSixDO0FBQ0EsTUFBSSxHQUFKLEM7QUFDQSxNQUFJLEdBQUosQzs7QUFFQSxNQUFJLElBQUosQzs7QUFFQSxNQUFJLEtBQUosQztBQUNBLE1BQUksS0FBSixDO0FBQ0EsTUFBSSxLQUFKLEM7O0FBRUEsTUFBSSxRQUFKLEM7QUFDQSxNQUFJLElBQUosQztBQUNBLE1BQUksSUFBSixDO0FBQ0EsTUFBSSxLQUFKLEM7QUFDQSxNQUFJLEtBQUosQztBQUNBLE1BQUksS0FBSixDO0FBQ0EsTUFBSSxLQUFKLEM7QUFDQSxNQUFJLElBQUosQztBQUNBLE1BQUksRUFBSixDOztBQUVBLE1BQUksR0FBSixDO0FBQ0EsTUFBSSxJQUFKLEM7QUFDQSxNQUFJLElBQUosQztBQUNBLE1BQUksV0FBSjs7QUFHQSxNQUFJLEtBQUosRUFBVyxNQUFYLEM7OztBQUdBLFVBQVEsS0FBSyxLQUFiOztBQUVBLFFBQU0sS0FBSyxPQUFYO0FBQ0EsVUFBUSxLQUFLLEtBQWI7QUFDQSxTQUFPLE9BQU8sS0FBSyxRQUFMLEdBQWdCLENBQXZCLENBQVA7QUFDQSxTQUFPLEtBQUssUUFBWjtBQUNBLFdBQVMsS0FBSyxNQUFkO0FBQ0EsUUFBTSxRQUFRLFFBQVEsS0FBSyxTQUFyQixDQUFOO0FBQ0EsUUFBTSxRQUFRLEtBQUssU0FBTCxHQUFpQixHQUF6QixDQUFOOztBQUVBLFNBQU8sTUFBTSxJQUFiOztBQUVBLFVBQVEsTUFBTSxLQUFkO0FBQ0EsVUFBUSxNQUFNLEtBQWQ7QUFDQSxVQUFRLE1BQU0sS0FBZDtBQUNBLGFBQVcsTUFBTSxNQUFqQjtBQUNBLFNBQU8sTUFBTSxJQUFiO0FBQ0EsU0FBTyxNQUFNLElBQWI7QUFDQSxVQUFRLE1BQU0sT0FBZDtBQUNBLFVBQVEsTUFBTSxRQUFkO0FBQ0EsVUFBUSxDQUFDLEtBQUssTUFBTSxPQUFaLElBQXVCLENBQS9CO0FBQ0EsVUFBUSxDQUFDLEtBQUssTUFBTSxRQUFaLElBQXdCLENBQWhDOzs7OztBQU1BLE9BQ0EsR0FBRztBQUNELFFBQUksT0FBTyxFQUFYLEVBQWU7QUFDYixjQUFRLE1BQU0sS0FBTixLQUFnQixJQUF4QjtBQUNBLGNBQVEsQ0FBUjtBQUNBLGNBQVEsTUFBTSxLQUFOLEtBQWdCLElBQXhCO0FBQ0EsY0FBUSxDQUFSO0FBQ0Q7O0FBRUQsV0FBTyxNQUFNLE9BQU8sS0FBYixDQUFQOztBQUVBLFdBQ0EsU0FBUzs7QUFDUCxXQUFLLFNBQVMsRSxjQUFkO0FBQ0EsZ0JBQVUsRUFBVjtBQUNBLGNBQVEsRUFBUjtBQUNBLFdBQU0sU0FBUyxFQUFWLEdBQWdCLEksWUFBckI7QUFDQSxVQUFJLE9BQU8sQ0FBWCxFQUFjOzs7OztBQUlaLGVBQU8sTUFBUCxJQUFpQixPQUFPLE0sYUFBeEI7QUFDRCxPQUxELE1BTUssSUFBSSxLQUFLLEVBQVQsRUFBYTs7QUFDaEIsY0FBTSxPQUFPLE0sYUFBYjtBQUNBLGNBQU0sRUFBTixDO0FBQ0EsWUFBSSxFQUFKLEVBQVE7QUFDTixjQUFJLE9BQU8sRUFBWCxFQUFlO0FBQ2Isb0JBQVEsTUFBTSxLQUFOLEtBQWdCLElBQXhCO0FBQ0Esb0JBQVEsQ0FBUjtBQUNEO0FBQ0QsaUJBQU8sT0FBUSxDQUFDLEtBQUssRUFBTixJQUFZLENBQTNCO0FBQ0Esb0JBQVUsRUFBVjtBQUNBLGtCQUFRLEVBQVI7QUFDRDs7QUFFRCxZQUFJLE9BQU8sRUFBWCxFQUFlO0FBQ2Isa0JBQVEsTUFBTSxLQUFOLEtBQWdCLElBQXhCO0FBQ0Esa0JBQVEsQ0FBUjtBQUNBLGtCQUFRLE1BQU0sS0FBTixLQUFnQixJQUF4QjtBQUNBLGtCQUFRLENBQVI7QUFDRDtBQUNELGVBQU8sTUFBTSxPQUFPLEtBQWIsQ0FBUDs7QUFFQSxnQkFDQSxTQUFTOztBQUNQLGVBQUssU0FBUyxFLGNBQWQ7QUFDQSxvQkFBVSxFQUFWO0FBQ0Esa0JBQVEsRUFBUjtBQUNBLGVBQU0sU0FBUyxFQUFWLEdBQWdCLEksWUFBckI7O0FBRUEsY0FBSSxLQUFLLEVBQVQsRUFBYTs7QUFDWCxtQkFBTyxPQUFPLE0sYUFBZDtBQUNBLGtCQUFNLEVBQU4sQztBQUNBLGdCQUFJLE9BQU8sRUFBWCxFQUFlO0FBQ2Isc0JBQVEsTUFBTSxLQUFOLEtBQWdCLElBQXhCO0FBQ0Esc0JBQVEsQ0FBUjtBQUNBLGtCQUFJLE9BQU8sRUFBWCxFQUFlO0FBQ2Isd0JBQVEsTUFBTSxLQUFOLEtBQWdCLElBQXhCO0FBQ0Esd0JBQVEsQ0FBUjtBQUNEO0FBQ0Y7QUFDRCxvQkFBUSxPQUFRLENBQUMsS0FBSyxFQUFOLElBQVksQ0FBNUI7O0FBRUEsZ0JBQUksT0FBTyxJQUFYLEVBQWlCO0FBQ2YsbUJBQUssR0FBTCxHQUFXLCtCQUFYO0FBQ0Esb0JBQU0sSUFBTixHQUFhLEdBQWI7QUFDQSxvQkFBTSxHQUFOO0FBQ0Q7O0FBRUQsc0JBQVUsRUFBVjtBQUNBLG9CQUFRLEVBQVI7O0FBRUEsaUJBQUssT0FBTyxHQUFaLEM7QUFDQSxnQkFBSSxPQUFPLEVBQVgsRUFBZTs7QUFDYixtQkFBSyxPQUFPLEVBQVosQztBQUNBLGtCQUFJLEtBQUssS0FBVCxFQUFnQjtBQUNkLG9CQUFJLE1BQU0sSUFBVixFQUFnQjtBQUNkLHVCQUFLLEdBQUwsR0FBVywrQkFBWDtBQUNBLHdCQUFNLElBQU4sR0FBYSxHQUFiO0FBQ0Esd0JBQU0sR0FBTjtBQUNEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXVCRjtBQUNELHFCQUFPLENBQVAsQztBQUNBLDRCQUFjLFFBQWQ7QUFDQSxrQkFBSSxVQUFVLENBQWQsRUFBaUI7O0FBQ2Ysd0JBQVEsUUFBUSxFQUFoQjtBQUNBLG9CQUFJLEtBQUssR0FBVCxFQUFjOztBQUNaLHlCQUFPLEVBQVA7QUFDQSxxQkFBRztBQUNELDJCQUFPLE1BQVAsSUFBaUIsU0FBUyxNQUFULENBQWpCO0FBQ0QsbUJBRkQsUUFFUyxFQUFFLEVBRlg7QUFHQSx5QkFBTyxPQUFPLElBQWQsQztBQUNBLGdDQUFjLE1BQWQ7QUFDRDtBQUNGLGVBVkQsTUFXSyxJQUFJLFFBQVEsRUFBWixFQUFnQjs7QUFDbkIsd0JBQVEsUUFBUSxLQUFSLEdBQWdCLEVBQXhCO0FBQ0Esc0JBQU0sS0FBTjtBQUNBLG9CQUFJLEtBQUssR0FBVCxFQUFjOztBQUNaLHlCQUFPLEVBQVA7QUFDQSxxQkFBRztBQUNELDJCQUFPLE1BQVAsSUFBaUIsU0FBUyxNQUFULENBQWpCO0FBQ0QsbUJBRkQsUUFFUyxFQUFFLEVBRlg7QUFHQSx5QkFBTyxDQUFQO0FBQ0Esc0JBQUksUUFBUSxHQUFaLEVBQWlCOztBQUNmLHlCQUFLLEtBQUw7QUFDQSwyQkFBTyxFQUFQO0FBQ0EsdUJBQUc7QUFDRCw2QkFBTyxNQUFQLElBQWlCLFNBQVMsTUFBVCxDQUFqQjtBQUNELHFCQUZELFFBRVMsRUFBRSxFQUZYO0FBR0EsMkJBQU8sT0FBTyxJQUFkLEM7QUFDQSxrQ0FBYyxNQUFkO0FBQ0Q7QUFDRjtBQUNGLGVBbkJJLE1Bb0JBOztBQUNILHdCQUFRLFFBQVEsRUFBaEI7QUFDQSxvQkFBSSxLQUFLLEdBQVQsRUFBYzs7QUFDWix5QkFBTyxFQUFQO0FBQ0EscUJBQUc7QUFDRCwyQkFBTyxNQUFQLElBQWlCLFNBQVMsTUFBVCxDQUFqQjtBQUNELG1CQUZELFFBRVMsRUFBRSxFQUZYO0FBR0EseUJBQU8sT0FBTyxJQUFkLEM7QUFDQSxnQ0FBYyxNQUFkO0FBQ0Q7QUFDRjtBQUNELHFCQUFPLE1BQU0sQ0FBYixFQUFnQjtBQUNkLHVCQUFPLE1BQVAsSUFBaUIsWUFBWSxNQUFaLENBQWpCO0FBQ0EsdUJBQU8sTUFBUCxJQUFpQixZQUFZLE1BQVosQ0FBakI7QUFDQSx1QkFBTyxNQUFQLElBQWlCLFlBQVksTUFBWixDQUFqQjtBQUNBLHVCQUFPLENBQVA7QUFDRDtBQUNELGtCQUFJLEdBQUosRUFBUztBQUNQLHVCQUFPLE1BQVAsSUFBaUIsWUFBWSxNQUFaLENBQWpCO0FBQ0Esb0JBQUksTUFBTSxDQUFWLEVBQWE7QUFDWCx5QkFBTyxNQUFQLElBQWlCLFlBQVksTUFBWixDQUFqQjtBQUNEO0FBQ0Y7QUFDRixhQXZGRCxNQXdGSztBQUNILHFCQUFPLE9BQU8sSUFBZCxDO0FBQ0EsaUJBQUc7O0FBQ0QsdUJBQU8sTUFBUCxJQUFpQixPQUFPLE1BQVAsQ0FBakI7QUFDQSx1QkFBTyxNQUFQLElBQWlCLE9BQU8sTUFBUCxDQUFqQjtBQUNBLHVCQUFPLE1BQVAsSUFBaUIsT0FBTyxNQUFQLENBQWpCO0FBQ0EsdUJBQU8sQ0FBUDtBQUNELGVBTEQsUUFLUyxNQUFNLENBTGY7QUFNQSxrQkFBSSxHQUFKLEVBQVM7QUFDUCx1QkFBTyxNQUFQLElBQWlCLE9BQU8sTUFBUCxDQUFqQjtBQUNBLG9CQUFJLE1BQU0sQ0FBVixFQUFhO0FBQ1gseUJBQU8sTUFBUCxJQUFpQixPQUFPLE1BQVAsQ0FBakI7QUFDRDtBQUNGO0FBQ0Y7QUFDRixXQTlIRCxNQStISyxJQUFJLENBQUMsS0FBSyxFQUFOLE1BQWMsQ0FBbEIsRUFBcUI7O0FBQ3hCLG1CQUFPLE1BQU0sQ0FBQyxPQUFPLE1BQVIsSyxhQUErQixPQUFRLENBQUMsS0FBSyxFQUFOLElBQVksQ0FBbkQsQ0FBTixDQUFQO0FBQ0EscUJBQVMsTUFBVDtBQUNELFdBSEksTUFJQTtBQUNILGlCQUFLLEdBQUwsR0FBVyx1QkFBWDtBQUNBLGtCQUFNLElBQU4sR0FBYSxHQUFiO0FBQ0Esa0JBQU0sR0FBTjtBQUNEOztBQUVELGdCO0FBQ0Q7QUFDRixPQXZLSSxNQXdLQSxJQUFJLENBQUMsS0FBSyxFQUFOLE1BQWMsQ0FBbEIsRUFBcUI7O0FBQ3hCLGVBQU8sTUFBTSxDQUFDLE9BQU8sTUFBUixLLGFBQStCLE9BQVEsQ0FBQyxLQUFLLEVBQU4sSUFBWSxDQUFuRCxDQUFOLENBQVA7QUFDQSxpQkFBUyxLQUFUO0FBQ0QsT0FISSxNQUlBLElBQUksS0FBSyxFQUFULEVBQWE7OztBQUVoQixjQUFNLElBQU4sR0FBYSxJQUFiO0FBQ0EsY0FBTSxHQUFOO0FBQ0QsT0FKSSxNQUtBO0FBQ0gsYUFBSyxHQUFMLEdBQVcsNkJBQVg7QUFDQSxjQUFNLElBQU4sR0FBYSxHQUFiO0FBQ0EsY0FBTSxHQUFOO0FBQ0Q7O0FBRUQsWTtBQUNEO0FBQ0YsR0EvTUQsUUErTVMsTUFBTSxJQUFOLElBQWMsT0FBTyxHQS9NOUI7OztBQWtOQSxRQUFNLFFBQVEsQ0FBZDtBQUNBLFNBQU8sR0FBUDtBQUNBLFVBQVEsT0FBTyxDQUFmO0FBQ0EsVUFBUSxDQUFDLEtBQUssSUFBTixJQUFjLENBQXRCOzs7QUFHQSxPQUFLLE9BQUwsR0FBZSxHQUFmO0FBQ0EsT0FBSyxRQUFMLEdBQWdCLElBQWhCO0FBQ0EsT0FBSyxRQUFMLEdBQWlCLE1BQU0sSUFBTixHQUFhLEtBQUssT0FBTyxHQUFaLENBQWIsR0FBZ0MsS0FBSyxNQUFNLElBQVgsQ0FBakQ7QUFDQSxPQUFLLFNBQUwsR0FBa0IsT0FBTyxHQUFQLEdBQWEsT0FBTyxNQUFNLElBQWIsQ0FBYixHQUFrQyxPQUFPLE9BQU8sR0FBZCxDQUFwRDtBQUNBLFFBQU0sSUFBTixHQUFhLElBQWI7QUFDQSxRQUFNLElBQU4sR0FBYSxJQUFiO0FBQ0E7QUFDRCxDQTVSRDs7O0FDekNBOztBQUdBLElBQUksUUFBZ0IsUUFBUSxpQkFBUixDQUFwQjtBQUNBLElBQUksVUFBZ0IsUUFBUSxXQUFSLENBQXBCO0FBQ0EsSUFBSSxRQUFnQixRQUFRLFNBQVIsQ0FBcEI7QUFDQSxJQUFJLGVBQWdCLFFBQVEsV0FBUixDQUFwQjtBQUNBLElBQUksZ0JBQWdCLFFBQVEsWUFBUixDQUFwQjs7QUFFQSxJQUFJLFFBQVEsQ0FBWjtBQUNBLElBQUksT0FBTyxDQUFYO0FBQ0EsSUFBSSxRQUFRLENBQVo7Ozs7Ozs7Ozs7QUFXQSxJQUFJLFdBQWtCLENBQXRCO0FBQ0EsSUFBSSxVQUFrQixDQUF0QjtBQUNBLElBQUksVUFBa0IsQ0FBdEI7Ozs7O0FBTUEsSUFBSSxPQUFrQixDQUF0QjtBQUNBLElBQUksZUFBa0IsQ0FBdEI7QUFDQSxJQUFJLGNBQWtCLENBQXRCOztBQUVBLElBQUksaUJBQWtCLENBQUMsQ0FBdkI7QUFDQSxJQUFJLGVBQWtCLENBQUMsQ0FBdkI7QUFDQSxJQUFJLGNBQWtCLENBQUMsQ0FBdkI7QUFDQSxJQUFJLGNBQWtCLENBQUMsQ0FBdkI7Ozs7QUFJQSxJQUFJLGFBQWMsQ0FBbEI7Ozs7O0FBT0EsSUFBTyxPQUFPLENBQWQsQztBQUNBLElBQU8sUUFBUSxDQUFmLEM7QUFDQSxJQUFPLE9BQU8sQ0FBZCxDO0FBQ0EsSUFBTyxLQUFLLENBQVosQztBQUNBLElBQU8sUUFBUSxDQUFmLEM7QUFDQSxJQUFPLFFBQVEsQ0FBZixDO0FBQ0EsSUFBTyxPQUFPLENBQWQsQztBQUNBLElBQU8sVUFBVSxDQUFqQixDO0FBQ0EsSUFBTyxPQUFPLENBQWQsQztBQUNBLElBQU8sU0FBUyxFQUFoQixDO0FBQ0EsSUFBTyxPQUFPLEVBQWQsQztBQUNBLElBQVcsT0FBTyxFQUFsQixDO0FBQ0EsSUFBVyxTQUFTLEVBQXBCLEM7QUFDQSxJQUFXLFNBQVMsRUFBcEIsQztBQUNBLElBQVcsUUFBUSxFQUFuQixDO0FBQ0EsSUFBVyxPQUFPLEVBQWxCLEM7QUFDQSxJQUFXLFFBQVEsRUFBbkIsQztBQUNBLElBQVcsVUFBVSxFQUFyQixDO0FBQ0EsSUFBVyxXQUFXLEVBQXRCLEM7QUFDQSxJQUFlLE9BQU8sRUFBdEIsQztBQUNBLElBQWUsTUFBTSxFQUFyQixDO0FBQ0EsSUFBZSxTQUFTLEVBQXhCLEM7QUFDQSxJQUFlLE9BQU8sRUFBdEIsQztBQUNBLElBQWUsVUFBVSxFQUF6QixDO0FBQ0EsSUFBZSxRQUFRLEVBQXZCLEM7QUFDQSxJQUFlLE1BQU0sRUFBckIsQztBQUNBLElBQU8sUUFBUSxFQUFmLEM7QUFDQSxJQUFPLFNBQVMsRUFBaEIsQztBQUNBLElBQU8sT0FBTyxFQUFkLEM7QUFDQSxJQUFPLE1BQU0sRUFBYixDO0FBQ0EsSUFBTyxNQUFNLEVBQWIsQztBQUNBLElBQU8sT0FBTyxFQUFkLEM7Ozs7QUFNQSxJQUFJLGNBQWMsR0FBbEI7QUFDQSxJQUFJLGVBQWUsR0FBbkI7OztBQUdBLElBQUksWUFBWSxFQUFoQjs7QUFFQSxJQUFJLFlBQVksU0FBaEI7O0FBR0EsU0FBUyxPQUFULENBQWlCLENBQWpCLEVBQW9CO0FBQ2xCLFNBQVMsQ0FBRSxNQUFNLEVBQVAsR0FBYSxJQUFkLEtBQ0MsTUFBTSxDQUFQLEdBQVksTUFEWixLQUVBLENBQUMsSUFBSSxNQUFMLEtBQWdCLENBRmhCLEtBR0EsQ0FBQyxJQUFJLElBQUwsS0FBYyxFQUhkLENBQVQ7QUFJRDs7QUFHRCxTQUFTLFlBQVQsR0FBd0I7QUFDdEIsT0FBSyxJQUFMLEdBQVksQ0FBWixDO0FBQ0EsT0FBSyxJQUFMLEdBQVksS0FBWixDO0FBQ0EsT0FBSyxJQUFMLEdBQVksQ0FBWixDO0FBQ0EsT0FBSyxRQUFMLEdBQWdCLEtBQWhCLEM7QUFDQSxPQUFLLEtBQUwsR0FBYSxDQUFiLEM7QUFDQSxPQUFLLElBQUwsR0FBWSxDQUFaLEM7QUFDQSxPQUFLLEtBQUwsR0FBYSxDQUFiLEM7QUFDQSxPQUFLLEtBQUwsR0FBYSxDQUFiLEM7O0FBRUEsT0FBSyxJQUFMLEdBQVksSUFBWixDOzs7QUFHQSxPQUFLLEtBQUwsR0FBYSxDQUFiLEM7QUFDQSxPQUFLLEtBQUwsR0FBYSxDQUFiLEM7QUFDQSxPQUFLLEtBQUwsR0FBYSxDQUFiLEM7QUFDQSxPQUFLLEtBQUwsR0FBYSxDQUFiLEM7QUFDQSxPQUFLLE1BQUwsR0FBYyxJQUFkLEM7OztBQUdBLE9BQUssSUFBTCxHQUFZLENBQVosQztBQUNBLE9BQUssSUFBTCxHQUFZLENBQVosQzs7O0FBR0EsT0FBSyxNQUFMLEdBQWMsQ0FBZCxDO0FBQ0EsT0FBSyxNQUFMLEdBQWMsQ0FBZCxDOzs7QUFHQSxPQUFLLEtBQUwsR0FBYSxDQUFiLEM7OztBQUdBLE9BQUssT0FBTCxHQUFlLElBQWYsQztBQUNBLE9BQUssUUFBTCxHQUFnQixJQUFoQixDO0FBQ0EsT0FBSyxPQUFMLEdBQWUsQ0FBZixDO0FBQ0EsT0FBSyxRQUFMLEdBQWdCLENBQWhCLEM7OztBQUdBLE9BQUssS0FBTCxHQUFhLENBQWIsQztBQUNBLE9BQUssSUFBTCxHQUFZLENBQVosQztBQUNBLE9BQUssS0FBTCxHQUFhLENBQWIsQztBQUNBLE9BQUssSUFBTCxHQUFZLENBQVosQztBQUNBLE9BQUssSUFBTCxHQUFZLElBQVosQzs7QUFFQSxPQUFLLElBQUwsR0FBWSxJQUFJLE1BQU0sS0FBVixDQUFnQixHQUFoQixDQUFaLEM7QUFDQSxPQUFLLElBQUwsR0FBWSxJQUFJLE1BQU0sS0FBVixDQUFnQixHQUFoQixDQUFaLEM7Ozs7Ozs7QUFPQSxPQUFLLE1BQUwsR0FBYyxJQUFkLEM7QUFDQSxPQUFLLE9BQUwsR0FBZSxJQUFmLEM7QUFDQSxPQUFLLElBQUwsR0FBWSxDQUFaLEM7QUFDQSxPQUFLLElBQUwsR0FBWSxDQUFaLEM7QUFDQSxPQUFLLEdBQUwsR0FBVyxDQUFYLEM7QUFDRDs7QUFFRCxTQUFTLGdCQUFULENBQTBCLElBQTFCLEVBQWdDO0FBQzlCLE1BQUksS0FBSjs7QUFFQSxNQUFJLENBQUMsSUFBRCxJQUFTLENBQUMsS0FBSyxLQUFuQixFQUEwQjtBQUFFLFdBQU8sY0FBUDtBQUF3QjtBQUNwRCxVQUFRLEtBQUssS0FBYjtBQUNBLE9BQUssUUFBTCxHQUFnQixLQUFLLFNBQUwsR0FBaUIsTUFBTSxLQUFOLEdBQWMsQ0FBL0M7QUFDQSxPQUFLLEdBQUwsR0FBVyxFQUFYLEM7QUFDQSxNQUFJLE1BQU0sSUFBVixFQUFnQjs7QUFDZCxTQUFLLEtBQUwsR0FBYSxNQUFNLElBQU4sR0FBYSxDQUExQjtBQUNEO0FBQ0QsUUFBTSxJQUFOLEdBQWEsSUFBYjtBQUNBLFFBQU0sSUFBTixHQUFhLENBQWI7QUFDQSxRQUFNLFFBQU4sR0FBaUIsQ0FBakI7QUFDQSxRQUFNLElBQU4sR0FBYSxLQUFiO0FBQ0EsUUFBTSxJQUFOLEdBQWEsSSxXQUFiO0FBQ0EsUUFBTSxJQUFOLEdBQWEsQ0FBYjtBQUNBLFFBQU0sSUFBTixHQUFhLENBQWI7O0FBRUEsUUFBTSxPQUFOLEdBQWdCLE1BQU0sTUFBTixHQUFlLElBQUksTUFBTSxLQUFWLENBQWdCLFdBQWhCLENBQS9CO0FBQ0EsUUFBTSxRQUFOLEdBQWlCLE1BQU0sT0FBTixHQUFnQixJQUFJLE1BQU0sS0FBVixDQUFnQixZQUFoQixDQUFqQzs7QUFFQSxRQUFNLElBQU4sR0FBYSxDQUFiO0FBQ0EsUUFBTSxJQUFOLEdBQWEsQ0FBQyxDQUFkOztBQUVBLFNBQU8sSUFBUDtBQUNEOztBQUVELFNBQVMsWUFBVCxDQUFzQixJQUF0QixFQUE0QjtBQUMxQixNQUFJLEtBQUo7O0FBRUEsTUFBSSxDQUFDLElBQUQsSUFBUyxDQUFDLEtBQUssS0FBbkIsRUFBMEI7QUFBRSxXQUFPLGNBQVA7QUFBd0I7QUFDcEQsVUFBUSxLQUFLLEtBQWI7QUFDQSxRQUFNLEtBQU4sR0FBYyxDQUFkO0FBQ0EsUUFBTSxLQUFOLEdBQWMsQ0FBZDtBQUNBLFFBQU0sS0FBTixHQUFjLENBQWQ7QUFDQSxTQUFPLGlCQUFpQixJQUFqQixDQUFQO0FBRUQ7O0FBRUQsU0FBUyxhQUFULENBQXVCLElBQXZCLEVBQTZCLFVBQTdCLEVBQXlDO0FBQ3ZDLE1BQUksSUFBSjtBQUNBLE1BQUksS0FBSjs7O0FBR0EsTUFBSSxDQUFDLElBQUQsSUFBUyxDQUFDLEtBQUssS0FBbkIsRUFBMEI7QUFBRSxXQUFPLGNBQVA7QUFBd0I7QUFDcEQsVUFBUSxLQUFLLEtBQWI7OztBQUdBLE1BQUksYUFBYSxDQUFqQixFQUFvQjtBQUNsQixXQUFPLENBQVA7QUFDQSxpQkFBYSxDQUFDLFVBQWQ7QUFDRCxHQUhELE1BSUs7QUFDSCxXQUFPLENBQUMsY0FBYyxDQUFmLElBQW9CLENBQTNCO0FBQ0EsUUFBSSxhQUFhLEVBQWpCLEVBQXFCO0FBQ25CLG9CQUFjLEVBQWQ7QUFDRDtBQUNGOzs7QUFHRCxNQUFJLGVBQWUsYUFBYSxDQUFiLElBQWtCLGFBQWEsRUFBOUMsQ0FBSixFQUF1RDtBQUNyRCxXQUFPLGNBQVA7QUFDRDtBQUNELE1BQUksTUFBTSxNQUFOLEtBQWlCLElBQWpCLElBQXlCLE1BQU0sS0FBTixLQUFnQixVQUE3QyxFQUF5RDtBQUN2RCxVQUFNLE1BQU4sR0FBZSxJQUFmO0FBQ0Q7OztBQUdELFFBQU0sSUFBTixHQUFhLElBQWI7QUFDQSxRQUFNLEtBQU4sR0FBYyxVQUFkO0FBQ0EsU0FBTyxhQUFhLElBQWIsQ0FBUDtBQUNEOztBQUVELFNBQVMsWUFBVCxDQUFzQixJQUF0QixFQUE0QixVQUE1QixFQUF3QztBQUN0QyxNQUFJLEdBQUo7QUFDQSxNQUFJLEtBQUo7O0FBRUEsTUFBSSxDQUFDLElBQUwsRUFBVztBQUFFLFdBQU8sY0FBUDtBQUF3Qjs7O0FBR3JDLFVBQVEsSUFBSSxZQUFKLEVBQVI7Ozs7QUFJQSxPQUFLLEtBQUwsR0FBYSxLQUFiO0FBQ0EsUUFBTSxNQUFOLEdBQWUsSSxXQUFmO0FBQ0EsUUFBTSxjQUFjLElBQWQsRUFBb0IsVUFBcEIsQ0FBTjtBQUNBLE1BQUksUUFBUSxJQUFaLEVBQWtCO0FBQ2hCLFNBQUssS0FBTCxHQUFhLEksV0FBYjtBQUNEO0FBQ0QsU0FBTyxHQUFQO0FBQ0Q7O0FBRUQsU0FBUyxXQUFULENBQXFCLElBQXJCLEVBQTJCO0FBQ3pCLFNBQU8sYUFBYSxJQUFiLEVBQW1CLFNBQW5CLENBQVA7QUFDRDs7Ozs7Ozs7Ozs7O0FBYUQsSUFBSSxTQUFTLElBQWI7O0FBRUEsSUFBSSxNQUFKLEVBQVksT0FBWixDOztBQUVBLFNBQVMsV0FBVCxDQUFxQixLQUFyQixFQUE0Qjs7QUFFMUIsTUFBSSxNQUFKLEVBQVk7QUFDVixRQUFJLEdBQUo7O0FBRUEsYUFBUyxJQUFJLE1BQU0sS0FBVixDQUFnQixHQUFoQixDQUFUO0FBQ0EsY0FBVSxJQUFJLE1BQU0sS0FBVixDQUFnQixFQUFoQixDQUFWOzs7QUFHQSxVQUFNLENBQU47QUFDQSxXQUFPLE1BQU0sR0FBYixFQUFrQjtBQUFFLFlBQU0sSUFBTixDQUFXLEtBQVgsSUFBb0IsQ0FBcEI7QUFBd0I7QUFDNUMsV0FBTyxNQUFNLEdBQWIsRUFBa0I7QUFBRSxZQUFNLElBQU4sQ0FBVyxLQUFYLElBQW9CLENBQXBCO0FBQXdCO0FBQzVDLFdBQU8sTUFBTSxHQUFiLEVBQWtCO0FBQUUsWUFBTSxJQUFOLENBQVcsS0FBWCxJQUFvQixDQUFwQjtBQUF3QjtBQUM1QyxXQUFPLE1BQU0sR0FBYixFQUFrQjtBQUFFLFlBQU0sSUFBTixDQUFXLEtBQVgsSUFBb0IsQ0FBcEI7QUFBd0I7O0FBRTVDLGtCQUFjLElBQWQsRUFBcUIsTUFBTSxJQUEzQixFQUFpQyxDQUFqQyxFQUFvQyxHQUFwQyxFQUF5QyxNQUF6QyxFQUFtRCxDQUFuRCxFQUFzRCxNQUFNLElBQTVELEVBQWtFLEVBQUUsTUFBTSxDQUFSLEVBQWxFOzs7QUFHQSxVQUFNLENBQU47QUFDQSxXQUFPLE1BQU0sRUFBYixFQUFpQjtBQUFFLFlBQU0sSUFBTixDQUFXLEtBQVgsSUFBb0IsQ0FBcEI7QUFBd0I7O0FBRTNDLGtCQUFjLEtBQWQsRUFBcUIsTUFBTSxJQUEzQixFQUFpQyxDQUFqQyxFQUFvQyxFQUFwQyxFQUEwQyxPQUExQyxFQUFtRCxDQUFuRCxFQUFzRCxNQUFNLElBQTVELEVBQWtFLEVBQUUsTUFBTSxDQUFSLEVBQWxFOzs7QUFHQSxhQUFTLEtBQVQ7QUFDRDs7QUFFRCxRQUFNLE9BQU4sR0FBZ0IsTUFBaEI7QUFDQSxRQUFNLE9BQU4sR0FBZ0IsQ0FBaEI7QUFDQSxRQUFNLFFBQU4sR0FBaUIsT0FBakI7QUFDQSxRQUFNLFFBQU4sR0FBaUIsQ0FBakI7QUFDRDs7Ozs7Ozs7Ozs7Ozs7OztBQWlCRCxTQUFTLFlBQVQsQ0FBc0IsSUFBdEIsRUFBNEIsR0FBNUIsRUFBaUMsR0FBakMsRUFBc0MsSUFBdEMsRUFBNEM7QUFDMUMsTUFBSSxJQUFKO0FBQ0EsTUFBSSxRQUFRLEtBQUssS0FBakI7OztBQUdBLE1BQUksTUFBTSxNQUFOLEtBQWlCLElBQXJCLEVBQTJCO0FBQ3pCLFVBQU0sS0FBTixHQUFjLEtBQUssTUFBTSxLQUF6QjtBQUNBLFVBQU0sS0FBTixHQUFjLENBQWQ7QUFDQSxVQUFNLEtBQU4sR0FBYyxDQUFkOztBQUVBLFVBQU0sTUFBTixHQUFlLElBQUksTUFBTSxJQUFWLENBQWUsTUFBTSxLQUFyQixDQUFmO0FBQ0Q7OztBQUdELE1BQUksUUFBUSxNQUFNLEtBQWxCLEVBQXlCO0FBQ3ZCLFVBQU0sUUFBTixDQUFlLE1BQU0sTUFBckIsRUFBNkIsR0FBN0IsRUFBa0MsTUFBTSxNQUFNLEtBQTlDLEVBQXFELE1BQU0sS0FBM0QsRUFBa0UsQ0FBbEU7QUFDQSxVQUFNLEtBQU4sR0FBYyxDQUFkO0FBQ0EsVUFBTSxLQUFOLEdBQWMsTUFBTSxLQUFwQjtBQUNELEdBSkQsTUFLSztBQUNILFdBQU8sTUFBTSxLQUFOLEdBQWMsTUFBTSxLQUEzQjtBQUNBLFFBQUksT0FBTyxJQUFYLEVBQWlCO0FBQ2YsYUFBTyxJQUFQO0FBQ0Q7O0FBRUQsVUFBTSxRQUFOLENBQWUsTUFBTSxNQUFyQixFQUE2QixHQUE3QixFQUFrQyxNQUFNLElBQXhDLEVBQThDLElBQTlDLEVBQW9ELE1BQU0sS0FBMUQ7QUFDQSxZQUFRLElBQVI7QUFDQSxRQUFJLElBQUosRUFBVTs7QUFFUixZQUFNLFFBQU4sQ0FBZSxNQUFNLE1BQXJCLEVBQTZCLEdBQTdCLEVBQWtDLE1BQU0sSUFBeEMsRUFBOEMsSUFBOUMsRUFBb0QsQ0FBcEQ7QUFDQSxZQUFNLEtBQU4sR0FBYyxJQUFkO0FBQ0EsWUFBTSxLQUFOLEdBQWMsTUFBTSxLQUFwQjtBQUNELEtBTEQsTUFNSztBQUNILFlBQU0sS0FBTixJQUFlLElBQWY7QUFDQSxVQUFJLE1BQU0sS0FBTixLQUFnQixNQUFNLEtBQTFCLEVBQWlDO0FBQUUsY0FBTSxLQUFOLEdBQWMsQ0FBZDtBQUFrQjtBQUNyRCxVQUFJLE1BQU0sS0FBTixHQUFjLE1BQU0sS0FBeEIsRUFBK0I7QUFBRSxjQUFNLEtBQU4sSUFBZSxJQUFmO0FBQXNCO0FBQ3hEO0FBQ0Y7QUFDRCxTQUFPLENBQVA7QUFDRDs7QUFFRCxTQUFTLE9BQVQsQ0FBaUIsSUFBakIsRUFBdUIsS0FBdkIsRUFBOEI7QUFDNUIsTUFBSSxLQUFKO0FBQ0EsTUFBSSxLQUFKLEVBQVcsTUFBWCxDO0FBQ0EsTUFBSSxJQUFKLEM7QUFDQSxNQUFJLEdBQUosQztBQUNBLE1BQUksSUFBSixFQUFVLElBQVYsQztBQUNBLE1BQUksSUFBSixDO0FBQ0EsTUFBSSxJQUFKLEM7QUFDQSxNQUFJLEdBQUosRUFBUyxJQUFULEM7QUFDQSxNQUFJLElBQUosQztBQUNBLE1BQUksSUFBSixDO0FBQ0EsTUFBSSxXQUFKO0FBQ0EsTUFBSSxPQUFPLENBQVgsQztBQUNBLE1BQUksU0FBSixFQUFlLE9BQWYsRUFBd0IsUUFBeEIsQzs7QUFFQSxNQUFJLFNBQUosRUFBZSxPQUFmLEVBQXdCLFFBQXhCLEM7QUFDQSxNQUFJLEdBQUosQztBQUNBLE1BQUksR0FBSixDO0FBQ0EsTUFBSSxPQUFPLElBQUksTUFBTSxJQUFWLENBQWUsQ0FBZixDQUFYLEM7QUFDQSxNQUFJLElBQUo7O0FBRUEsTUFBSSxDQUFKLEM7O0FBRUEsTUFBSSxRO0FBQ0YsR0FBRSxFQUFGLEVBQU0sRUFBTixFQUFVLEVBQVYsRUFBYyxDQUFkLEVBQWlCLENBQWpCLEVBQW9CLENBQXBCLEVBQXVCLENBQXZCLEVBQTBCLENBQTFCLEVBQTZCLEVBQTdCLEVBQWlDLENBQWpDLEVBQW9DLEVBQXBDLEVBQXdDLENBQXhDLEVBQTJDLEVBQTNDLEVBQStDLENBQS9DLEVBQWtELEVBQWxELEVBQXNELENBQXRELEVBQXlELEVBQXpELEVBQTZELENBQTdELEVBQWdFLEVBQWhFLENBREY7O0FBSUEsTUFBSSxDQUFDLElBQUQsSUFBUyxDQUFDLEtBQUssS0FBZixJQUF3QixDQUFDLEtBQUssTUFBOUIsSUFDQyxDQUFDLEtBQUssS0FBTixJQUFlLEtBQUssUUFBTCxLQUFrQixDQUR0QyxFQUMwQztBQUN4QyxXQUFPLGNBQVA7QUFDRDs7QUFFRCxVQUFRLEtBQUssS0FBYjtBQUNBLE1BQUksTUFBTSxJQUFOLEtBQWUsSUFBbkIsRUFBeUI7QUFBRSxVQUFNLElBQU4sR0FBYSxNQUFiO0FBQXNCLEc7OztBQUlqRCxRQUFNLEtBQUssUUFBWDtBQUNBLFdBQVMsS0FBSyxNQUFkO0FBQ0EsU0FBTyxLQUFLLFNBQVo7QUFDQSxTQUFPLEtBQUssT0FBWjtBQUNBLFVBQVEsS0FBSyxLQUFiO0FBQ0EsU0FBTyxLQUFLLFFBQVo7QUFDQSxTQUFPLE1BQU0sSUFBYjtBQUNBLFNBQU8sTUFBTSxJQUFiOzs7QUFHQSxRQUFNLElBQU47QUFDQSxTQUFPLElBQVA7QUFDQSxRQUFNLElBQU47O0FBRUEsYTtBQUNBLFdBQVM7QUFDUCxZQUFRLE1BQU0sSUFBZDtBQUNBLFdBQUssSUFBTDtBQUNFLFlBQUksTUFBTSxJQUFOLEtBQWUsQ0FBbkIsRUFBc0I7QUFDcEIsZ0JBQU0sSUFBTixHQUFhLE1BQWI7QUFDQTtBQUNEOztBQUVELGVBQU8sT0FBTyxFQUFkLEVBQWtCO0FBQ2hCLGNBQUksU0FBUyxDQUFiLEVBQWdCO0FBQUUsa0JBQU0sU0FBTjtBQUFrQjtBQUNwQztBQUNBLGtCQUFRLE1BQU0sTUFBTixLQUFpQixJQUF6QjtBQUNBLGtCQUFRLENBQVI7QUFDRDs7QUFFRCxZQUFLLE1BQU0sSUFBTixHQUFhLENBQWQsSUFBb0IsU0FBUyxNQUFqQyxFQUF5Qzs7QUFDdkMsZ0JBQU0sS0FBTixHQUFjLEMseUJBQWQ7O0FBRUEsZUFBSyxDQUFMLElBQVUsT0FBTyxJQUFqQjtBQUNBLGVBQUssQ0FBTCxJQUFXLFNBQVMsQ0FBVixHQUFlLElBQXpCO0FBQ0EsZ0JBQU0sS0FBTixHQUFjLE1BQU0sTUFBTSxLQUFaLEVBQW1CLElBQW5CLEVBQXlCLENBQXpCLEVBQTRCLENBQTVCLENBQWQ7Ozs7QUFJQSxpQkFBTyxDQUFQO0FBQ0EsaUJBQU8sQ0FBUDs7QUFFQSxnQkFBTSxJQUFOLEdBQWEsS0FBYjtBQUNBO0FBQ0Q7QUFDRCxjQUFNLEtBQU4sR0FBYyxDQUFkLEM7QUFDQSxZQUFJLE1BQU0sSUFBVixFQUFnQjtBQUNkLGdCQUFNLElBQU4sQ0FBVyxJQUFYLEdBQWtCLEtBQWxCO0FBQ0Q7QUFDRCxZQUFJLEVBQUUsTUFBTSxJQUFOLEdBQWEsQ0FBZixLO0FBQ0YsU0FBQyxDQUFDLENBQUMsT0FBTyxJQUFSLEssV0FBNEIsQ0FBN0IsS0FBbUMsUUFBUSxDQUEzQyxDQUFELElBQWtELEVBRHBELEVBQ3dEO0FBQ3RELGVBQUssR0FBTCxHQUFXLHdCQUFYO0FBQ0EsZ0JBQU0sSUFBTixHQUFhLEdBQWI7QUFDQTtBQUNEO0FBQ0QsWUFBSSxDQUFDLE9BQU8sSUFBUixNLFdBQTZCLFVBQWpDLEVBQTZDO0FBQzNDLGVBQUssR0FBTCxHQUFXLDRCQUFYO0FBQ0EsZ0JBQU0sSUFBTixHQUFhLEdBQWI7QUFDQTtBQUNEOztBQUVELGtCQUFVLENBQVY7QUFDQSxnQkFBUSxDQUFSOztBQUVBLGNBQU0sQ0FBQyxPQUFPLElBQVIsSSxXQUEyQixDQUFqQztBQUNBLFlBQUksTUFBTSxLQUFOLEtBQWdCLENBQXBCLEVBQXVCO0FBQ3JCLGdCQUFNLEtBQU4sR0FBYyxHQUFkO0FBQ0QsU0FGRCxNQUdLLElBQUksTUFBTSxNQUFNLEtBQWhCLEVBQXVCO0FBQzFCLGVBQUssR0FBTCxHQUFXLHFCQUFYO0FBQ0EsZ0JBQU0sSUFBTixHQUFhLEdBQWI7QUFDQTtBQUNEO0FBQ0QsY0FBTSxJQUFOLEdBQWEsS0FBSyxHQUFsQjs7QUFFQSxhQUFLLEtBQUwsR0FBYSxNQUFNLEtBQU4sR0FBYyxDLDJCQUEzQjtBQUNBLGNBQU0sSUFBTixHQUFhLE9BQU8sS0FBUCxHQUFlLE1BQWYsR0FBd0IsSUFBckM7O0FBRUEsZUFBTyxDQUFQO0FBQ0EsZUFBTyxDQUFQOztBQUVBO0FBQ0YsV0FBSyxLQUFMOztBQUVFLGVBQU8sT0FBTyxFQUFkLEVBQWtCO0FBQ2hCLGNBQUksU0FBUyxDQUFiLEVBQWdCO0FBQUUsa0JBQU0sU0FBTjtBQUFrQjtBQUNwQztBQUNBLGtCQUFRLE1BQU0sTUFBTixLQUFpQixJQUF6QjtBQUNBLGtCQUFRLENBQVI7QUFDRDs7QUFFRCxjQUFNLEtBQU4sR0FBYyxJQUFkO0FBQ0EsWUFBSSxDQUFDLE1BQU0sS0FBTixHQUFjLElBQWYsTUFBeUIsVUFBN0IsRUFBeUM7QUFDdkMsZUFBSyxHQUFMLEdBQVcsNEJBQVg7QUFDQSxnQkFBTSxJQUFOLEdBQWEsR0FBYjtBQUNBO0FBQ0Q7QUFDRCxZQUFJLE1BQU0sS0FBTixHQUFjLE1BQWxCLEVBQTBCO0FBQ3hCLGVBQUssR0FBTCxHQUFXLDBCQUFYO0FBQ0EsZ0JBQU0sSUFBTixHQUFhLEdBQWI7QUFDQTtBQUNEO0FBQ0QsWUFBSSxNQUFNLElBQVYsRUFBZ0I7QUFDZCxnQkFBTSxJQUFOLENBQVcsSUFBWCxHQUFvQixRQUFRLENBQVQsR0FBYyxDQUFqQztBQUNEO0FBQ0QsWUFBSSxNQUFNLEtBQU4sR0FBYyxNQUFsQixFQUEwQjs7QUFFeEIsZUFBSyxDQUFMLElBQVUsT0FBTyxJQUFqQjtBQUNBLGVBQUssQ0FBTCxJQUFXLFNBQVMsQ0FBVixHQUFlLElBQXpCO0FBQ0EsZ0JBQU0sS0FBTixHQUFjLE1BQU0sTUFBTSxLQUFaLEVBQW1CLElBQW5CLEVBQXlCLENBQXpCLEVBQTRCLENBQTVCLENBQWQ7O0FBRUQ7O0FBRUQsZUFBTyxDQUFQO0FBQ0EsZUFBTyxDQUFQOztBQUVBLGNBQU0sSUFBTixHQUFhLElBQWI7O0FBRUYsV0FBSyxJQUFMOztBQUVFLGVBQU8sT0FBTyxFQUFkLEVBQWtCO0FBQ2hCLGNBQUksU0FBUyxDQUFiLEVBQWdCO0FBQUUsa0JBQU0sU0FBTjtBQUFrQjtBQUNwQztBQUNBLGtCQUFRLE1BQU0sTUFBTixLQUFpQixJQUF6QjtBQUNBLGtCQUFRLENBQVI7QUFDRDs7QUFFRCxZQUFJLE1BQU0sSUFBVixFQUFnQjtBQUNkLGdCQUFNLElBQU4sQ0FBVyxJQUFYLEdBQWtCLElBQWxCO0FBQ0Q7QUFDRCxZQUFJLE1BQU0sS0FBTixHQUFjLE1BQWxCLEVBQTBCOztBQUV4QixlQUFLLENBQUwsSUFBVSxPQUFPLElBQWpCO0FBQ0EsZUFBSyxDQUFMLElBQVcsU0FBUyxDQUFWLEdBQWUsSUFBekI7QUFDQSxlQUFLLENBQUwsSUFBVyxTQUFTLEVBQVYsR0FBZ0IsSUFBMUI7QUFDQSxlQUFLLENBQUwsSUFBVyxTQUFTLEVBQVYsR0FBZ0IsSUFBMUI7QUFDQSxnQkFBTSxLQUFOLEdBQWMsTUFBTSxNQUFNLEtBQVosRUFBbUIsSUFBbkIsRUFBeUIsQ0FBekIsRUFBNEIsQ0FBNUIsQ0FBZDs7QUFFRDs7QUFFRCxlQUFPLENBQVA7QUFDQSxlQUFPLENBQVA7O0FBRUEsY0FBTSxJQUFOLEdBQWEsRUFBYjs7QUFFRixXQUFLLEVBQUw7O0FBRUUsZUFBTyxPQUFPLEVBQWQsRUFBa0I7QUFDaEIsY0FBSSxTQUFTLENBQWIsRUFBZ0I7QUFBRSxrQkFBTSxTQUFOO0FBQWtCO0FBQ3BDO0FBQ0Esa0JBQVEsTUFBTSxNQUFOLEtBQWlCLElBQXpCO0FBQ0Esa0JBQVEsQ0FBUjtBQUNEOztBQUVELFlBQUksTUFBTSxJQUFWLEVBQWdCO0FBQ2QsZ0JBQU0sSUFBTixDQUFXLE1BQVgsR0FBcUIsT0FBTyxJQUE1QjtBQUNBLGdCQUFNLElBQU4sQ0FBVyxFQUFYLEdBQWlCLFFBQVEsQ0FBekI7QUFDRDtBQUNELFlBQUksTUFBTSxLQUFOLEdBQWMsTUFBbEIsRUFBMEI7O0FBRXhCLGVBQUssQ0FBTCxJQUFVLE9BQU8sSUFBakI7QUFDQSxlQUFLLENBQUwsSUFBVyxTQUFTLENBQVYsR0FBZSxJQUF6QjtBQUNBLGdCQUFNLEtBQU4sR0FBYyxNQUFNLE1BQU0sS0FBWixFQUFtQixJQUFuQixFQUF5QixDQUF6QixFQUE0QixDQUE1QixDQUFkOztBQUVEOztBQUVELGVBQU8sQ0FBUDtBQUNBLGVBQU8sQ0FBUDs7QUFFQSxjQUFNLElBQU4sR0FBYSxLQUFiOztBQUVGLFdBQUssS0FBTDtBQUNFLFlBQUksTUFBTSxLQUFOLEdBQWMsTUFBbEIsRUFBMEI7O0FBRXhCLGlCQUFPLE9BQU8sRUFBZCxFQUFrQjtBQUNoQixnQkFBSSxTQUFTLENBQWIsRUFBZ0I7QUFBRSxvQkFBTSxTQUFOO0FBQWtCO0FBQ3BDO0FBQ0Esb0JBQVEsTUFBTSxNQUFOLEtBQWlCLElBQXpCO0FBQ0Esb0JBQVEsQ0FBUjtBQUNEOztBQUVELGdCQUFNLE1BQU4sR0FBZSxJQUFmO0FBQ0EsY0FBSSxNQUFNLElBQVYsRUFBZ0I7QUFDZCxrQkFBTSxJQUFOLENBQVcsU0FBWCxHQUF1QixJQUF2QjtBQUNEO0FBQ0QsY0FBSSxNQUFNLEtBQU4sR0FBYyxNQUFsQixFQUEwQjs7QUFFeEIsaUJBQUssQ0FBTCxJQUFVLE9BQU8sSUFBakI7QUFDQSxpQkFBSyxDQUFMLElBQVcsU0FBUyxDQUFWLEdBQWUsSUFBekI7QUFDQSxrQkFBTSxLQUFOLEdBQWMsTUFBTSxNQUFNLEtBQVosRUFBbUIsSUFBbkIsRUFBeUIsQ0FBekIsRUFBNEIsQ0FBNUIsQ0FBZDs7QUFFRDs7QUFFRCxpQkFBTyxDQUFQO0FBQ0EsaUJBQU8sQ0FBUDs7QUFFRCxTQXhCRCxNQXlCSyxJQUFJLE1BQU0sSUFBVixFQUFnQjtBQUNuQixnQkFBTSxJQUFOLENBQVcsS0FBWCxHQUFtQixJLFdBQW5CO0FBQ0Q7QUFDRCxjQUFNLElBQU4sR0FBYSxLQUFiOztBQUVGLFdBQUssS0FBTDtBQUNFLFlBQUksTUFBTSxLQUFOLEdBQWMsTUFBbEIsRUFBMEI7QUFDeEIsaUJBQU8sTUFBTSxNQUFiO0FBQ0EsY0FBSSxPQUFPLElBQVgsRUFBaUI7QUFBRSxtQkFBTyxJQUFQO0FBQWM7QUFDakMsY0FBSSxJQUFKLEVBQVU7QUFDUixnQkFBSSxNQUFNLElBQVYsRUFBZ0I7QUFDZCxvQkFBTSxNQUFNLElBQU4sQ0FBVyxTQUFYLEdBQXVCLE1BQU0sTUFBbkM7QUFDQSxrQkFBSSxDQUFDLE1BQU0sSUFBTixDQUFXLEtBQWhCLEVBQXVCOztBQUVyQixzQkFBTSxJQUFOLENBQVcsS0FBWCxHQUFtQixJQUFJLEtBQUosQ0FBVSxNQUFNLElBQU4sQ0FBVyxTQUFyQixDQUFuQjtBQUNEO0FBQ0Qsb0JBQU0sUUFBTixDQUNFLE1BQU0sSUFBTixDQUFXLEtBRGIsRUFFRSxLQUZGLEVBR0UsSUFIRjs7O0FBTUUsa0JBTkY7O0FBUUUsaUJBUkY7Ozs7QUFhRDtBQUNELGdCQUFJLE1BQU0sS0FBTixHQUFjLE1BQWxCLEVBQTBCO0FBQ3hCLG9CQUFNLEtBQU4sR0FBYyxNQUFNLE1BQU0sS0FBWixFQUFtQixLQUFuQixFQUEwQixJQUExQixFQUFnQyxJQUFoQyxDQUFkO0FBQ0Q7QUFDRCxvQkFBUSxJQUFSO0FBQ0Esb0JBQVEsSUFBUjtBQUNBLGtCQUFNLE1BQU4sSUFBZ0IsSUFBaEI7QUFDRDtBQUNELGNBQUksTUFBTSxNQUFWLEVBQWtCO0FBQUUsa0JBQU0sU0FBTjtBQUFrQjtBQUN2QztBQUNELGNBQU0sTUFBTixHQUFlLENBQWY7QUFDQSxjQUFNLElBQU4sR0FBYSxJQUFiOztBQUVGLFdBQUssSUFBTDtBQUNFLFlBQUksTUFBTSxLQUFOLEdBQWMsTUFBbEIsRUFBMEI7QUFDeEIsY0FBSSxTQUFTLENBQWIsRUFBZ0I7QUFBRSxrQkFBTSxTQUFOO0FBQWtCO0FBQ3BDLGlCQUFPLENBQVA7QUFDQSxhQUFHOztBQUVELGtCQUFNLE1BQU0sT0FBTyxNQUFiLENBQU47O0FBRUEsZ0JBQUksTUFBTSxJQUFOLElBQWMsR0FBZCxJQUNDLE1BQU0sTUFBTixHQUFlLEssd0JBRHBCLEVBQ29EO0FBQ2xELG9CQUFNLElBQU4sQ0FBVyxJQUFYLElBQW1CLE9BQU8sWUFBUCxDQUFvQixHQUFwQixDQUFuQjtBQUNEO0FBQ0YsV0FSRCxRQVFTLE9BQU8sT0FBTyxJQVJ2Qjs7QUFVQSxjQUFJLE1BQU0sS0FBTixHQUFjLE1BQWxCLEVBQTBCO0FBQ3hCLGtCQUFNLEtBQU4sR0FBYyxNQUFNLE1BQU0sS0FBWixFQUFtQixLQUFuQixFQUEwQixJQUExQixFQUFnQyxJQUFoQyxDQUFkO0FBQ0Q7QUFDRCxrQkFBUSxJQUFSO0FBQ0Esa0JBQVEsSUFBUjtBQUNBLGNBQUksR0FBSixFQUFTO0FBQUUsa0JBQU0sU0FBTjtBQUFrQjtBQUM5QixTQW5CRCxNQW9CSyxJQUFJLE1BQU0sSUFBVixFQUFnQjtBQUNuQixnQkFBTSxJQUFOLENBQVcsSUFBWCxHQUFrQixJQUFsQjtBQUNEO0FBQ0QsY0FBTSxNQUFOLEdBQWUsQ0FBZjtBQUNBLGNBQU0sSUFBTixHQUFhLE9BQWI7O0FBRUYsV0FBSyxPQUFMO0FBQ0UsWUFBSSxNQUFNLEtBQU4sR0FBYyxNQUFsQixFQUEwQjtBQUN4QixjQUFJLFNBQVMsQ0FBYixFQUFnQjtBQUFFLGtCQUFNLFNBQU47QUFBa0I7QUFDcEMsaUJBQU8sQ0FBUDtBQUNBLGFBQUc7QUFDRCxrQkFBTSxNQUFNLE9BQU8sTUFBYixDQUFOOztBQUVBLGdCQUFJLE1BQU0sSUFBTixJQUFjLEdBQWQsSUFDQyxNQUFNLE1BQU4sR0FBZSxLLHdCQURwQixFQUNvRDtBQUNsRCxvQkFBTSxJQUFOLENBQVcsT0FBWCxJQUFzQixPQUFPLFlBQVAsQ0FBb0IsR0FBcEIsQ0FBdEI7QUFDRDtBQUNGLFdBUEQsUUFPUyxPQUFPLE9BQU8sSUFQdkI7QUFRQSxjQUFJLE1BQU0sS0FBTixHQUFjLE1BQWxCLEVBQTBCO0FBQ3hCLGtCQUFNLEtBQU4sR0FBYyxNQUFNLE1BQU0sS0FBWixFQUFtQixLQUFuQixFQUEwQixJQUExQixFQUFnQyxJQUFoQyxDQUFkO0FBQ0Q7QUFDRCxrQkFBUSxJQUFSO0FBQ0Esa0JBQVEsSUFBUjtBQUNBLGNBQUksR0FBSixFQUFTO0FBQUUsa0JBQU0sU0FBTjtBQUFrQjtBQUM5QixTQWpCRCxNQWtCSyxJQUFJLE1BQU0sSUFBVixFQUFnQjtBQUNuQixnQkFBTSxJQUFOLENBQVcsT0FBWCxHQUFxQixJQUFyQjtBQUNEO0FBQ0QsY0FBTSxJQUFOLEdBQWEsSUFBYjs7QUFFRixXQUFLLElBQUw7QUFDRSxZQUFJLE1BQU0sS0FBTixHQUFjLE1BQWxCLEVBQTBCOztBQUV4QixpQkFBTyxPQUFPLEVBQWQsRUFBa0I7QUFDaEIsZ0JBQUksU0FBUyxDQUFiLEVBQWdCO0FBQUUsb0JBQU0sU0FBTjtBQUFrQjtBQUNwQztBQUNBLG9CQUFRLE1BQU0sTUFBTixLQUFpQixJQUF6QjtBQUNBLG9CQUFRLENBQVI7QUFDRDs7QUFFRCxjQUFJLFVBQVUsTUFBTSxLQUFOLEdBQWMsTUFBeEIsQ0FBSixFQUFxQztBQUNuQyxpQkFBSyxHQUFMLEdBQVcscUJBQVg7QUFDQSxrQkFBTSxJQUFOLEdBQWEsR0FBYjtBQUNBO0FBQ0Q7O0FBRUQsaUJBQU8sQ0FBUDtBQUNBLGlCQUFPLENBQVA7O0FBRUQ7QUFDRCxZQUFJLE1BQU0sSUFBVixFQUFnQjtBQUNkLGdCQUFNLElBQU4sQ0FBVyxJQUFYLEdBQW9CLE1BQU0sS0FBTixJQUFlLENBQWhCLEdBQXFCLENBQXhDO0FBQ0EsZ0JBQU0sSUFBTixDQUFXLElBQVgsR0FBa0IsSUFBbEI7QUFDRDtBQUNELGFBQUssS0FBTCxHQUFhLE1BQU0sS0FBTixHQUFjLENBQTNCO0FBQ0EsY0FBTSxJQUFOLEdBQWEsSUFBYjtBQUNBO0FBQ0YsV0FBSyxNQUFMOztBQUVFLGVBQU8sT0FBTyxFQUFkLEVBQWtCO0FBQ2hCLGNBQUksU0FBUyxDQUFiLEVBQWdCO0FBQUUsa0JBQU0sU0FBTjtBQUFrQjtBQUNwQztBQUNBLGtCQUFRLE1BQU0sTUFBTixLQUFpQixJQUF6QjtBQUNBLGtCQUFRLENBQVI7QUFDRDs7QUFFRCxhQUFLLEtBQUwsR0FBYSxNQUFNLEtBQU4sR0FBYyxRQUFRLElBQVIsQ0FBM0I7O0FBRUEsZUFBTyxDQUFQO0FBQ0EsZUFBTyxDQUFQOztBQUVBLGNBQU0sSUFBTixHQUFhLElBQWI7O0FBRUYsV0FBSyxJQUFMO0FBQ0UsWUFBSSxNQUFNLFFBQU4sS0FBbUIsQ0FBdkIsRUFBMEI7O0FBRXhCLGVBQUssUUFBTCxHQUFnQixHQUFoQjtBQUNBLGVBQUssU0FBTCxHQUFpQixJQUFqQjtBQUNBLGVBQUssT0FBTCxHQUFlLElBQWY7QUFDQSxlQUFLLFFBQUwsR0FBZ0IsSUFBaEI7QUFDQSxnQkFBTSxJQUFOLEdBQWEsSUFBYjtBQUNBLGdCQUFNLElBQU4sR0FBYSxJQUFiOztBQUVBLGlCQUFPLFdBQVA7QUFDRDtBQUNELGFBQUssS0FBTCxHQUFhLE1BQU0sS0FBTixHQUFjLEMsMkJBQTNCO0FBQ0EsY0FBTSxJQUFOLEdBQWEsSUFBYjs7QUFFRixXQUFLLElBQUw7QUFDRSxZQUFJLFVBQVUsT0FBVixJQUFxQixVQUFVLE9BQW5DLEVBQTRDO0FBQUUsZ0JBQU0sU0FBTjtBQUFrQjs7QUFFbEUsV0FBSyxNQUFMO0FBQ0UsWUFBSSxNQUFNLElBQVYsRUFBZ0I7O0FBRWQsb0JBQVUsT0FBTyxDQUFqQjtBQUNBLGtCQUFRLE9BQU8sQ0FBZjs7QUFFQSxnQkFBTSxJQUFOLEdBQWEsS0FBYjtBQUNBO0FBQ0Q7O0FBRUQsZUFBTyxPQUFPLENBQWQsRUFBaUI7QUFDZixjQUFJLFNBQVMsQ0FBYixFQUFnQjtBQUFFLGtCQUFNLFNBQU47QUFBa0I7QUFDcEM7QUFDQSxrQkFBUSxNQUFNLE1BQU4sS0FBaUIsSUFBekI7QUFDQSxrQkFBUSxDQUFSO0FBQ0Q7O0FBRUQsY0FBTSxJQUFOLEdBQWMsT0FBTyxJLFlBQXJCOztBQUVBLGtCQUFVLENBQVY7QUFDQSxnQkFBUSxDQUFSOzs7QUFHQSxnQkFBUyxPQUFPLElBQWhCLEc7QUFDQSxlQUFLLENBQUw7Ozs7QUFHRSxrQkFBTSxJQUFOLEdBQWEsTUFBYjtBQUNBO0FBQ0YsZUFBSyxDQUFMOztBQUNFLHdCQUFZLEtBQVo7OztBQUdBLGtCQUFNLElBQU4sR0FBYSxJQUFiLEM7QUFDQSxnQkFBSSxVQUFVLE9BQWQsRUFBdUI7O0FBRXJCLHdCQUFVLENBQVY7QUFDQSxzQkFBUSxDQUFSOztBQUVBLG9CQUFNLFNBQU47QUFDRDtBQUNEO0FBQ0YsZUFBSyxDQUFMOzs7O0FBR0Usa0JBQU0sSUFBTixHQUFhLEtBQWI7QUFDQTtBQUNGLGVBQUssQ0FBTDtBQUNFLGlCQUFLLEdBQUwsR0FBVyxvQkFBWDtBQUNBLGtCQUFNLElBQU4sR0FBYSxHQUFiO0FBMUJGOztBQTZCQSxrQkFBVSxDQUFWO0FBQ0EsZ0JBQVEsQ0FBUjs7QUFFQTtBQUNGLFdBQUssTUFBTDs7QUFFRSxrQkFBVSxPQUFPLENBQWpCO0FBQ0EsZ0JBQVEsT0FBTyxDQUFmOzs7QUFHQSxlQUFPLE9BQU8sRUFBZCxFQUFrQjtBQUNoQixjQUFJLFNBQVMsQ0FBYixFQUFnQjtBQUFFLGtCQUFNLFNBQU47QUFBa0I7QUFDcEM7QUFDQSxrQkFBUSxNQUFNLE1BQU4sS0FBaUIsSUFBekI7QUFDQSxrQkFBUSxDQUFSO0FBQ0Q7O0FBRUQsWUFBSSxDQUFDLE9BQU8sTUFBUixPQUFzQixTQUFTLEVBQVYsR0FBZ0IsTUFBckMsQ0FBSixFQUFrRDtBQUNoRCxlQUFLLEdBQUwsR0FBVyw4QkFBWDtBQUNBLGdCQUFNLElBQU4sR0FBYSxHQUFiO0FBQ0E7QUFDRDtBQUNELGNBQU0sTUFBTixHQUFlLE9BQU8sTUFBdEI7Ozs7QUFJQSxlQUFPLENBQVA7QUFDQSxlQUFPLENBQVA7O0FBRUEsY0FBTSxJQUFOLEdBQWEsS0FBYjtBQUNBLFlBQUksVUFBVSxPQUFkLEVBQXVCO0FBQUUsZ0JBQU0sU0FBTjtBQUFrQjs7QUFFN0MsV0FBSyxLQUFMO0FBQ0UsY0FBTSxJQUFOLEdBQWEsSUFBYjs7QUFFRixXQUFLLElBQUw7QUFDRSxlQUFPLE1BQU0sTUFBYjtBQUNBLFlBQUksSUFBSixFQUFVO0FBQ1IsY0FBSSxPQUFPLElBQVgsRUFBaUI7QUFBRSxtQkFBTyxJQUFQO0FBQWM7QUFDakMsY0FBSSxPQUFPLElBQVgsRUFBaUI7QUFBRSxtQkFBTyxJQUFQO0FBQWM7QUFDakMsY0FBSSxTQUFTLENBQWIsRUFBZ0I7QUFBRSxrQkFBTSxTQUFOO0FBQWtCOztBQUVwQyxnQkFBTSxRQUFOLENBQWUsTUFBZixFQUF1QixLQUF2QixFQUE4QixJQUE5QixFQUFvQyxJQUFwQyxFQUEwQyxHQUExQzs7QUFFQSxrQkFBUSxJQUFSO0FBQ0Esa0JBQVEsSUFBUjtBQUNBLGtCQUFRLElBQVI7QUFDQSxpQkFBTyxJQUFQO0FBQ0EsZ0JBQU0sTUFBTixJQUFnQixJQUFoQjtBQUNBO0FBQ0Q7O0FBRUQsY0FBTSxJQUFOLEdBQWEsSUFBYjtBQUNBO0FBQ0YsV0FBSyxLQUFMOztBQUVFLGVBQU8sT0FBTyxFQUFkLEVBQWtCO0FBQ2hCLGNBQUksU0FBUyxDQUFiLEVBQWdCO0FBQUUsa0JBQU0sU0FBTjtBQUFrQjtBQUNwQztBQUNBLGtCQUFRLE1BQU0sTUFBTixLQUFpQixJQUF6QjtBQUNBLGtCQUFRLENBQVI7QUFDRDs7QUFFRCxjQUFNLElBQU4sR0FBYSxDQUFDLE9BQU8sSUFBUixJLFdBQTJCLEdBQXhDOztBQUVBLGtCQUFVLENBQVY7QUFDQSxnQkFBUSxDQUFSOztBQUVBLGNBQU0sS0FBTixHQUFjLENBQUMsT0FBTyxJQUFSLEksV0FBMkIsQ0FBekM7O0FBRUEsa0JBQVUsQ0FBVjtBQUNBLGdCQUFRLENBQVI7O0FBRUEsY0FBTSxLQUFOLEdBQWMsQ0FBQyxPQUFPLElBQVIsSSxXQUEyQixDQUF6Qzs7QUFFQSxrQkFBVSxDQUFWO0FBQ0EsZ0JBQVEsQ0FBUjs7O0FBR0EsWUFBSSxNQUFNLElBQU4sR0FBYSxHQUFiLElBQW9CLE1BQU0sS0FBTixHQUFjLEVBQXRDLEVBQTBDO0FBQ3hDLGVBQUssR0FBTCxHQUFXLHFDQUFYO0FBQ0EsZ0JBQU0sSUFBTixHQUFhLEdBQWI7QUFDQTtBQUNEOzs7QUFHRCxjQUFNLElBQU4sR0FBYSxDQUFiO0FBQ0EsY0FBTSxJQUFOLEdBQWEsT0FBYjs7QUFFRixXQUFLLE9BQUw7QUFDRSxlQUFPLE1BQU0sSUFBTixHQUFhLE1BQU0sS0FBMUIsRUFBaUM7O0FBRS9CLGlCQUFPLE9BQU8sQ0FBZCxFQUFpQjtBQUNmLGdCQUFJLFNBQVMsQ0FBYixFQUFnQjtBQUFFLG9CQUFNLFNBQU47QUFBa0I7QUFDcEM7QUFDQSxvQkFBUSxNQUFNLE1BQU4sS0FBaUIsSUFBekI7QUFDQSxvQkFBUSxDQUFSO0FBQ0Q7O0FBRUQsZ0JBQU0sSUFBTixDQUFXLE1BQU0sTUFBTSxJQUFOLEVBQU4sQ0FBWCxJQUFtQyxPQUFPLElBQTFDLEM7O0FBRUEsb0JBQVUsQ0FBVjtBQUNBLGtCQUFRLENBQVI7O0FBRUQ7QUFDRCxlQUFPLE1BQU0sSUFBTixHQUFhLEVBQXBCLEVBQXdCO0FBQ3RCLGdCQUFNLElBQU4sQ0FBVyxNQUFNLE1BQU0sSUFBTixFQUFOLENBQVgsSUFBa0MsQ0FBbEM7QUFDRDs7Ozs7QUFLRCxjQUFNLE9BQU4sR0FBZ0IsTUFBTSxNQUF0QjtBQUNBLGNBQU0sT0FBTixHQUFnQixDQUFoQjs7QUFFQSxlQUFPLEVBQUUsTUFBTSxNQUFNLE9BQWQsRUFBUDtBQUNBLGNBQU0sY0FBYyxLQUFkLEVBQXFCLE1BQU0sSUFBM0IsRUFBaUMsQ0FBakMsRUFBb0MsRUFBcEMsRUFBd0MsTUFBTSxPQUE5QyxFQUF1RCxDQUF2RCxFQUEwRCxNQUFNLElBQWhFLEVBQXNFLElBQXRFLENBQU47QUFDQSxjQUFNLE9BQU4sR0FBZ0IsS0FBSyxJQUFyQjs7QUFFQSxZQUFJLEdBQUosRUFBUztBQUNQLGVBQUssR0FBTCxHQUFXLDBCQUFYO0FBQ0EsZ0JBQU0sSUFBTixHQUFhLEdBQWI7QUFDQTtBQUNEOztBQUVELGNBQU0sSUFBTixHQUFhLENBQWI7QUFDQSxjQUFNLElBQU4sR0FBYSxRQUFiOztBQUVGLFdBQUssUUFBTDtBQUNFLGVBQU8sTUFBTSxJQUFOLEdBQWEsTUFBTSxJQUFOLEdBQWEsTUFBTSxLQUF2QyxFQUE4QztBQUM1QyxtQkFBUztBQUNQLG1CQUFPLE1BQU0sT0FBTixDQUFjLE9BQVEsQ0FBQyxLQUFLLE1BQU0sT0FBWixJQUF1QixDQUE3QyxDQUFQLEM7QUFDQSx3QkFBWSxTQUFTLEVBQXJCO0FBQ0Esc0JBQVcsU0FBUyxFQUFWLEdBQWdCLElBQTFCO0FBQ0EsdUJBQVcsT0FBTyxNQUFsQjs7QUFFQSxnQkFBSyxTQUFELElBQWUsSUFBbkIsRUFBeUI7QUFBRTtBQUFROztBQUVuQyxnQkFBSSxTQUFTLENBQWIsRUFBZ0I7QUFBRSxvQkFBTSxTQUFOO0FBQWtCO0FBQ3BDO0FBQ0Esb0JBQVEsTUFBTSxNQUFOLEtBQWlCLElBQXpCO0FBQ0Esb0JBQVEsQ0FBUjs7QUFFRDtBQUNELGNBQUksV0FBVyxFQUFmLEVBQW1COztBQUVqQixzQkFBVSxTQUFWO0FBQ0Esb0JBQVEsU0FBUjs7QUFFQSxrQkFBTSxJQUFOLENBQVcsTUFBTSxJQUFOLEVBQVgsSUFBMkIsUUFBM0I7QUFDRCxXQU5ELE1BT0s7QUFDSCxnQkFBSSxhQUFhLEVBQWpCLEVBQXFCOztBQUVuQixrQkFBSSxZQUFZLENBQWhCO0FBQ0EscUJBQU8sT0FBTyxDQUFkLEVBQWlCO0FBQ2Ysb0JBQUksU0FBUyxDQUFiLEVBQWdCO0FBQUUsd0JBQU0sU0FBTjtBQUFrQjtBQUNwQztBQUNBLHdCQUFRLE1BQU0sTUFBTixLQUFpQixJQUF6QjtBQUNBLHdCQUFRLENBQVI7QUFDRDs7O0FBR0Qsd0JBQVUsU0FBVjtBQUNBLHNCQUFRLFNBQVI7O0FBRUEsa0JBQUksTUFBTSxJQUFOLEtBQWUsQ0FBbkIsRUFBc0I7QUFDcEIscUJBQUssR0FBTCxHQUFXLDJCQUFYO0FBQ0Esc0JBQU0sSUFBTixHQUFhLEdBQWI7QUFDQTtBQUNEO0FBQ0Qsb0JBQU0sTUFBTSxJQUFOLENBQVcsTUFBTSxJQUFOLEdBQWEsQ0FBeEIsQ0FBTjtBQUNBLHFCQUFPLEtBQUssT0FBTyxJQUFaLENBQVAsQzs7QUFFQSx3QkFBVSxDQUFWO0FBQ0Esc0JBQVEsQ0FBUjs7QUFFRCxhQXpCRCxNQTBCSyxJQUFJLGFBQWEsRUFBakIsRUFBcUI7O0FBRXhCLGtCQUFJLFlBQVksQ0FBaEI7QUFDQSxxQkFBTyxPQUFPLENBQWQsRUFBaUI7QUFDZixvQkFBSSxTQUFTLENBQWIsRUFBZ0I7QUFBRSx3QkFBTSxTQUFOO0FBQWtCO0FBQ3BDO0FBQ0Esd0JBQVEsTUFBTSxNQUFOLEtBQWlCLElBQXpCO0FBQ0Esd0JBQVEsQ0FBUjtBQUNEOzs7QUFHRCx3QkFBVSxTQUFWO0FBQ0Esc0JBQVEsU0FBUjs7QUFFQSxvQkFBTSxDQUFOO0FBQ0EscUJBQU8sS0FBSyxPQUFPLElBQVosQ0FBUCxDOztBQUVBLHdCQUFVLENBQVY7QUFDQSxzQkFBUSxDQUFSOztBQUVELGFBcEJJLE1BcUJBOztBQUVILGtCQUFJLFlBQVksQ0FBaEI7QUFDQSxxQkFBTyxPQUFPLENBQWQsRUFBaUI7QUFDZixvQkFBSSxTQUFTLENBQWIsRUFBZ0I7QUFBRSx3QkFBTSxTQUFOO0FBQWtCO0FBQ3BDO0FBQ0Esd0JBQVEsTUFBTSxNQUFOLEtBQWlCLElBQXpCO0FBQ0Esd0JBQVEsQ0FBUjtBQUNEOzs7QUFHRCx3QkFBVSxTQUFWO0FBQ0Esc0JBQVEsU0FBUjs7QUFFQSxvQkFBTSxDQUFOO0FBQ0EscUJBQU8sTUFBTSxPQUFPLElBQWIsQ0FBUCxDOztBQUVBLHdCQUFVLENBQVY7QUFDQSxzQkFBUSxDQUFSOztBQUVEO0FBQ0QsZ0JBQUksTUFBTSxJQUFOLEdBQWEsSUFBYixHQUFvQixNQUFNLElBQU4sR0FBYSxNQUFNLEtBQTNDLEVBQWtEO0FBQ2hELG1CQUFLLEdBQUwsR0FBVywyQkFBWDtBQUNBLG9CQUFNLElBQU4sR0FBYSxHQUFiO0FBQ0E7QUFDRDtBQUNELG1CQUFPLE1BQVAsRUFBZTtBQUNiLG9CQUFNLElBQU4sQ0FBVyxNQUFNLElBQU4sRUFBWCxJQUEyQixHQUEzQjtBQUNEO0FBQ0Y7QUFDRjs7O0FBR0QsWUFBSSxNQUFNLElBQU4sS0FBZSxHQUFuQixFQUF3QjtBQUFFO0FBQVE7OztBQUdsQyxZQUFJLE1BQU0sSUFBTixDQUFXLEdBQVgsTUFBb0IsQ0FBeEIsRUFBMkI7QUFDekIsZUFBSyxHQUFMLEdBQVcsc0NBQVg7QUFDQSxnQkFBTSxJQUFOLEdBQWEsR0FBYjtBQUNBO0FBQ0Q7Ozs7O0FBS0QsY0FBTSxPQUFOLEdBQWdCLENBQWhCOztBQUVBLGVBQU8sRUFBRSxNQUFNLE1BQU0sT0FBZCxFQUFQO0FBQ0EsY0FBTSxjQUFjLElBQWQsRUFBb0IsTUFBTSxJQUExQixFQUFnQyxDQUFoQyxFQUFtQyxNQUFNLElBQXpDLEVBQStDLE1BQU0sT0FBckQsRUFBOEQsQ0FBOUQsRUFBaUUsTUFBTSxJQUF2RSxFQUE2RSxJQUE3RSxDQUFOOzs7QUFHQSxjQUFNLE9BQU4sR0FBZ0IsS0FBSyxJQUFyQjs7O0FBR0EsWUFBSSxHQUFKLEVBQVM7QUFDUCxlQUFLLEdBQUwsR0FBVyw2QkFBWDtBQUNBLGdCQUFNLElBQU4sR0FBYSxHQUFiO0FBQ0E7QUFDRDs7QUFFRCxjQUFNLFFBQU4sR0FBaUIsQ0FBakI7OztBQUdBLGNBQU0sUUFBTixHQUFpQixNQUFNLE9BQXZCO0FBQ0EsZUFBTyxFQUFFLE1BQU0sTUFBTSxRQUFkLEVBQVA7QUFDQSxjQUFNLGNBQWMsS0FBZCxFQUFxQixNQUFNLElBQTNCLEVBQWlDLE1BQU0sSUFBdkMsRUFBNkMsTUFBTSxLQUFuRCxFQUEwRCxNQUFNLFFBQWhFLEVBQTBFLENBQTFFLEVBQTZFLE1BQU0sSUFBbkYsRUFBeUYsSUFBekYsQ0FBTjs7O0FBR0EsY0FBTSxRQUFOLEdBQWlCLEtBQUssSUFBdEI7OztBQUdBLFlBQUksR0FBSixFQUFTO0FBQ1AsZUFBSyxHQUFMLEdBQVcsdUJBQVg7QUFDQSxnQkFBTSxJQUFOLEdBQWEsR0FBYjtBQUNBO0FBQ0Q7O0FBRUQsY0FBTSxJQUFOLEdBQWEsSUFBYjtBQUNBLFlBQUksVUFBVSxPQUFkLEVBQXVCO0FBQUUsZ0JBQU0sU0FBTjtBQUFrQjs7QUFFN0MsV0FBSyxJQUFMO0FBQ0UsY0FBTSxJQUFOLEdBQWEsR0FBYjs7QUFFRixXQUFLLEdBQUw7QUFDRSxZQUFJLFFBQVEsQ0FBUixJQUFhLFFBQVEsR0FBekIsRUFBOEI7O0FBRTVCLGVBQUssUUFBTCxHQUFnQixHQUFoQjtBQUNBLGVBQUssU0FBTCxHQUFpQixJQUFqQjtBQUNBLGVBQUssT0FBTCxHQUFlLElBQWY7QUFDQSxlQUFLLFFBQUwsR0FBZ0IsSUFBaEI7QUFDQSxnQkFBTSxJQUFOLEdBQWEsSUFBYjtBQUNBLGdCQUFNLElBQU4sR0FBYSxJQUFiOztBQUVBLHVCQUFhLElBQWIsRUFBbUIsSUFBbkI7O0FBRUEsZ0JBQU0sS0FBSyxRQUFYO0FBQ0EsbUJBQVMsS0FBSyxNQUFkO0FBQ0EsaUJBQU8sS0FBSyxTQUFaO0FBQ0EsaUJBQU8sS0FBSyxPQUFaO0FBQ0Esa0JBQVEsS0FBSyxLQUFiO0FBQ0EsaUJBQU8sS0FBSyxRQUFaO0FBQ0EsaUJBQU8sTUFBTSxJQUFiO0FBQ0EsaUJBQU8sTUFBTSxJQUFiOzs7QUFHQSxjQUFJLE1BQU0sSUFBTixLQUFlLElBQW5CLEVBQXlCO0FBQ3ZCLGtCQUFNLElBQU4sR0FBYSxDQUFDLENBQWQ7QUFDRDtBQUNEO0FBQ0Q7QUFDRCxjQUFNLElBQU4sR0FBYSxDQUFiO0FBQ0EsaUJBQVM7QUFDUCxpQkFBTyxNQUFNLE9BQU4sQ0FBYyxPQUFRLENBQUMsS0FBSyxNQUFNLE9BQVosSUFBdUIsQ0FBN0MsQ0FBUCxDO0FBQ0Esc0JBQVksU0FBUyxFQUFyQjtBQUNBLG9CQUFXLFNBQVMsRUFBVixHQUFnQixJQUExQjtBQUNBLHFCQUFXLE9BQU8sTUFBbEI7O0FBRUEsY0FBSSxhQUFhLElBQWpCLEVBQXVCO0FBQUU7QUFBUTs7QUFFakMsY0FBSSxTQUFTLENBQWIsRUFBZ0I7QUFBRSxrQkFBTSxTQUFOO0FBQWtCO0FBQ3BDO0FBQ0Esa0JBQVEsTUFBTSxNQUFOLEtBQWlCLElBQXpCO0FBQ0Esa0JBQVEsQ0FBUjs7QUFFRDtBQUNELFlBQUksV0FBVyxDQUFDLFVBQVUsSUFBWCxNQUFxQixDQUFwQyxFQUF1QztBQUNyQyxzQkFBWSxTQUFaO0FBQ0Esb0JBQVUsT0FBVjtBQUNBLHFCQUFXLFFBQVg7QUFDQSxtQkFBUztBQUNQLG1CQUFPLE1BQU0sT0FBTixDQUFjLFlBQ1osQ0FBQyxPQUFRLENBQUMsS0FBTSxZQUFZLE9BQW5CLElBQStCLENBQXhDLEssNkJBQTRFLFNBRGhFLENBQWQsQ0FBUDtBQUVBLHdCQUFZLFNBQVMsRUFBckI7QUFDQSxzQkFBVyxTQUFTLEVBQVYsR0FBZ0IsSUFBMUI7QUFDQSx1QkFBVyxPQUFPLE1BQWxCOztBQUVBLGdCQUFLLFlBQVksU0FBYixJQUEyQixJQUEvQixFQUFxQztBQUFFO0FBQVE7O0FBRS9DLGdCQUFJLFNBQVMsQ0FBYixFQUFnQjtBQUFFLG9CQUFNLFNBQU47QUFBa0I7QUFDcEM7QUFDQSxvQkFBUSxNQUFNLE1BQU4sS0FBaUIsSUFBekI7QUFDQSxvQkFBUSxDQUFSOztBQUVEOztBQUVELG9CQUFVLFNBQVY7QUFDQSxrQkFBUSxTQUFSOztBQUVBLGdCQUFNLElBQU4sSUFBYyxTQUFkO0FBQ0Q7O0FBRUQsa0JBQVUsU0FBVjtBQUNBLGdCQUFRLFNBQVI7O0FBRUEsY0FBTSxJQUFOLElBQWMsU0FBZDtBQUNBLGNBQU0sTUFBTixHQUFlLFFBQWY7QUFDQSxZQUFJLFlBQVksQ0FBaEIsRUFBbUI7Ozs7QUFJakIsZ0JBQU0sSUFBTixHQUFhLEdBQWI7QUFDQTtBQUNEO0FBQ0QsWUFBSSxVQUFVLEVBQWQsRUFBa0I7O0FBRWhCLGdCQUFNLElBQU4sR0FBYSxDQUFDLENBQWQ7QUFDQSxnQkFBTSxJQUFOLEdBQWEsSUFBYjtBQUNBO0FBQ0Q7QUFDRCxZQUFJLFVBQVUsRUFBZCxFQUFrQjtBQUNoQixlQUFLLEdBQUwsR0FBVyw2QkFBWDtBQUNBLGdCQUFNLElBQU4sR0FBYSxHQUFiO0FBQ0E7QUFDRDtBQUNELGNBQU0sS0FBTixHQUFjLFVBQVUsRUFBeEI7QUFDQSxjQUFNLElBQU4sR0FBYSxNQUFiOztBQUVGLFdBQUssTUFBTDtBQUNFLFlBQUksTUFBTSxLQUFWLEVBQWlCOztBQUVmLGNBQUksTUFBTSxLQUFWO0FBQ0EsaUJBQU8sT0FBTyxDQUFkLEVBQWlCO0FBQ2YsZ0JBQUksU0FBUyxDQUFiLEVBQWdCO0FBQUUsb0JBQU0sU0FBTjtBQUFrQjtBQUNwQztBQUNBLG9CQUFRLE1BQU0sTUFBTixLQUFpQixJQUF6QjtBQUNBLG9CQUFRLENBQVI7QUFDRDs7QUFFRCxnQkFBTSxNQUFOLElBQWdCLE9BQVEsQ0FBQyxLQUFLLE1BQU0sS0FBWixJQUFxQixDLHNCQUE3Qzs7QUFFQSxvQkFBVSxNQUFNLEtBQWhCO0FBQ0Esa0JBQVEsTUFBTSxLQUFkOztBQUVBLGdCQUFNLElBQU4sSUFBYyxNQUFNLEtBQXBCO0FBQ0Q7O0FBRUQsY0FBTSxHQUFOLEdBQVksTUFBTSxNQUFsQjtBQUNBLGNBQU0sSUFBTixHQUFhLElBQWI7O0FBRUYsV0FBSyxJQUFMO0FBQ0UsaUJBQVM7QUFDUCxpQkFBTyxNQUFNLFFBQU4sQ0FBZSxPQUFRLENBQUMsS0FBSyxNQUFNLFFBQVosSUFBd0IsQ0FBL0MsQ0FBUCxDO0FBQ0Esc0JBQVksU0FBUyxFQUFyQjtBQUNBLG9CQUFXLFNBQVMsRUFBVixHQUFnQixJQUExQjtBQUNBLHFCQUFXLE9BQU8sTUFBbEI7O0FBRUEsY0FBSyxTQUFELElBQWUsSUFBbkIsRUFBeUI7QUFBRTtBQUFROztBQUVuQyxjQUFJLFNBQVMsQ0FBYixFQUFnQjtBQUFFLGtCQUFNLFNBQU47QUFBa0I7QUFDcEM7QUFDQSxrQkFBUSxNQUFNLE1BQU4sS0FBaUIsSUFBekI7QUFDQSxrQkFBUSxDQUFSOztBQUVEO0FBQ0QsWUFBSSxDQUFDLFVBQVUsSUFBWCxNQUFxQixDQUF6QixFQUE0QjtBQUMxQixzQkFBWSxTQUFaO0FBQ0Esb0JBQVUsT0FBVjtBQUNBLHFCQUFXLFFBQVg7QUFDQSxtQkFBUztBQUNQLG1CQUFPLE1BQU0sUUFBTixDQUFlLFlBQ2IsQ0FBQyxPQUFRLENBQUMsS0FBTSxZQUFZLE9BQW5CLElBQStCLENBQXhDLEssNkJBQTRFLFNBRC9ELENBQWYsQ0FBUDtBQUVBLHdCQUFZLFNBQVMsRUFBckI7QUFDQSxzQkFBVyxTQUFTLEVBQVYsR0FBZ0IsSUFBMUI7QUFDQSx1QkFBVyxPQUFPLE1BQWxCOztBQUVBLGdCQUFLLFlBQVksU0FBYixJQUEyQixJQUEvQixFQUFxQztBQUFFO0FBQVE7O0FBRS9DLGdCQUFJLFNBQVMsQ0FBYixFQUFnQjtBQUFFLG9CQUFNLFNBQU47QUFBa0I7QUFDcEM7QUFDQSxvQkFBUSxNQUFNLE1BQU4sS0FBaUIsSUFBekI7QUFDQSxvQkFBUSxDQUFSOztBQUVEOztBQUVELG9CQUFVLFNBQVY7QUFDQSxrQkFBUSxTQUFSOztBQUVBLGdCQUFNLElBQU4sSUFBYyxTQUFkO0FBQ0Q7O0FBRUQsa0JBQVUsU0FBVjtBQUNBLGdCQUFRLFNBQVI7O0FBRUEsY0FBTSxJQUFOLElBQWMsU0FBZDtBQUNBLFlBQUksVUFBVSxFQUFkLEVBQWtCO0FBQ2hCLGVBQUssR0FBTCxHQUFXLHVCQUFYO0FBQ0EsZ0JBQU0sSUFBTixHQUFhLEdBQWI7QUFDQTtBQUNEO0FBQ0QsY0FBTSxNQUFOLEdBQWUsUUFBZjtBQUNBLGNBQU0sS0FBTixHQUFlLE9BQUQsR0FBWSxFQUExQjtBQUNBLGNBQU0sSUFBTixHQUFhLE9BQWI7O0FBRUYsV0FBSyxPQUFMO0FBQ0UsWUFBSSxNQUFNLEtBQVYsRUFBaUI7O0FBRWYsY0FBSSxNQUFNLEtBQVY7QUFDQSxpQkFBTyxPQUFPLENBQWQsRUFBaUI7QUFDZixnQkFBSSxTQUFTLENBQWIsRUFBZ0I7QUFBRSxvQkFBTSxTQUFOO0FBQWtCO0FBQ3BDO0FBQ0Esb0JBQVEsTUFBTSxNQUFOLEtBQWlCLElBQXpCO0FBQ0Esb0JBQVEsQ0FBUjtBQUNEOztBQUVELGdCQUFNLE1BQU4sSUFBZ0IsT0FBUSxDQUFDLEtBQUssTUFBTSxLQUFaLElBQXFCLEMsc0JBQTdDOztBQUVBLG9CQUFVLE1BQU0sS0FBaEI7QUFDQSxrQkFBUSxNQUFNLEtBQWQ7O0FBRUEsZ0JBQU0sSUFBTixJQUFjLE1BQU0sS0FBcEI7QUFDRDs7QUFFRCxZQUFJLE1BQU0sTUFBTixHQUFlLE1BQU0sSUFBekIsRUFBK0I7QUFDN0IsZUFBSyxHQUFMLEdBQVcsK0JBQVg7QUFDQSxnQkFBTSxJQUFOLEdBQWEsR0FBYjtBQUNBO0FBQ0Q7OztBQUdELGNBQU0sSUFBTixHQUFhLEtBQWI7O0FBRUYsV0FBSyxLQUFMO0FBQ0UsWUFBSSxTQUFTLENBQWIsRUFBZ0I7QUFBRSxnQkFBTSxTQUFOO0FBQWtCO0FBQ3BDLGVBQU8sT0FBTyxJQUFkO0FBQ0EsWUFBSSxNQUFNLE1BQU4sR0FBZSxJQUFuQixFQUF5Qjs7QUFDdkIsaUJBQU8sTUFBTSxNQUFOLEdBQWUsSUFBdEI7QUFDQSxjQUFJLE9BQU8sTUFBTSxLQUFqQixFQUF3QjtBQUN0QixnQkFBSSxNQUFNLElBQVYsRUFBZ0I7QUFDZCxtQkFBSyxHQUFMLEdBQVcsK0JBQVg7QUFDQSxvQkFBTSxJQUFOLEdBQWEsR0FBYjtBQUNBO0FBQ0Q7Ozs7Ozs7Ozs7Ozs7Ozs7QUFnQkY7QUFDRCxjQUFJLE9BQU8sTUFBTSxLQUFqQixFQUF3QjtBQUN0QixvQkFBUSxNQUFNLEtBQWQ7QUFDQSxtQkFBTyxNQUFNLEtBQU4sR0FBYyxJQUFyQjtBQUNELFdBSEQsTUFJSztBQUNILG1CQUFPLE1BQU0sS0FBTixHQUFjLElBQXJCO0FBQ0Q7QUFDRCxjQUFJLE9BQU8sTUFBTSxNQUFqQixFQUF5QjtBQUFFLG1CQUFPLE1BQU0sTUFBYjtBQUFzQjtBQUNqRCx3QkFBYyxNQUFNLE1BQXBCO0FBQ0QsU0FqQ0QsTUFrQ0s7O0FBQ0gsd0JBQWMsTUFBZDtBQUNBLGlCQUFPLE1BQU0sTUFBTSxNQUFuQjtBQUNBLGlCQUFPLE1BQU0sTUFBYjtBQUNEO0FBQ0QsWUFBSSxPQUFPLElBQVgsRUFBaUI7QUFBRSxpQkFBTyxJQUFQO0FBQWM7QUFDakMsZ0JBQVEsSUFBUjtBQUNBLGNBQU0sTUFBTixJQUFnQixJQUFoQjtBQUNBLFdBQUc7QUFDRCxpQkFBTyxLQUFQLElBQWdCLFlBQVksTUFBWixDQUFoQjtBQUNELFNBRkQsUUFFUyxFQUFFLElBRlg7QUFHQSxZQUFJLE1BQU0sTUFBTixLQUFpQixDQUFyQixFQUF3QjtBQUFFLGdCQUFNLElBQU4sR0FBYSxHQUFiO0FBQW1CO0FBQzdDO0FBQ0YsV0FBSyxHQUFMO0FBQ0UsWUFBSSxTQUFTLENBQWIsRUFBZ0I7QUFBRSxnQkFBTSxTQUFOO0FBQWtCO0FBQ3BDLGVBQU8sS0FBUCxJQUFnQixNQUFNLE1BQXRCO0FBQ0E7QUFDQSxjQUFNLElBQU4sR0FBYSxHQUFiO0FBQ0E7QUFDRixXQUFLLEtBQUw7QUFDRSxZQUFJLE1BQU0sSUFBVixFQUFnQjs7QUFFZCxpQkFBTyxPQUFPLEVBQWQsRUFBa0I7QUFDaEIsZ0JBQUksU0FBUyxDQUFiLEVBQWdCO0FBQUUsb0JBQU0sU0FBTjtBQUFrQjtBQUNwQzs7QUFFQSxvQkFBUSxNQUFNLE1BQU4sS0FBaUIsSUFBekI7QUFDQSxvQkFBUSxDQUFSO0FBQ0Q7O0FBRUQsa0JBQVEsSUFBUjtBQUNBLGVBQUssU0FBTCxJQUFrQixJQUFsQjtBQUNBLGdCQUFNLEtBQU4sSUFBZSxJQUFmO0FBQ0EsY0FBSSxJQUFKLEVBQVU7QUFDUixpQkFBSyxLQUFMLEdBQWEsTUFBTSxLQUFOOztBQUVSLGtCQUFNLEtBQU4sR0FBYyxNQUFNLE1BQU0sS0FBWixFQUFtQixNQUFuQixFQUEyQixJQUEzQixFQUFpQyxNQUFNLElBQXZDLENBQWQsR0FBNkQsUUFBUSxNQUFNLEtBQWQsRUFBcUIsTUFBckIsRUFBNkIsSUFBN0IsRUFBbUMsTUFBTSxJQUF6QyxDQUZsRTtBQUlEO0FBQ0QsaUJBQU8sSUFBUDs7QUFFQSxjQUFJLENBQUMsTUFBTSxLQUFOLEdBQWMsSUFBZCxHQUFxQixRQUFRLElBQVIsQ0FBdEIsTUFBeUMsTUFBTSxLQUFuRCxFQUEwRDtBQUN4RCxpQkFBSyxHQUFMLEdBQVcsc0JBQVg7QUFDQSxrQkFBTSxJQUFOLEdBQWEsR0FBYjtBQUNBO0FBQ0Q7O0FBRUQsaUJBQU8sQ0FBUDtBQUNBLGlCQUFPLENBQVA7OztBQUdEO0FBQ0QsY0FBTSxJQUFOLEdBQWEsTUFBYjs7QUFFRixXQUFLLE1BQUw7QUFDRSxZQUFJLE1BQU0sSUFBTixJQUFjLE1BQU0sS0FBeEIsRUFBK0I7O0FBRTdCLGlCQUFPLE9BQU8sRUFBZCxFQUFrQjtBQUNoQixnQkFBSSxTQUFTLENBQWIsRUFBZ0I7QUFBRSxvQkFBTSxTQUFOO0FBQWtCO0FBQ3BDO0FBQ0Esb0JBQVEsTUFBTSxNQUFOLEtBQWlCLElBQXpCO0FBQ0Esb0JBQVEsQ0FBUjtBQUNEOztBQUVELGNBQUksVUFBVSxNQUFNLEtBQU4sR0FBYyxVQUF4QixDQUFKLEVBQXlDO0FBQ3ZDLGlCQUFLLEdBQUwsR0FBVyx3QkFBWDtBQUNBLGtCQUFNLElBQU4sR0FBYSxHQUFiO0FBQ0E7QUFDRDs7QUFFRCxpQkFBTyxDQUFQO0FBQ0EsaUJBQU8sQ0FBUDs7O0FBR0Q7QUFDRCxjQUFNLElBQU4sR0FBYSxJQUFiOztBQUVGLFdBQUssSUFBTDtBQUNFLGNBQU0sWUFBTjtBQUNBLGNBQU0sU0FBTjtBQUNGLFdBQUssR0FBTDtBQUNFLGNBQU0sWUFBTjtBQUNBLGNBQU0sU0FBTjtBQUNGLFdBQUssR0FBTDtBQUNFLGVBQU8sV0FBUDtBQUNGLFdBQUssSUFBTDs7QUFFQTtBQUNFLGVBQU8sY0FBUDtBQWgrQkY7QUFrK0JEOzs7Ozs7Ozs7Ozs7QUFZRCxPQUFLLFFBQUwsR0FBZ0IsR0FBaEI7QUFDQSxPQUFLLFNBQUwsR0FBaUIsSUFBakI7QUFDQSxPQUFLLE9BQUwsR0FBZSxJQUFmO0FBQ0EsT0FBSyxRQUFMLEdBQWdCLElBQWhCO0FBQ0EsUUFBTSxJQUFOLEdBQWEsSUFBYjtBQUNBLFFBQU0sSUFBTixHQUFhLElBQWI7OztBQUdBLE1BQUksTUFBTSxLQUFOLElBQWdCLFNBQVMsS0FBSyxTQUFkLElBQTJCLE1BQU0sSUFBTixHQUFhLEdBQXhDLEtBQ0MsTUFBTSxJQUFOLEdBQWEsS0FBYixJQUFzQixVQUFVLFFBRGpDLENBQXBCLEVBQ2lFO0FBQy9ELFFBQUksYUFBYSxJQUFiLEVBQW1CLEtBQUssTUFBeEIsRUFBZ0MsS0FBSyxRQUFyQyxFQUErQyxPQUFPLEtBQUssU0FBM0QsQ0FBSixFQUEyRTtBQUN6RSxZQUFNLElBQU4sR0FBYSxHQUFiO0FBQ0EsYUFBTyxXQUFQO0FBQ0Q7QUFDRjtBQUNELFNBQU8sS0FBSyxRQUFaO0FBQ0EsVUFBUSxLQUFLLFNBQWI7QUFDQSxPQUFLLFFBQUwsSUFBaUIsR0FBakI7QUFDQSxPQUFLLFNBQUwsSUFBa0IsSUFBbEI7QUFDQSxRQUFNLEtBQU4sSUFBZSxJQUFmO0FBQ0EsTUFBSSxNQUFNLElBQU4sSUFBYyxJQUFsQixFQUF3QjtBQUN0QixTQUFLLEtBQUwsR0FBYSxNQUFNLEtBQU4sRztBQUNWLFVBQU0sS0FBTixHQUFjLE1BQU0sTUFBTSxLQUFaLEVBQW1CLE1BQW5CLEVBQTJCLElBQTNCLEVBQWlDLEtBQUssUUFBTCxHQUFnQixJQUFqRCxDQUFkLEdBQXVFLFFBQVEsTUFBTSxLQUFkLEVBQXFCLE1BQXJCLEVBQTZCLElBQTdCLEVBQW1DLEtBQUssUUFBTCxHQUFnQixJQUFuRCxDQUQxRTtBQUVEO0FBQ0QsT0FBSyxTQUFMLEdBQWlCLE1BQU0sSUFBTixJQUFjLE1BQU0sSUFBTixHQUFhLEVBQWIsR0FBa0IsQ0FBaEMsS0FDRSxNQUFNLElBQU4sS0FBZSxJQUFmLEdBQXNCLEdBQXRCLEdBQTRCLENBRDlCLEtBRUUsTUFBTSxJQUFOLEtBQWUsSUFBZixJQUF1QixNQUFNLElBQU4sS0FBZSxLQUF0QyxHQUE4QyxHQUE5QyxHQUFvRCxDQUZ0RCxDQUFqQjtBQUdBLE1BQUksQ0FBRSxRQUFRLENBQVIsSUFBYSxTQUFTLENBQXZCLElBQTZCLFVBQVUsUUFBeEMsS0FBcUQsUUFBUSxJQUFqRSxFQUF1RTtBQUNyRSxVQUFNLFdBQU47QUFDRDtBQUNELFNBQU8sR0FBUDtBQUNEOztBQUVELFNBQVMsVUFBVCxDQUFvQixJQUFwQixFQUEwQjs7QUFFeEIsTUFBSSxDQUFDLElBQUQsSUFBUyxDQUFDLEtBQUssSyxtQ0FBbkIsRUFBNkQ7QUFDM0QsYUFBTyxjQUFQO0FBQ0Q7O0FBRUQsTUFBSSxRQUFRLEtBQUssS0FBakI7QUFDQSxNQUFJLE1BQU0sTUFBVixFQUFrQjtBQUNoQixVQUFNLE1BQU4sR0FBZSxJQUFmO0FBQ0Q7QUFDRCxPQUFLLEtBQUwsR0FBYSxJQUFiO0FBQ0EsU0FBTyxJQUFQO0FBQ0Q7O0FBRUQsU0FBUyxnQkFBVCxDQUEwQixJQUExQixFQUFnQyxJQUFoQyxFQUFzQztBQUNwQyxNQUFJLEtBQUo7OztBQUdBLE1BQUksQ0FBQyxJQUFELElBQVMsQ0FBQyxLQUFLLEtBQW5CLEVBQTBCO0FBQUUsV0FBTyxjQUFQO0FBQXdCO0FBQ3BELFVBQVEsS0FBSyxLQUFiO0FBQ0EsTUFBSSxDQUFDLE1BQU0sSUFBTixHQUFhLENBQWQsTUFBcUIsQ0FBekIsRUFBNEI7QUFBRSxXQUFPLGNBQVA7QUFBd0I7OztBQUd0RCxRQUFNLElBQU4sR0FBYSxJQUFiO0FBQ0EsT0FBSyxJQUFMLEdBQVksS0FBWjtBQUNBLFNBQU8sSUFBUDtBQUNEOztBQUVELFNBQVMsb0JBQVQsQ0FBOEIsSUFBOUIsRUFBb0MsVUFBcEMsRUFBZ0Q7QUFDOUMsTUFBSSxhQUFhLFdBQVcsTUFBNUI7O0FBRUEsTUFBSSxLQUFKO0FBQ0EsTUFBSSxNQUFKO0FBQ0EsTUFBSSxHQUFKOzs7QUFHQSxNQUFJLENBQUMsSSxnQkFBRCxJQUF5QixDQUFDLEtBQUssSyxnQkFBbkMsRUFBMEQ7QUFBRSxhQUFPLGNBQVA7QUFBd0I7QUFDcEYsVUFBUSxLQUFLLEtBQWI7O0FBRUEsTUFBSSxNQUFNLElBQU4sS0FBZSxDQUFmLElBQW9CLE1BQU0sSUFBTixLQUFlLElBQXZDLEVBQTZDO0FBQzNDLFdBQU8sY0FBUDtBQUNEOzs7QUFHRCxNQUFJLE1BQU0sSUFBTixLQUFlLElBQW5CLEVBQXlCO0FBQ3ZCLGFBQVMsQ0FBVCxDOztBQUVBLGFBQVMsUUFBUSxNQUFSLEVBQWdCLFVBQWhCLEVBQTRCLFVBQTVCLEVBQXdDLENBQXhDLENBQVQ7QUFDQSxRQUFJLFdBQVcsTUFBTSxLQUFyQixFQUE0QjtBQUMxQixhQUFPLFlBQVA7QUFDRDtBQUNGOzs7QUFHRCxRQUFNLGFBQWEsSUFBYixFQUFtQixVQUFuQixFQUErQixVQUEvQixFQUEyQyxVQUEzQyxDQUFOO0FBQ0EsTUFBSSxHQUFKLEVBQVM7QUFDUCxVQUFNLElBQU4sR0FBYSxHQUFiO0FBQ0EsV0FBTyxXQUFQO0FBQ0Q7QUFDRCxRQUFNLFFBQU4sR0FBaUIsQ0FBakI7O0FBRUEsU0FBTyxJQUFQO0FBQ0Q7O0FBRUQsUUFBUSxZQUFSLEdBQXVCLFlBQXZCO0FBQ0EsUUFBUSxhQUFSLEdBQXdCLGFBQXhCO0FBQ0EsUUFBUSxnQkFBUixHQUEyQixnQkFBM0I7QUFDQSxRQUFRLFdBQVIsR0FBc0IsV0FBdEI7QUFDQSxRQUFRLFlBQVIsR0FBdUIsWUFBdkI7QUFDQSxRQUFRLE9BQVIsR0FBa0IsT0FBbEI7QUFDQSxRQUFRLFVBQVIsR0FBcUIsVUFBckI7QUFDQSxRQUFRLGdCQUFSLEdBQTJCLGdCQUEzQjtBQUNBLFFBQVEsb0JBQVIsR0FBK0Isb0JBQS9CO0FBQ0EsUUFBUSxXQUFSLEdBQXNCLG9DQUF0Qjs7Ozs7Ozs7Ozs7OztBQ3YvQ0E7O0FBR0EsSUFBSSxRQUFRLFFBQVEsaUJBQVIsQ0FBWjs7QUFFQSxJQUFJLFVBQVUsRUFBZDtBQUNBLElBQUksY0FBYyxHQUFsQjtBQUNBLElBQUksZUFBZSxHQUFuQjs7O0FBR0EsSUFBSSxRQUFRLENBQVo7QUFDQSxJQUFJLE9BQU8sQ0FBWDtBQUNBLElBQUksUUFBUSxDQUFaOztBQUVBLElBQUksUUFBUSxDO0FBQ1YsQ0FEVSxFQUNQLENBRE8sRUFDSixDQURJLEVBQ0QsQ0FEQyxFQUNFLENBREYsRUFDSyxDQURMLEVBQ1EsQ0FEUixFQUNXLEVBRFgsRUFDZSxFQURmLEVBQ21CLEVBRG5CLEVBQ3VCLEVBRHZCLEVBQzJCLEVBRDNCLEVBQytCLEVBRC9CLEVBQ21DLEVBRG5DLEVBQ3VDLEVBRHZDLEVBQzJDLEVBRDNDLEVBRVYsRUFGVSxFQUVOLEVBRk0sRUFFRixFQUZFLEVBRUUsRUFGRixFQUVNLEVBRk4sRUFFVSxFQUZWLEVBRWMsRUFGZCxFQUVrQixHQUZsQixFQUV1QixHQUZ2QixFQUU0QixHQUY1QixFQUVpQyxHQUZqQyxFQUVzQyxHQUZ0QyxFQUUyQyxHQUYzQyxFQUVnRCxDQUZoRCxFQUVtRCxDQUZuRCxDQUFaOztBQUtBLElBQUksT0FBTyxDO0FBQ1QsRUFEUyxFQUNMLEVBREssRUFDRCxFQURDLEVBQ0csRUFESCxFQUNPLEVBRFAsRUFDVyxFQURYLEVBQ2UsRUFEZixFQUNtQixFQURuQixFQUN1QixFQUR2QixFQUMyQixFQUQzQixFQUMrQixFQUQvQixFQUNtQyxFQURuQyxFQUN1QyxFQUR2QyxFQUMyQyxFQUQzQyxFQUMrQyxFQUQvQyxFQUNtRCxFQURuRCxFQUVULEVBRlMsRUFFTCxFQUZLLEVBRUQsRUFGQyxFQUVHLEVBRkgsRUFFTyxFQUZQLEVBRVcsRUFGWCxFQUVlLEVBRmYsRUFFbUIsRUFGbkIsRUFFdUIsRUFGdkIsRUFFMkIsRUFGM0IsRUFFK0IsRUFGL0IsRUFFbUMsRUFGbkMsRUFFdUMsRUFGdkMsRUFFMkMsRUFGM0MsRUFFK0MsRUFGL0MsQ0FBWDs7QUFLQSxJQUFJLFFBQVEsQztBQUNWLENBRFUsRUFDUCxDQURPLEVBQ0osQ0FESSxFQUNELENBREMsRUFDRSxDQURGLEVBQ0ssQ0FETCxFQUNRLENBRFIsRUFDVyxFQURYLEVBQ2UsRUFEZixFQUNtQixFQURuQixFQUN1QixFQUR2QixFQUMyQixFQUQzQixFQUMrQixFQUQvQixFQUNtQyxFQURuQyxFQUN1QyxHQUR2QyxFQUM0QyxHQUQ1QyxFQUVWLEdBRlUsRUFFTCxHQUZLLEVBRUEsR0FGQSxFQUVLLEdBRkwsRUFFVSxJQUZWLEVBRWdCLElBRmhCLEVBRXNCLElBRnRCLEVBRTRCLElBRjVCLEVBRWtDLElBRmxDLEVBRXdDLElBRnhDLEVBR1YsSUFIVSxFQUdKLEtBSEksRUFHRyxLQUhILEVBR1UsS0FIVixFQUdpQixDQUhqQixFQUdvQixDQUhwQixDQUFaOztBQU1BLElBQUksT0FBTyxDO0FBQ1QsRUFEUyxFQUNMLEVBREssRUFDRCxFQURDLEVBQ0csRUFESCxFQUNPLEVBRFAsRUFDVyxFQURYLEVBQ2UsRUFEZixFQUNtQixFQURuQixFQUN1QixFQUR2QixFQUMyQixFQUQzQixFQUMrQixFQUQvQixFQUNtQyxFQURuQyxFQUN1QyxFQUR2QyxFQUMyQyxFQUQzQyxFQUMrQyxFQUQvQyxFQUNtRCxFQURuRCxFQUVULEVBRlMsRUFFTCxFQUZLLEVBRUQsRUFGQyxFQUVHLEVBRkgsRUFFTyxFQUZQLEVBRVcsRUFGWCxFQUVlLEVBRmYsRUFFbUIsRUFGbkIsRUFFdUIsRUFGdkIsRUFFMkIsRUFGM0IsRUFHVCxFQUhTLEVBR0wsRUFISyxFQUdELEVBSEMsRUFHRyxFQUhILEVBR08sRUFIUCxFQUdXLEVBSFgsQ0FBWDs7QUFNQSxPQUFPLE9BQVAsR0FBaUIsU0FBUyxhQUFULENBQXVCLElBQXZCLEVBQTZCLElBQTdCLEVBQW1DLFVBQW5DLEVBQStDLEtBQS9DLEVBQXNELEtBQXRELEVBQTZELFdBQTdELEVBQTBFLElBQTFFLEVBQWdGLElBQWhGLEVBQ2pCO0FBQ0UsTUFBSSxPQUFPLEtBQUssSUFBaEI7OztBQUdBLE1BQUksTUFBTSxDQUFWLEM7QUFDQSxNQUFJLE1BQU0sQ0FBVixDO0FBQ0EsTUFBSSxNQUFNLENBQVY7QUFBQSxNQUFhLE1BQU0sQ0FBbkIsQztBQUNBLE1BQUksT0FBTyxDQUFYLEM7QUFDQSxNQUFJLE9BQU8sQ0FBWCxDO0FBQ0EsTUFBSSxPQUFPLENBQVgsQztBQUNBLE1BQUksT0FBTyxDQUFYLEM7QUFDQSxNQUFJLE9BQU8sQ0FBWCxDO0FBQ0EsTUFBSSxPQUFPLENBQVgsQztBQUNBLE1BQUksSUFBSixDO0FBQ0EsTUFBSSxJQUFKLEM7QUFDQSxNQUFJLEdBQUosQztBQUNBLE1BQUksSUFBSixDO0FBQ0EsTUFBSSxJQUFKLEM7QUFDQSxNQUFJLE9BQU8sSUFBWCxDO0FBQ0EsTUFBSSxhQUFhLENBQWpCOztBQUVBLE1BQUksR0FBSixDO0FBQ0EsTUFBSSxRQUFRLElBQUksTUFBTSxLQUFWLENBQWdCLFVBQVUsQ0FBMUIsQ0FBWixDO0FBQ0EsTUFBSSxPQUFPLElBQUksTUFBTSxLQUFWLENBQWdCLFVBQVUsQ0FBMUIsQ0FBWCxDO0FBQ0EsTUFBSSxRQUFRLElBQVo7QUFDQSxNQUFJLGNBQWMsQ0FBbEI7O0FBRUEsTUFBSSxTQUFKLEVBQWUsT0FBZixFQUF3QixRQUF4Qjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQWtDQSxPQUFLLE1BQU0sQ0FBWCxFQUFjLE9BQU8sT0FBckIsRUFBOEIsS0FBOUIsRUFBcUM7QUFDbkMsVUFBTSxHQUFOLElBQWEsQ0FBYjtBQUNEO0FBQ0QsT0FBSyxNQUFNLENBQVgsRUFBYyxNQUFNLEtBQXBCLEVBQTJCLEtBQTNCLEVBQWtDO0FBQ2hDLFVBQU0sS0FBSyxhQUFhLEdBQWxCLENBQU47QUFDRDs7O0FBR0QsU0FBTyxJQUFQO0FBQ0EsT0FBSyxNQUFNLE9BQVgsRUFBb0IsT0FBTyxDQUEzQixFQUE4QixLQUE5QixFQUFxQztBQUNuQyxRQUFJLE1BQU0sR0FBTixNQUFlLENBQW5CLEVBQXNCO0FBQUU7QUFBUTtBQUNqQztBQUNELE1BQUksT0FBTyxHQUFYLEVBQWdCO0FBQ2QsV0FBTyxHQUFQO0FBQ0Q7QUFDRCxNQUFJLFFBQVEsQ0FBWixFQUFlOzs7OztBQUliLFVBQU0sYUFBTixJQUF3QixLQUFLLEVBQU4sR0FBYSxNQUFNLEVBQW5CLEdBQXlCLENBQWhEOzs7OztBQU1BLFVBQU0sYUFBTixJQUF3QixLQUFLLEVBQU4sR0FBYSxNQUFNLEVBQW5CLEdBQXlCLENBQWhEOztBQUVBLFNBQUssSUFBTCxHQUFZLENBQVo7QUFDQSxXQUFPLENBQVAsQztBQUNEO0FBQ0QsT0FBSyxNQUFNLENBQVgsRUFBYyxNQUFNLEdBQXBCLEVBQXlCLEtBQXpCLEVBQWdDO0FBQzlCLFFBQUksTUFBTSxHQUFOLE1BQWUsQ0FBbkIsRUFBc0I7QUFBRTtBQUFRO0FBQ2pDO0FBQ0QsTUFBSSxPQUFPLEdBQVgsRUFBZ0I7QUFDZCxXQUFPLEdBQVA7QUFDRDs7O0FBR0QsU0FBTyxDQUFQO0FBQ0EsT0FBSyxNQUFNLENBQVgsRUFBYyxPQUFPLE9BQXJCLEVBQThCLEtBQTlCLEVBQXFDO0FBQ25DLGFBQVMsQ0FBVDtBQUNBLFlBQVEsTUFBTSxHQUFOLENBQVI7QUFDQSxRQUFJLE9BQU8sQ0FBWCxFQUFjO0FBQ1osYUFBTyxDQUFDLENBQVI7QUFDRCxLO0FBQ0Y7QUFDRCxNQUFJLE9BQU8sQ0FBUCxLQUFhLFNBQVMsS0FBVCxJQUFrQixRQUFRLENBQXZDLENBQUosRUFBK0M7QUFDN0MsV0FBTyxDQUFDLENBQVIsQztBQUNEOzs7QUFHRCxPQUFLLENBQUwsSUFBVSxDQUFWO0FBQ0EsT0FBSyxNQUFNLENBQVgsRUFBYyxNQUFNLE9BQXBCLEVBQTZCLEtBQTdCLEVBQW9DO0FBQ2xDLFNBQUssTUFBTSxDQUFYLElBQWdCLEtBQUssR0FBTCxJQUFZLE1BQU0sR0FBTixDQUE1QjtBQUNEOzs7QUFHRCxPQUFLLE1BQU0sQ0FBWCxFQUFjLE1BQU0sS0FBcEIsRUFBMkIsS0FBM0IsRUFBa0M7QUFDaEMsUUFBSSxLQUFLLGFBQWEsR0FBbEIsTUFBMkIsQ0FBL0IsRUFBa0M7QUFDaEMsV0FBSyxLQUFLLEtBQUssYUFBYSxHQUFsQixDQUFMLEdBQUwsSUFBdUMsR0FBdkM7QUFDRDtBQUNGOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQW9DRCxNQUFJLFNBQVMsS0FBYixFQUFvQjtBQUNsQixXQUFPLFFBQVEsSUFBZixDO0FBQ0EsVUFBTSxFQUFOO0FBRUQsR0FKRCxNQUlPLElBQUksU0FBUyxJQUFiLEVBQW1CO0FBQ3hCLFdBQU8sS0FBUDtBQUNBLGtCQUFjLEdBQWQ7QUFDQSxZQUFRLElBQVI7QUFDQSxtQkFBZSxHQUFmO0FBQ0EsVUFBTSxHQUFOO0FBRUQsR0FQTSxNQU9BOztBQUNMLFdBQU8sS0FBUDtBQUNBLFlBQVEsSUFBUjtBQUNBLFVBQU0sQ0FBQyxDQUFQO0FBQ0Q7OztBQUdELFNBQU8sQ0FBUCxDO0FBQ0EsUUFBTSxDQUFOLEM7QUFDQSxRQUFNLEdBQU4sQztBQUNBLFNBQU8sV0FBUCxDO0FBQ0EsU0FBTyxJQUFQLEM7QUFDQSxTQUFPLENBQVAsQztBQUNBLFFBQU0sQ0FBQyxDQUFQLEM7QUFDQSxTQUFPLEtBQUssSUFBWixDO0FBQ0EsU0FBTyxPQUFPLENBQWQsQzs7O0FBR0EsTUFBSyxTQUFTLElBQVQsSUFBaUIsT0FBTyxXQUF6QixJQUNELFNBQVMsS0FBVCxJQUFrQixPQUFPLFlBRDVCLEVBQzJDO0FBQ3pDLFdBQU8sQ0FBUDtBQUNEOztBQUVELE1BQUksSUFBSSxDQUFSOztBQUVBLFdBQVM7QUFDUDs7QUFFQSxnQkFBWSxNQUFNLElBQWxCO0FBQ0EsUUFBSSxLQUFLLEdBQUwsSUFBWSxHQUFoQixFQUFxQjtBQUNuQixnQkFBVSxDQUFWO0FBQ0EsaUJBQVcsS0FBSyxHQUFMLENBQVg7QUFDRCxLQUhELE1BSUssSUFBSSxLQUFLLEdBQUwsSUFBWSxHQUFoQixFQUFxQjtBQUN4QixnQkFBVSxNQUFNLGNBQWMsS0FBSyxHQUFMLENBQXBCLENBQVY7QUFDQSxpQkFBVyxLQUFLLGFBQWEsS0FBSyxHQUFMLENBQWxCLENBQVg7QUFDRCxLQUhJLE1BSUE7QUFDSCxnQkFBVSxLQUFLLEVBQWYsQztBQUNBLGlCQUFXLENBQVg7QUFDRDs7O0FBR0QsV0FBTyxLQUFNLE1BQU0sSUFBbkI7QUFDQSxXQUFPLEtBQUssSUFBWjtBQUNBLFVBQU0sSUFBTixDO0FBQ0EsT0FBRztBQUNELGNBQVEsSUFBUjtBQUNBLFlBQU0sUUFBUSxRQUFRLElBQWhCLElBQXdCLElBQTlCLElBQXVDLGFBQWEsRUFBZCxHQUFxQixXQUFXLEVBQWhDLEdBQXNDLFFBQXRDLEdBQWdELENBQXRGO0FBQ0QsS0FIRCxRQUdTLFNBQVMsQ0FIbEI7OztBQU1BLFdBQU8sS0FBTSxNQUFNLENBQW5CO0FBQ0EsV0FBTyxPQUFPLElBQWQsRUFBb0I7QUFDbEIsZUFBUyxDQUFUO0FBQ0Q7QUFDRCxRQUFJLFNBQVMsQ0FBYixFQUFnQjtBQUNkLGNBQVEsT0FBTyxDQUFmO0FBQ0EsY0FBUSxJQUFSO0FBQ0QsS0FIRCxNQUdPO0FBQ0wsYUFBTyxDQUFQO0FBQ0Q7OztBQUdEO0FBQ0EsUUFBSSxFQUFFLE1BQU0sR0FBTixDQUFGLEtBQWlCLENBQXJCLEVBQXdCO0FBQ3RCLFVBQUksUUFBUSxHQUFaLEVBQWlCO0FBQUU7QUFBUTtBQUMzQixZQUFNLEtBQUssYUFBYSxLQUFLLEdBQUwsQ0FBbEIsQ0FBTjtBQUNEOzs7QUFHRCxRQUFJLE1BQU0sSUFBTixJQUFjLENBQUMsT0FBTyxJQUFSLE1BQWtCLEdBQXBDLEVBQXlDOztBQUV2QyxVQUFJLFNBQVMsQ0FBYixFQUFnQjtBQUNkLGVBQU8sSUFBUDtBQUNEOzs7QUFHRCxjQUFRLEdBQVIsQzs7O0FBR0EsYUFBTyxNQUFNLElBQWI7QUFDQSxhQUFPLEtBQUssSUFBWjtBQUNBLGFBQU8sT0FBTyxJQUFQLEdBQWMsR0FBckIsRUFBMEI7QUFDeEIsZ0JBQVEsTUFBTSxPQUFPLElBQWIsQ0FBUjtBQUNBLFlBQUksUUFBUSxDQUFaLEVBQWU7QUFBRTtBQUFRO0FBQ3pCO0FBQ0EsaUJBQVMsQ0FBVDtBQUNEOzs7QUFHRCxjQUFRLEtBQUssSUFBYjtBQUNBLFVBQUssU0FBUyxJQUFULElBQWlCLE9BQU8sV0FBekIsSUFDRCxTQUFTLEtBQVQsSUFBa0IsT0FBTyxZQUQ1QixFQUMyQztBQUN6QyxlQUFPLENBQVA7QUFDRDs7O0FBR0QsWUFBTSxPQUFPLElBQWI7Ozs7QUFJQSxZQUFNLEdBQU4sSUFBYyxRQUFRLEVBQVQsR0FBZ0IsUUFBUSxFQUF4QixHQUErQixPQUFPLFdBQXRDLEdBQW9ELENBQWpFO0FBQ0Q7QUFDRjs7Ozs7QUFLRCxNQUFJLFNBQVMsQ0FBYixFQUFnQjs7OztBQUlkLFVBQU0sT0FBTyxJQUFiLElBQXVCLE1BQU0sSUFBUCxJQUFnQixFQUFqQixHQUF3QixNQUFNLEVBQTlCLEdBQW1DLENBQXhEO0FBQ0Q7Ozs7QUFJRCxPQUFLLElBQUwsR0FBWSxJQUFaO0FBQ0EsU0FBTyxDQUFQO0FBQ0QsQ0FsU0Q7OztBQ3BDQTs7QUFFQSxPQUFPLE9BQVAsR0FBaUI7QUFDZixLQUFRLGlCQURPLEU7QUFFZixLQUFRLFlBRk8sRTtBQUdmLEtBQVEsRUFITyxFO0FBSWYsUUFBUSxZQUpPLEU7QUFLZixRQUFRLGNBTE8sRTtBQU1mLFFBQVEsWUFOTyxFO0FBT2YsUUFBUSxxQkFQTyxFO0FBUWYsUUFBUSxjQVJPLEU7QUFTZixRQUFRLHNCO0FBVE8sQ0FBakI7OztBQ0ZBOztBQUdBLElBQUksUUFBUSxRQUFRLGlCQUFSLENBQVo7Ozs7Ozs7O0FBU0EsSUFBSSxVQUF3QixDQUE1Qjs7OztBQUlBLElBQUksV0FBd0IsQ0FBNUI7QUFDQSxJQUFJLFNBQXdCLENBQTVCOztBQUVBLElBQUksWUFBd0IsQ0FBNUI7Ozs7QUFLQSxTQUFTLElBQVQsQ0FBYyxHQUFkLEVBQW1CO0FBQUUsTUFBSSxNQUFNLElBQUksTUFBZCxDQUFzQixPQUFPLEVBQUUsR0FBRixJQUFTLENBQWhCLEVBQW1CO0FBQUUsUUFBSSxHQUFKLElBQVcsQ0FBWDtBQUFlO0FBQUU7Ozs7QUFJakYsSUFBSSxlQUFlLENBQW5CO0FBQ0EsSUFBSSxlQUFlLENBQW5CO0FBQ0EsSUFBSSxZQUFlLENBQW5COzs7QUFHQSxJQUFJLFlBQWUsQ0FBbkI7QUFDQSxJQUFJLFlBQWUsR0FBbkI7Ozs7Ozs7O0FBUUEsSUFBSSxlQUFnQixFQUFwQjs7O0FBR0EsSUFBSSxXQUFnQixHQUFwQjs7O0FBR0EsSUFBSSxVQUFnQixXQUFXLENBQVgsR0FBZSxZQUFuQzs7O0FBR0EsSUFBSSxVQUFnQixFQUFwQjs7O0FBR0EsSUFBSSxXQUFnQixFQUFwQjs7O0FBR0EsSUFBSSxZQUFnQixJQUFJLE9BQUosR0FBYyxDQUFsQzs7O0FBR0EsSUFBSSxXQUFnQixFQUFwQjs7O0FBR0EsSUFBSSxXQUFnQixFQUFwQjs7Ozs7OztBQVFBLElBQUksY0FBYyxDQUFsQjs7O0FBR0EsSUFBSSxZQUFjLEdBQWxCOzs7QUFHQSxJQUFJLFVBQWMsRUFBbEI7OztBQUdBLElBQUksWUFBYyxFQUFsQjs7O0FBR0EsSUFBSSxjQUFjLEVBQWxCOzs7O0FBSUEsSUFBSSxjO0FBQ0YsQ0FBQyxDQUFELEVBQUcsQ0FBSCxFQUFLLENBQUwsRUFBTyxDQUFQLEVBQVMsQ0FBVCxFQUFXLENBQVgsRUFBYSxDQUFiLEVBQWUsQ0FBZixFQUFpQixDQUFqQixFQUFtQixDQUFuQixFQUFxQixDQUFyQixFQUF1QixDQUF2QixFQUF5QixDQUF6QixFQUEyQixDQUEzQixFQUE2QixDQUE3QixFQUErQixDQUEvQixFQUFpQyxDQUFqQyxFQUFtQyxDQUFuQyxFQUFxQyxDQUFyQyxFQUF1QyxDQUF2QyxFQUF5QyxDQUF6QyxFQUEyQyxDQUEzQyxFQUE2QyxDQUE3QyxFQUErQyxDQUEvQyxFQUFpRCxDQUFqRCxFQUFtRCxDQUFuRCxFQUFxRCxDQUFyRCxFQUF1RCxDQUF2RCxFQUF5RCxDQUF6RCxDQURGOztBQUdBLElBQUksYztBQUNGLENBQUMsQ0FBRCxFQUFHLENBQUgsRUFBSyxDQUFMLEVBQU8sQ0FBUCxFQUFTLENBQVQsRUFBVyxDQUFYLEVBQWEsQ0FBYixFQUFlLENBQWYsRUFBaUIsQ0FBakIsRUFBbUIsQ0FBbkIsRUFBcUIsQ0FBckIsRUFBdUIsQ0FBdkIsRUFBeUIsQ0FBekIsRUFBMkIsQ0FBM0IsRUFBNkIsQ0FBN0IsRUFBK0IsQ0FBL0IsRUFBaUMsQ0FBakMsRUFBbUMsQ0FBbkMsRUFBcUMsQ0FBckMsRUFBdUMsQ0FBdkMsRUFBeUMsQ0FBekMsRUFBMkMsQ0FBM0MsRUFBNkMsRUFBN0MsRUFBZ0QsRUFBaEQsRUFBbUQsRUFBbkQsRUFBc0QsRUFBdEQsRUFBeUQsRUFBekQsRUFBNEQsRUFBNUQsRUFBK0QsRUFBL0QsRUFBa0UsRUFBbEUsQ0FERjs7QUFHQSxJQUFJLGU7QUFDRixDQUFDLENBQUQsRUFBRyxDQUFILEVBQUssQ0FBTCxFQUFPLENBQVAsRUFBUyxDQUFULEVBQVcsQ0FBWCxFQUFhLENBQWIsRUFBZSxDQUFmLEVBQWlCLENBQWpCLEVBQW1CLENBQW5CLEVBQXFCLENBQXJCLEVBQXVCLENBQXZCLEVBQXlCLENBQXpCLEVBQTJCLENBQTNCLEVBQTZCLENBQTdCLEVBQStCLENBQS9CLEVBQWlDLENBQWpDLEVBQW1DLENBQW5DLEVBQXFDLENBQXJDLENBREY7O0FBR0EsSUFBSSxXQUNGLENBQUMsRUFBRCxFQUFJLEVBQUosRUFBTyxFQUFQLEVBQVUsQ0FBVixFQUFZLENBQVosRUFBYyxDQUFkLEVBQWdCLENBQWhCLEVBQWtCLENBQWxCLEVBQW9CLEVBQXBCLEVBQXVCLENBQXZCLEVBQXlCLEVBQXpCLEVBQTRCLENBQTVCLEVBQThCLEVBQTlCLEVBQWlDLENBQWpDLEVBQW1DLEVBQW5DLEVBQXNDLENBQXRDLEVBQXdDLEVBQXhDLEVBQTJDLENBQTNDLEVBQTZDLEVBQTdDLENBREY7Ozs7Ozs7Ozs7Ozs7QUFjQSxJQUFJLGdCQUFnQixHQUFwQixDOzs7QUFHQSxJQUFJLGVBQWdCLElBQUksS0FBSixDQUFVLENBQUMsVUFBVSxDQUFYLElBQWdCLENBQTFCLENBQXBCO0FBQ0EsS0FBSyxZQUFMOzs7Ozs7O0FBT0EsSUFBSSxlQUFnQixJQUFJLEtBQUosQ0FBVSxVQUFVLENBQXBCLENBQXBCO0FBQ0EsS0FBSyxZQUFMOzs7OztBQUtBLElBQUksYUFBZ0IsSUFBSSxLQUFKLENBQVUsYUFBVixDQUFwQjtBQUNBLEtBQUssVUFBTDs7Ozs7O0FBTUEsSUFBSSxlQUFnQixJQUFJLEtBQUosQ0FBVSxZQUFZLFNBQVosR0FBd0IsQ0FBbEMsQ0FBcEI7QUFDQSxLQUFLLFlBQUw7OztBQUdBLElBQUksY0FBZ0IsSUFBSSxLQUFKLENBQVUsWUFBVixDQUFwQjtBQUNBLEtBQUssV0FBTDs7O0FBR0EsSUFBSSxZQUFnQixJQUFJLEtBQUosQ0FBVSxPQUFWLENBQXBCO0FBQ0EsS0FBSyxTQUFMOzs7QUFJQSxTQUFTLGNBQVQsQ0FBd0IsV0FBeEIsRUFBcUMsVUFBckMsRUFBaUQsVUFBakQsRUFBNkQsS0FBN0QsRUFBb0UsVUFBcEUsRUFBZ0Y7O0FBRTlFLE9BQUssV0FBTCxHQUFvQixXQUFwQixDO0FBQ0EsT0FBSyxVQUFMLEdBQW9CLFVBQXBCLEM7QUFDQSxPQUFLLFVBQUwsR0FBb0IsVUFBcEIsQztBQUNBLE9BQUssS0FBTCxHQUFvQixLQUFwQixDO0FBQ0EsT0FBSyxVQUFMLEdBQW9CLFVBQXBCLEM7OztBQUdBLE9BQUssU0FBTCxHQUFvQixlQUFlLFlBQVksTUFBL0M7QUFDRDs7QUFHRCxJQUFJLGFBQUo7QUFDQSxJQUFJLGFBQUo7QUFDQSxJQUFJLGNBQUo7O0FBR0EsU0FBUyxRQUFULENBQWtCLFFBQWxCLEVBQTRCLFNBQTVCLEVBQXVDO0FBQ3JDLE9BQUssUUFBTCxHQUFnQixRQUFoQixDO0FBQ0EsT0FBSyxRQUFMLEdBQWdCLENBQWhCLEM7QUFDQSxPQUFLLFNBQUwsR0FBaUIsU0FBakIsQztBQUNEOztBQUlELFNBQVMsTUFBVCxDQUFnQixJQUFoQixFQUFzQjtBQUNwQixTQUFPLE9BQU8sR0FBUCxHQUFhLFdBQVcsSUFBWCxDQUFiLEdBQWdDLFdBQVcsT0FBTyxTQUFTLENBQWhCLENBQVgsQ0FBdkM7QUFDRDs7Ozs7O0FBT0QsU0FBUyxTQUFULENBQW1CLENBQW5CLEVBQXNCLENBQXRCLEVBQXlCOzs7QUFHdkIsSUFBRSxXQUFGLENBQWMsRUFBRSxPQUFGLEVBQWQsSUFBOEIsQ0FBRCxHQUFNLElBQW5DO0FBQ0EsSUFBRSxXQUFGLENBQWMsRUFBRSxPQUFGLEVBQWQsSUFBOEIsTUFBTSxDQUFQLEdBQVksSUFBekM7QUFDRDs7Ozs7O0FBT0QsU0FBUyxTQUFULENBQW1CLENBQW5CLEVBQXNCLEtBQXRCLEVBQTZCLE1BQTdCLEVBQXFDO0FBQ25DLE1BQUksRUFBRSxRQUFGLEdBQWMsV0FBVyxNQUE3QixFQUFzQztBQUNwQyxNQUFFLE1BQUYsSUFBYSxTQUFTLEVBQUUsUUFBWixHQUF3QixNQUFwQztBQUNBLGNBQVUsQ0FBVixFQUFhLEVBQUUsTUFBZjtBQUNBLE1BQUUsTUFBRixHQUFXLFNBQVUsV0FBVyxFQUFFLFFBQWxDO0FBQ0EsTUFBRSxRQUFGLElBQWMsU0FBUyxRQUF2QjtBQUNELEdBTEQsTUFLTztBQUNMLE1BQUUsTUFBRixJQUFhLFNBQVMsRUFBRSxRQUFaLEdBQXdCLE1BQXBDO0FBQ0EsTUFBRSxRQUFGLElBQWMsTUFBZDtBQUNEO0FBQ0Y7O0FBR0QsU0FBUyxTQUFULENBQW1CLENBQW5CLEVBQXNCLENBQXRCLEVBQXlCLElBQXpCLEVBQStCO0FBQzdCLFlBQVUsQ0FBVixFQUFhLEtBQUssSUFBSSxDQUFULEMsVUFBYixFQUFtQyxLQUFLLElBQUksQ0FBSixHQUFRLENBQWIsQyxTQUFuQztBQUNEOzs7Ozs7O0FBUUQsU0FBUyxVQUFULENBQW9CLElBQXBCLEVBQTBCLEdBQTFCLEVBQStCO0FBQzdCLE1BQUksTUFBTSxDQUFWO0FBQ0EsS0FBRztBQUNELFdBQU8sT0FBTyxDQUFkO0FBQ0EsY0FBVSxDQUFWO0FBQ0EsWUFBUSxDQUFSO0FBQ0QsR0FKRCxRQUlTLEVBQUUsR0FBRixHQUFRLENBSmpCO0FBS0EsU0FBTyxRQUFRLENBQWY7QUFDRDs7Ozs7QUFNRCxTQUFTLFFBQVQsQ0FBa0IsQ0FBbEIsRUFBcUI7QUFDbkIsTUFBSSxFQUFFLFFBQUYsS0FBZSxFQUFuQixFQUF1QjtBQUNyQixjQUFVLENBQVYsRUFBYSxFQUFFLE1BQWY7QUFDQSxNQUFFLE1BQUYsR0FBVyxDQUFYO0FBQ0EsTUFBRSxRQUFGLEdBQWEsQ0FBYjtBQUVELEdBTEQsTUFLTyxJQUFJLEVBQUUsUUFBRixJQUFjLENBQWxCLEVBQXFCO0FBQzFCLE1BQUUsV0FBRixDQUFjLEVBQUUsT0FBRixFQUFkLElBQTZCLEVBQUUsTUFBRixHQUFXLElBQXhDO0FBQ0EsTUFBRSxNQUFGLEtBQWEsQ0FBYjtBQUNBLE1BQUUsUUFBRixJQUFjLENBQWQ7QUFDRDtBQUNGOzs7Ozs7Ozs7Ozs7QUFhRCxTQUFTLFVBQVQsQ0FBb0IsQ0FBcEIsRUFBdUIsSUFBdkI7OztBQUdBO0FBQ0UsTUFBSSxPQUFrQixLQUFLLFFBQTNCO0FBQ0EsTUFBSSxXQUFrQixLQUFLLFFBQTNCO0FBQ0EsTUFBSSxRQUFrQixLQUFLLFNBQUwsQ0FBZSxXQUFyQztBQUNBLE1BQUksWUFBa0IsS0FBSyxTQUFMLENBQWUsU0FBckM7QUFDQSxNQUFJLFFBQWtCLEtBQUssU0FBTCxDQUFlLFVBQXJDO0FBQ0EsTUFBSSxPQUFrQixLQUFLLFNBQUwsQ0FBZSxVQUFyQztBQUNBLE1BQUksYUFBa0IsS0FBSyxTQUFMLENBQWUsVUFBckM7QUFDQSxNQUFJLENBQUosQztBQUNBLE1BQUksQ0FBSixFQUFPLENBQVAsQztBQUNBLE1BQUksSUFBSixDO0FBQ0EsTUFBSSxLQUFKLEM7QUFDQSxNQUFJLENBQUosQztBQUNBLE1BQUksV0FBVyxDQUFmLEM7O0FBRUEsT0FBSyxPQUFPLENBQVosRUFBZSxRQUFRLFFBQXZCLEVBQWlDLE1BQWpDLEVBQXlDO0FBQ3ZDLE1BQUUsUUFBRixDQUFXLElBQVgsSUFBbUIsQ0FBbkI7QUFDRDs7Ozs7QUFLRCxPQUFLLEVBQUUsSUFBRixDQUFPLEVBQUUsUUFBVCxJQUFxQixDQUFyQixHQUF5QixDQUE5QixDLFNBQUEsR0FBMkMsQ0FBM0MsQzs7QUFFQSxPQUFLLElBQUksRUFBRSxRQUFGLEdBQWEsQ0FBdEIsRUFBeUIsSUFBSSxTQUE3QixFQUF3QyxHQUF4QyxFQUE2QztBQUMzQyxRQUFJLEVBQUUsSUFBRixDQUFPLENBQVAsQ0FBSjtBQUNBLFdBQU8sS0FBSyxLQUFLLElBQUksQ0FBSixHQUFRLENBQWIsQyxTQUFBLEdBQTBCLENBQTFCLEdBQThCLENBQW5DLEMsU0FBQSxHQUFnRCxDQUF2RDtBQUNBLFFBQUksT0FBTyxVQUFYLEVBQXVCO0FBQ3JCLGFBQU8sVUFBUDtBQUNBO0FBQ0Q7QUFDRCxTQUFLLElBQUksQ0FBSixHQUFRLENBQWIsQyxTQUFBLEdBQTBCLElBQTFCOzs7QUFHQSxRQUFJLElBQUksUUFBUixFQUFrQjtBQUFFO0FBQVcsSzs7QUFFL0IsTUFBRSxRQUFGLENBQVcsSUFBWDtBQUNBLFlBQVEsQ0FBUjtBQUNBLFFBQUksS0FBSyxJQUFULEVBQWU7QUFDYixjQUFRLE1BQU0sSUFBSSxJQUFWLENBQVI7QUFDRDtBQUNELFFBQUksS0FBSyxJQUFJLENBQVQsQyxVQUFKO0FBQ0EsTUFBRSxPQUFGLElBQWEsS0FBSyxPQUFPLEtBQVosQ0FBYjtBQUNBLFFBQUksU0FBSixFQUFlO0FBQ2IsUUFBRSxVQUFGLElBQWdCLEtBQUssTUFBTSxJQUFJLENBQUosR0FBUSxDQUFkLEMsU0FBQSxHQUEyQixLQUFoQyxDQUFoQjtBQUNEO0FBQ0Y7QUFDRCxNQUFJLGFBQWEsQ0FBakIsRUFBb0I7QUFBRTtBQUFTOzs7Ozs7QUFNL0IsS0FBRztBQUNELFdBQU8sYUFBYSxDQUFwQjtBQUNBLFdBQU8sRUFBRSxRQUFGLENBQVcsSUFBWCxNQUFxQixDQUE1QixFQUErQjtBQUFFO0FBQVM7QUFDMUMsTUFBRSxRQUFGLENBQVcsSUFBWCxJO0FBQ0EsTUFBRSxRQUFGLENBQVcsT0FBTyxDQUFsQixLQUF3QixDQUF4QixDO0FBQ0EsTUFBRSxRQUFGLENBQVcsVUFBWDs7OztBQUlBLGdCQUFZLENBQVo7QUFDRCxHQVZELFFBVVMsV0FBVyxDQVZwQjs7Ozs7OztBQWlCQSxPQUFLLE9BQU8sVUFBWixFQUF3QixTQUFTLENBQWpDLEVBQW9DLE1BQXBDLEVBQTRDO0FBQzFDLFFBQUksRUFBRSxRQUFGLENBQVcsSUFBWCxDQUFKO0FBQ0EsV0FBTyxNQUFNLENBQWIsRUFBZ0I7QUFDZCxVQUFJLEVBQUUsSUFBRixDQUFPLEVBQUUsQ0FBVCxDQUFKO0FBQ0EsVUFBSSxJQUFJLFFBQVIsRUFBa0I7QUFBRTtBQUFXO0FBQy9CLFVBQUksS0FBSyxJQUFJLENBQUosR0FBUSxDQUFiLEMsU0FBQSxLQUE0QixJQUFoQyxFQUFzQzs7QUFFcEMsVUFBRSxPQUFGLElBQWEsQ0FBQyxPQUFPLEtBQUssSUFBSSxDQUFKLEdBQVEsQ0FBYixDLFNBQVIsSUFBbUMsS0FBSyxJQUFJLENBQVQsQyxVQUFoRDtBQUNBLGFBQUssSUFBSSxDQUFKLEdBQVEsQ0FBYixDLFNBQUEsR0FBMEIsSUFBMUI7QUFDRDtBQUNEO0FBQ0Q7QUFDRjtBQUNGOzs7Ozs7Ozs7O0FBV0QsU0FBUyxTQUFULENBQW1CLElBQW5CLEVBQXlCLFFBQXpCLEVBQW1DLFFBQW5DOzs7O0FBSUE7QUFDRSxNQUFJLFlBQVksSUFBSSxLQUFKLENBQVUsV0FBVyxDQUFyQixDQUFoQixDO0FBQ0EsTUFBSSxPQUFPLENBQVgsQztBQUNBLE1BQUksSUFBSixDO0FBQ0EsTUFBSSxDQUFKLEM7Ozs7O0FBS0EsT0FBSyxPQUFPLENBQVosRUFBZSxRQUFRLFFBQXZCLEVBQWlDLE1BQWpDLEVBQXlDO0FBQ3ZDLGNBQVUsSUFBVixJQUFrQixPQUFRLE9BQU8sU0FBUyxPQUFPLENBQWhCLENBQVIsSUFBK0IsQ0FBeEQ7QUFDRDs7Ozs7Ozs7QUFRRCxPQUFLLElBQUksQ0FBVCxFQUFhLEtBQUssUUFBbEIsRUFBNEIsR0FBNUIsRUFBaUM7QUFDL0IsUUFBSSxNQUFNLEtBQUssSUFBSSxDQUFKLEdBQVEsQ0FBYixDLFNBQVY7QUFDQSxRQUFJLFFBQVEsQ0FBWixFQUFlO0FBQUU7QUFBVzs7QUFFNUIsU0FBSyxJQUFJLENBQVQsQyxVQUFBLEdBQXVCLFdBQVcsVUFBVSxHQUFWLEdBQVgsRUFBNkIsR0FBN0IsQ0FBdkI7Ozs7QUFJRDtBQUNGOzs7OztBQU1ELFNBQVMsY0FBVCxHQUEwQjtBQUN4QixNQUFJLENBQUosQztBQUNBLE1BQUksSUFBSixDO0FBQ0EsTUFBSSxNQUFKLEM7QUFDQSxNQUFJLElBQUosQztBQUNBLE1BQUksSUFBSixDO0FBQ0EsTUFBSSxXQUFXLElBQUksS0FBSixDQUFVLFdBQVcsQ0FBckIsQ0FBZjs7Ozs7Ozs7Ozs7Ozs7OztBQWdCQSxXQUFTLENBQVQ7QUFDQSxPQUFLLE9BQU8sQ0FBWixFQUFlLE9BQU8sZUFBZSxDQUFyQyxFQUF3QyxNQUF4QyxFQUFnRDtBQUM5QyxnQkFBWSxJQUFaLElBQW9CLE1BQXBCO0FBQ0EsU0FBSyxJQUFJLENBQVQsRUFBWSxJQUFLLEtBQUssWUFBWSxJQUFaLENBQXRCLEVBQTBDLEdBQTFDLEVBQStDO0FBQzdDLG1CQUFhLFFBQWIsSUFBeUIsSUFBekI7QUFDRDtBQUNGOzs7Ozs7QUFNRCxlQUFhLFNBQVMsQ0FBdEIsSUFBMkIsSUFBM0I7OztBQUdBLFNBQU8sQ0FBUDtBQUNBLE9BQUssT0FBTyxDQUFaLEVBQWUsT0FBTyxFQUF0QixFQUEwQixNQUExQixFQUFrQztBQUNoQyxjQUFVLElBQVYsSUFBa0IsSUFBbEI7QUFDQSxTQUFLLElBQUksQ0FBVCxFQUFZLElBQUssS0FBSyxZQUFZLElBQVosQ0FBdEIsRUFBMEMsR0FBMUMsRUFBK0M7QUFDN0MsaUJBQVcsTUFBWCxJQUFxQixJQUFyQjtBQUNEO0FBQ0Y7O0FBRUQsV0FBUyxDQUFULEM7QUFDQSxTQUFPLE9BQU8sT0FBZCxFQUF1QixNQUF2QixFQUErQjtBQUM3QixjQUFVLElBQVYsSUFBa0IsUUFBUSxDQUExQjtBQUNBLFNBQUssSUFBSSxDQUFULEVBQVksSUFBSyxLQUFNLFlBQVksSUFBWixJQUFvQixDQUEzQyxFQUFnRCxHQUFoRCxFQUFxRDtBQUNuRCxpQkFBVyxNQUFNLE1BQWpCLElBQTJCLElBQTNCO0FBQ0Q7QUFDRjs7OztBQUlELE9BQUssT0FBTyxDQUFaLEVBQWUsUUFBUSxRQUF2QixFQUFpQyxNQUFqQyxFQUF5QztBQUN2QyxhQUFTLElBQVQsSUFBaUIsQ0FBakI7QUFDRDs7QUFFRCxNQUFJLENBQUo7QUFDQSxTQUFPLEtBQUssR0FBWixFQUFpQjtBQUNmLGlCQUFhLElBQUksQ0FBSixHQUFRLENBQXJCLEMsU0FBQSxHQUFrQyxDQUFsQztBQUNBO0FBQ0EsYUFBUyxDQUFUO0FBQ0Q7QUFDRCxTQUFPLEtBQUssR0FBWixFQUFpQjtBQUNmLGlCQUFhLElBQUksQ0FBSixHQUFRLENBQXJCLEMsU0FBQSxHQUFrQyxDQUFsQztBQUNBO0FBQ0EsYUFBUyxDQUFUO0FBQ0Q7QUFDRCxTQUFPLEtBQUssR0FBWixFQUFpQjtBQUNmLGlCQUFhLElBQUksQ0FBSixHQUFRLENBQXJCLEMsU0FBQSxHQUFrQyxDQUFsQztBQUNBO0FBQ0EsYUFBUyxDQUFUO0FBQ0Q7QUFDRCxTQUFPLEtBQUssR0FBWixFQUFpQjtBQUNmLGlCQUFhLElBQUksQ0FBSixHQUFRLENBQXJCLEMsU0FBQSxHQUFrQyxDQUFsQztBQUNBO0FBQ0EsYUFBUyxDQUFUO0FBQ0Q7Ozs7O0FBS0QsWUFBVSxZQUFWLEVBQXdCLFVBQVUsQ0FBbEMsRUFBcUMsUUFBckM7OztBQUdBLE9BQUssSUFBSSxDQUFULEVBQVksSUFBSSxPQUFoQixFQUF5QixHQUF6QixFQUE4QjtBQUM1QixpQkFBYSxJQUFJLENBQUosR0FBUSxDQUFyQixDLFNBQUEsR0FBa0MsQ0FBbEM7QUFDQSxpQkFBYSxJQUFJLENBQWpCLEMsVUFBQSxHQUErQixXQUFXLENBQVgsRUFBYyxDQUFkLENBQS9CO0FBQ0Q7OztBQUdELGtCQUFnQixJQUFJLGNBQUosQ0FBbUIsWUFBbkIsRUFBaUMsV0FBakMsRUFBOEMsV0FBVyxDQUF6RCxFQUE0RCxPQUE1RCxFQUFxRSxRQUFyRSxDQUFoQjtBQUNBLGtCQUFnQixJQUFJLGNBQUosQ0FBbUIsWUFBbkIsRUFBaUMsV0FBakMsRUFBOEMsQ0FBOUMsRUFBMEQsT0FBMUQsRUFBbUUsUUFBbkUsQ0FBaEI7QUFDQSxtQkFBaUIsSUFBSSxjQUFKLENBQW1CLElBQUksS0FBSixDQUFVLENBQVYsQ0FBbkIsRUFBaUMsWUFBakMsRUFBK0MsQ0FBL0MsRUFBMEQsUUFBMUQsRUFBb0UsV0FBcEUsQ0FBakI7OztBQUdEOzs7OztBQU1ELFNBQVMsVUFBVCxDQUFvQixDQUFwQixFQUF1QjtBQUNyQixNQUFJLENBQUosQzs7O0FBR0EsT0FBSyxJQUFJLENBQVQsRUFBWSxJQUFJLE9BQWhCLEVBQTBCLEdBQTFCLEVBQStCO0FBQUUsTUFBRSxTQUFGLENBQVksSUFBSSxDQUFoQixDLFVBQUEsR0FBOEIsQ0FBOUI7QUFBa0M7QUFDbkUsT0FBSyxJQUFJLENBQVQsRUFBWSxJQUFJLE9BQWhCLEVBQTBCLEdBQTFCLEVBQStCO0FBQUUsTUFBRSxTQUFGLENBQVksSUFBSSxDQUFoQixDLFVBQUEsR0FBOEIsQ0FBOUI7QUFBa0M7QUFDbkUsT0FBSyxJQUFJLENBQVQsRUFBWSxJQUFJLFFBQWhCLEVBQTBCLEdBQTFCLEVBQStCO0FBQUUsTUFBRSxPQUFGLENBQVUsSUFBSSxDQUFkLEMsVUFBQSxHQUE0QixDQUE1QjtBQUFnQzs7QUFFakUsSUFBRSxTQUFGLENBQVksWUFBWSxDQUF4QixDLFVBQUEsR0FBc0MsQ0FBdEM7QUFDQSxJQUFFLE9BQUYsR0FBWSxFQUFFLFVBQUYsR0FBZSxDQUEzQjtBQUNBLElBQUUsUUFBRixHQUFhLEVBQUUsT0FBRixHQUFZLENBQXpCO0FBQ0Q7Ozs7O0FBTUQsU0FBUyxTQUFULENBQW1CLENBQW5CLEVBQ0E7QUFDRSxNQUFJLEVBQUUsUUFBRixHQUFhLENBQWpCLEVBQW9CO0FBQ2xCLGNBQVUsQ0FBVixFQUFhLEVBQUUsTUFBZjtBQUNELEdBRkQsTUFFTyxJQUFJLEVBQUUsUUFBRixHQUFhLENBQWpCLEVBQW9COztBQUV6QixNQUFFLFdBQUYsQ0FBYyxFQUFFLE9BQUYsRUFBZCxJQUE2QixFQUFFLE1BQS9CO0FBQ0Q7QUFDRCxJQUFFLE1BQUYsR0FBVyxDQUFYO0FBQ0EsSUFBRSxRQUFGLEdBQWEsQ0FBYjtBQUNEOzs7Ozs7QUFNRCxTQUFTLFVBQVQsQ0FBb0IsQ0FBcEIsRUFBdUIsR0FBdkIsRUFBNEIsR0FBNUIsRUFBaUMsTUFBakM7Ozs7O0FBS0E7QUFDRSxZQUFVLENBQVYsRTs7QUFFQSxNQUFJLE1BQUosRUFBWTtBQUNWLGNBQVUsQ0FBVixFQUFhLEdBQWI7QUFDQSxjQUFVLENBQVYsRUFBYSxDQUFDLEdBQWQ7QUFDRDs7OztBQUlELFFBQU0sUUFBTixDQUFlLEVBQUUsV0FBakIsRUFBOEIsRUFBRSxNQUFoQyxFQUF3QyxHQUF4QyxFQUE2QyxHQUE3QyxFQUFrRCxFQUFFLE9BQXBEO0FBQ0EsSUFBRSxPQUFGLElBQWEsR0FBYjtBQUNEOzs7Ozs7QUFNRCxTQUFTLE9BQVQsQ0FBaUIsSUFBakIsRUFBdUIsQ0FBdkIsRUFBMEIsQ0FBMUIsRUFBNkIsS0FBN0IsRUFBb0M7QUFDbEMsTUFBSSxNQUFNLElBQUksQ0FBZDtBQUNBLE1BQUksTUFBTSxJQUFJLENBQWQ7QUFDQSxTQUFRLEtBQUssR0FBTCxDLFVBQUEsR0FBcUIsS0FBSyxHQUFMLEMsVUFBckIsSUFDQSxLQUFLLEdBQUwsQyxVQUFBLEtBQXVCLEtBQUssR0FBTCxDLFVBQXZCLElBQTZDLE1BQU0sQ0FBTixLQUFZLE1BQU0sQ0FBTixDQURqRTtBQUVEOzs7Ozs7OztBQVFELFNBQVMsVUFBVCxDQUFvQixDQUFwQixFQUF1QixJQUF2QixFQUE2QixDQUE3Qjs7OztBQUlBO0FBQ0UsTUFBSSxJQUFJLEVBQUUsSUFBRixDQUFPLENBQVAsQ0FBUjtBQUNBLE1BQUksSUFBSSxLQUFLLENBQWIsQztBQUNBLFNBQU8sS0FBSyxFQUFFLFFBQWQsRUFBd0I7O0FBRXRCLFFBQUksSUFBSSxFQUFFLFFBQU4sSUFDRixRQUFRLElBQVIsRUFBYyxFQUFFLElBQUYsQ0FBTyxJQUFJLENBQVgsQ0FBZCxFQUE2QixFQUFFLElBQUYsQ0FBTyxDQUFQLENBQTdCLEVBQXdDLEVBQUUsS0FBMUMsQ0FERixFQUNvRDtBQUNsRDtBQUNEOztBQUVELFFBQUksUUFBUSxJQUFSLEVBQWMsQ0FBZCxFQUFpQixFQUFFLElBQUYsQ0FBTyxDQUFQLENBQWpCLEVBQTRCLEVBQUUsS0FBOUIsQ0FBSixFQUEwQztBQUFFO0FBQVE7OztBQUdwRCxNQUFFLElBQUYsQ0FBTyxDQUFQLElBQVksRUFBRSxJQUFGLENBQU8sQ0FBUCxDQUFaO0FBQ0EsUUFBSSxDQUFKOzs7QUFHQSxVQUFNLENBQU47QUFDRDtBQUNELElBQUUsSUFBRixDQUFPLENBQVAsSUFBWSxDQUFaO0FBQ0Q7Ozs7Ozs7O0FBU0QsU0FBUyxjQUFULENBQXdCLENBQXhCLEVBQTJCLEtBQTNCLEVBQWtDLEtBQWxDOzs7O0FBSUE7QUFDRSxNQUFJLElBQUosQztBQUNBLE1BQUksRUFBSixDO0FBQ0EsTUFBSSxLQUFLLENBQVQsQztBQUNBLE1BQUksSUFBSixDO0FBQ0EsTUFBSSxLQUFKLEM7O0FBRUEsTUFBSSxFQUFFLFFBQUYsS0FBZSxDQUFuQixFQUFzQjtBQUNwQixPQUFHO0FBQ0QsYUFBUSxFQUFFLFdBQUYsQ0FBYyxFQUFFLEtBQUYsR0FBVSxLQUFLLENBQTdCLEtBQW1DLENBQXBDLEdBQTBDLEVBQUUsV0FBRixDQUFjLEVBQUUsS0FBRixHQUFVLEtBQUssQ0FBZixHQUFtQixDQUFqQyxDQUFqRDtBQUNBLFdBQUssRUFBRSxXQUFGLENBQWMsRUFBRSxLQUFGLEdBQVUsRUFBeEIsQ0FBTDtBQUNBOztBQUVBLFVBQUksU0FBUyxDQUFiLEVBQWdCO0FBQ2Qsa0JBQVUsQ0FBVixFQUFhLEVBQWIsRUFBaUIsS0FBakIsRTs7QUFFRCxPQUhELE1BR087O0FBRUwsZUFBTyxhQUFhLEVBQWIsQ0FBUDtBQUNBLGtCQUFVLENBQVYsRUFBYSxPQUFPLFFBQVAsR0FBa0IsQ0FBL0IsRUFBa0MsS0FBbEMsRTtBQUNBLGdCQUFRLFlBQVksSUFBWixDQUFSO0FBQ0EsWUFBSSxVQUFVLENBQWQsRUFBaUI7QUFDZixnQkFBTSxZQUFZLElBQVosQ0FBTjtBQUNBLG9CQUFVLENBQVYsRUFBYSxFQUFiLEVBQWlCLEtBQWpCLEU7QUFDRDtBQUNELGU7QUFDQSxlQUFPLE9BQU8sSUFBUCxDQUFQOzs7QUFHQSxrQkFBVSxDQUFWLEVBQWEsSUFBYixFQUFtQixLQUFuQixFO0FBQ0EsZ0JBQVEsWUFBWSxJQUFaLENBQVI7QUFDQSxZQUFJLFVBQVUsQ0FBZCxFQUFpQjtBQUNmLGtCQUFRLFVBQVUsSUFBVixDQUFSO0FBQ0Esb0JBQVUsQ0FBVixFQUFhLElBQWIsRUFBbUIsS0FBbkIsRTtBQUNEO0FBQ0YsTzs7Ozs7QUFNRixLQWpDRCxRQWlDUyxLQUFLLEVBQUUsUUFqQ2hCO0FBa0NEOztBQUVELFlBQVUsQ0FBVixFQUFhLFNBQWIsRUFBd0IsS0FBeEI7QUFDRDs7Ozs7Ozs7OztBQVdELFNBQVMsVUFBVCxDQUFvQixDQUFwQixFQUF1QixJQUF2Qjs7O0FBR0E7QUFDRSxNQUFJLE9BQVcsS0FBSyxRQUFwQjtBQUNBLE1BQUksUUFBVyxLQUFLLFNBQUwsQ0FBZSxXQUE5QjtBQUNBLE1BQUksWUFBWSxLQUFLLFNBQUwsQ0FBZSxTQUEvQjtBQUNBLE1BQUksUUFBVyxLQUFLLFNBQUwsQ0FBZSxLQUE5QjtBQUNBLE1BQUksQ0FBSixFQUFPLENBQVAsQztBQUNBLE1BQUksV0FBVyxDQUFDLENBQWhCLEM7QUFDQSxNQUFJLElBQUosQzs7Ozs7O0FBTUEsSUFBRSxRQUFGLEdBQWEsQ0FBYjtBQUNBLElBQUUsUUFBRixHQUFhLFNBQWI7O0FBRUEsT0FBSyxJQUFJLENBQVQsRUFBWSxJQUFJLEtBQWhCLEVBQXVCLEdBQXZCLEVBQTRCO0FBQzFCLFFBQUksS0FBSyxJQUFJLENBQVQsQyxVQUFBLEtBQXlCLENBQTdCLEVBQWdDO0FBQzlCLFFBQUUsSUFBRixDQUFPLEVBQUUsRUFBRSxRQUFYLElBQXVCLFdBQVcsQ0FBbEM7QUFDQSxRQUFFLEtBQUYsQ0FBUSxDQUFSLElBQWEsQ0FBYjtBQUVELEtBSkQsTUFJTztBQUNMLFdBQUssSUFBSSxDQUFKLEdBQVEsQ0FBYixDLFNBQUEsR0FBMEIsQ0FBMUI7QUFDRDtBQUNGOzs7Ozs7O0FBT0QsU0FBTyxFQUFFLFFBQUYsR0FBYSxDQUFwQixFQUF1QjtBQUNyQixXQUFPLEVBQUUsSUFBRixDQUFPLEVBQUUsRUFBRSxRQUFYLElBQXdCLFdBQVcsQ0FBWCxHQUFlLEVBQUUsUUFBakIsR0FBNEIsQ0FBM0Q7QUFDQSxTQUFLLE9BQU8sQ0FBWixDLFVBQUEsR0FBMEIsQ0FBMUI7QUFDQSxNQUFFLEtBQUYsQ0FBUSxJQUFSLElBQWdCLENBQWhCO0FBQ0EsTUFBRSxPQUFGOztBQUVBLFFBQUksU0FBSixFQUFlO0FBQ2IsUUFBRSxVQUFGLElBQWdCLE1BQU0sT0FBTyxDQUFQLEdBQVcsQ0FBakIsQyxTQUFoQjtBQUNEOztBQUVGO0FBQ0QsT0FBSyxRQUFMLEdBQWdCLFFBQWhCOzs7OztBQUtBLE9BQUssSUFBSyxFQUFFLFFBQUYsSUFBYyxDLFdBQXhCLEVBQXNDLEtBQUssQ0FBM0MsRUFBOEMsR0FBOUMsRUFBbUQ7QUFBRSxlQUFXLENBQVgsRUFBYyxJQUFkLEVBQW9CLENBQXBCO0FBQXlCOzs7OztBQUs5RSxTQUFPLEtBQVAsQztBQUNBLEtBQUc7OztBQUdELFFBQUksRUFBRSxJQUFGLENBQU8sQyxhQUFQLENBQUo7QUFDQSxNQUFFLElBQUYsQ0FBTyxDLGFBQVAsSUFBd0IsRUFBRSxJQUFGLENBQU8sRUFBRSxRQUFGLEVBQVAsQ0FBeEI7QUFDQSxlQUFXLENBQVgsRUFBYyxJQUFkLEVBQW9CLEMsYUFBcEI7OztBQUdBLFFBQUksRUFBRSxJQUFGLENBQU8sQyxhQUFQLENBQUosQzs7QUFFQSxNQUFFLElBQUYsQ0FBTyxFQUFFLEVBQUUsUUFBWCxJQUF1QixDQUF2QixDO0FBQ0EsTUFBRSxJQUFGLENBQU8sRUFBRSxFQUFFLFFBQVgsSUFBdUIsQ0FBdkI7OztBQUdBLFNBQUssT0FBTyxDQUFaLEMsVUFBQSxHQUEwQixLQUFLLElBQUksQ0FBVCxDLFVBQUEsR0FBdUIsS0FBSyxJQUFJLENBQVQsQyxVQUFqRDtBQUNBLE1BQUUsS0FBRixDQUFRLElBQVIsSUFBZ0IsQ0FBQyxFQUFFLEtBQUYsQ0FBUSxDQUFSLEtBQWMsRUFBRSxLQUFGLENBQVEsQ0FBUixDQUFkLEdBQTJCLEVBQUUsS0FBRixDQUFRLENBQVIsQ0FBM0IsR0FBd0MsRUFBRSxLQUFGLENBQVEsQ0FBUixDQUF6QyxJQUF1RCxDQUF2RTtBQUNBLFNBQUssSUFBSSxDQUFKLEdBQVEsQ0FBYixDLFNBQUEsR0FBMEIsS0FBSyxJQUFJLENBQUosR0FBUSxDQUFiLEMsU0FBQSxHQUEwQixJQUFwRDs7O0FBR0EsTUFBRSxJQUFGLENBQU8sQyxhQUFQLElBQXdCLE1BQXhCO0FBQ0EsZUFBVyxDQUFYLEVBQWMsSUFBZCxFQUFvQixDLGFBQXBCO0FBRUQsR0F0QkQsUUFzQlMsRUFBRSxRQUFGLElBQWMsQ0F0QnZCOztBQXdCQSxJQUFFLElBQUYsQ0FBTyxFQUFFLEVBQUUsUUFBWCxJQUF1QixFQUFFLElBQUYsQ0FBTyxDLGFBQVAsQ0FBdkI7Ozs7O0FBS0EsYUFBVyxDQUFYLEVBQWMsSUFBZDs7O0FBR0EsWUFBVSxJQUFWLEVBQWdCLFFBQWhCLEVBQTBCLEVBQUUsUUFBNUI7QUFDRDs7Ozs7O0FBT0QsU0FBUyxTQUFULENBQW1CLENBQW5CLEVBQXNCLElBQXRCLEVBQTRCLFFBQTVCOzs7O0FBSUE7QUFDRSxNQUFJLENBQUosQztBQUNBLE1BQUksVUFBVSxDQUFDLENBQWYsQztBQUNBLE1BQUksTUFBSixDOztBQUVBLE1BQUksVUFBVSxLQUFLLElBQUksQ0FBSixHQUFRLENBQWIsQyxTQUFkLEM7O0FBRUEsTUFBSSxRQUFRLENBQVosQztBQUNBLE1BQUksWUFBWSxDQUFoQixDO0FBQ0EsTUFBSSxZQUFZLENBQWhCLEM7O0FBRUEsTUFBSSxZQUFZLENBQWhCLEVBQW1CO0FBQ2pCLGdCQUFZLEdBQVo7QUFDQSxnQkFBWSxDQUFaO0FBQ0Q7QUFDRCxPQUFLLENBQUMsV0FBVyxDQUFaLElBQWlCLENBQWpCLEdBQXFCLENBQTFCLEMsU0FBQSxHQUF1QyxNQUF2QyxDOztBQUVBLE9BQUssSUFBSSxDQUFULEVBQVksS0FBSyxRQUFqQixFQUEyQixHQUEzQixFQUFnQztBQUM5QixhQUFTLE9BQVQ7QUFDQSxjQUFVLEtBQUssQ0FBQyxJQUFJLENBQUwsSUFBVSxDQUFWLEdBQWMsQ0FBbkIsQyxTQUFWOztBQUVBLFFBQUksRUFBRSxLQUFGLEdBQVUsU0FBVixJQUF1QixXQUFXLE9BQXRDLEVBQStDO0FBQzdDO0FBRUQsS0FIRCxNQUdPLElBQUksUUFBUSxTQUFaLEVBQXVCO0FBQzVCLFFBQUUsT0FBRixDQUFVLFNBQVMsQ0FBbkIsQyxVQUFBLElBQWtDLEtBQWxDO0FBRUQsS0FITSxNQUdBLElBQUksV0FBVyxDQUFmLEVBQWtCOztBQUV2QixVQUFJLFdBQVcsT0FBZixFQUF3QjtBQUFFLFVBQUUsT0FBRixDQUFVLFNBQVMsQ0FBbkIsQyxVQUFBO0FBQW1DO0FBQzdELFFBQUUsT0FBRixDQUFVLFVBQVUsQ0FBcEIsQyxVQUFBO0FBRUQsS0FMTSxNQUtBLElBQUksU0FBUyxFQUFiLEVBQWlCO0FBQ3RCLFFBQUUsT0FBRixDQUFVLFlBQVksQ0FBdEIsQyxVQUFBO0FBRUQsS0FITSxNQUdBO0FBQ0wsUUFBRSxPQUFGLENBQVUsY0FBYyxDQUF4QixDLFVBQUE7QUFDRDs7QUFFRCxZQUFRLENBQVI7QUFDQSxjQUFVLE1BQVY7O0FBRUEsUUFBSSxZQUFZLENBQWhCLEVBQW1CO0FBQ2pCLGtCQUFZLEdBQVo7QUFDQSxrQkFBWSxDQUFaO0FBRUQsS0FKRCxNQUlPLElBQUksV0FBVyxPQUFmLEVBQXdCO0FBQzdCLGtCQUFZLENBQVo7QUFDQSxrQkFBWSxDQUFaO0FBRUQsS0FKTSxNQUlBO0FBQ0wsa0JBQVksQ0FBWjtBQUNBLGtCQUFZLENBQVo7QUFDRDtBQUNGO0FBQ0Y7Ozs7OztBQU9ELFNBQVMsU0FBVCxDQUFtQixDQUFuQixFQUFzQixJQUF0QixFQUE0QixRQUE1Qjs7OztBQUlBO0FBQ0UsTUFBSSxDQUFKLEM7QUFDQSxNQUFJLFVBQVUsQ0FBQyxDQUFmLEM7QUFDQSxNQUFJLE1BQUosQzs7QUFFQSxNQUFJLFVBQVUsS0FBSyxJQUFJLENBQUosR0FBUSxDQUFiLEMsU0FBZCxDOztBQUVBLE1BQUksUUFBUSxDQUFaLEM7QUFDQSxNQUFJLFlBQVksQ0FBaEIsQztBQUNBLE1BQUksWUFBWSxDQUFoQixDOzs7QUFHQSxNQUFJLFlBQVksQ0FBaEIsRUFBbUI7QUFDakIsZ0JBQVksR0FBWjtBQUNBLGdCQUFZLENBQVo7QUFDRDs7QUFFRCxPQUFLLElBQUksQ0FBVCxFQUFZLEtBQUssUUFBakIsRUFBMkIsR0FBM0IsRUFBZ0M7QUFDOUIsYUFBUyxPQUFUO0FBQ0EsY0FBVSxLQUFLLENBQUMsSUFBSSxDQUFMLElBQVUsQ0FBVixHQUFjLENBQW5CLEMsU0FBVjs7QUFFQSxRQUFJLEVBQUUsS0FBRixHQUFVLFNBQVYsSUFBdUIsV0FBVyxPQUF0QyxFQUErQztBQUM3QztBQUVELEtBSEQsTUFHTyxJQUFJLFFBQVEsU0FBWixFQUF1QjtBQUM1QixTQUFHO0FBQUUsa0JBQVUsQ0FBVixFQUFhLE1BQWIsRUFBcUIsRUFBRSxPQUF2QjtBQUFrQyxPQUF2QyxRQUErQyxFQUFFLEtBQUYsS0FBWSxDQUEzRDtBQUVELEtBSE0sTUFHQSxJQUFJLFdBQVcsQ0FBZixFQUFrQjtBQUN2QixVQUFJLFdBQVcsT0FBZixFQUF3QjtBQUN0QixrQkFBVSxDQUFWLEVBQWEsTUFBYixFQUFxQixFQUFFLE9BQXZCO0FBQ0E7QUFDRDs7QUFFRCxnQkFBVSxDQUFWLEVBQWEsT0FBYixFQUFzQixFQUFFLE9BQXhCO0FBQ0EsZ0JBQVUsQ0FBVixFQUFhLFFBQVEsQ0FBckIsRUFBd0IsQ0FBeEI7QUFFRCxLQVRNLE1BU0EsSUFBSSxTQUFTLEVBQWIsRUFBaUI7QUFDdEIsZ0JBQVUsQ0FBVixFQUFhLFNBQWIsRUFBd0IsRUFBRSxPQUExQjtBQUNBLGdCQUFVLENBQVYsRUFBYSxRQUFRLENBQXJCLEVBQXdCLENBQXhCO0FBRUQsS0FKTSxNQUlBO0FBQ0wsZ0JBQVUsQ0FBVixFQUFhLFdBQWIsRUFBMEIsRUFBRSxPQUE1QjtBQUNBLGdCQUFVLENBQVYsRUFBYSxRQUFRLEVBQXJCLEVBQXlCLENBQXpCO0FBQ0Q7O0FBRUQsWUFBUSxDQUFSO0FBQ0EsY0FBVSxNQUFWO0FBQ0EsUUFBSSxZQUFZLENBQWhCLEVBQW1CO0FBQ2pCLGtCQUFZLEdBQVo7QUFDQSxrQkFBWSxDQUFaO0FBRUQsS0FKRCxNQUlPLElBQUksV0FBVyxPQUFmLEVBQXdCO0FBQzdCLGtCQUFZLENBQVo7QUFDQSxrQkFBWSxDQUFaO0FBRUQsS0FKTSxNQUlBO0FBQ0wsa0JBQVksQ0FBWjtBQUNBLGtCQUFZLENBQVo7QUFDRDtBQUNGO0FBQ0Y7Ozs7OztBQU9ELFNBQVMsYUFBVCxDQUF1QixDQUF2QixFQUEwQjtBQUN4QixNQUFJLFdBQUosQzs7O0FBR0EsWUFBVSxDQUFWLEVBQWEsRUFBRSxTQUFmLEVBQTBCLEVBQUUsTUFBRixDQUFTLFFBQW5DO0FBQ0EsWUFBVSxDQUFWLEVBQWEsRUFBRSxTQUFmLEVBQTBCLEVBQUUsTUFBRixDQUFTLFFBQW5DOzs7QUFHQSxhQUFXLENBQVgsRUFBYyxFQUFFLE9BQWhCOzs7Ozs7Ozs7QUFTQSxPQUFLLGNBQWMsV0FBVyxDQUE5QixFQUFpQyxlQUFlLENBQWhELEVBQW1ELGFBQW5ELEVBQWtFO0FBQ2hFLFFBQUksRUFBRSxPQUFGLENBQVUsU0FBUyxXQUFULElBQXdCLENBQXhCLEdBQTRCLENBQXRDLEMsU0FBQSxLQUFxRCxDQUF6RCxFQUE0RDtBQUMxRDtBQUNEO0FBQ0Y7O0FBRUQsSUFBRSxPQUFGLElBQWEsS0FBSyxjQUFjLENBQW5CLElBQXdCLENBQXhCLEdBQTRCLENBQTVCLEdBQWdDLENBQTdDOzs7O0FBSUEsU0FBTyxXQUFQO0FBQ0Q7Ozs7Ozs7QUFRRCxTQUFTLGNBQVQsQ0FBd0IsQ0FBeEIsRUFBMkIsTUFBM0IsRUFBbUMsTUFBbkMsRUFBMkMsT0FBM0M7OztBQUdBO0FBQ0UsTUFBSSxJQUFKLEM7Ozs7OztBQU1BLFlBQVUsQ0FBVixFQUFhLFNBQVMsR0FBdEIsRUFBMkIsQ0FBM0IsRTtBQUNBLFlBQVUsQ0FBVixFQUFhLFNBQVMsQ0FBdEIsRUFBMkIsQ0FBM0I7QUFDQSxZQUFVLENBQVYsRUFBYSxVQUFVLENBQXZCLEVBQTJCLENBQTNCLEU7QUFDQSxPQUFLLE9BQU8sQ0FBWixFQUFlLE9BQU8sT0FBdEIsRUFBK0IsTUFBL0IsRUFBdUM7O0FBRXJDLGNBQVUsQ0FBVixFQUFhLEVBQUUsT0FBRixDQUFVLFNBQVMsSUFBVCxJQUFpQixDQUFqQixHQUFxQixDQUEvQixDLFNBQWIsRUFBd0QsQ0FBeEQ7QUFDRDs7O0FBR0QsWUFBVSxDQUFWLEVBQWEsRUFBRSxTQUFmLEVBQTBCLFNBQVMsQ0FBbkMsRTs7O0FBR0EsWUFBVSxDQUFWLEVBQWEsRUFBRSxTQUFmLEVBQTBCLFNBQVMsQ0FBbkMsRTs7QUFFRDs7Ozs7Ozs7Ozs7Ozs7O0FBZ0JELFNBQVMsZ0JBQVQsQ0FBMEIsQ0FBMUIsRUFBNkI7Ozs7O0FBSzNCLE1BQUksYUFBYSxVQUFqQjtBQUNBLE1BQUksQ0FBSjs7O0FBR0EsT0FBSyxJQUFJLENBQVQsRUFBWSxLQUFLLEVBQWpCLEVBQXFCLEtBQUssZ0JBQWdCLENBQTFDLEVBQTZDO0FBQzNDLFFBQUssYUFBYSxDQUFkLElBQXFCLEVBQUUsU0FBRixDQUFZLElBQUksQ0FBaEIsQyxVQUFBLEtBQWdDLENBQXpELEVBQTZEO0FBQzNELGFBQU8sUUFBUDtBQUNEO0FBQ0Y7OztBQUdELE1BQUksRUFBRSxTQUFGLENBQVksSUFBSSxDQUFoQixDLFVBQUEsS0FBZ0MsQ0FBaEMsSUFBcUMsRUFBRSxTQUFGLENBQVksS0FBSyxDQUFqQixDLFVBQUEsS0FBaUMsQ0FBdEUsSUFDQSxFQUFFLFNBQUYsQ0FBWSxLQUFLLENBQWpCLEMsVUFBQSxLQUFpQyxDQURyQyxFQUN3QztBQUN0QyxXQUFPLE1BQVA7QUFDRDtBQUNELE9BQUssSUFBSSxFQUFULEVBQWEsSUFBSSxRQUFqQixFQUEyQixHQUEzQixFQUFnQztBQUM5QixRQUFJLEVBQUUsU0FBRixDQUFZLElBQUksQ0FBaEIsQyxVQUFBLEtBQWdDLENBQXBDLEVBQXVDO0FBQ3JDLGFBQU8sTUFBUDtBQUNEO0FBQ0Y7Ozs7O0FBS0QsU0FBTyxRQUFQO0FBQ0Q7O0FBR0QsSUFBSSxtQkFBbUIsS0FBdkI7Ozs7O0FBS0EsU0FBUyxRQUFULENBQWtCLENBQWxCLEVBQ0E7O0FBRUUsTUFBSSxDQUFDLGdCQUFMLEVBQXVCO0FBQ3JCO0FBQ0EsdUJBQW1CLElBQW5CO0FBQ0Q7O0FBRUQsSUFBRSxNQUFGLEdBQVksSUFBSSxRQUFKLENBQWEsRUFBRSxTQUFmLEVBQTBCLGFBQTFCLENBQVo7QUFDQSxJQUFFLE1BQUYsR0FBWSxJQUFJLFFBQUosQ0FBYSxFQUFFLFNBQWYsRUFBMEIsYUFBMUIsQ0FBWjtBQUNBLElBQUUsT0FBRixHQUFZLElBQUksUUFBSixDQUFhLEVBQUUsT0FBZixFQUF3QixjQUF4QixDQUFaOztBQUVBLElBQUUsTUFBRixHQUFXLENBQVg7QUFDQSxJQUFFLFFBQUYsR0FBYSxDQUFiOzs7QUFHQSxhQUFXLENBQVg7QUFDRDs7Ozs7QUFNRCxTQUFTLGdCQUFULENBQTBCLENBQTFCLEVBQTZCLEdBQTdCLEVBQWtDLFVBQWxDLEVBQThDLElBQTlDOzs7OztBQUtBO0FBQ0UsWUFBVSxDQUFWLEVBQWEsQ0FBQyxnQkFBZ0IsQ0FBakIsS0FBdUIsT0FBTyxDQUFQLEdBQVcsQ0FBbEMsQ0FBYixFQUFtRCxDQUFuRCxFO0FBQ0EsYUFBVyxDQUFYLEVBQWMsR0FBZCxFQUFtQixVQUFuQixFQUErQixJQUEvQixFO0FBQ0Q7Ozs7OztBQU9ELFNBQVMsU0FBVCxDQUFtQixDQUFuQixFQUFzQjtBQUNwQixZQUFVLENBQVYsRUFBYSxnQkFBZ0IsQ0FBN0IsRUFBZ0MsQ0FBaEM7QUFDQSxZQUFVLENBQVYsRUFBYSxTQUFiLEVBQXdCLFlBQXhCO0FBQ0EsV0FBUyxDQUFUO0FBQ0Q7Ozs7OztBQU9ELFNBQVMsZUFBVCxDQUF5QixDQUF6QixFQUE0QixHQUE1QixFQUFpQyxVQUFqQyxFQUE2QyxJQUE3Qzs7Ozs7QUFLQTtBQUNFLE1BQUksUUFBSixFQUFjLFdBQWQsQztBQUNBLE1BQUksY0FBYyxDQUFsQixDOzs7QUFHQSxNQUFJLEVBQUUsS0FBRixHQUFVLENBQWQsRUFBaUI7OztBQUdmLFFBQUksRUFBRSxJQUFGLENBQU8sU0FBUCxLQUFxQixTQUF6QixFQUFvQztBQUNsQyxRQUFFLElBQUYsQ0FBTyxTQUFQLEdBQW1CLGlCQUFpQixDQUFqQixDQUFuQjtBQUNEOzs7QUFHRCxlQUFXLENBQVgsRUFBYyxFQUFFLE1BQWhCOzs7O0FBSUEsZUFBVyxDQUFYLEVBQWMsRUFBRSxNQUFoQjs7Ozs7Ozs7OztBQVVBLGtCQUFjLGNBQWMsQ0FBZCxDQUFkOzs7QUFHQSxlQUFZLEVBQUUsT0FBRixHQUFZLENBQVosR0FBZ0IsQ0FBakIsS0FBd0IsQ0FBbkM7QUFDQSxrQkFBZSxFQUFFLFVBQUYsR0FBZSxDQUFmLEdBQW1CLENBQXBCLEtBQTJCLENBQXpDOzs7Ozs7QUFNQSxRQUFJLGVBQWUsUUFBbkIsRUFBNkI7QUFBRSxpQkFBVyxXQUFYO0FBQXlCO0FBRXpELEdBbENELE1Ba0NPOztBQUVMLGVBQVcsY0FBYyxhQUFhLENBQXRDLEM7QUFDRDs7QUFFRCxNQUFLLGFBQWEsQ0FBYixJQUFrQixRQUFuQixJQUFpQyxRQUFRLENBQUMsQ0FBOUMsRUFBa0Q7Ozs7Ozs7OztBQVNoRCxxQkFBaUIsQ0FBakIsRUFBb0IsR0FBcEIsRUFBeUIsVUFBekIsRUFBcUMsSUFBckM7QUFFRCxHQVhELE1BV08sSUFBSSxFQUFFLFFBQUYsS0FBZSxPQUFmLElBQTBCLGdCQUFnQixRQUE5QyxFQUF3RDs7QUFFN0QsY0FBVSxDQUFWLEVBQWEsQ0FBQyxnQkFBZ0IsQ0FBakIsS0FBdUIsT0FBTyxDQUFQLEdBQVcsQ0FBbEMsQ0FBYixFQUFtRCxDQUFuRDtBQUNBLG1CQUFlLENBQWYsRUFBa0IsWUFBbEIsRUFBZ0MsWUFBaEM7QUFFRCxHQUxNLE1BS0E7QUFDTCxjQUFVLENBQVYsRUFBYSxDQUFDLGFBQWEsQ0FBZCxLQUFvQixPQUFPLENBQVAsR0FBVyxDQUEvQixDQUFiLEVBQWdELENBQWhEO0FBQ0EsbUJBQWUsQ0FBZixFQUFrQixFQUFFLE1BQUYsQ0FBUyxRQUFULEdBQW9CLENBQXRDLEVBQXlDLEVBQUUsTUFBRixDQUFTLFFBQVQsR0FBb0IsQ0FBN0QsRUFBZ0UsY0FBYyxDQUE5RTtBQUNBLG1CQUFlLENBQWYsRUFBa0IsRUFBRSxTQUFwQixFQUErQixFQUFFLFNBQWpDO0FBQ0Q7Ozs7O0FBS0QsYUFBVyxDQUFYOztBQUVBLE1BQUksSUFBSixFQUFVO0FBQ1IsY0FBVSxDQUFWO0FBQ0Q7OztBQUdGOzs7Ozs7QUFNRCxTQUFTLFNBQVQsQ0FBbUIsQ0FBbkIsRUFBc0IsSUFBdEIsRUFBNEIsRUFBNUI7Ozs7QUFJQTs7O0FBR0UsSUFBRSxXQUFGLENBQWMsRUFBRSxLQUFGLEdBQVUsRUFBRSxRQUFGLEdBQWEsQ0FBckMsSUFBK0MsU0FBUyxDQUFWLEdBQWUsSUFBN0Q7QUFDQSxJQUFFLFdBQUYsQ0FBYyxFQUFFLEtBQUYsR0FBVSxFQUFFLFFBQUYsR0FBYSxDQUF2QixHQUEyQixDQUF6QyxJQUE4QyxPQUFPLElBQXJEOztBQUVBLElBQUUsV0FBRixDQUFjLEVBQUUsS0FBRixHQUFVLEVBQUUsUUFBMUIsSUFBc0MsS0FBSyxJQUEzQztBQUNBLElBQUUsUUFBRjs7QUFFQSxNQUFJLFNBQVMsQ0FBYixFQUFnQjs7QUFFZCxNQUFFLFNBQUYsQ0FBWSxLQUFLLENBQWpCLEMsVUFBQTtBQUNELEdBSEQsTUFHTztBQUNMLE1BQUUsT0FBRjs7QUFFQSxXOzs7OztBQUtBLE1BQUUsU0FBRixDQUFZLENBQUMsYUFBYSxFQUFiLElBQW1CLFFBQW5CLEdBQThCLENBQS9CLElBQW9DLENBQWhELEMsVUFBQTtBQUNBLE1BQUUsU0FBRixDQUFZLE9BQU8sSUFBUCxJQUFlLENBQTNCLEMsVUFBQTtBQUNEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBeUJELFNBQVEsRUFBRSxRQUFGLEtBQWUsRUFBRSxXQUFGLEdBQWdCLENBQXZDOzs7OztBQUtEOztBQUVELFFBQVEsUUFBUixHQUFvQixRQUFwQjtBQUNBLFFBQVEsZ0JBQVIsR0FBMkIsZ0JBQTNCO0FBQ0EsUUFBUSxlQUFSLEdBQTJCLGVBQTNCO0FBQ0EsUUFBUSxTQUFSLEdBQW9CLFNBQXBCO0FBQ0EsUUFBUSxTQUFSLEdBQW9CLFNBQXBCOzs7QUNqckNBOztBQUdBLFNBQVMsT0FBVCxHQUFtQjs7QUFFakIsT0FBSyxLQUFMLEdBQWEsSUFBYixDO0FBQ0EsT0FBSyxPQUFMLEdBQWUsQ0FBZjs7QUFFQSxPQUFLLFFBQUwsR0FBZ0IsQ0FBaEI7O0FBRUEsT0FBSyxRQUFMLEdBQWdCLENBQWhCOztBQUVBLE9BQUssTUFBTCxHQUFjLElBQWQsQztBQUNBLE9BQUssUUFBTCxHQUFnQixDQUFoQjs7QUFFQSxPQUFLLFNBQUwsR0FBaUIsQ0FBakI7O0FBRUEsT0FBSyxTQUFMLEdBQWlCLENBQWpCOztBQUVBLE9BQUssR0FBTCxHQUFXLEUsV0FBWDs7QUFFQSxPQUFLLEtBQUwsR0FBYSxJQUFiOztBQUVBLE9BQUssU0FBTCxHQUFpQixDLGNBQWpCOztBQUVBLE9BQUssS0FBTCxHQUFhLENBQWI7QUFDRDs7QUFFRCxPQUFPLE9BQVAsR0FBaUIsT0FBakI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNIQSxTQUFTLGNBQVQsQ0FBd0IsS0FBeEIsRUFBK0IsY0FBL0IsRUFBK0M7O0FBRTdDLE1BQUksS0FBSyxDQUFUO0FBQ0EsT0FBSyxJQUFJLElBQUksTUFBTSxNQUFOLEdBQWUsQ0FBNUIsRUFBK0IsS0FBSyxDQUFwQyxFQUF1QyxHQUF2QyxFQUE0QztBQUMxQyxRQUFJLE9BQU8sTUFBTSxDQUFOLENBQVg7QUFDQSxRQUFJLFNBQVMsR0FBYixFQUFrQjtBQUNoQixZQUFNLE1BQU4sQ0FBYSxDQUFiLEVBQWdCLENBQWhCO0FBQ0QsS0FGRCxNQUVPLElBQUksU0FBUyxJQUFiLEVBQW1CO0FBQ3hCLFlBQU0sTUFBTixDQUFhLENBQWIsRUFBZ0IsQ0FBaEI7QUFDQTtBQUNELEtBSE0sTUFHQSxJQUFJLEVBQUosRUFBUTtBQUNiLFlBQU0sTUFBTixDQUFhLENBQWIsRUFBZ0IsQ0FBaEI7QUFDQTtBQUNEO0FBQ0Y7OztBQUdELE1BQUksY0FBSixFQUFvQjtBQUNsQixXQUFPLElBQVAsRUFBYSxFQUFiLEVBQWlCO0FBQ2YsWUFBTSxPQUFOLENBQWMsSUFBZDtBQUNEO0FBQ0Y7O0FBRUQsU0FBTyxLQUFQO0FBQ0Q7Ozs7QUFJRCxJQUFJLGNBQ0EsK0RBREo7QUFFQSxJQUFJLFlBQVksU0FBWixTQUFZLENBQVMsUUFBVCxFQUFtQjtBQUNqQyxTQUFPLFlBQVksSUFBWixDQUFpQixRQUFqQixFQUEyQixLQUEzQixDQUFpQyxDQUFqQyxDQUFQO0FBQ0QsQ0FGRDs7OztBQU1BLFFBQVEsT0FBUixHQUFrQixZQUFXO0FBQzNCLE1BQUksZUFBZSxFQUFuQjtBQUFBLE1BQ0ksbUJBQW1CLEtBRHZCOztBQUdBLE9BQUssSUFBSSxJQUFJLFVBQVUsTUFBVixHQUFtQixDQUFoQyxFQUFtQyxLQUFLLENBQUMsQ0FBTixJQUFXLENBQUMsZ0JBQS9DLEVBQWlFLEdBQWpFLEVBQXNFO0FBQ3BFLFFBQUksT0FBUSxLQUFLLENBQU4sR0FBVyxVQUFVLENBQVYsQ0FBWCxHQUEwQixRQUFRLEdBQVIsRUFBckM7OztBQUdBLFFBQUksT0FBTyxJQUFQLEtBQWdCLFFBQXBCLEVBQThCO0FBQzVCLFlBQU0sSUFBSSxTQUFKLENBQWMsMkNBQWQsQ0FBTjtBQUNELEtBRkQsTUFFTyxJQUFJLENBQUMsSUFBTCxFQUFXO0FBQ2hCO0FBQ0Q7O0FBRUQsbUJBQWUsT0FBTyxHQUFQLEdBQWEsWUFBNUI7QUFDQSx1QkFBbUIsS0FBSyxNQUFMLENBQVksQ0FBWixNQUFtQixHQUF0QztBQUNEOzs7Ozs7QUFNRCxpQkFBZSxlQUFlLE9BQU8sYUFBYSxLQUFiLENBQW1CLEdBQW5CLENBQVAsRUFBZ0MsVUFBUyxDQUFULEVBQVk7QUFDeEUsV0FBTyxDQUFDLENBQUMsQ0FBVDtBQUNELEdBRjZCLENBQWYsRUFFWCxDQUFDLGdCQUZVLEVBRVEsSUFGUixDQUVhLEdBRmIsQ0FBZjs7QUFJQSxTQUFRLENBQUMsbUJBQW1CLEdBQW5CLEdBQXlCLEVBQTFCLElBQWdDLFlBQWpDLElBQWtELEdBQXpEO0FBQ0QsQ0EzQkQ7Ozs7QUErQkEsUUFBUSxTQUFSLEdBQW9CLFVBQVMsSUFBVCxFQUFlO0FBQ2pDLE1BQUksYUFBYSxRQUFRLFVBQVIsQ0FBbUIsSUFBbkIsQ0FBakI7QUFBQSxNQUNJLGdCQUFnQixPQUFPLElBQVAsRUFBYSxDQUFDLENBQWQsTUFBcUIsR0FEekM7OztBQUlBLFNBQU8sZUFBZSxPQUFPLEtBQUssS0FBTCxDQUFXLEdBQVgsQ0FBUCxFQUF3QixVQUFTLENBQVQsRUFBWTtBQUN4RCxXQUFPLENBQUMsQ0FBQyxDQUFUO0FBQ0QsR0FGcUIsQ0FBZixFQUVILENBQUMsVUFGRSxFQUVVLElBRlYsQ0FFZSxHQUZmLENBQVA7O0FBSUEsTUFBSSxDQUFDLElBQUQsSUFBUyxDQUFDLFVBQWQsRUFBMEI7QUFDeEIsV0FBTyxHQUFQO0FBQ0Q7QUFDRCxNQUFJLFFBQVEsYUFBWixFQUEyQjtBQUN6QixZQUFRLEdBQVI7QUFDRDs7QUFFRCxTQUFPLENBQUMsYUFBYSxHQUFiLEdBQW1CLEVBQXBCLElBQTBCLElBQWpDO0FBQ0QsQ0FqQkQ7OztBQW9CQSxRQUFRLFVBQVIsR0FBcUIsVUFBUyxJQUFULEVBQWU7QUFDbEMsU0FBTyxLQUFLLE1BQUwsQ0FBWSxDQUFaLE1BQW1CLEdBQTFCO0FBQ0QsQ0FGRDs7O0FBS0EsUUFBUSxJQUFSLEdBQWUsWUFBVztBQUN4QixNQUFJLFFBQVEsTUFBTSxTQUFOLENBQWdCLEtBQWhCLENBQXNCLElBQXRCLENBQTJCLFNBQTNCLEVBQXNDLENBQXRDLENBQVo7QUFDQSxTQUFPLFFBQVEsU0FBUixDQUFrQixPQUFPLEtBQVAsRUFBYyxVQUFTLENBQVQsRUFBWSxLQUFaLEVBQW1CO0FBQ3hELFFBQUksT0FBTyxDQUFQLEtBQWEsUUFBakIsRUFBMkI7QUFDekIsWUFBTSxJQUFJLFNBQUosQ0FBYyx3Q0FBZCxDQUFOO0FBQ0Q7QUFDRCxXQUFPLENBQVA7QUFDRCxHQUx3QixFQUt0QixJQUxzQixDQUtqQixHQUxpQixDQUFsQixDQUFQO0FBTUQsQ0FSRDs7OztBQWFBLFFBQVEsUUFBUixHQUFtQixVQUFTLElBQVQsRUFBZSxFQUFmLEVBQW1CO0FBQ3BDLFNBQU8sUUFBUSxPQUFSLENBQWdCLElBQWhCLEVBQXNCLE1BQXRCLENBQTZCLENBQTdCLENBQVA7QUFDQSxPQUFLLFFBQVEsT0FBUixDQUFnQixFQUFoQixFQUFvQixNQUFwQixDQUEyQixDQUEzQixDQUFMOztBQUVBLFdBQVMsSUFBVCxDQUFjLEdBQWQsRUFBbUI7QUFDakIsUUFBSSxRQUFRLENBQVo7QUFDQSxXQUFPLFFBQVEsSUFBSSxNQUFuQixFQUEyQixPQUEzQixFQUFvQztBQUNsQyxVQUFJLElBQUksS0FBSixNQUFlLEVBQW5CLEVBQXVCO0FBQ3hCOztBQUVELFFBQUksTUFBTSxJQUFJLE1BQUosR0FBYSxDQUF2QjtBQUNBLFdBQU8sT0FBTyxDQUFkLEVBQWlCLEtBQWpCLEVBQXdCO0FBQ3RCLFVBQUksSUFBSSxHQUFKLE1BQWEsRUFBakIsRUFBcUI7QUFDdEI7O0FBRUQsUUFBSSxRQUFRLEdBQVosRUFBaUIsT0FBTyxFQUFQO0FBQ2pCLFdBQU8sSUFBSSxLQUFKLENBQVUsS0FBVixFQUFpQixNQUFNLEtBQU4sR0FBYyxDQUEvQixDQUFQO0FBQ0Q7O0FBRUQsTUFBSSxZQUFZLEtBQUssS0FBSyxLQUFMLENBQVcsR0FBWCxDQUFMLENBQWhCO0FBQ0EsTUFBSSxVQUFVLEtBQUssR0FBRyxLQUFILENBQVMsR0FBVCxDQUFMLENBQWQ7O0FBRUEsTUFBSSxTQUFTLEtBQUssR0FBTCxDQUFTLFVBQVUsTUFBbkIsRUFBMkIsUUFBUSxNQUFuQyxDQUFiO0FBQ0EsTUFBSSxrQkFBa0IsTUFBdEI7QUFDQSxPQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksTUFBcEIsRUFBNEIsR0FBNUIsRUFBaUM7QUFDL0IsUUFBSSxVQUFVLENBQVYsTUFBaUIsUUFBUSxDQUFSLENBQXJCLEVBQWlDO0FBQy9CLHdCQUFrQixDQUFsQjtBQUNBO0FBQ0Q7QUFDRjs7QUFFRCxNQUFJLGNBQWMsRUFBbEI7QUFDQSxPQUFLLElBQUksSUFBSSxlQUFiLEVBQThCLElBQUksVUFBVSxNQUE1QyxFQUFvRCxHQUFwRCxFQUF5RDtBQUN2RCxnQkFBWSxJQUFaLENBQWlCLElBQWpCO0FBQ0Q7O0FBRUQsZ0JBQWMsWUFBWSxNQUFaLENBQW1CLFFBQVEsS0FBUixDQUFjLGVBQWQsQ0FBbkIsQ0FBZDs7QUFFQSxTQUFPLFlBQVksSUFBWixDQUFpQixHQUFqQixDQUFQO0FBQ0QsQ0F2Q0Q7O0FBeUNBLFFBQVEsR0FBUixHQUFjLEdBQWQ7QUFDQSxRQUFRLFNBQVIsR0FBb0IsR0FBcEI7O0FBRUEsUUFBUSxPQUFSLEdBQWtCLFVBQVMsSUFBVCxFQUFlO0FBQy9CLE1BQUksU0FBUyxVQUFVLElBQVYsQ0FBYjtBQUFBLE1BQ0ksT0FBTyxPQUFPLENBQVAsQ0FEWDtBQUFBLE1BRUksTUFBTSxPQUFPLENBQVAsQ0FGVjs7QUFJQSxNQUFJLENBQUMsSUFBRCxJQUFTLENBQUMsR0FBZCxFQUFtQjs7QUFFakIsV0FBTyxHQUFQO0FBQ0Q7O0FBRUQsTUFBSSxHQUFKLEVBQVM7O0FBRVAsVUFBTSxJQUFJLE1BQUosQ0FBVyxDQUFYLEVBQWMsSUFBSSxNQUFKLEdBQWEsQ0FBM0IsQ0FBTjtBQUNEOztBQUVELFNBQU8sT0FBTyxHQUFkO0FBQ0QsQ0FoQkQ7O0FBbUJBLFFBQVEsUUFBUixHQUFtQixVQUFTLElBQVQsRUFBZSxHQUFmLEVBQW9CO0FBQ3JDLE1BQUksSUFBSSxVQUFVLElBQVYsRUFBZ0IsQ0FBaEIsQ0FBUjs7QUFFQSxNQUFJLE9BQU8sRUFBRSxNQUFGLENBQVMsQ0FBQyxDQUFELEdBQUssSUFBSSxNQUFsQixNQUE4QixHQUF6QyxFQUE4QztBQUM1QyxRQUFJLEVBQUUsTUFBRixDQUFTLENBQVQsRUFBWSxFQUFFLE1BQUYsR0FBVyxJQUFJLE1BQTNCLENBQUo7QUFDRDtBQUNELFNBQU8sQ0FBUDtBQUNELENBUEQ7O0FBVUEsUUFBUSxPQUFSLEdBQWtCLFVBQVMsSUFBVCxFQUFlO0FBQy9CLFNBQU8sVUFBVSxJQUFWLEVBQWdCLENBQWhCLENBQVA7QUFDRCxDQUZEOztBQUlBLFNBQVMsTUFBVCxDQUFpQixFQUFqQixFQUFxQixDQUFyQixFQUF3QjtBQUNwQixNQUFJLEdBQUcsTUFBUCxFQUFlLE9BQU8sR0FBRyxNQUFILENBQVUsQ0FBVixDQUFQO0FBQ2YsTUFBSSxNQUFNLEVBQVY7QUFDQSxPQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksR0FBRyxNQUF2QixFQUErQixHQUEvQixFQUFvQztBQUNoQyxRQUFJLEVBQUUsR0FBRyxDQUFILENBQUYsRUFBUyxDQUFULEVBQVksRUFBWixDQUFKLEVBQXFCLElBQUksSUFBSixDQUFTLEdBQUcsQ0FBSCxDQUFUO0FBQ3hCO0FBQ0QsU0FBTyxHQUFQO0FBQ0g7OztBQUdELElBQUksU0FBUyxLQUFLLE1BQUwsQ0FBWSxDQUFDLENBQWIsTUFBb0IsR0FBcEIsR0FDUCxVQUFVLEdBQVYsRUFBZSxLQUFmLEVBQXNCLEdBQXRCLEVBQTJCO0FBQUUsU0FBTyxJQUFJLE1BQUosQ0FBVyxLQUFYLEVBQWtCLEdBQWxCLENBQVA7QUFBK0IsQ0FEckQsR0FFUCxVQUFVLEdBQVYsRUFBZSxLQUFmLEVBQXNCLEdBQXRCLEVBQTJCO0FBQ3pCLE1BQUksUUFBUSxDQUFaLEVBQWUsUUFBUSxJQUFJLE1BQUosR0FBYSxLQUFyQjtBQUNmLFNBQU8sSUFBSSxNQUFKLENBQVcsS0FBWCxFQUFrQixHQUFsQixDQUFQO0FBQ0gsQ0FMTDs7Ozs7Ozs7O0FDdk5BLElBQUksVUFBVSxPQUFPLE9BQVAsR0FBaUIsRUFBL0I7Ozs7Ozs7QUFPQSxJQUFJLGdCQUFKO0FBQ0EsSUFBSSxrQkFBSjs7QUFFQyxhQUFZO0FBQ1gsUUFBSTtBQUNGLDJCQUFtQixVQUFuQjtBQUNELEtBRkQsQ0FFRSxPQUFPLENBQVAsRUFBVTtBQUNWLDJCQUFtQiw0QkFBWTtBQUM3QixrQkFBTSxJQUFJLEtBQUosQ0FBVSwyQkFBVixDQUFOO0FBQ0QsU0FGRDtBQUdEO0FBQ0QsUUFBSTtBQUNGLDZCQUFxQixZQUFyQjtBQUNELEtBRkQsQ0FFRSxPQUFPLENBQVAsRUFBVTtBQUNWLDZCQUFxQiw4QkFBWTtBQUMvQixrQkFBTSxJQUFJLEtBQUosQ0FBVSw2QkFBVixDQUFOO0FBQ0QsU0FGRDtBQUdEO0FBQ0YsQ0FmQSxHQUFEO0FBZ0JBLElBQUksUUFBUSxFQUFaO0FBQ0EsSUFBSSxXQUFXLEtBQWY7QUFDQSxJQUFJLFlBQUo7QUFDQSxJQUFJLGFBQWEsQ0FBQyxDQUFsQjs7QUFFQSxTQUFTLGVBQVQsR0FBMkI7QUFDdkIsUUFBSSxDQUFDLFFBQUQsSUFBYSxDQUFDLFlBQWxCLEVBQWdDO0FBQzVCO0FBQ0g7QUFDRCxlQUFXLEtBQVg7QUFDQSxRQUFJLGFBQWEsTUFBakIsRUFBeUI7QUFDckIsZ0JBQVEsYUFBYSxNQUFiLENBQW9CLEtBQXBCLENBQVI7QUFDSCxLQUZELE1BRU87QUFDSCxxQkFBYSxDQUFDLENBQWQ7QUFDSDtBQUNELFFBQUksTUFBTSxNQUFWLEVBQWtCO0FBQ2Q7QUFDSDtBQUNKOztBQUVELFNBQVMsVUFBVCxHQUFzQjtBQUNsQixRQUFJLFFBQUosRUFBYztBQUNWO0FBQ0g7QUFDRCxRQUFJLFVBQVUsaUJBQWlCLGVBQWpCLENBQWQ7QUFDQSxlQUFXLElBQVg7O0FBRUEsUUFBSSxNQUFNLE1BQU0sTUFBaEI7QUFDQSxXQUFNLEdBQU4sRUFBVztBQUNQLHVCQUFlLEtBQWY7QUFDQSxnQkFBUSxFQUFSO0FBQ0EsZUFBTyxFQUFFLFVBQUYsR0FBZSxHQUF0QixFQUEyQjtBQUN2QixnQkFBSSxZQUFKLEVBQWtCO0FBQ2QsNkJBQWEsVUFBYixFQUF5QixHQUF6QjtBQUNIO0FBQ0o7QUFDRCxxQkFBYSxDQUFDLENBQWQ7QUFDQSxjQUFNLE1BQU0sTUFBWjtBQUNIO0FBQ0QsbUJBQWUsSUFBZjtBQUNBLGVBQVcsS0FBWDtBQUNBLHVCQUFtQixPQUFuQjtBQUNIOztBQUVELFFBQVEsUUFBUixHQUFtQixVQUFVLEdBQVYsRUFBZTtBQUM5QixRQUFJLE9BQU8sSUFBSSxLQUFKLENBQVUsVUFBVSxNQUFWLEdBQW1CLENBQTdCLENBQVg7QUFDQSxRQUFJLFVBQVUsTUFBVixHQUFtQixDQUF2QixFQUEwQjtBQUN0QixhQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksVUFBVSxNQUE5QixFQUFzQyxHQUF0QyxFQUEyQztBQUN2QyxpQkFBSyxJQUFJLENBQVQsSUFBYyxVQUFVLENBQVYsQ0FBZDtBQUNIO0FBQ0o7QUFDRCxVQUFNLElBQU4sQ0FBVyxJQUFJLElBQUosQ0FBUyxHQUFULEVBQWMsSUFBZCxDQUFYO0FBQ0EsUUFBSSxNQUFNLE1BQU4sS0FBaUIsQ0FBakIsSUFBc0IsQ0FBQyxRQUEzQixFQUFxQztBQUNqQyx5QkFBaUIsVUFBakIsRUFBNkIsQ0FBN0I7QUFDSDtBQUNKLENBWEQ7OztBQWNBLFNBQVMsSUFBVCxDQUFjLEdBQWQsRUFBbUIsS0FBbkIsRUFBMEI7QUFDdEIsU0FBSyxHQUFMLEdBQVcsR0FBWDtBQUNBLFNBQUssS0FBTCxHQUFhLEtBQWI7QUFDSDtBQUNELEtBQUssU0FBTCxDQUFlLEdBQWYsR0FBcUIsWUFBWTtBQUM3QixTQUFLLEdBQUwsQ0FBUyxLQUFULENBQWUsSUFBZixFQUFxQixLQUFLLEtBQTFCO0FBQ0gsQ0FGRDtBQUdBLFFBQVEsS0FBUixHQUFnQixTQUFoQjtBQUNBLFFBQVEsT0FBUixHQUFrQixJQUFsQjtBQUNBLFFBQVEsR0FBUixHQUFjLEVBQWQ7QUFDQSxRQUFRLElBQVIsR0FBZSxFQUFmO0FBQ0EsUUFBUSxPQUFSLEdBQWtCLEVBQWxCLEM7QUFDQSxRQUFRLFFBQVIsR0FBbUIsRUFBbkI7O0FBRUEsU0FBUyxJQUFULEdBQWdCLENBQUU7O0FBRWxCLFFBQVEsRUFBUixHQUFhLElBQWI7QUFDQSxRQUFRLFdBQVIsR0FBc0IsSUFBdEI7QUFDQSxRQUFRLElBQVIsR0FBZSxJQUFmO0FBQ0EsUUFBUSxHQUFSLEdBQWMsSUFBZDtBQUNBLFFBQVEsY0FBUixHQUF5QixJQUF6QjtBQUNBLFFBQVEsa0JBQVIsR0FBNkIsSUFBN0I7QUFDQSxRQUFRLElBQVIsR0FBZSxJQUFmOztBQUVBLFFBQVEsT0FBUixHQUFrQixVQUFVLElBQVYsRUFBZ0I7QUFDOUIsVUFBTSxJQUFJLEtBQUosQ0FBVSxrQ0FBVixDQUFOO0FBQ0gsQ0FGRDs7QUFJQSxRQUFRLEdBQVIsR0FBYyxZQUFZO0FBQUUsV0FBTyxHQUFQO0FBQVksQ0FBeEM7QUFDQSxRQUFRLEtBQVIsR0FBZ0IsVUFBVSxHQUFWLEVBQWU7QUFDM0IsVUFBTSxJQUFJLEtBQUosQ0FBVSxnQ0FBVixDQUFOO0FBQ0gsQ0FGRDtBQUdBLFFBQVEsS0FBUixHQUFnQixZQUFXO0FBQUUsV0FBTyxDQUFQO0FBQVcsQ0FBeEM7Ozs7Ozs7QUNySEEsU0FBUyxJQUFULENBQWUsU0FBZixFQUEwQixTQUExQixFQUFxQztBQUNuQyxPQUFLLE1BQUwsR0FBYyxJQUFJLE1BQUosQ0FBVyxTQUFYLENBQWQ7QUFDQSxPQUFLLFVBQUwsR0FBa0IsU0FBbEI7QUFDQSxPQUFLLFVBQUwsR0FBa0IsU0FBbEI7QUFDQSxPQUFLLElBQUwsR0FBWSxDQUFaO0FBQ0EsT0FBSyxFQUFMLEdBQVUsQ0FBVjtBQUNEOztBQUVELEtBQUssU0FBTCxDQUFlLE1BQWYsR0FBd0IsVUFBVSxJQUFWLEVBQWdCLEdBQWhCLEVBQXFCO0FBQzNDLE1BQUksT0FBTyxJQUFQLEtBQWdCLFFBQXBCLEVBQThCO0FBQzVCLFVBQU0sT0FBTyxNQUFiO0FBQ0EsV0FBTyxJQUFJLE1BQUosQ0FBVyxJQUFYLEVBQWlCLEdBQWpCLENBQVA7QUFDRDs7QUFFRCxNQUFJLElBQUksS0FBSyxJQUFMLElBQWEsS0FBSyxNQUExQjtBQUNBLE1BQUksSUFBSSxLQUFLLEVBQUwsSUFBVyxDQUFuQjtBQUNBLE1BQUksSUFBSSxDQUFSO0FBQ0EsTUFBSSxTQUFTLEtBQUssTUFBbEI7O0FBRUEsU0FBTyxJQUFJLENBQVgsRUFBYztBQUNaLFFBQUksSUFBSSxLQUFLLEdBQUwsQ0FBUyxLQUFLLE1BQWQsRUFBc0IsSUFBSSxLQUFLLFVBQVQsR0FBdUIsSUFBSSxLQUFLLFVBQXRELENBQVI7QUFDQSxRQUFJLEtBQU0sSUFBSSxDQUFkOztBQUVBLFNBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxFQUFwQixFQUF3QixHQUF4QixFQUE2QjtBQUMzQixhQUFRLElBQUksS0FBSyxVQUFWLEdBQXdCLENBQS9CLElBQW9DLEtBQUssSUFBSSxDQUFULENBQXBDO0FBQ0Q7O0FBRUQsU0FBSyxFQUFMO0FBQ0EsU0FBSyxFQUFMOztBQUVBLFFBQUssSUFBSSxLQUFLLFVBQVYsS0FBMEIsQ0FBOUIsRUFBaUM7QUFDL0IsV0FBSyxPQUFMLENBQWEsTUFBYjtBQUNEO0FBQ0Y7QUFDRCxPQUFLLEVBQUwsR0FBVSxDQUFWOztBQUVBLFNBQU8sSUFBUDtBQUNELENBN0JEOztBQStCQSxLQUFLLFNBQUwsQ0FBZSxNQUFmLEdBQXdCLFVBQVUsR0FBVixFQUFlOztBQUVyQyxNQUFJLElBQUksS0FBSyxJQUFMLEdBQVksQ0FBcEI7OztBQUdBLE9BQUssTUFBTCxDQUFZLEtBQUssSUFBTCxHQUFZLEtBQUssVUFBN0IsSUFBMkMsSUFBM0M7OztBQUdBLE9BQUssTUFBTCxDQUFZLElBQVosQ0FBaUIsQ0FBakIsRUFBb0IsS0FBSyxJQUFMLEdBQVksS0FBSyxVQUFqQixHQUE4QixDQUFsRDs7QUFFQSxNQUFJLEtBQUssS0FBSyxVQUFMLEdBQWtCLENBQXZCLEtBQTZCLEtBQUssVUFBTCxHQUFrQixDQUFuRCxFQUFzRDtBQUNwRCxTQUFLLE9BQUwsQ0FBYSxLQUFLLE1BQWxCO0FBQ0EsU0FBSyxNQUFMLENBQVksSUFBWixDQUFpQixDQUFqQjtBQUNEOzs7O0FBSUQsT0FBSyxNQUFMLENBQVksWUFBWixDQUF5QixDQUF6QixFQUE0QixLQUFLLFVBQUwsR0FBa0IsQ0FBOUM7O0FBRUEsTUFBSSxPQUFPLEtBQUssT0FBTCxDQUFhLEtBQUssTUFBbEIsS0FBNkIsS0FBSyxLQUFMLEVBQXhDOztBQUVBLFNBQU8sTUFBTSxLQUFLLFFBQUwsQ0FBYyxHQUFkLENBQU4sR0FBMkIsSUFBbEM7QUFDRCxDQXRCRDs7QUF3QkEsS0FBSyxTQUFMLENBQWUsT0FBZixHQUF5QixZQUFZO0FBQ25DLFFBQU0sSUFBSSxLQUFKLENBQVUseUNBQVYsQ0FBTjtBQUNELENBRkQ7O0FBSUEsT0FBTyxPQUFQLEdBQWlCLElBQWpCOzs7Ozs7O0FDcEVBLElBQUksV0FBVSxPQUFPLE9BQVAsR0FBaUIsU0FBUyxHQUFULENBQWMsU0FBZCxFQUF5QjtBQUN0RCxjQUFZLFVBQVUsV0FBVixFQUFaOztBQUVBLE1BQUksWUFBWSxTQUFRLFNBQVIsQ0FBaEI7QUFDQSxNQUFJLENBQUMsU0FBTCxFQUFnQixNQUFNLElBQUksS0FBSixDQUFVLFlBQVksNkNBQXRCLENBQU47O0FBRWhCLFNBQU8sSUFBSSxTQUFKLEVBQVA7QUFDRCxDQVBEOztBQVNBLFNBQVEsR0FBUixHQUFjLFFBQVEsT0FBUixDQUFkO0FBQ0EsU0FBUSxJQUFSLEdBQWUsUUFBUSxRQUFSLENBQWY7QUFDQSxTQUFRLE1BQVIsR0FBaUIsUUFBUSxVQUFSLENBQWpCO0FBQ0EsU0FBUSxNQUFSLEdBQWlCLFFBQVEsVUFBUixDQUFqQjtBQUNBLFNBQVEsTUFBUixHQUFpQixRQUFRLFVBQVIsQ0FBakI7QUFDQSxTQUFRLE1BQVIsR0FBaUIsUUFBUSxVQUFSLENBQWpCOzs7Ozs7Ozs7Ozs7OztBQ05BLElBQUksV0FBVyxRQUFRLFVBQVIsQ0FBZjtBQUNBLElBQUksT0FBTyxRQUFRLFFBQVIsQ0FBWDs7QUFFQSxJQUFJLElBQUksQ0FDTixVQURNLEVBQ00sVUFETixFQUNrQixhQUFhLENBRC9CLEVBQ2tDLGFBQWEsQ0FEL0MsQ0FBUjs7QUFJQSxJQUFJLElBQUksSUFBSSxLQUFKLENBQVUsRUFBVixDQUFSOztBQUVBLFNBQVMsR0FBVCxHQUFnQjtBQUNkLE9BQUssSUFBTDtBQUNBLE9BQUssRUFBTCxHQUFVLENBQVY7O0FBRUEsT0FBSyxJQUFMLENBQVUsSUFBVixFQUFnQixFQUFoQixFQUFvQixFQUFwQjtBQUNEOztBQUVELFNBQVMsR0FBVCxFQUFjLElBQWQ7O0FBRUEsSUFBSSxTQUFKLENBQWMsSUFBZCxHQUFxQixZQUFZO0FBQy9CLE9BQUssRUFBTCxHQUFVLFVBQVY7QUFDQSxPQUFLLEVBQUwsR0FBVSxVQUFWO0FBQ0EsT0FBSyxFQUFMLEdBQVUsVUFBVjtBQUNBLE9BQUssRUFBTCxHQUFVLFVBQVY7QUFDQSxPQUFLLEVBQUwsR0FBVSxVQUFWOztBQUVBLFNBQU8sSUFBUDtBQUNELENBUkQ7O0FBVUEsU0FBUyxLQUFULENBQWdCLEdBQWhCLEVBQXFCO0FBQ25CLFNBQVEsT0FBTyxDQUFSLEdBQWMsUUFBUSxFQUE3QjtBQUNEOztBQUVELFNBQVMsTUFBVCxDQUFpQixHQUFqQixFQUFzQjtBQUNwQixTQUFRLE9BQU8sRUFBUixHQUFlLFFBQVEsQ0FBOUI7QUFDRDs7QUFFRCxTQUFTLEVBQVQsQ0FBYSxDQUFiLEVBQWdCLENBQWhCLEVBQW1CLENBQW5CLEVBQXNCLENBQXRCLEVBQXlCO0FBQ3ZCLE1BQUksTUFBTSxDQUFWLEVBQWEsT0FBUSxJQUFJLENBQUwsR0FBWSxDQUFDLENBQUYsR0FBTyxDQUF6QjtBQUNiLE1BQUksTUFBTSxDQUFWLEVBQWEsT0FBUSxJQUFJLENBQUwsR0FBVyxJQUFJLENBQWYsR0FBcUIsSUFBSSxDQUFoQztBQUNiLFNBQU8sSUFBSSxDQUFKLEdBQVEsQ0FBZjtBQUNEOztBQUVELElBQUksU0FBSixDQUFjLE9BQWQsR0FBd0IsVUFBVSxDQUFWLEVBQWE7QUFDbkMsTUFBSSxJQUFJLEtBQUssRUFBYjs7QUFFQSxNQUFJLElBQUksS0FBSyxFQUFMLEdBQVUsQ0FBbEI7QUFDQSxNQUFJLElBQUksS0FBSyxFQUFMLEdBQVUsQ0FBbEI7QUFDQSxNQUFJLElBQUksS0FBSyxFQUFMLEdBQVUsQ0FBbEI7QUFDQSxNQUFJLElBQUksS0FBSyxFQUFMLEdBQVUsQ0FBbEI7QUFDQSxNQUFJLElBQUksS0FBSyxFQUFMLEdBQVUsQ0FBbEI7O0FBRUEsT0FBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLEVBQXBCLEVBQXdCLEVBQUUsQ0FBMUI7QUFBNkIsTUFBRSxDQUFGLElBQU8sRUFBRSxXQUFGLENBQWMsSUFBSSxDQUFsQixDQUFQO0FBQTdCLEdBQ0EsT0FBTyxJQUFJLEVBQVgsRUFBZSxFQUFFLENBQWpCO0FBQW9CLE1BQUUsQ0FBRixJQUFPLEVBQUUsSUFBSSxDQUFOLElBQVcsRUFBRSxJQUFJLENBQU4sQ0FBWCxHQUFzQixFQUFFLElBQUksRUFBTixDQUF0QixHQUFrQyxFQUFFLElBQUksRUFBTixDQUF6QztBQUFwQixHQUVBLEtBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxFQUFwQixFQUF3QixFQUFFLENBQTFCLEVBQTZCO0FBQzNCLFFBQUksSUFBSSxDQUFDLEVBQUUsSUFBSSxFQUFOLENBQVQ7QUFDQSxRQUFJLElBQUssTUFBTSxDQUFOLElBQVcsR0FBRyxDQUFILEVBQU0sQ0FBTixFQUFTLENBQVQsRUFBWSxDQUFaLENBQVgsR0FBNEIsQ0FBNUIsR0FBZ0MsRUFBRSxDQUFGLENBQWhDLEdBQXVDLEVBQUUsQ0FBRixDQUF4QyxHQUFnRCxDQUF4RDs7QUFFQSxRQUFJLENBQUo7QUFDQSxRQUFJLENBQUo7QUFDQSxRQUFJLE9BQU8sQ0FBUCxDQUFKO0FBQ0EsUUFBSSxDQUFKO0FBQ0EsUUFBSSxDQUFKO0FBQ0Q7O0FBRUQsT0FBSyxFQUFMLEdBQVcsSUFBSSxLQUFLLEVBQVYsR0FBZ0IsQ0FBMUI7QUFDQSxPQUFLLEVBQUwsR0FBVyxJQUFJLEtBQUssRUFBVixHQUFnQixDQUExQjtBQUNBLE9BQUssRUFBTCxHQUFXLElBQUksS0FBSyxFQUFWLEdBQWdCLENBQTFCO0FBQ0EsT0FBSyxFQUFMLEdBQVcsSUFBSSxLQUFLLEVBQVYsR0FBZ0IsQ0FBMUI7QUFDQSxPQUFLLEVBQUwsR0FBVyxJQUFJLEtBQUssRUFBVixHQUFnQixDQUExQjtBQUNELENBNUJEOztBQThCQSxJQUFJLFNBQUosQ0FBYyxLQUFkLEdBQXNCLFlBQVk7QUFDaEMsTUFBSSxJQUFJLElBQUksTUFBSixDQUFXLEVBQVgsQ0FBUjs7QUFFQSxJQUFFLFlBQUYsQ0FBZSxLQUFLLEVBQUwsR0FBVSxDQUF6QixFQUE0QixDQUE1QjtBQUNBLElBQUUsWUFBRixDQUFlLEtBQUssRUFBTCxHQUFVLENBQXpCLEVBQTRCLENBQTVCO0FBQ0EsSUFBRSxZQUFGLENBQWUsS0FBSyxFQUFMLEdBQVUsQ0FBekIsRUFBNEIsQ0FBNUI7QUFDQSxJQUFFLFlBQUYsQ0FBZSxLQUFLLEVBQUwsR0FBVSxDQUF6QixFQUE0QixFQUE1QjtBQUNBLElBQUUsWUFBRixDQUFlLEtBQUssRUFBTCxHQUFVLENBQXpCLEVBQTRCLEVBQTVCOztBQUVBLFNBQU8sQ0FBUDtBQUNELENBVkQ7O0FBWUEsT0FBTyxPQUFQLEdBQWlCLEdBQWpCOzs7Ozs7Ozs7Ozs7Ozs7OztBQ25GQSxJQUFJLFdBQVcsUUFBUSxVQUFSLENBQWY7QUFDQSxJQUFJLE9BQU8sUUFBUSxRQUFSLENBQVg7O0FBRUEsSUFBSSxJQUFJLENBQ04sVUFETSxFQUNNLFVBRE4sRUFDa0IsYUFBYSxDQUQvQixFQUNrQyxhQUFhLENBRC9DLENBQVI7O0FBSUEsSUFBSSxJQUFJLElBQUksS0FBSixDQUFVLEVBQVYsQ0FBUjs7QUFFQSxTQUFTLElBQVQsR0FBaUI7QUFDZixPQUFLLElBQUw7QUFDQSxPQUFLLEVBQUwsR0FBVSxDQUFWOztBQUVBLE9BQUssSUFBTCxDQUFVLElBQVYsRUFBZ0IsRUFBaEIsRUFBb0IsRUFBcEI7QUFDRDs7QUFFRCxTQUFTLElBQVQsRUFBZSxJQUFmOztBQUVBLEtBQUssU0FBTCxDQUFlLElBQWYsR0FBc0IsWUFBWTtBQUNoQyxPQUFLLEVBQUwsR0FBVSxVQUFWO0FBQ0EsT0FBSyxFQUFMLEdBQVUsVUFBVjtBQUNBLE9BQUssRUFBTCxHQUFVLFVBQVY7QUFDQSxPQUFLLEVBQUwsR0FBVSxVQUFWO0FBQ0EsT0FBSyxFQUFMLEdBQVUsVUFBVjs7QUFFQSxTQUFPLElBQVA7QUFDRCxDQVJEOztBQVVBLFNBQVMsS0FBVCxDQUFnQixHQUFoQixFQUFxQjtBQUNuQixTQUFRLE9BQU8sQ0FBUixHQUFjLFFBQVEsRUFBN0I7QUFDRDs7QUFFRCxTQUFTLEtBQVQsQ0FBZ0IsR0FBaEIsRUFBcUI7QUFDbkIsU0FBUSxPQUFPLENBQVIsR0FBYyxRQUFRLEVBQTdCO0FBQ0Q7O0FBRUQsU0FBUyxNQUFULENBQWlCLEdBQWpCLEVBQXNCO0FBQ3BCLFNBQVEsT0FBTyxFQUFSLEdBQWUsUUFBUSxDQUE5QjtBQUNEOztBQUVELFNBQVMsRUFBVCxDQUFhLENBQWIsRUFBZ0IsQ0FBaEIsRUFBbUIsQ0FBbkIsRUFBc0IsQ0FBdEIsRUFBeUI7QUFDdkIsTUFBSSxNQUFNLENBQVYsRUFBYSxPQUFRLElBQUksQ0FBTCxHQUFZLENBQUMsQ0FBRixHQUFPLENBQXpCO0FBQ2IsTUFBSSxNQUFNLENBQVYsRUFBYSxPQUFRLElBQUksQ0FBTCxHQUFXLElBQUksQ0FBZixHQUFxQixJQUFJLENBQWhDO0FBQ2IsU0FBTyxJQUFJLENBQUosR0FBUSxDQUFmO0FBQ0Q7O0FBRUQsS0FBSyxTQUFMLENBQWUsT0FBZixHQUF5QixVQUFVLENBQVYsRUFBYTtBQUNwQyxNQUFJLElBQUksS0FBSyxFQUFiOztBQUVBLE1BQUksSUFBSSxLQUFLLEVBQUwsR0FBVSxDQUFsQjtBQUNBLE1BQUksSUFBSSxLQUFLLEVBQUwsR0FBVSxDQUFsQjtBQUNBLE1BQUksSUFBSSxLQUFLLEVBQUwsR0FBVSxDQUFsQjtBQUNBLE1BQUksSUFBSSxLQUFLLEVBQUwsR0FBVSxDQUFsQjtBQUNBLE1BQUksSUFBSSxLQUFLLEVBQUwsR0FBVSxDQUFsQjs7QUFFQSxPQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksRUFBcEIsRUFBd0IsRUFBRSxDQUExQjtBQUE2QixNQUFFLENBQUYsSUFBTyxFQUFFLFdBQUYsQ0FBYyxJQUFJLENBQWxCLENBQVA7QUFBN0IsR0FDQSxPQUFPLElBQUksRUFBWCxFQUFlLEVBQUUsQ0FBakI7QUFBb0IsTUFBRSxDQUFGLElBQU8sTUFBTSxFQUFFLElBQUksQ0FBTixJQUFXLEVBQUUsSUFBSSxDQUFOLENBQVgsR0FBc0IsRUFBRSxJQUFJLEVBQU4sQ0FBdEIsR0FBa0MsRUFBRSxJQUFJLEVBQU4sQ0FBeEMsQ0FBUDtBQUFwQixHQUVBLEtBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxFQUFwQixFQUF3QixFQUFFLENBQTFCLEVBQTZCO0FBQzNCLFFBQUksSUFBSSxDQUFDLEVBQUUsSUFBSSxFQUFOLENBQVQ7QUFDQSxRQUFJLElBQUssTUFBTSxDQUFOLElBQVcsR0FBRyxDQUFILEVBQU0sQ0FBTixFQUFTLENBQVQsRUFBWSxDQUFaLENBQVgsR0FBNEIsQ0FBNUIsR0FBZ0MsRUFBRSxDQUFGLENBQWhDLEdBQXVDLEVBQUUsQ0FBRixDQUF4QyxHQUFnRCxDQUF4RDs7QUFFQSxRQUFJLENBQUo7QUFDQSxRQUFJLENBQUo7QUFDQSxRQUFJLE9BQU8sQ0FBUCxDQUFKO0FBQ0EsUUFBSSxDQUFKO0FBQ0EsUUFBSSxDQUFKO0FBQ0Q7O0FBRUQsT0FBSyxFQUFMLEdBQVcsSUFBSSxLQUFLLEVBQVYsR0FBZ0IsQ0FBMUI7QUFDQSxPQUFLLEVBQUwsR0FBVyxJQUFJLEtBQUssRUFBVixHQUFnQixDQUExQjtBQUNBLE9BQUssRUFBTCxHQUFXLElBQUksS0FBSyxFQUFWLEdBQWdCLENBQTFCO0FBQ0EsT0FBSyxFQUFMLEdBQVcsSUFBSSxLQUFLLEVBQVYsR0FBZ0IsQ0FBMUI7QUFDQSxPQUFLLEVBQUwsR0FBVyxJQUFJLEtBQUssRUFBVixHQUFnQixDQUExQjtBQUNELENBNUJEOztBQThCQSxLQUFLLFNBQUwsQ0FBZSxLQUFmLEdBQXVCLFlBQVk7QUFDakMsTUFBSSxJQUFJLElBQUksTUFBSixDQUFXLEVBQVgsQ0FBUjs7QUFFQSxJQUFFLFlBQUYsQ0FBZSxLQUFLLEVBQUwsR0FBVSxDQUF6QixFQUE0QixDQUE1QjtBQUNBLElBQUUsWUFBRixDQUFlLEtBQUssRUFBTCxHQUFVLENBQXpCLEVBQTRCLENBQTVCO0FBQ0EsSUFBRSxZQUFGLENBQWUsS0FBSyxFQUFMLEdBQVUsQ0FBekIsRUFBNEIsQ0FBNUI7QUFDQSxJQUFFLFlBQUYsQ0FBZSxLQUFLLEVBQUwsR0FBVSxDQUF6QixFQUE0QixFQUE1QjtBQUNBLElBQUUsWUFBRixDQUFlLEtBQUssRUFBTCxHQUFVLENBQXpCLEVBQTRCLEVBQTVCOztBQUVBLFNBQU8sQ0FBUDtBQUNELENBVkQ7O0FBWUEsT0FBTyxPQUFQLEdBQWlCLElBQWpCOzs7Ozs7Ozs7Ozs7Ozs7O0FDekZBLElBQUksV0FBVyxRQUFRLFVBQVIsQ0FBZjtBQUNBLElBQUksU0FBUyxRQUFRLFVBQVIsQ0FBYjtBQUNBLElBQUksT0FBTyxRQUFRLFFBQVIsQ0FBWDs7QUFFQSxJQUFJLElBQUksSUFBSSxLQUFKLENBQVUsRUFBVixDQUFSOztBQUVBLFNBQVMsTUFBVCxHQUFtQjtBQUNqQixPQUFLLElBQUw7O0FBRUEsT0FBSyxFQUFMLEdBQVUsQ0FBVixDOztBQUVBLE9BQUssSUFBTCxDQUFVLElBQVYsRUFBZ0IsRUFBaEIsRUFBb0IsRUFBcEI7QUFDRDs7QUFFRCxTQUFTLE1BQVQsRUFBaUIsTUFBakI7O0FBRUEsT0FBTyxTQUFQLENBQWlCLElBQWpCLEdBQXdCLFlBQVk7QUFDbEMsT0FBSyxFQUFMLEdBQVUsVUFBVjtBQUNBLE9BQUssRUFBTCxHQUFVLFVBQVY7QUFDQSxPQUFLLEVBQUwsR0FBVSxVQUFWO0FBQ0EsT0FBSyxFQUFMLEdBQVUsVUFBVjtBQUNBLE9BQUssRUFBTCxHQUFVLFVBQVY7QUFDQSxPQUFLLEVBQUwsR0FBVSxVQUFWO0FBQ0EsT0FBSyxFQUFMLEdBQVUsVUFBVjtBQUNBLE9BQUssRUFBTCxHQUFVLFVBQVY7O0FBRUEsU0FBTyxJQUFQO0FBQ0QsQ0FYRDs7QUFhQSxPQUFPLFNBQVAsQ0FBaUIsS0FBakIsR0FBeUIsWUFBWTtBQUNuQyxNQUFJLElBQUksSUFBSSxNQUFKLENBQVcsRUFBWCxDQUFSOztBQUVBLElBQUUsWUFBRixDQUFlLEtBQUssRUFBcEIsRUFBd0IsQ0FBeEI7QUFDQSxJQUFFLFlBQUYsQ0FBZSxLQUFLLEVBQXBCLEVBQXdCLENBQXhCO0FBQ0EsSUFBRSxZQUFGLENBQWUsS0FBSyxFQUFwQixFQUF3QixDQUF4QjtBQUNBLElBQUUsWUFBRixDQUFlLEtBQUssRUFBcEIsRUFBd0IsRUFBeEI7QUFDQSxJQUFFLFlBQUYsQ0FBZSxLQUFLLEVBQXBCLEVBQXdCLEVBQXhCO0FBQ0EsSUFBRSxZQUFGLENBQWUsS0FBSyxFQUFwQixFQUF3QixFQUF4QjtBQUNBLElBQUUsWUFBRixDQUFlLEtBQUssRUFBcEIsRUFBd0IsRUFBeEI7O0FBRUEsU0FBTyxDQUFQO0FBQ0QsQ0FaRDs7QUFjQSxPQUFPLE9BQVAsR0FBaUIsTUFBakI7Ozs7Ozs7Ozs7Ozs7Ozs7QUMzQ0EsSUFBSSxXQUFXLFFBQVEsVUFBUixDQUFmO0FBQ0EsSUFBSSxPQUFPLFFBQVEsUUFBUixDQUFYOztBQUVBLElBQUksSUFBSSxDQUNOLFVBRE0sRUFDTSxVQUROLEVBQ2tCLFVBRGxCLEVBQzhCLFVBRDlCLEVBRU4sVUFGTSxFQUVNLFVBRk4sRUFFa0IsVUFGbEIsRUFFOEIsVUFGOUIsRUFHTixVQUhNLEVBR00sVUFITixFQUdrQixVQUhsQixFQUc4QixVQUg5QixFQUlOLFVBSk0sRUFJTSxVQUpOLEVBSWtCLFVBSmxCLEVBSThCLFVBSjlCLEVBS04sVUFMTSxFQUtNLFVBTE4sRUFLa0IsVUFMbEIsRUFLOEIsVUFMOUIsRUFNTixVQU5NLEVBTU0sVUFOTixFQU1rQixVQU5sQixFQU04QixVQU45QixFQU9OLFVBUE0sRUFPTSxVQVBOLEVBT2tCLFVBUGxCLEVBTzhCLFVBUDlCLEVBUU4sVUFSTSxFQVFNLFVBUk4sRUFRa0IsVUFSbEIsRUFROEIsVUFSOUIsRUFTTixVQVRNLEVBU00sVUFUTixFQVNrQixVQVRsQixFQVM4QixVQVQ5QixFQVVOLFVBVk0sRUFVTSxVQVZOLEVBVWtCLFVBVmxCLEVBVThCLFVBVjlCLEVBV04sVUFYTSxFQVdNLFVBWE4sRUFXa0IsVUFYbEIsRUFXOEIsVUFYOUIsRUFZTixVQVpNLEVBWU0sVUFaTixFQVlrQixVQVpsQixFQVk4QixVQVo5QixFQWFOLFVBYk0sRUFhTSxVQWJOLEVBYWtCLFVBYmxCLEVBYThCLFVBYjlCLEVBY04sVUFkTSxFQWNNLFVBZE4sRUFja0IsVUFkbEIsRUFjOEIsVUFkOUIsRUFlTixVQWZNLEVBZU0sVUFmTixFQWVrQixVQWZsQixFQWU4QixVQWY5QixFQWdCTixVQWhCTSxFQWdCTSxVQWhCTixFQWdCa0IsVUFoQmxCLEVBZ0I4QixVQWhCOUIsQ0FBUjs7QUFtQkEsSUFBSSxJQUFJLElBQUksS0FBSixDQUFVLEVBQVYsQ0FBUjs7QUFFQSxTQUFTLE1BQVQsR0FBbUI7QUFDakIsT0FBSyxJQUFMOztBQUVBLE9BQUssRUFBTCxHQUFVLENBQVYsQzs7QUFFQSxPQUFLLElBQUwsQ0FBVSxJQUFWLEVBQWdCLEVBQWhCLEVBQW9CLEVBQXBCO0FBQ0Q7O0FBRUQsU0FBUyxNQUFULEVBQWlCLElBQWpCOztBQUVBLE9BQU8sU0FBUCxDQUFpQixJQUFqQixHQUF3QixZQUFZO0FBQ2xDLE9BQUssRUFBTCxHQUFVLFVBQVY7QUFDQSxPQUFLLEVBQUwsR0FBVSxVQUFWO0FBQ0EsT0FBSyxFQUFMLEdBQVUsVUFBVjtBQUNBLE9BQUssRUFBTCxHQUFVLFVBQVY7QUFDQSxPQUFLLEVBQUwsR0FBVSxVQUFWO0FBQ0EsT0FBSyxFQUFMLEdBQVUsVUFBVjtBQUNBLE9BQUssRUFBTCxHQUFVLFVBQVY7QUFDQSxPQUFLLEVBQUwsR0FBVSxVQUFWOztBQUVBLFNBQU8sSUFBUDtBQUNELENBWEQ7O0FBYUEsU0FBUyxFQUFULENBQWEsQ0FBYixFQUFnQixDQUFoQixFQUFtQixDQUFuQixFQUFzQjtBQUNwQixTQUFPLElBQUssS0FBSyxJQUFJLENBQVQsQ0FBWjtBQUNEOztBQUVELFNBQVMsR0FBVCxDQUFjLENBQWQsRUFBaUIsQ0FBakIsRUFBb0IsQ0FBcEIsRUFBdUI7QUFDckIsU0FBUSxJQUFJLENBQUwsR0FBVyxLQUFLLElBQUksQ0FBVCxDQUFsQjtBQUNEOztBQUVELFNBQVMsTUFBVCxDQUFpQixDQUFqQixFQUFvQjtBQUNsQixTQUFPLENBQUMsTUFBTSxDQUFOLEdBQVUsS0FBSyxFQUFoQixLQUF1QixNQUFNLEVBQU4sR0FBVyxLQUFLLEVBQXZDLEtBQThDLE1BQU0sRUFBTixHQUFXLEtBQUssRUFBOUQsQ0FBUDtBQUNEOztBQUVELFNBQVMsTUFBVCxDQUFpQixDQUFqQixFQUFvQjtBQUNsQixTQUFPLENBQUMsTUFBTSxDQUFOLEdBQVUsS0FBSyxFQUFoQixLQUF1QixNQUFNLEVBQU4sR0FBVyxLQUFLLEVBQXZDLEtBQThDLE1BQU0sRUFBTixHQUFXLEtBQUssQ0FBOUQsQ0FBUDtBQUNEOztBQUVELFNBQVMsTUFBVCxDQUFpQixDQUFqQixFQUFvQjtBQUNsQixTQUFPLENBQUMsTUFBTSxDQUFOLEdBQVUsS0FBSyxFQUFoQixLQUF1QixNQUFNLEVBQU4sR0FBVyxLQUFLLEVBQXZDLElBQThDLE1BQU0sQ0FBM0Q7QUFDRDs7QUFFRCxTQUFTLE1BQVQsQ0FBaUIsQ0FBakIsRUFBb0I7QUFDbEIsU0FBTyxDQUFDLE1BQU0sRUFBTixHQUFXLEtBQUssRUFBakIsS0FBd0IsTUFBTSxFQUFOLEdBQVcsS0FBSyxFQUF4QyxJQUErQyxNQUFNLEVBQTVEO0FBQ0Q7O0FBRUQsT0FBTyxTQUFQLENBQWlCLE9BQWpCLEdBQTJCLFVBQVUsQ0FBVixFQUFhO0FBQ3RDLE1BQUksSUFBSSxLQUFLLEVBQWI7O0FBRUEsTUFBSSxJQUFJLEtBQUssRUFBTCxHQUFVLENBQWxCO0FBQ0EsTUFBSSxJQUFJLEtBQUssRUFBTCxHQUFVLENBQWxCO0FBQ0EsTUFBSSxJQUFJLEtBQUssRUFBTCxHQUFVLENBQWxCO0FBQ0EsTUFBSSxJQUFJLEtBQUssRUFBTCxHQUFVLENBQWxCO0FBQ0EsTUFBSSxJQUFJLEtBQUssRUFBTCxHQUFVLENBQWxCO0FBQ0EsTUFBSSxJQUFJLEtBQUssRUFBTCxHQUFVLENBQWxCO0FBQ0EsTUFBSSxJQUFJLEtBQUssRUFBTCxHQUFVLENBQWxCO0FBQ0EsTUFBSSxJQUFJLEtBQUssRUFBTCxHQUFVLENBQWxCOztBQUVBLE9BQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxFQUFwQixFQUF3QixFQUFFLENBQTFCO0FBQTZCLE1BQUUsQ0FBRixJQUFPLEVBQUUsV0FBRixDQUFjLElBQUksQ0FBbEIsQ0FBUDtBQUE3QixHQUNBLE9BQU8sSUFBSSxFQUFYLEVBQWUsRUFBRSxDQUFqQjtBQUFvQixNQUFFLENBQUYsSUFBUSxPQUFPLEVBQUUsSUFBSSxDQUFOLENBQVAsSUFBbUIsRUFBRSxJQUFJLENBQU4sQ0FBbkIsR0FBOEIsT0FBTyxFQUFFLElBQUksRUFBTixDQUFQLENBQTlCLEdBQWtELEVBQUUsSUFBSSxFQUFOLENBQW5ELEdBQWdFLENBQXZFO0FBQXBCLEdBRUEsS0FBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLEVBQXBCLEVBQXdCLEVBQUUsQ0FBMUIsRUFBNkI7QUFDM0IsUUFBSSxLQUFNLElBQUksT0FBTyxDQUFQLENBQUosR0FBZ0IsR0FBRyxDQUFILEVBQU0sQ0FBTixFQUFTLENBQVQsQ0FBaEIsR0FBOEIsRUFBRSxDQUFGLENBQTlCLEdBQXFDLEVBQUUsQ0FBRixDQUF0QyxHQUE4QyxDQUF2RDtBQUNBLFFBQUksS0FBTSxPQUFPLENBQVAsSUFBWSxJQUFJLENBQUosRUFBTyxDQUFQLEVBQVUsQ0FBVixDQUFiLEdBQTZCLENBQXRDOztBQUVBLFFBQUksQ0FBSjtBQUNBLFFBQUksQ0FBSjtBQUNBLFFBQUksQ0FBSjtBQUNBLFFBQUssSUFBSSxFQUFMLEdBQVcsQ0FBZjtBQUNBLFFBQUksQ0FBSjtBQUNBLFFBQUksQ0FBSjtBQUNBLFFBQUksQ0FBSjtBQUNBLFFBQUssS0FBSyxFQUFOLEdBQVksQ0FBaEI7QUFDRDs7QUFFRCxPQUFLLEVBQUwsR0FBVyxJQUFJLEtBQUssRUFBVixHQUFnQixDQUExQjtBQUNBLE9BQUssRUFBTCxHQUFXLElBQUksS0FBSyxFQUFWLEdBQWdCLENBQTFCO0FBQ0EsT0FBSyxFQUFMLEdBQVcsSUFBSSxLQUFLLEVBQVYsR0FBZ0IsQ0FBMUI7QUFDQSxPQUFLLEVBQUwsR0FBVyxJQUFJLEtBQUssRUFBVixHQUFnQixDQUExQjtBQUNBLE9BQUssRUFBTCxHQUFXLElBQUksS0FBSyxFQUFWLEdBQWdCLENBQTFCO0FBQ0EsT0FBSyxFQUFMLEdBQVcsSUFBSSxLQUFLLEVBQVYsR0FBZ0IsQ0FBMUI7QUFDQSxPQUFLLEVBQUwsR0FBVyxJQUFJLEtBQUssRUFBVixHQUFnQixDQUExQjtBQUNBLE9BQUssRUFBTCxHQUFXLElBQUksS0FBSyxFQUFWLEdBQWdCLENBQTFCO0FBQ0QsQ0FyQ0Q7O0FBdUNBLE9BQU8sU0FBUCxDQUFpQixLQUFqQixHQUF5QixZQUFZO0FBQ25DLE1BQUksSUFBSSxJQUFJLE1BQUosQ0FBVyxFQUFYLENBQVI7O0FBRUEsSUFBRSxZQUFGLENBQWUsS0FBSyxFQUFwQixFQUF3QixDQUF4QjtBQUNBLElBQUUsWUFBRixDQUFlLEtBQUssRUFBcEIsRUFBd0IsQ0FBeEI7QUFDQSxJQUFFLFlBQUYsQ0FBZSxLQUFLLEVBQXBCLEVBQXdCLENBQXhCO0FBQ0EsSUFBRSxZQUFGLENBQWUsS0FBSyxFQUFwQixFQUF3QixFQUF4QjtBQUNBLElBQUUsWUFBRixDQUFlLEtBQUssRUFBcEIsRUFBd0IsRUFBeEI7QUFDQSxJQUFFLFlBQUYsQ0FBZSxLQUFLLEVBQXBCLEVBQXdCLEVBQXhCO0FBQ0EsSUFBRSxZQUFGLENBQWUsS0FBSyxFQUFwQixFQUF3QixFQUF4QjtBQUNBLElBQUUsWUFBRixDQUFlLEtBQUssRUFBcEIsRUFBd0IsRUFBeEI7O0FBRUEsU0FBTyxDQUFQO0FBQ0QsQ0FiRDs7QUFlQSxPQUFPLE9BQVAsR0FBaUIsTUFBakI7Ozs7Ozs7O0FDcklBLElBQUksV0FBVyxRQUFRLFVBQVIsQ0FBZjtBQUNBLElBQUksU0FBUyxRQUFRLFVBQVIsQ0FBYjtBQUNBLElBQUksT0FBTyxRQUFRLFFBQVIsQ0FBWDs7QUFFQSxJQUFJLElBQUksSUFBSSxLQUFKLENBQVUsR0FBVixDQUFSOztBQUVBLFNBQVMsTUFBVCxHQUFtQjtBQUNqQixPQUFLLElBQUw7QUFDQSxPQUFLLEVBQUwsR0FBVSxDQUFWOztBQUVBLE9BQUssSUFBTCxDQUFVLElBQVYsRUFBZ0IsR0FBaEIsRUFBcUIsR0FBckI7QUFDRDs7QUFFRCxTQUFTLE1BQVQsRUFBaUIsTUFBakI7O0FBRUEsT0FBTyxTQUFQLENBQWlCLElBQWpCLEdBQXdCLFlBQVk7QUFDbEMsT0FBSyxHQUFMLEdBQVcsVUFBWDtBQUNBLE9BQUssR0FBTCxHQUFXLFVBQVg7QUFDQSxPQUFLLEdBQUwsR0FBVyxVQUFYO0FBQ0EsT0FBSyxHQUFMLEdBQVcsVUFBWDtBQUNBLE9BQUssR0FBTCxHQUFXLFVBQVg7QUFDQSxPQUFLLEdBQUwsR0FBVyxVQUFYO0FBQ0EsT0FBSyxHQUFMLEdBQVcsVUFBWDtBQUNBLE9BQUssR0FBTCxHQUFXLFVBQVg7O0FBRUEsT0FBSyxHQUFMLEdBQVcsVUFBWDtBQUNBLE9BQUssR0FBTCxHQUFXLFVBQVg7QUFDQSxPQUFLLEdBQUwsR0FBVyxVQUFYO0FBQ0EsT0FBSyxHQUFMLEdBQVcsVUFBWDtBQUNBLE9BQUssR0FBTCxHQUFXLFVBQVg7QUFDQSxPQUFLLEdBQUwsR0FBVyxVQUFYO0FBQ0EsT0FBSyxHQUFMLEdBQVcsVUFBWDtBQUNBLE9BQUssR0FBTCxHQUFXLFVBQVg7O0FBRUEsU0FBTyxJQUFQO0FBQ0QsQ0FwQkQ7O0FBc0JBLE9BQU8sU0FBUCxDQUFpQixLQUFqQixHQUF5QixZQUFZO0FBQ25DLE1BQUksSUFBSSxJQUFJLE1BQUosQ0FBVyxFQUFYLENBQVI7O0FBRUEsV0FBUyxZQUFULENBQXVCLENBQXZCLEVBQTBCLENBQTFCLEVBQTZCLE1BQTdCLEVBQXFDO0FBQ25DLE1BQUUsWUFBRixDQUFlLENBQWYsRUFBa0IsTUFBbEI7QUFDQSxNQUFFLFlBQUYsQ0FBZSxDQUFmLEVBQWtCLFNBQVMsQ0FBM0I7QUFDRDs7QUFFRCxlQUFhLEtBQUssR0FBbEIsRUFBdUIsS0FBSyxHQUE1QixFQUFpQyxDQUFqQztBQUNBLGVBQWEsS0FBSyxHQUFsQixFQUF1QixLQUFLLEdBQTVCLEVBQWlDLENBQWpDO0FBQ0EsZUFBYSxLQUFLLEdBQWxCLEVBQXVCLEtBQUssR0FBNUIsRUFBaUMsRUFBakM7QUFDQSxlQUFhLEtBQUssR0FBbEIsRUFBdUIsS0FBSyxHQUE1QixFQUFpQyxFQUFqQztBQUNBLGVBQWEsS0FBSyxHQUFsQixFQUF1QixLQUFLLEdBQTVCLEVBQWlDLEVBQWpDO0FBQ0EsZUFBYSxLQUFLLEdBQWxCLEVBQXVCLEtBQUssR0FBNUIsRUFBaUMsRUFBakM7O0FBRUEsU0FBTyxDQUFQO0FBQ0QsQ0FoQkQ7O0FBa0JBLE9BQU8sT0FBUCxHQUFpQixNQUFqQjs7Ozs7Ozs7QUN2REEsSUFBSSxXQUFXLFFBQVEsVUFBUixDQUFmO0FBQ0EsSUFBSSxPQUFPLFFBQVEsUUFBUixDQUFYOztBQUVBLElBQUksSUFBSSxDQUNOLFVBRE0sRUFDTSxVQUROLEVBQ2tCLFVBRGxCLEVBQzhCLFVBRDlCLEVBRU4sVUFGTSxFQUVNLFVBRk4sRUFFa0IsVUFGbEIsRUFFOEIsVUFGOUIsRUFHTixVQUhNLEVBR00sVUFITixFQUdrQixVQUhsQixFQUc4QixVQUg5QixFQUlOLFVBSk0sRUFJTSxVQUpOLEVBSWtCLFVBSmxCLEVBSThCLFVBSjlCLEVBS04sVUFMTSxFQUtNLFVBTE4sRUFLa0IsVUFMbEIsRUFLOEIsVUFMOUIsRUFNTixVQU5NLEVBTU0sVUFOTixFQU1rQixVQU5sQixFQU04QixVQU45QixFQU9OLFVBUE0sRUFPTSxVQVBOLEVBT2tCLFVBUGxCLEVBTzhCLFVBUDlCLEVBUU4sVUFSTSxFQVFNLFVBUk4sRUFRa0IsVUFSbEIsRUFROEIsVUFSOUIsRUFTTixVQVRNLEVBU00sVUFUTixFQVNrQixVQVRsQixFQVM4QixVQVQ5QixFQVVOLFVBVk0sRUFVTSxVQVZOLEVBVWtCLFVBVmxCLEVBVThCLFVBVjlCLEVBV04sVUFYTSxFQVdNLFVBWE4sRUFXa0IsVUFYbEIsRUFXOEIsVUFYOUIsRUFZTixVQVpNLEVBWU0sVUFaTixFQVlrQixVQVpsQixFQVk4QixVQVo5QixFQWFOLFVBYk0sRUFhTSxVQWJOLEVBYWtCLFVBYmxCLEVBYThCLFVBYjlCLEVBY04sVUFkTSxFQWNNLFVBZE4sRUFja0IsVUFkbEIsRUFjOEIsVUFkOUIsRUFlTixVQWZNLEVBZU0sVUFmTixFQWVrQixVQWZsQixFQWU4QixVQWY5QixFQWdCTixVQWhCTSxFQWdCTSxVQWhCTixFQWdCa0IsVUFoQmxCLEVBZ0I4QixVQWhCOUIsRUFpQk4sVUFqQk0sRUFpQk0sVUFqQk4sRUFpQmtCLFVBakJsQixFQWlCOEIsVUFqQjlCLEVBa0JOLFVBbEJNLEVBa0JNLFVBbEJOLEVBa0JrQixVQWxCbEIsRUFrQjhCLFVBbEI5QixFQW1CTixVQW5CTSxFQW1CTSxVQW5CTixFQW1Ca0IsVUFuQmxCLEVBbUI4QixVQW5COUIsRUFvQk4sVUFwQk0sRUFvQk0sVUFwQk4sRUFvQmtCLFVBcEJsQixFQW9COEIsVUFwQjlCLEVBcUJOLFVBckJNLEVBcUJNLFVBckJOLEVBcUJrQixVQXJCbEIsRUFxQjhCLFVBckI5QixFQXNCTixVQXRCTSxFQXNCTSxVQXRCTixFQXNCa0IsVUF0QmxCLEVBc0I4QixVQXRCOUIsRUF1Qk4sVUF2Qk0sRUF1Qk0sVUF2Qk4sRUF1QmtCLFVBdkJsQixFQXVCOEIsVUF2QjlCLEVBd0JOLFVBeEJNLEVBd0JNLFVBeEJOLEVBd0JrQixVQXhCbEIsRUF3QjhCLFVBeEI5QixFQXlCTixVQXpCTSxFQXlCTSxVQXpCTixFQXlCa0IsVUF6QmxCLEVBeUI4QixVQXpCOUIsRUEwQk4sVUExQk0sRUEwQk0sVUExQk4sRUEwQmtCLFVBMUJsQixFQTBCOEIsVUExQjlCLEVBMkJOLFVBM0JNLEVBMkJNLFVBM0JOLEVBMkJrQixVQTNCbEIsRUEyQjhCLFVBM0I5QixFQTRCTixVQTVCTSxFQTRCTSxVQTVCTixFQTRCa0IsVUE1QmxCLEVBNEI4QixVQTVCOUIsRUE2Qk4sVUE3Qk0sRUE2Qk0sVUE3Qk4sRUE2QmtCLFVBN0JsQixFQTZCOEIsVUE3QjlCLEVBOEJOLFVBOUJNLEVBOEJNLFVBOUJOLEVBOEJrQixVQTlCbEIsRUE4QjhCLFVBOUI5QixFQStCTixVQS9CTSxFQStCTSxVQS9CTixFQStCa0IsVUEvQmxCLEVBK0I4QixVQS9COUIsRUFnQ04sVUFoQ00sRUFnQ00sVUFoQ04sRUFnQ2tCLFVBaENsQixFQWdDOEIsVUFoQzlCLEVBaUNOLFVBakNNLEVBaUNNLFVBakNOLEVBaUNrQixVQWpDbEIsRUFpQzhCLFVBakM5QixFQWtDTixVQWxDTSxFQWtDTSxVQWxDTixFQWtDa0IsVUFsQ2xCLEVBa0M4QixVQWxDOUIsRUFtQ04sVUFuQ00sRUFtQ00sVUFuQ04sRUFtQ2tCLFVBbkNsQixFQW1DOEIsVUFuQzlCLEVBb0NOLFVBcENNLEVBb0NNLFVBcENOLEVBb0NrQixVQXBDbEIsRUFvQzhCLFVBcEM5QixFQXFDTixVQXJDTSxFQXFDTSxVQXJDTixFQXFDa0IsVUFyQ2xCLEVBcUM4QixVQXJDOUIsRUFzQ04sVUF0Q00sRUFzQ00sVUF0Q04sRUFzQ2tCLFVBdENsQixFQXNDOEIsVUF0QzlCLEVBdUNOLFVBdkNNLEVBdUNNLFVBdkNOLEVBdUNrQixVQXZDbEIsRUF1QzhCLFVBdkM5QixFQXdDTixVQXhDTSxFQXdDTSxVQXhDTixFQXdDa0IsVUF4Q2xCLEVBd0M4QixVQXhDOUIsQ0FBUjs7QUEyQ0EsSUFBSSxJQUFJLElBQUksS0FBSixDQUFVLEdBQVYsQ0FBUjs7QUFFQSxTQUFTLE1BQVQsR0FBbUI7QUFDakIsT0FBSyxJQUFMO0FBQ0EsT0FBSyxFQUFMLEdBQVUsQ0FBVjs7QUFFQSxPQUFLLElBQUwsQ0FBVSxJQUFWLEVBQWdCLEdBQWhCLEVBQXFCLEdBQXJCO0FBQ0Q7O0FBRUQsU0FBUyxNQUFULEVBQWlCLElBQWpCOztBQUVBLE9BQU8sU0FBUCxDQUFpQixJQUFqQixHQUF3QixZQUFZO0FBQ2xDLE9BQUssR0FBTCxHQUFXLFVBQVg7QUFDQSxPQUFLLEdBQUwsR0FBVyxVQUFYO0FBQ0EsT0FBSyxHQUFMLEdBQVcsVUFBWDtBQUNBLE9BQUssR0FBTCxHQUFXLFVBQVg7QUFDQSxPQUFLLEdBQUwsR0FBVyxVQUFYO0FBQ0EsT0FBSyxHQUFMLEdBQVcsVUFBWDtBQUNBLE9BQUssR0FBTCxHQUFXLFVBQVg7QUFDQSxPQUFLLEdBQUwsR0FBVyxVQUFYOztBQUVBLE9BQUssR0FBTCxHQUFXLFVBQVg7QUFDQSxPQUFLLEdBQUwsR0FBVyxVQUFYO0FBQ0EsT0FBSyxHQUFMLEdBQVcsVUFBWDtBQUNBLE9BQUssR0FBTCxHQUFXLFVBQVg7QUFDQSxPQUFLLEdBQUwsR0FBVyxVQUFYO0FBQ0EsT0FBSyxHQUFMLEdBQVcsVUFBWDtBQUNBLE9BQUssR0FBTCxHQUFXLFVBQVg7QUFDQSxPQUFLLEdBQUwsR0FBVyxVQUFYOztBQUVBLFNBQU8sSUFBUDtBQUNELENBcEJEOztBQXNCQSxTQUFTLEVBQVQsQ0FBYSxDQUFiLEVBQWdCLENBQWhCLEVBQW1CLENBQW5CLEVBQXNCO0FBQ3BCLFNBQU8sSUFBSyxLQUFLLElBQUksQ0FBVCxDQUFaO0FBQ0Q7O0FBRUQsU0FBUyxHQUFULENBQWMsQ0FBZCxFQUFpQixDQUFqQixFQUFvQixDQUFwQixFQUF1QjtBQUNyQixTQUFRLElBQUksQ0FBTCxHQUFXLEtBQUssSUFBSSxDQUFULENBQWxCO0FBQ0Q7O0FBRUQsU0FBUyxNQUFULENBQWlCLENBQWpCLEVBQW9CLEVBQXBCLEVBQXdCO0FBQ3RCLFNBQU8sQ0FBQyxNQUFNLEVBQU4sR0FBVyxNQUFNLENBQWxCLEtBQXdCLE9BQU8sQ0FBUCxHQUFXLEtBQUssRUFBeEMsS0FBK0MsT0FBTyxDQUFQLEdBQVcsS0FBSyxFQUEvRCxDQUFQO0FBQ0Q7O0FBRUQsU0FBUyxNQUFULENBQWlCLENBQWpCLEVBQW9CLEVBQXBCLEVBQXdCO0FBQ3RCLFNBQU8sQ0FBQyxNQUFNLEVBQU4sR0FBVyxNQUFNLEVBQWxCLEtBQXlCLE1BQU0sRUFBTixHQUFXLE1BQU0sRUFBMUMsS0FBaUQsT0FBTyxDQUFQLEdBQVcsS0FBSyxFQUFqRSxDQUFQO0FBQ0Q7O0FBRUQsU0FBUyxNQUFULENBQWlCLENBQWpCLEVBQW9CLEVBQXBCLEVBQXdCO0FBQ3RCLFNBQU8sQ0FBQyxNQUFNLENBQU4sR0FBVSxNQUFNLEVBQWpCLEtBQXdCLE1BQU0sQ0FBTixHQUFVLE1BQU0sRUFBeEMsSUFBK0MsTUFBTSxDQUE1RDtBQUNEOztBQUVELFNBQVMsT0FBVCxDQUFrQixDQUFsQixFQUFxQixFQUFyQixFQUF5QjtBQUN2QixTQUFPLENBQUMsTUFBTSxDQUFOLEdBQVUsTUFBTSxFQUFqQixLQUF3QixNQUFNLENBQU4sR0FBVSxNQUFNLEVBQXhDLEtBQStDLE1BQU0sQ0FBTixHQUFVLE1BQU0sRUFBL0QsQ0FBUDtBQUNEOztBQUVELFNBQVMsTUFBVCxDQUFpQixDQUFqQixFQUFvQixFQUFwQixFQUF3QjtBQUN0QixTQUFPLENBQUMsTUFBTSxFQUFOLEdBQVcsTUFBTSxFQUFsQixLQUF5QixPQUFPLEVBQVAsR0FBWSxLQUFLLENBQTFDLElBQWdELE1BQU0sQ0FBN0Q7QUFDRDs7QUFFRCxTQUFTLE9BQVQsQ0FBa0IsQ0FBbEIsRUFBcUIsRUFBckIsRUFBeUI7QUFDdkIsU0FBTyxDQUFDLE1BQU0sRUFBTixHQUFXLE1BQU0sRUFBbEIsS0FBeUIsT0FBTyxFQUFQLEdBQVksS0FBSyxDQUExQyxLQUFnRCxNQUFNLENBQU4sR0FBVSxNQUFNLEVBQWhFLENBQVA7QUFDRDs7QUFFRCxTQUFTLFFBQVQsQ0FBbUIsQ0FBbkIsRUFBc0IsQ0FBdEIsRUFBeUI7QUFDdkIsU0FBUSxNQUFNLENBQVAsR0FBYSxNQUFNLENBQW5CLEdBQXdCLENBQXhCLEdBQTRCLENBQW5DO0FBQ0Q7O0FBRUQsT0FBTyxTQUFQLENBQWlCLE9BQWpCLEdBQTJCLFVBQVUsQ0FBVixFQUFhO0FBQ3RDLE1BQUksSUFBSSxLQUFLLEVBQWI7O0FBRUEsTUFBSSxLQUFLLEtBQUssR0FBTCxHQUFXLENBQXBCO0FBQ0EsTUFBSSxLQUFLLEtBQUssR0FBTCxHQUFXLENBQXBCO0FBQ0EsTUFBSSxLQUFLLEtBQUssR0FBTCxHQUFXLENBQXBCO0FBQ0EsTUFBSSxLQUFLLEtBQUssR0FBTCxHQUFXLENBQXBCO0FBQ0EsTUFBSSxLQUFLLEtBQUssR0FBTCxHQUFXLENBQXBCO0FBQ0EsTUFBSSxLQUFLLEtBQUssR0FBTCxHQUFXLENBQXBCO0FBQ0EsTUFBSSxLQUFLLEtBQUssR0FBTCxHQUFXLENBQXBCO0FBQ0EsTUFBSSxLQUFLLEtBQUssR0FBTCxHQUFXLENBQXBCOztBQUVBLE1BQUksS0FBSyxLQUFLLEdBQUwsR0FBVyxDQUFwQjtBQUNBLE1BQUksS0FBSyxLQUFLLEdBQUwsR0FBVyxDQUFwQjtBQUNBLE1BQUksS0FBSyxLQUFLLEdBQUwsR0FBVyxDQUFwQjtBQUNBLE1BQUksS0FBSyxLQUFLLEdBQUwsR0FBVyxDQUFwQjtBQUNBLE1BQUksS0FBSyxLQUFLLEdBQUwsR0FBVyxDQUFwQjtBQUNBLE1BQUksS0FBSyxLQUFLLEdBQUwsR0FBVyxDQUFwQjtBQUNBLE1BQUksS0FBSyxLQUFLLEdBQUwsR0FBVyxDQUFwQjtBQUNBLE1BQUksS0FBSyxLQUFLLEdBQUwsR0FBVyxDQUFwQjs7QUFFQSxPQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksRUFBcEIsRUFBd0IsS0FBSyxDQUE3QixFQUFnQztBQUM5QixNQUFFLENBQUYsSUFBTyxFQUFFLFdBQUYsQ0FBYyxJQUFJLENBQWxCLENBQVA7QUFDQSxNQUFFLElBQUksQ0FBTixJQUFXLEVBQUUsV0FBRixDQUFjLElBQUksQ0FBSixHQUFRLENBQXRCLENBQVg7QUFDRDtBQUNELFNBQU8sSUFBSSxHQUFYLEVBQWdCLEtBQUssQ0FBckIsRUFBd0I7QUFDdEIsUUFBSSxLQUFLLEVBQUUsSUFBSSxLQUFLLENBQVgsQ0FBVDtBQUNBLFFBQUksS0FBSyxFQUFFLElBQUksS0FBSyxDQUFULEdBQWEsQ0FBZixDQUFUO0FBQ0EsUUFBSSxTQUFTLE9BQU8sRUFBUCxFQUFXLEVBQVgsQ0FBYjtBQUNBLFFBQUksVUFBVSxRQUFRLEVBQVIsRUFBWSxFQUFaLENBQWQ7O0FBRUEsU0FBSyxFQUFFLElBQUksSUFBSSxDQUFWLENBQUw7QUFDQSxTQUFLLEVBQUUsSUFBSSxJQUFJLENBQVIsR0FBWSxDQUFkLENBQUw7QUFDQSxRQUFJLFNBQVMsT0FBTyxFQUFQLEVBQVcsRUFBWCxDQUFiO0FBQ0EsUUFBSSxVQUFVLFFBQVEsRUFBUixFQUFZLEVBQVosQ0FBZDs7O0FBR0EsUUFBSSxPQUFPLEVBQUUsSUFBSSxJQUFJLENBQVYsQ0FBWDtBQUNBLFFBQUksT0FBTyxFQUFFLElBQUksSUFBSSxDQUFSLEdBQVksQ0FBZCxDQUFYOztBQUVBLFFBQUksUUFBUSxFQUFFLElBQUksS0FBSyxDQUFYLENBQVo7QUFDQSxRQUFJLFFBQVEsRUFBRSxJQUFJLEtBQUssQ0FBVCxHQUFhLENBQWYsQ0FBWjs7QUFFQSxRQUFJLE1BQU8sVUFBVSxJQUFYLEdBQW1CLENBQTdCO0FBQ0EsUUFBSSxNQUFPLFNBQVMsSUFBVCxHQUFnQixTQUFTLEdBQVQsRUFBYyxPQUFkLENBQWpCLEdBQTJDLENBQXJEO0FBQ0EsVUFBTyxNQUFNLE9BQVAsR0FBa0IsQ0FBeEI7QUFDQSxVQUFPLE1BQU0sTUFBTixHQUFlLFNBQVMsR0FBVCxFQUFjLE9BQWQsQ0FBaEIsR0FBMEMsQ0FBaEQ7QUFDQSxVQUFPLE1BQU0sS0FBUCxHQUFnQixDQUF0QjtBQUNBLFVBQU8sTUFBTSxLQUFOLEdBQWMsU0FBUyxHQUFULEVBQWMsS0FBZCxDQUFmLEdBQXVDLENBQTdDOztBQUVBLE1BQUUsQ0FBRixJQUFPLEdBQVA7QUFDQSxNQUFFLElBQUksQ0FBTixJQUFXLEdBQVg7QUFDRDs7QUFFRCxPQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksR0FBcEIsRUFBeUIsS0FBSyxDQUE5QixFQUFpQztBQUMvQixVQUFNLEVBQUUsQ0FBRixDQUFOO0FBQ0EsVUFBTSxFQUFFLElBQUksQ0FBTixDQUFOOztBQUVBLFFBQUksT0FBTyxJQUFJLEVBQUosRUFBUSxFQUFSLEVBQVksRUFBWixDQUFYO0FBQ0EsUUFBSSxPQUFPLElBQUksRUFBSixFQUFRLEVBQVIsRUFBWSxFQUFaLENBQVg7O0FBRUEsUUFBSSxVQUFVLE9BQU8sRUFBUCxFQUFXLEVBQVgsQ0FBZDtBQUNBLFFBQUksVUFBVSxPQUFPLEVBQVAsRUFBVyxFQUFYLENBQWQ7QUFDQSxRQUFJLFVBQVUsT0FBTyxFQUFQLEVBQVcsRUFBWCxDQUFkO0FBQ0EsUUFBSSxVQUFVLE9BQU8sRUFBUCxFQUFXLEVBQVgsQ0FBZDs7O0FBR0EsUUFBSSxNQUFNLEVBQUUsQ0FBRixDQUFWO0FBQ0EsUUFBSSxNQUFNLEVBQUUsSUFBSSxDQUFOLENBQVY7O0FBRUEsUUFBSSxNQUFNLEdBQUcsRUFBSCxFQUFPLEVBQVAsRUFBVyxFQUFYLENBQVY7QUFDQSxRQUFJLE1BQU0sR0FBRyxFQUFILEVBQU8sRUFBUCxFQUFXLEVBQVgsQ0FBVjs7QUFFQSxRQUFJLE1BQU8sS0FBSyxPQUFOLEdBQWlCLENBQTNCO0FBQ0EsUUFBSSxNQUFPLEtBQUssT0FBTCxHQUFlLFNBQVMsR0FBVCxFQUFjLEVBQWQsQ0FBaEIsR0FBcUMsQ0FBL0M7QUFDQSxVQUFPLE1BQU0sR0FBUCxHQUFjLENBQXBCO0FBQ0EsVUFBTyxNQUFNLEdBQU4sR0FBWSxTQUFTLEdBQVQsRUFBYyxHQUFkLENBQWIsR0FBbUMsQ0FBekM7QUFDQSxVQUFPLE1BQU0sR0FBUCxHQUFjLENBQXBCO0FBQ0EsVUFBTyxNQUFNLEdBQU4sR0FBWSxTQUFTLEdBQVQsRUFBYyxHQUFkLENBQWIsR0FBbUMsQ0FBekM7QUFDQSxVQUFPLE1BQU0sR0FBUCxHQUFjLENBQXBCO0FBQ0EsVUFBTyxNQUFNLEdBQU4sR0FBWSxTQUFTLEdBQVQsRUFBYyxHQUFkLENBQWIsR0FBbUMsQ0FBekM7OztBQUdBLFFBQUksTUFBTyxVQUFVLElBQVgsR0FBbUIsQ0FBN0I7QUFDQSxRQUFJLE1BQU8sVUFBVSxJQUFWLEdBQWlCLFNBQVMsR0FBVCxFQUFjLE9BQWQsQ0FBbEIsR0FBNEMsQ0FBdEQ7O0FBRUEsU0FBSyxFQUFMO0FBQ0EsU0FBSyxFQUFMO0FBQ0EsU0FBSyxFQUFMO0FBQ0EsU0FBSyxFQUFMO0FBQ0EsU0FBSyxFQUFMO0FBQ0EsU0FBSyxFQUFMO0FBQ0EsU0FBTSxLQUFLLEdBQU4sR0FBYSxDQUFsQjtBQUNBLFNBQU0sS0FBSyxHQUFMLEdBQVcsU0FBUyxFQUFULEVBQWEsRUFBYixDQUFaLEdBQWdDLENBQXJDO0FBQ0EsU0FBSyxFQUFMO0FBQ0EsU0FBSyxFQUFMO0FBQ0EsU0FBSyxFQUFMO0FBQ0EsU0FBSyxFQUFMO0FBQ0EsU0FBSyxFQUFMO0FBQ0EsU0FBSyxFQUFMO0FBQ0EsU0FBTSxNQUFNLEdBQVAsR0FBYyxDQUFuQjtBQUNBLFNBQU0sTUFBTSxHQUFOLEdBQVksU0FBUyxFQUFULEVBQWEsR0FBYixDQUFiLEdBQWtDLENBQXZDO0FBQ0Q7O0FBRUQsT0FBSyxHQUFMLEdBQVksS0FBSyxHQUFMLEdBQVcsRUFBWixHQUFrQixDQUE3QjtBQUNBLE9BQUssR0FBTCxHQUFZLEtBQUssR0FBTCxHQUFXLEVBQVosR0FBa0IsQ0FBN0I7QUFDQSxPQUFLLEdBQUwsR0FBWSxLQUFLLEdBQUwsR0FBVyxFQUFaLEdBQWtCLENBQTdCO0FBQ0EsT0FBSyxHQUFMLEdBQVksS0FBSyxHQUFMLEdBQVcsRUFBWixHQUFrQixDQUE3QjtBQUNBLE9BQUssR0FBTCxHQUFZLEtBQUssR0FBTCxHQUFXLEVBQVosR0FBa0IsQ0FBN0I7QUFDQSxPQUFLLEdBQUwsR0FBWSxLQUFLLEdBQUwsR0FBVyxFQUFaLEdBQWtCLENBQTdCO0FBQ0EsT0FBSyxHQUFMLEdBQVksS0FBSyxHQUFMLEdBQVcsRUFBWixHQUFrQixDQUE3QjtBQUNBLE9BQUssR0FBTCxHQUFZLEtBQUssR0FBTCxHQUFXLEVBQVosR0FBa0IsQ0FBN0I7O0FBRUEsT0FBSyxHQUFMLEdBQVksS0FBSyxHQUFMLEdBQVcsRUFBWCxHQUFnQixTQUFTLEtBQUssR0FBZCxFQUFtQixFQUFuQixDQUFqQixHQUEyQyxDQUF0RDtBQUNBLE9BQUssR0FBTCxHQUFZLEtBQUssR0FBTCxHQUFXLEVBQVgsR0FBZ0IsU0FBUyxLQUFLLEdBQWQsRUFBbUIsRUFBbkIsQ0FBakIsR0FBMkMsQ0FBdEQ7QUFDQSxPQUFLLEdBQUwsR0FBWSxLQUFLLEdBQUwsR0FBVyxFQUFYLEdBQWdCLFNBQVMsS0FBSyxHQUFkLEVBQW1CLEVBQW5CLENBQWpCLEdBQTJDLENBQXREO0FBQ0EsT0FBSyxHQUFMLEdBQVksS0FBSyxHQUFMLEdBQVcsRUFBWCxHQUFnQixTQUFTLEtBQUssR0FBZCxFQUFtQixFQUFuQixDQUFqQixHQUEyQyxDQUF0RDtBQUNBLE9BQUssR0FBTCxHQUFZLEtBQUssR0FBTCxHQUFXLEVBQVgsR0FBZ0IsU0FBUyxLQUFLLEdBQWQsRUFBbUIsRUFBbkIsQ0FBakIsR0FBMkMsQ0FBdEQ7QUFDQSxPQUFLLEdBQUwsR0FBWSxLQUFLLEdBQUwsR0FBVyxFQUFYLEdBQWdCLFNBQVMsS0FBSyxHQUFkLEVBQW1CLEVBQW5CLENBQWpCLEdBQTJDLENBQXREO0FBQ0EsT0FBSyxHQUFMLEdBQVksS0FBSyxHQUFMLEdBQVcsRUFBWCxHQUFnQixTQUFTLEtBQUssR0FBZCxFQUFtQixFQUFuQixDQUFqQixHQUEyQyxDQUF0RDtBQUNBLE9BQUssR0FBTCxHQUFZLEtBQUssR0FBTCxHQUFXLEVBQVgsR0FBZ0IsU0FBUyxLQUFLLEdBQWQsRUFBbUIsRUFBbkIsQ0FBakIsR0FBMkMsQ0FBdEQ7QUFDRCxDQXpIRDs7QUEySEEsT0FBTyxTQUFQLENBQWlCLEtBQWpCLEdBQXlCLFlBQVk7QUFDbkMsTUFBSSxJQUFJLElBQUksTUFBSixDQUFXLEVBQVgsQ0FBUjs7QUFFQSxXQUFTLFlBQVQsQ0FBdUIsQ0FBdkIsRUFBMEIsQ0FBMUIsRUFBNkIsTUFBN0IsRUFBcUM7QUFDbkMsTUFBRSxZQUFGLENBQWUsQ0FBZixFQUFrQixNQUFsQjtBQUNBLE1BQUUsWUFBRixDQUFlLENBQWYsRUFBa0IsU0FBUyxDQUEzQjtBQUNEOztBQUVELGVBQWEsS0FBSyxHQUFsQixFQUF1QixLQUFLLEdBQTVCLEVBQWlDLENBQWpDO0FBQ0EsZUFBYSxLQUFLLEdBQWxCLEVBQXVCLEtBQUssR0FBNUIsRUFBaUMsQ0FBakM7QUFDQSxlQUFhLEtBQUssR0FBbEIsRUFBdUIsS0FBSyxHQUE1QixFQUFpQyxFQUFqQztBQUNBLGVBQWEsS0FBSyxHQUFsQixFQUF1QixLQUFLLEdBQTVCLEVBQWlDLEVBQWpDO0FBQ0EsZUFBYSxLQUFLLEdBQWxCLEVBQXVCLEtBQUssR0FBNUIsRUFBaUMsRUFBakM7QUFDQSxlQUFhLEtBQUssR0FBbEIsRUFBdUIsS0FBSyxHQUE1QixFQUFpQyxFQUFqQztBQUNBLGVBQWEsS0FBSyxHQUFsQixFQUF1QixLQUFLLEdBQTVCLEVBQWlDLEVBQWpDO0FBQ0EsZUFBYSxLQUFLLEdBQWxCLEVBQXVCLEtBQUssR0FBNUIsRUFBaUMsRUFBakM7O0FBRUEsU0FBTyxDQUFQO0FBQ0QsQ0FsQkQ7O0FBb0JBLE9BQU8sT0FBUCxHQUFpQixNQUFqQjs7Ozs7QUNsUUE7O0FBRUEsT0FBTyxPQUFQLEdBQWlCLFVBQVUsR0FBVixFQUFlLE1BQWYsRUFBdUIsR0FBdkIsRUFBNEI7QUFDNUMsT0FBTSxPQUFPLEdBQVAsS0FBZSxRQUFmLEdBQTBCLEdBQTFCLEdBQWdDLENBQXRDOztBQUVBLEtBQUksT0FBTyxHQUFQLEtBQWUsUUFBbkIsRUFBNkI7QUFDNUIsUUFBTSxJQUFJLFNBQUosQ0FBYyxtQkFBZCxDQUFOO0FBQ0E7O0FBRUQsUUFBTyxJQUFJLE9BQUosQ0FBWSxNQUFaLEVBQW9CLEdBQXBCLE1BQTZCLENBQUMsQ0FBckM7QUFDQSxDQVJEOzs7QUNGQTs7QUFFQSxJQUFNLGdCQUFnQixtREFBdEI7O0FBRUEsTUFBTSxHQUFOLENBQVU7QUFDTixrQkFBYztBQUNWLGFBQUssTUFBTCxHQUFjLElBQUksR0FBSixFQUFkO0FBQ0g7OztBQUdELFFBQUksSUFBSixHQUFXO0FBQ1AsZUFBTyxLQUFLLEtBQUwsR0FBYSxLQUFLLE1BQXpCO0FBQ0g7QUFDRCxRQUFJLEtBQUosR0FBWTtBQUNSLGVBQU8sS0FBSyxVQUFaO0FBQ0g7QUFDRCxRQUFJLE1BQUosR0FBYTtBQUNULGVBQU8sS0FBSyxXQUFaO0FBQ0g7QUFDRCxRQUFJLFVBQUosR0FBaUI7QUFDYixlQUFPLEtBQUssZUFBWjtBQUNIO0FBQ0QsUUFBSSxJQUFKLEdBQVc7QUFDUCxZQUFJLE9BQU8sSUFBSSxJQUFKLEVBQVg7QUFDQSxZQUFJLFNBQVMsY0FBYyxJQUFkLENBQW1CLEtBQUssUUFBeEIsQ0FBYjtBQUNBLGFBQUssV0FBTCxDQUFpQixPQUFPLENBQVAsQ0FBakIsRUFBNEIsT0FBTyxDQUFQLElBQVksQ0FBeEMsRUFBMkMsT0FBTyxDQUFQLENBQTNDO0FBQ0EsYUFBSyxRQUFMLENBQWMsT0FBTyxDQUFQLENBQWQsRUFBeUIsT0FBTyxDQUFQLENBQXpCLEVBQW9DLE9BQU8sQ0FBUCxDQUFwQztBQUNBLGVBQU8sSUFBUDtBQUNIOzs7QUFHRCxRQUFJLGNBQUosR0FBcUI7QUFDakIsZUFBTyxLQUFLLE1BQUwsQ0FBWSxHQUFaLENBQWdCLEdBQWhCLENBQVA7QUFDSDtBQUNELFFBQUksVUFBSixHQUFpQjtBQUNiLGVBQU8sS0FBSyxNQUFMLENBQVksR0FBWixDQUFnQixHQUFoQixDQUFQO0FBQ0g7QUFDRCxRQUFJLFdBQUosR0FBa0I7QUFDZCxlQUFPLEtBQUssTUFBTCxDQUFZLEdBQVosQ0FBZ0IsR0FBaEIsQ0FBUDtBQUNIO0FBQ0QsUUFBSSxhQUFKLEdBQW9CO0FBQ2hCLGVBQU8sS0FBSyxNQUFMLENBQVksR0FBWixDQUFnQixHQUFoQixDQUFQO0FBQ0g7QUFDRCxRQUFJLFdBQUosR0FBa0I7QUFDZCxlQUFPLEtBQUssTUFBTCxDQUFZLEdBQVosQ0FBZ0IsR0FBaEIsS0FBd0IsQ0FBL0I7QUFDSDtBQUNELFFBQUksSUFBSixHQUFXO0FBQ1AsZUFBTyxLQUFLLE1BQUwsQ0FBWSxHQUFaLENBQWdCLEdBQWhCLENBQVA7QUFDSDtBQUNELFFBQUksU0FBSixHQUFnQjtBQUNaLGVBQU8sS0FBSyxNQUFMLENBQVksR0FBWixDQUFnQixHQUFoQixLQUF3QixDQUEvQjtBQUNIO0FBQ0QsUUFBSSxZQUFKLEdBQW1CO0FBQ2YsZUFBTyxLQUFLLE1BQUwsQ0FBWSxHQUFaLENBQWdCLEdBQWhCLENBQVA7QUFDSDtBQUNELFFBQUksZ0JBQUosR0FBdUI7QUFDbkIsZUFBTyxLQUFLLE1BQUwsQ0FBWSxHQUFaLENBQWdCLEdBQWhCLENBQVA7QUFDSDtBQUNELFFBQUksWUFBSixHQUFtQjtBQUNmLGVBQU8sWUFBWSxLQUFLLE1BQUwsQ0FBWSxHQUFaLENBQWdCLEdBQWhCLENBQVosQ0FBUDtBQUNIO0FBQ0QsUUFBSSxXQUFKLEdBQWtCO0FBQ2QsZUFBTyxLQUFLLE1BQUwsQ0FBWSxHQUFaLENBQWdCLEdBQWhCLENBQVA7QUFDSDtBQUNELFFBQUksZUFBSixHQUFzQjtBQUNsQixlQUFPLEtBQUssTUFBTCxDQUFZLEdBQVosQ0FBZ0IsR0FBaEIsQ0FBUDtBQUNIO0FBQ0QsUUFBSSxZQUFKLEdBQW1CO0FBQ2YsZUFBTyxLQUFLLE1BQUwsQ0FBWSxHQUFaLENBQWdCLEdBQWhCLENBQVA7QUFDSDtBQUNELFFBQUksZUFBSixHQUFzQjtBQUNsQixlQUFPLFlBQVksS0FBSyxNQUFMLENBQVksR0FBWixDQUFnQixHQUFoQixDQUFaLENBQVA7QUFDSDtBQUNELFFBQUksY0FBSixHQUFxQjtBQUNqQixlQUFPLEtBQUssTUFBTCxDQUFZLEdBQVosQ0FBZ0IsR0FBaEIsS0FBd0IsQ0FBL0I7QUFDSDtBQUNELFFBQUksY0FBSixHQUFxQjtBQUNqQixlQUFPLEtBQUssTUFBTCxDQUFZLEdBQVosQ0FBZ0IsR0FBaEIsS0FBd0IsS0FBSyxHQUFMLENBQVMsQ0FBVCxFQUFZLEtBQUssYUFBakIsSUFBa0MsQ0FBakU7QUFDSDtBQUNELFFBQUksV0FBSixHQUFrQjtBQUNkLGVBQU8sS0FBSyxNQUFMLENBQVksR0FBWixDQUFnQixHQUFoQixDQUFQO0FBQ0g7QUFDRCxRQUFJLFdBQUosR0FBa0I7QUFDZCxlQUFPLEtBQUssTUFBTCxDQUFZLEdBQVosQ0FBZ0IsR0FBaEIsQ0FBUDtBQUNIO0FBQ0QsUUFBSSxtQkFBSixHQUEwQjtBQUN0QixlQUFPLEtBQUssTUFBTCxDQUFZLEdBQVosQ0FBZ0IsR0FBaEIsS0FBd0IsQ0FBL0I7QUFDSDtBQUNELFFBQUksY0FBSixHQUFxQjtBQUNqQixlQUFPLEtBQUssTUFBTCxDQUFZLEdBQVosQ0FBZ0IsR0FBaEIsS0FBd0IsQ0FBL0I7QUFDSDtBQUNELFFBQUksUUFBSixHQUFlO0FBQ1gsZUFBTyxLQUFLLE1BQUwsQ0FBWSxHQUFaLENBQWdCLEdBQWhCLENBQVA7QUFDSDtBQUNELFFBQUksU0FBSixHQUFnQjtBQUNaLGVBQU8sS0FBSyxNQUFMLENBQVksR0FBWixDQUFnQixHQUFoQixLQUF3QixDQUEvQjtBQUNIO0FBQ0QsUUFBSSxZQUFKLEdBQW1CO0FBQ2YsZUFBTyxLQUFLLE1BQUwsQ0FBWSxHQUFaLENBQWdCLEdBQWhCLEtBQXdCLENBQS9CO0FBQ0g7QUFDRCxRQUFJLGVBQUosR0FBc0I7QUFDbEIsZUFBTyxLQUFLLE1BQUwsQ0FBWSxHQUFaLENBQWdCLEdBQWhCLEtBQXdCLEtBQUssY0FBcEM7QUFDSDtBQUNELFFBQUksZUFBSixHQUFzQjtBQUNsQixlQUFPLEtBQUssTUFBTCxDQUFZLEdBQVosQ0FBZ0IsR0FBaEIsS0FBd0IsS0FBSyxjQUFwQztBQUNIO0FBckdLOztBQXdHVixPQUFPLE9BQVAsR0FBaUIsR0FBakI7O0FBRUEsU0FBUyxXQUFULENBQXFCLEtBQXJCLEVBQTRCO0FBQ3hCLFFBQUksT0FBTyxLQUFQLEtBQWlCLFFBQXJCLEVBQStCLE9BQU8sQ0FBQyxLQUFELENBQVA7QUFDL0IsV0FBTyxLQUFQO0FBQ0g7OztBQ2pIRDs7QUFFQSxJQUFJLFFBQVEsSUFBSSxHQUFKLENBQVEsQ0FDaEIsQ0FBQyxDQUFELEVBQUssQ0FBQyxDQUFELEVBQUksUUFBSixDQUFMLENBRGdCLEU7QUFFaEIsQ0FBQyxDQUFELEVBQUssQ0FBQyxDQUFELEVBQUksU0FBSixDQUFMLENBRmdCLEU7QUFHaEIsQ0FBQyxDQUFELEVBQUssQ0FBQyxDQUFELEVBQUksU0FBSixDQUFMLENBSGdCLEU7QUFJaEIsQ0FBQyxDQUFELEVBQUssQ0FBQyxDQUFELEVBQUksUUFBSixDQUFMLENBSmdCLEU7QUFLaEIsQ0FBQyxDQUFELEVBQUssQ0FBQyxDQUFELEVBQUksWUFBSixDQUFMLENBTGdCLEU7QUFNaEIsQ0FBQyxDQUFELEVBQUssQ0FBQyxDQUFELEVBQUksU0FBSixDQUFMLENBTmdCLEU7QUFPaEIsQ0FBQyxDQUFELEVBQUssQ0FBQyxDQUFELEVBQUksUUFBSixDQUFMLENBUGdCLEU7QUFRaEIsQ0FBQyxDQUFELEVBQUssQ0FBQyxDQUFELEVBQUksVUFBSixDQUFMLENBUmdCLEU7QUFTaEIsQ0FBQyxDQUFELEVBQUssQ0FBQyxDQUFELEVBQUksU0FBSixDQUFMLENBVGdCLEU7QUFVaEIsQ0FBQyxFQUFELEVBQUssQ0FBQyxDQUFELEVBQUksYUFBSixDQUFMLENBVmdCLEU7QUFXaEIsQ0FBQyxFQUFELEVBQUssQ0FBQyxDQUFELEVBQUksU0FBSixDQUFMLENBWGdCLEU7QUFZaEIsQ0FBQyxFQUFELEVBQUssQ0FBQyxDQUFELEVBQUksVUFBSixDQUFMLEM7QUFaZ0IsQ0FBUixDQUFaOztBQWVBLFFBQVEsYUFBUixHQUF3QixVQUFVLElBQVYsRUFBZ0IsS0FBaEIsRUFBdUI7QUFDM0MsV0FBTyxNQUFNLEdBQU4sQ0FBVSxJQUFWLEVBQWdCLENBQWhCLElBQXFCLEtBQTVCO0FBQ0gsQ0FGRDs7QUFJQSxRQUFRLFFBQVIsR0FBbUIsVUFBVSxPQUFWLEVBQW1CLElBQW5CLEVBQXlCLEtBQXpCLEVBQWdDO0FBQy9DLFdBQU8sTUFBTSxHQUFOLENBQVUsSUFBVixFQUFnQixDQUFoQixFQUFtQixPQUFuQixFQUE0QixLQUE1QixDQUFQO0FBQ0gsQ0FGRDs7QUFJQSxTQUFTLFFBQVQsQ0FBa0IsT0FBbEIsRUFBMkIsS0FBM0IsRUFBa0M7QUFDOUIsUUFBSSxVQUFVLENBQWQsRUFBaUIsT0FBTyxRQUFRLFNBQVIsRUFBUDtBQUNqQixRQUFJLFFBQVEsSUFBSSxVQUFKLENBQWUsS0FBZixDQUFaO0FBQ0EsU0FBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLEtBQXBCLEVBQTJCLEdBQTNCLEVBQWdDO0FBQzVCLGNBQU0sQ0FBTixJQUFXLFFBQVEsU0FBUixFQUFYO0FBQ0g7QUFDRCxXQUFPLEtBQVA7QUFDSDs7QUFFRCxTQUFTLFNBQVQsQ0FBbUIsT0FBbkIsRUFBNEIsS0FBNUIsRUFBbUM7QUFDL0IsUUFBSSxVQUFVLEVBQWQ7QUFDQSxRQUFJLGdCQUFnQixFQUFwQjtBQUNBLFNBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxLQUFwQixFQUEyQixHQUEzQixFQUFnQztBQUM1QixZQUFJLE9BQU8sT0FBTyxZQUFQLENBQW9CLFFBQVEsU0FBUixFQUFwQixDQUFYO0FBQ0EsWUFBSSxTQUFTLElBQWIsRUFBbUI7QUFDZixvQkFBUSxJQUFSLENBQWEsYUFBYjtBQUNBLDRCQUFnQixFQUFoQjtBQUNILFNBSEQsTUFHTztBQUNILDZCQUFpQixJQUFqQjtBQUNIO0FBQ0o7QUFDRCxRQUFJLFFBQVEsTUFBUixLQUFtQixDQUF2QixFQUEwQjtBQUN0QixlQUFPLFFBQVEsQ0FBUixDQUFQO0FBQ0gsS0FGRCxNQUVPO0FBQ0gsZUFBTyxPQUFQO0FBQ0g7QUFDSjs7QUFFRCxTQUFTLFNBQVQsQ0FBbUIsT0FBbkIsRUFBNEIsS0FBNUIsRUFBbUM7QUFDL0IsUUFBSSxVQUFVLENBQWQsRUFBaUIsT0FBTyxRQUFRLFVBQVIsRUFBUDtBQUNqQixRQUFJLFFBQVEsSUFBSSxXQUFKLENBQWdCLEtBQWhCLENBQVo7QUFDQSxTQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksS0FBcEIsRUFBMkIsR0FBM0IsRUFBZ0M7QUFDNUIsY0FBTSxDQUFOLElBQVcsUUFBUSxVQUFSLEVBQVg7QUFDSDtBQUNELFdBQU8sS0FBUDtBQUNIOztBQUVELFNBQVMsUUFBVCxDQUFrQixPQUFsQixFQUEyQixLQUEzQixFQUFrQztBQUM5QixRQUFJLFVBQVUsQ0FBZCxFQUFpQixPQUFPLFFBQVEsVUFBUixFQUFQO0FBQ2pCLFFBQUksUUFBUSxJQUFJLFdBQUosQ0FBZ0IsS0FBaEIsQ0FBWjtBQUNBLFNBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxLQUFwQixFQUEyQixHQUEzQixFQUFnQztBQUM1QixjQUFNLENBQU4sSUFBVyxRQUFRLFVBQVIsRUFBWDtBQUNIO0FBQ0QsV0FBTyxLQUFQO0FBQ0g7O0FBRUQsU0FBUyxZQUFULENBQXNCLE9BQXRCLEVBQStCLEtBQS9CLEVBQXNDO0FBQ2xDLFFBQUksVUFBVSxDQUFkLEVBQWlCO0FBQ2IsZUFBTyxDQUNILFFBQVEsVUFBUixFQURHLEVBRUgsUUFBUSxVQUFSLEVBRkcsQ0FBUDtBQUlIO0FBQ0QsUUFBSSxZQUFZLElBQUksS0FBSixDQUFVLEtBQVYsQ0FBaEI7QUFDQSxTQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksS0FBcEIsRUFBMkIsR0FBM0IsRUFBZ0M7QUFDNUIsa0JBQVUsQ0FBVixJQUFlLENBQ1gsUUFBUSxVQUFSLEVBRFcsRUFFWCxRQUFRLFVBQVIsRUFGVyxDQUFmO0FBSUg7QUFDRCxXQUFPLFNBQVA7QUFDSDs7QUFFRCxTQUFTLFNBQVQsQ0FBbUIsT0FBbkIsRUFBNEIsS0FBNUIsRUFBbUM7QUFDL0IsUUFBSSxVQUFVLENBQWQsRUFBaUIsT0FBTyxRQUFRLFFBQVIsRUFBUDtBQUNqQixRQUFJLFFBQVEsSUFBSSxTQUFKLENBQWMsS0FBZCxDQUFaO0FBQ0EsU0FBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLEtBQXBCLEVBQTJCLEdBQTNCLEVBQWdDO0FBQzVCLGNBQU0sQ0FBTixJQUFXLFFBQVEsUUFBUixFQUFYO0FBQ0g7QUFDRCxXQUFPLEtBQVA7QUFDSDs7QUFFRCxTQUFTLFVBQVQsQ0FBb0IsT0FBcEIsRUFBNkIsS0FBN0IsRUFBb0M7QUFDaEMsUUFBSSxVQUFVLENBQWQsRUFBaUIsT0FBTyxRQUFRLFNBQVIsRUFBUDtBQUNqQixRQUFJLFFBQVEsSUFBSSxVQUFKLENBQWUsS0FBZixDQUFaO0FBQ0EsU0FBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLEtBQXBCLEVBQTJCLEdBQTNCLEVBQWdDO0FBQzVCLGNBQU0sQ0FBTixJQUFXLFFBQVEsU0FBUixFQUFYO0FBQ0g7QUFDRCxXQUFPLEtBQVA7QUFDSDs7QUFFRCxTQUFTLFNBQVQsQ0FBbUIsT0FBbkIsRUFBNEIsS0FBNUIsRUFBbUM7QUFDL0IsUUFBSSxVQUFVLENBQWQsRUFBaUIsT0FBTyxRQUFRLFNBQVIsRUFBUDtBQUNqQixRQUFJLFFBQVEsSUFBSSxVQUFKLENBQWUsS0FBZixDQUFaO0FBQ0EsU0FBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLEtBQXBCLEVBQTJCLEdBQTNCLEVBQWdDO0FBQzVCLGNBQU0sQ0FBTixJQUFXLFFBQVEsU0FBUixFQUFYO0FBQ0g7QUFDRCxXQUFPLEtBQVA7QUFDSDs7QUFFRCxTQUFTLGFBQVQsQ0FBdUIsT0FBdkIsRUFBZ0MsS0FBaEMsRUFBdUM7QUFDbkMsUUFBSSxVQUFVLENBQWQsRUFBaUI7QUFDYixlQUFPLENBQ0gsUUFBUSxTQUFSLEVBREcsRUFFSCxRQUFRLFNBQVIsRUFGRyxDQUFQO0FBSUg7QUFDRCxRQUFJLFlBQVksSUFBSSxLQUFKLENBQVUsS0FBVixDQUFoQjtBQUNBLFNBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxLQUFwQixFQUEyQixHQUEzQixFQUFnQztBQUM1QixrQkFBVSxDQUFWLElBQWUsQ0FDWCxRQUFRLFNBQVIsRUFEVyxFQUVYLFFBQVEsU0FBUixFQUZXLENBQWY7QUFJSDtBQUNELFdBQU8sU0FBUDtBQUNIOztBQUVELFNBQVMsU0FBVCxDQUFtQixPQUFuQixFQUE0QixLQUE1QixFQUFtQztBQUMvQixRQUFJLFVBQVUsQ0FBZCxFQUFpQixPQUFPLFFBQVEsV0FBUixFQUFQO0FBQ2pCLFFBQUksUUFBUSxJQUFJLFlBQUosQ0FBaUIsS0FBakIsQ0FBWjtBQUNBLFNBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxLQUFwQixFQUEyQixHQUEzQixFQUFnQztBQUM1QixjQUFNLENBQU4sSUFBVyxRQUFRLFdBQVIsRUFBWDtBQUNIO0FBQ0QsV0FBTyxLQUFQO0FBQ0g7O0FBRUQsU0FBUyxVQUFULENBQW9CLE9BQXBCLEVBQTZCLEtBQTdCLEVBQW9DO0FBQ2hDLFFBQUksVUFBVSxDQUFkLEVBQWlCLE9BQU8sUUFBUSxXQUFSLEVBQVA7QUFDakIsUUFBSSxRQUFRLElBQUksWUFBSixDQUFpQixLQUFqQixDQUFaO0FBQ0EsU0FBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLEtBQXBCLEVBQTJCLEdBQTNCLEVBQWdDO0FBQzVCLGNBQU0sQ0FBTixJQUFXLFFBQVEsV0FBUixFQUFYO0FBQ0g7QUFDRCxXQUFPLEtBQVA7QUFDSDs7O0FDcEpEOztBQUVBLE1BQU0sSUFBTixDQUFXO0FBQ1Asa0JBQWM7QUFDVixhQUFLLEdBQUwsR0FBVyxFQUFYO0FBQ0g7QUFITTs7QUFNWCxPQUFPLE9BQVAsR0FBaUIsSUFBakI7OztBQ1JBOztBQUVBLElBQU0sV0FBVyxRQUFRLFVBQVIsQ0FBakI7QUFDQSxJQUFNLE1BQU0sUUFBUSxPQUFSLENBQVo7QUFDQSxJQUFNLFdBQVcsUUFBUSxZQUFSLENBQWpCO0FBQ0EsSUFBTSxPQUFPLFFBQVEsUUFBUixDQUFiOztBQUVBLE1BQU0sV0FBTixTQUEwQixRQUExQixDQUFtQztBQUMvQixnQkFBWSxJQUFaLEVBQWtCO0FBQ2QsY0FBTSxJQUFOO0FBQ0EsYUFBSyxRQUFMLEdBQWdCLEtBQWhCO0FBQ0EsYUFBSyxLQUFMLEdBQWEsSUFBYjtBQUNBLGFBQUssUUFBTCxHQUFnQixDQUFoQjtBQUNIOztBQUVELGFBQVM7QUFDTCxZQUFJLEtBQUssUUFBVCxFQUFtQixPQUFPLEtBQUssS0FBWjtBQUNuQixhQUFLLEtBQUwsR0FBYSxJQUFJLElBQUosRUFBYjtBQUNBLGFBQUssWUFBTDtBQUNBLGVBQU8sS0FBSyxRQUFaLEVBQXNCO0FBQ2xCLGlCQUFLLFNBQUw7QUFDSDtBQUNELGVBQU8sS0FBSyxLQUFaO0FBQ0g7O0FBRUQsbUJBQWU7O0FBRVgsWUFBSSxRQUFRLEtBQUssVUFBTCxFQUFaO0FBQ0EsWUFBSSxVQUFVLE1BQWQsRUFBc0I7QUFDbEIsaUJBQUssZUFBTDtBQUNILFNBRkQsTUFFTyxJQUFJLFVBQVUsTUFBZCxFQUFzQjtBQUN6QixpQkFBSyxZQUFMO0FBQ0gsU0FGTSxNQUVBO0FBQ0gsa0JBQU0sSUFBSSxLQUFKLENBQVUsMkJBQTJCLE1BQU0sUUFBTixDQUFlLEVBQWYsQ0FBckMsQ0FBTjtBQUNIOzs7QUFHRCxnQkFBUSxLQUFLLFVBQUwsRUFBUjtBQUNBLFlBQUksVUFBVSxFQUFkLEVBQWtCO0FBQ2Qsa0JBQU0sSUFBSSxLQUFKLENBQVUsaUJBQVYsQ0FBTjtBQUNIOzs7QUFHRCxhQUFLLFFBQUwsR0FBZ0IsS0FBSyxVQUFMLEVBQWhCO0FBQ0g7O0FBRUQsZ0JBQVk7QUFDUixhQUFLLElBQUwsQ0FBVSxLQUFLLFFBQWY7QUFDQSxZQUFJLE1BQU0sSUFBSSxHQUFKLEVBQVY7QUFDQSxhQUFLLEtBQUwsQ0FBVyxHQUFYLENBQWUsSUFBZixDQUFvQixHQUFwQjtBQUNBLFlBQU0sYUFBYSxLQUFLLFVBQUwsRUFBbkI7QUFDQSxhQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksVUFBcEIsRUFBZ0MsR0FBaEMsRUFBcUM7QUFDakMsaUJBQUssY0FBTCxDQUFvQixHQUFwQjtBQUNIO0FBQ0QsYUFBSyxlQUFMLENBQXFCLEdBQXJCO0FBQ0EsYUFBSyxRQUFMLEdBQWdCLEtBQUssVUFBTCxFQUFoQjtBQUNIOztBQUVELG1CQUFlLEdBQWYsRUFBb0I7QUFDaEIsYUFBSyxJQUFMO0FBQ0EsWUFBSSxNQUFNLEtBQUssVUFBTCxFQUFWO0FBQ0EsWUFBSSxPQUFPLEtBQUssVUFBTCxFQUFYO0FBQ0EsWUFBSSxZQUFZLEtBQUssVUFBTCxFQUFoQjs7QUFFQSxZQUFJLE9BQU8sQ0FBUCxJQUFZLE9BQU8sRUFBdkIsRUFBMkI7QUFDdkIsaUJBQUssSUFBTCxDQUFVLENBQVYsRTtBQUNBO0FBQ0g7O0FBRUQsWUFBSSxrQkFBa0IsU0FBUyxhQUFULENBQXVCLElBQXZCLEVBQTZCLFNBQTdCLENBQXRCO0FBQ0EsWUFBSSxrQkFBa0IsQ0FBdEIsRUFBeUI7QUFDckIsaUJBQUssSUFBTCxDQUFVLEtBQUssVUFBTCxFQUFWO0FBQ0g7O0FBRUQsWUFBSSxRQUFRLFNBQVMsUUFBVCxDQUFrQixJQUFsQixFQUF3QixJQUF4QixFQUE4QixTQUE5QixDQUFaO0FBQ0EsWUFBSSxNQUFKLENBQVcsR0FBWCxDQUFlLEdBQWYsRUFBb0IsS0FBcEI7OztBQUdBLGFBQUssS0FBTDtBQUNBLGFBQUssSUFBTCxDQUFVLEVBQVY7QUFDSDs7QUFFRCxvQkFBZ0IsR0FBaEIsRUFBcUI7QUFDakIsWUFBTSxjQUFjLElBQUksV0FBeEI7QUFDQSxZQUFJLGVBQWUsZ0JBQWdCLENBQW5DLEVBQXNDO0FBQ2xDLHdCQUFZLGFBQVosRUFBMkIsV0FBM0I7QUFDSDtBQUNELGdCQUFPLElBQUksSUFBWDtBQUNJLGlCQUFLLENBQUw7O0FBQ0kscUJBQUssbUJBQUwsQ0FBeUIsR0FBekI7QUFDQTtBQUNKO0FBQ0ksNEJBQVksWUFBWixFQUEwQixJQUFJLElBQTlCO0FBQ0E7QUFOUjtBQVFIOztBQUVELHdCQUFvQixHQUFwQixFQUF5QjtBQUNyQixZQUFNLFFBQVEsSUFBSSxLQUFsQjtBQUNBLFlBQU0sU0FBUyxJQUFJLE1BQW5COztBQUVBLFlBQU0sV0FBVyxJQUFJLGFBQXJCO0FBQ0EsWUFBTSxlQUFlLElBQUksWUFBekI7QUFDQSxZQUFJLE9BQU8sUUFBUSxNQUFuQjtBQUNBLFlBQU0sT0FBTyxhQUFhLElBQWIsRUFBbUIsQ0FBbkIsRUFBc0IsUUFBdEIsRUFBZ0MsWUFBaEMsQ0FBYjs7QUFFQSxZQUFNLGNBQWMsSUFBSSxXQUF4QjtBQUNBLFlBQU0sZUFBZSxJQUFJLFlBQXpCO0FBQ0EsWUFBTSxZQUFZLGVBQWUsS0FBakM7QUFDQSxZQUFNLGVBQWUsSUFBSSxZQUF6QjtBQUNBLFlBQU0sa0JBQWtCLElBQUksZUFBNUI7O0FBRUEsWUFBSSxRQUFRLENBQVo7QUFDQSxhQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksYUFBYSxNQUFqQyxFQUF5QyxHQUF6QyxFQUE4QztBQUMxQyxnQkFBSSxZQUFZLEtBQUssWUFBTCxDQUFrQixXQUFsQixFQUErQixhQUFhLENBQWIsQ0FBL0IsRUFBZ0QsZ0JBQWdCLENBQWhCLENBQWhELENBQWhCOztBQUVBLGdCQUFJLFNBQVMsT0FBTyxTQUFQLEdBQW1CLFNBQW5CLEdBQStCLElBQTVDO0FBQ0Esb0JBQVEsTUFBUjtBQUNBLGdCQUFJLGFBQWEsQ0FBakIsRUFBb0I7QUFDaEIsd0JBQVEsU0FBUyxJQUFULEVBQWUsU0FBZixFQUEwQixLQUExQixFQUFpQyxNQUFqQyxDQUFSO0FBQ0gsYUFGRCxNQUVPLElBQUksYUFBYSxFQUFqQixFQUFxQjtBQUN4Qix3QkFBUSxVQUFVLElBQVYsRUFBZ0IsU0FBaEIsRUFBMkIsS0FBM0IsRUFBa0MsTUFBbEMsRUFBMEMsS0FBSyxjQUFMLEVBQTFDLENBQVI7QUFDSCxhQUZNLE1BRUEsSUFBSSxhQUFhLEVBQWIsSUFBbUIsaUJBQWlCLENBQXhDLEVBQTJDO0FBQzlDLHdCQUFRLFlBQVksSUFBWixFQUFrQixTQUFsQixFQUE2QixLQUE3QixFQUFvQyxNQUFwQyxFQUE0QyxLQUFLLGNBQUwsRUFBNUMsQ0FBUjtBQUNILGFBRk0sTUFFQTtBQUNILDRCQUFZLFVBQVosRUFBd0IsUUFBeEI7QUFDSDtBQUNKOztBQUVELFlBQUksSUFBSixHQUFXLElBQVg7QUFDSDs7QUFFRCxpQkFBYSxXQUFiLEVBQTBCLE1BQTFCLEVBQWtDLFVBQWxDLEVBQThDO0FBQzFDLGdCQUFRLFdBQVI7QUFDSSxpQkFBSyxDQUFMOztBQUNJLHVCQUFPLElBQUksUUFBSixDQUFhLEtBQUssTUFBbEIsRUFBMEIsTUFBMUIsRUFBa0MsVUFBbEMsQ0FBUDtBQUNBO0FBQ0osaUJBQUssQ0FBTCxDO0FBQ0EsaUJBQUssS0FBTDs7QUFDSSw0QkFBWSxhQUFaLEVBQTJCLFdBQTNCO0FBQ0E7QUFDSjtBQUNJLHNCQUFNLElBQUksS0FBSixDQUFVLDBCQUEwQixXQUFwQyxDQUFOO0FBVFI7QUFXSDtBQXpJOEI7O0FBNEluQyxPQUFPLE9BQVAsR0FBaUIsV0FBakI7O0FBRUEsU0FBUyxZQUFULENBQXNCLElBQXRCLEVBQTRCLFFBQTVCLEVBQXNDLFFBQXRDLEVBQWdELFlBQWhELEVBQThEO0FBQzFELFFBQUksYUFBYSxDQUFqQixFQUFvQjtBQUNoQixlQUFPLElBQUksVUFBSixDQUFlLE9BQU8sUUFBdEIsQ0FBUDtBQUNILEtBRkQsTUFFTyxJQUFJLGFBQWEsRUFBakIsRUFBcUI7QUFDeEIsZUFBTyxJQUFJLFdBQUosQ0FBZ0IsT0FBTyxRQUF2QixDQUFQO0FBQ0gsS0FGTSxNQUVBLElBQUksYUFBYSxFQUFiLElBQW1CLGlCQUFpQixDQUF4QyxFQUEyQztBQUM5QyxlQUFPLElBQUksWUFBSixDQUFpQixPQUFPLFFBQXhCLENBQVA7QUFDSCxLQUZNLE1BRUE7QUFDSCxvQkFBWSwyQkFBWixFQUF5QyxXQUFXLEtBQVgsR0FBbUIsWUFBNUQ7QUFDSDtBQUNKOztBQUVELFNBQVMsUUFBVCxDQUFrQixNQUFsQixFQUEwQixRQUExQixFQUFvQyxLQUFwQyxFQUEyQyxNQUEzQyxFQUFtRDtBQUMvQyxTQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksTUFBcEIsRUFBNEIsR0FBNUIsRUFBaUM7QUFDN0IsZUFBTyxPQUFQLElBQWtCLFNBQVMsUUFBVCxDQUFrQixDQUFsQixDQUFsQjtBQUNIO0FBQ0QsV0FBTyxLQUFQO0FBQ0g7O0FBRUQsU0FBUyxTQUFULENBQW1CLE1BQW5CLEVBQTJCLFFBQTNCLEVBQXFDLEtBQXJDLEVBQTRDLE1BQTVDLEVBQW9ELFlBQXBELEVBQWtFO0FBQzlELFNBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxTQUFTLENBQTdCLEVBQWdDLEtBQUssQ0FBckMsRUFBd0M7QUFDcEMsZUFBTyxPQUFQLElBQWtCLFNBQVMsU0FBVCxDQUFtQixDQUFuQixFQUFzQixZQUF0QixDQUFsQjtBQUNIO0FBQ0QsV0FBTyxLQUFQO0FBQ0g7O0FBRUQsU0FBUyxXQUFULENBQXFCLE1BQXJCLEVBQTZCLFFBQTdCLEVBQXVDLEtBQXZDLEVBQThDLE1BQTlDLEVBQXNELFlBQXRELEVBQW9FO0FBQ2hFLFNBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxTQUFTLENBQTdCLEVBQWdDLEtBQUssQ0FBckMsRUFBd0M7QUFDcEMsZUFBTyxPQUFQLElBQWtCLFNBQVMsVUFBVCxDQUFvQixDQUFwQixFQUF1QixZQUF2QixDQUFsQjtBQUNIO0FBQ0QsV0FBTyxLQUFQO0FBQ0g7O0FBRUQsU0FBUyxXQUFULENBQXFCLElBQXJCLEVBQTJCLEtBQTNCLEVBQWtDO0FBQzlCLFVBQU0sSUFBSSxLQUFKLENBQVUsaUJBQWlCLElBQWpCLEdBQXdCLElBQXhCLEdBQStCLEtBQXpDLENBQU47QUFDSDs7O0FDeExEOztBQUVBLFFBQVEsV0FBUixHQUFzQixRQUFRLGVBQVIsQ0FBdEI7OztBQ0ZBOztBQUVBLElBQUksaUJBQWlCLFFBQVEsa0JBQVIsQ0FBckI7O0FBRUEsSUFBSSxRQUFRLFVBQVUsbUJBQVYsSUFBaUMsQ0FBN0M7O0FBRUEsSUFBSSxPQUFPLFNBQVMsU0FBcEI7O0FBRUEsU0FBUyxhQUFULENBQXVCLElBQXZCLEVBQTZCLE9BQTdCLEVBQXNDOztBQUVsQyxRQUFJLE9BQU8sSUFBUCxLQUFnQixRQUFoQixJQUE0QixPQUFPLElBQVAsS0FBZ0IsVUFBaEQsRUFDSSxNQUFNLElBQUksU0FBSixDQUFjLGtDQUFkLENBQU47QUFDSixRQUFJLFlBQVksU0FBaEIsRUFDSSxVQUFVLEVBQVY7QUFDSixRQUFJLE9BQU8sT0FBUCxLQUFtQixRQUFuQixJQUErQixZQUFZLElBQS9DLEVBQ0ksTUFBTSxJQUFJLFNBQUosQ0FBYyxvQ0FBZCxDQUFOOztBQUVKLFNBQUssV0FBTCxHQUFtQixLQUFLLFFBQUwsRUFBbkI7OztBQUdBLFFBQUksUUFBUSxVQUFSLEtBQXVCLFNBQXZCLElBQW9DLFFBQVEsVUFBUixLQUF1QixNQUEvRCxFQUF1RTtBQUNuRSxhQUFLLFdBQUwsR0FBbUIsS0FBSyxHQUFMLENBQVMsUUFBUSxDQUFqQixFQUFvQixDQUFwQixDQUFuQjtBQUNILEtBRkQsTUFFTyxJQUFJLFFBQVEsVUFBUixHQUFxQixDQUF6QixFQUE0QjtBQUMvQixhQUFLLFdBQUwsR0FBbUIsS0FBSyxHQUFMLENBQVMsUUFBUSxVQUFqQixFQUE2QixLQUE3QixDQUFuQjtBQUNILEtBRk0sTUFFQTtBQUNILGFBQUssV0FBTCxHQUFtQixLQUFuQjtBQUNIOztBQUVELFNBQUssUUFBTCxHQUFnQixJQUFJLEdBQUosRUFBaEI7QUFDQSxTQUFLLFFBQUwsR0FBZ0IsUUFBUSxPQUFSLElBQW1CLENBQW5DO0FBQ0EsU0FBSyxpQkFBTCxHQUF5QixDQUFDLENBQUMsUUFBUSxnQkFBbkM7O0FBRUEsUUFBSSxPQUFPLFFBQVEsSUFBbkI7QUFDQSxRQUFJLE9BQU8sSUFBUCxLQUFnQixRQUFwQixFQUNJLE9BQU8sQ0FBQyxJQUFELENBQVA7QUFDSixRQUFJLENBQUMsTUFBTSxPQUFOLENBQWMsSUFBZCxDQUFMLEVBQ0ksT0FBTyxTQUFQOztBQUVKLFNBQUssR0FBTCxHQUFXLENBQVg7QUFDQSxTQUFLLFdBQUwsR0FBbUIsS0FBbkI7QUFDQSxTQUFLLFFBQUwsR0FBZ0IsQ0FBaEI7QUFDQSxTQUFLLFFBQUwsR0FBZ0IsRUFBaEI7O0FBRUEsU0FBSyxLQUFMLENBQVcsSUFBWDtBQUNIOztBQUVELGNBQWMsU0FBZCxDQUF3QixLQUF4QixHQUFnQyxVQUFVLElBQVYsRUFBZ0I7QUFDNUMsUUFBSSxZQUFZLGVBQWUsWUFBZixDQUE0QixLQUFLLFdBQWpDLEVBQThDLElBQTlDLENBQWhCOztBQUVBLFNBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxLQUFLLFdBQXpCLEVBQXNDLEdBQXRDLEVBQTJDO0FBQ3ZDLFlBQUksU0FBUyxJQUFJLE1BQUosQ0FBVyxTQUFYLENBQWI7QUFDQSxlQUFPLFNBQVAsR0FBbUIsS0FBSyxVQUFMLENBQWdCLElBQWhCLENBQXFCLElBQXJCLEVBQTJCLE1BQTNCLENBQW5CO0FBQ0EsZUFBTyxPQUFQLEdBQWlCLEtBQUssUUFBTCxDQUFjLElBQWQsQ0FBbUIsSUFBbkIsRUFBeUIsTUFBekIsQ0FBakI7QUFDQSxlQUFPLE9BQVAsR0FBaUIsS0FBakI7QUFDQSxlQUFPLEVBQVAsR0FBWSxDQUFaO0FBQ0EsYUFBSyxRQUFMLENBQWMsR0FBZCxDQUFrQixNQUFsQixFQUEwQixJQUExQjtBQUNIOztBQUVELFFBQUksZUFBSixDQUFvQixTQUFwQjtBQUNILENBYkQ7O0FBZUEsY0FBYyxTQUFkLENBQXdCLFFBQXhCLEdBQW1DLFVBQVUsTUFBVixFQUFrQixLQUFsQixFQUF5QjtBQUN4RCxRQUFJLEtBQUssV0FBVCxFQUNJO0FBQ0osU0FBSyxRQUFMO0FBQ0EsV0FBTyxPQUFQLEdBQWlCLEtBQWpCO0FBQ0EsUUFBSSxXQUFXLEtBQUssUUFBTCxDQUFjLEdBQWQsQ0FBa0IsTUFBbEIsQ0FBZjtBQUNBLFFBQUksUUFBSixFQUFjO0FBQ1YsaUJBQVMsQ0FBVCxFQUFZLE1BQU0sT0FBbEI7QUFDSDtBQUNELFNBQUssUUFBTCxDQUFjLEdBQWQsQ0FBa0IsTUFBbEIsRUFBMEIsSUFBMUI7QUFDQSxRQUFJLEtBQUssaUJBQVQsRUFBNEI7QUFDeEIsYUFBSyxTQUFMO0FBQ0gsS0FGRCxNQUVPO0FBQ0gsYUFBSyxLQUFMO0FBQ0g7QUFDSixDQWZEOztBQWlCQSxjQUFjLFNBQWQsQ0FBd0IsVUFBeEIsR0FBcUMsVUFBVSxNQUFWLEVBQWtCLEtBQWxCLEVBQXlCO0FBQzFELFFBQUksS0FBSyxXQUFULEVBQ0k7QUFDSixTQUFLLFFBQUw7QUFDQSxXQUFPLE9BQVAsR0FBaUIsS0FBakI7QUFDQSxRQUFJLFdBQVcsS0FBSyxRQUFMLENBQWMsR0FBZCxDQUFrQixNQUFsQixDQUFmO0FBQ0EsUUFBSSxRQUFKLEVBQWM7QUFDVixpQkFBUyxDQUFULEVBQVksTUFBTSxJQUFOLENBQVcsSUFBdkI7QUFDSDtBQUNELFNBQUssUUFBTCxDQUFjLEdBQWQsQ0FBa0IsTUFBbEIsRUFBMEIsSUFBMUI7QUFDQSxTQUFLLEtBQUw7QUFDSCxDQVhEOztBQWFBLGNBQWMsU0FBZCxDQUF3QixLQUF4QixHQUFnQyxZQUFZO0FBQ3hDLFNBQUssSUFBSSxNQUFULElBQW1CLEtBQUssUUFBTCxDQUFjLElBQWQsRUFBbkIsRUFBeUM7QUFDckMsWUFBSSxLQUFLLFFBQUwsS0FBa0IsS0FBSyxXQUF2QixJQUNBLEtBQUssUUFBTCxDQUFjLE1BQWQsS0FBeUIsQ0FEN0IsRUFDZ0M7QUFDNUI7QUFDSDtBQUNELFlBQUksQ0FBQyxPQUFPLE9BQVosRUFBcUI7QUFDakIsaUJBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxLQUFLLFFBQUwsQ0FBYyxNQUFsQyxFQUEwQyxHQUExQyxFQUErQztBQUMzQyxvQkFBSSxXQUFXLEtBQUssUUFBTCxDQUFjLENBQWQsQ0FBZjtBQUNBLG9CQUFJLE9BQU8sU0FBUyxDQUFULENBQVAsS0FBdUIsUUFBdkIsSUFBbUMsU0FBUyxDQUFULE1BQWdCLE9BQU8sRUFBOUQsRUFBa0U7O0FBRTlEO0FBQ0g7QUFDRCxxQkFBSyxRQUFMLENBQWMsTUFBZCxDQUFxQixDQUFyQixFQUF3QixDQUF4QjtBQUNBLHVCQUFPLFdBQVAsQ0FBbUI7QUFDZiw0QkFBUSxNQURPO0FBRWYsMkJBQU8sU0FBUyxDQUFULENBRlE7QUFHZiwwQkFBTSxTQUFTLENBQVQ7QUFIUyxpQkFBbkIsRUFJRyxTQUFTLENBQVQsQ0FKSDtBQUtBLHVCQUFPLE9BQVAsR0FBaUIsSUFBakI7QUFDQSx1QkFBTyxJQUFQLEdBQWMsS0FBSyxHQUFMLEVBQWQ7QUFDQSxxQkFBSyxRQUFMLENBQWMsR0FBZCxDQUFrQixNQUFsQixFQUEwQixTQUFTLENBQVQsQ0FBMUI7QUFDQSxxQkFBSyxRQUFMO0FBQ0E7QUFDSDtBQUNKO0FBQ0o7QUFDSixDQTNCRDs7QUE2QkEsY0FBYyxTQUFkLENBQXdCLFNBQXhCLEdBQW9DLFlBQVk7QUFDNUMsUUFBSSxLQUFLLFdBQVQsRUFBc0I7QUFDdEIsU0FBSyxJQUFJLEtBQVQsSUFBa0IsS0FBSyxRQUF2QixFQUFpQztBQUM3QixjQUFNLENBQU4sRUFBUyxTQUFUO0FBQ0EsWUFBSSxNQUFNLENBQU4sQ0FBSixFQUFjO0FBQ1Ysa0JBQU0sQ0FBTixFQUFTLENBQVQsRUFBWSxJQUFJLEtBQUosQ0FBVSxZQUFWLENBQVo7QUFDSDtBQUNKO0FBQ0QsU0FBSyxRQUFMLENBQWMsS0FBZDtBQUNBLFNBQUssUUFBTCxHQUFnQixFQUFoQjtBQUNBLFNBQUssUUFBTCxHQUFnQixDQUFoQjtBQUNBLFNBQUssV0FBTCxHQUFtQixJQUFuQjtBQUNILENBWkQ7O0FBY0EsY0FBYyxTQUFkLENBQXdCLE9BQXhCLEdBQWtDLFVBQVUsS0FBVixFQUFpQixJQUFqQixFQUF1QjtBQUNyRCxRQUFJLEtBQUssV0FBVCxFQUNJLE1BQU0sSUFBSSxLQUFKLENBQVUsMEJBQVYsQ0FBTjtBQUNKLFFBQUksV0FBVyxFQUFmO0FBQ0EsU0FBSyxJQUFJLE1BQVQsSUFBbUIsS0FBSyxRQUFMLENBQWMsSUFBZCxFQUFuQixFQUF5QztBQUNyQyxpQkFBUyxJQUFULENBQWMsS0FBSyxJQUFMLENBQVUsS0FBVixFQUFpQixJQUFqQixFQUF1QixFQUF2QixFQUEyQixPQUFPLEVBQWxDLENBQWQ7QUFDSDtBQUNELFdBQU8sUUFBUSxHQUFSLENBQVksUUFBWixDQUFQO0FBQ0gsQ0FSRDs7QUFVQSxjQUFjLFNBQWQsQ0FBd0IsSUFBeEIsR0FBK0IsVUFBVSxLQUFWLEVBQWlCLElBQWpCLEVBQXVCLFlBQXZCLEVBQXFDLEVBQXJDLEVBQXlDO0FBQ3BFLFFBQUksU0FBUyxTQUFiLEVBQXdCLE9BQU8sRUFBUDtBQUN4QixRQUFJLGlCQUFpQixTQUFyQixFQUFnQyxlQUFlLEVBQWY7QUFDaEMsUUFBSSxDQUFDLE1BQU0sT0FBTixDQUFjLElBQWQsQ0FBTCxFQUEwQjtBQUN0QixlQUFPLENBQUMsSUFBRCxDQUFQO0FBQ0g7QUFDRCxRQUFJLENBQUMsTUFBTSxPQUFOLENBQWMsWUFBZCxDQUFMLEVBQWtDO0FBQzlCLHVCQUFlLENBQUMsWUFBRCxDQUFmO0FBQ0g7O0FBRUQsUUFBSSxPQUFPLElBQVg7QUFDQSxXQUFPLElBQUksT0FBSixDQUFZLFVBQVUsT0FBVixFQUFtQixNQUFuQixFQUEyQjtBQUMxQyxZQUFJLEtBQUssV0FBVCxFQUFzQixNQUFNLElBQUksS0FBSixDQUFVLDBCQUFWLENBQU47QUFDdEIsYUFBSyxRQUFMLENBQWMsSUFBZCxDQUFtQixDQUFDLEtBQUQsRUFBUSxJQUFSLEVBQWMsWUFBZCxFQUE0QixDQUFDLE9BQUQsRUFBVSxNQUFWLENBQTVCLEVBQStDLEVBQS9DLENBQW5CO0FBQ0EsYUFBSyxLQUFMO0FBQ0gsS0FKTSxDQUFQO0FBS0gsQ0FoQkQ7O0FBa0JBLE9BQU8sT0FBUCxHQUFpQixhQUFqQjs7O0FDbEtBOztBQUVBLElBQUksU0FBUyxrQkFBWTtBQUNyQixRQUFJLFNBQVMsS0FBSyxNQUFMLEdBQWMsSUFBM0I7QUFDQSxhQUFTLGFBQVQsR0FBeUI7QUFDckIsYUFBSyxVQUFMLEdBQWtCLEVBQWxCO0FBQ0g7QUFDRCxrQkFBYyxTQUFkLENBQXdCLEVBQXhCLEdBQTZCLFVBQVUsS0FBVixFQUFpQixRQUFqQixFQUEyQjtBQUNwRCxZQUFJLEtBQUssVUFBTCxDQUFnQixLQUFoQixDQUFKLEVBQ0ksTUFBTSxJQUFJLFVBQUosQ0FBZSxxQ0FBcUMsS0FBcEQsQ0FBTjtBQUNKLFlBQUksT0FBTyxRQUFQLEtBQW9CLFVBQXhCLEVBQ0ksTUFBTSxJQUFJLFNBQUosQ0FBYyxzQ0FBZCxDQUFOO0FBQ0osYUFBSyxVQUFMLENBQWdCLEtBQWhCLElBQXlCLFFBQXpCO0FBQ0gsS0FORDtBQU9BLGtCQUFjLFNBQWQsQ0FBd0IsS0FBeEIsR0FBZ0MsVUFBVSxFQUFWLEVBQWMsSUFBZCxFQUFvQixZQUFwQixFQUFrQztBQUM5RCxZQUFJLGlCQUFpQixTQUFyQixFQUFnQztBQUM1QiwyQkFBZSxFQUFmO0FBQ0gsU0FGRCxNQUVPLElBQUksQ0FBQyxNQUFNLE9BQU4sQ0FBYyxZQUFkLENBQUwsRUFBa0M7QUFDckMsMkJBQWUsQ0FBQyxZQUFELENBQWY7QUFDSDtBQUNELGFBQUssV0FBTCxDQUFpQjtBQUNiLGdCQUFJLEVBRFM7QUFFYixrQkFBTTtBQUZPLFNBQWpCLEVBR0csWUFISDtBQUlILEtBVkQ7QUFXQSxrQkFBYyxTQUFkLENBQXdCLFFBQXhCLEdBQW1DLFVBQVUsS0FBVixFQUFpQixJQUFqQixFQUF1QjtBQUN0RCxZQUFJLENBQUMsS0FBSyxVQUFMLENBQWdCLEtBQWhCLENBQUwsRUFDSSxNQUFNLElBQUksS0FBSixDQUFVLFdBQVcsS0FBWCxHQUFtQixpQkFBN0IsQ0FBTjtBQUNKLGFBQUssVUFBTCxDQUFnQixLQUFoQixFQUF1QixLQUF2QixDQUE2QixJQUE3QixFQUFtQyxJQUFuQztBQUNILEtBSkQ7QUFLQSxRQUFJLFNBQVMsSUFBSSxhQUFKLEVBQWI7QUFDQSxTQUFLLFNBQUwsR0FBaUIsVUFBVSxLQUFWLEVBQWlCO0FBQzlCLGdCQUFPLE1BQU0sSUFBTixDQUFXLE1BQWxCO0FBQ0ksaUJBQUssTUFBTDtBQUNJLHNCQUFNLElBQU4sQ0FBVyxJQUFYLENBQWdCLE9BQWhCLENBQXdCLFVBQVUsSUFBVixFQUFnQixZQUFoQixFQUE4QjtBQUNsRCwyQkFBTyxLQUFQLENBQWEsTUFBTSxJQUFOLENBQVcsRUFBeEIsRUFBNEIsSUFBNUIsRUFBa0MsWUFBbEM7QUFDSCxpQkFGRDtBQUdBLHVCQUFPLFFBQVAsQ0FBZ0IsTUFBTSxJQUFOLENBQVcsS0FBM0IsRUFBa0MsTUFBTSxJQUFOLENBQVcsSUFBN0M7QUFDQTtBQUNKLGlCQUFLLE1BQUw7QUFDSSx1QkFBTyxLQUFQLENBQWEsTUFBTSxJQUFOLENBQVcsRUFBeEIsRUFBNEIsTUFBNUI7QUFDQTtBQUNKO0FBQ0ksc0JBQU0sSUFBSSxLQUFKLENBQVUsd0JBQXdCLE1BQU0sSUFBTixDQUFXLE1BQTdDLENBQU47QUFYUjtBQWFILEtBZEQ7QUFlQTtBQUNILENBN0NEOztBQStDQSxJQUFJLFlBQVksT0FBTyxRQUFQLEdBQWtCLEtBQWxCLENBQXdCLFNBQXhCLENBQWhCOztBQUVBLFFBQVEsWUFBUixHQUF1QixTQUFTLFlBQVQsQ0FBc0IsSUFBdEIsRUFBNEIsSUFBNUIsRUFBa0M7QUFDckQsUUFBSSxPQUFPLElBQUksSUFBSixDQUFTLENBQUMsR0FBRCxFQUFNLFVBQVUsQ0FBVixDQUFOLEVBQW9CLCtCQUErQixLQUFLLFNBQUwsQ0FBZSxJQUFmLENBQS9CLEdBQXNELE1BQTFFLEVBQWtGLEdBQWxGLEVBQXVGLElBQXZGLEVBQTZGLE1BQTdGLEVBQXFHLFVBQVUsQ0FBVixDQUFyRyxFQUFtSCxNQUFuSCxDQUFULEVBQXFJLEVBQUMsTUFBTSx3QkFBUCxFQUFySSxDQUFYO0FBQ0EsV0FBTyxJQUFJLGVBQUosQ0FBb0IsSUFBcEIsQ0FBUDtBQUNILENBSEQ7Ozs7Ozs7OztrQkNJZSxVQUFVLEtBQVYsRUFBaUI7QUFDNUIsU0FBSyxJQUFJLENBQVQsSUFBYyxVQUFkLEVBQTBCO0FBQ3RCLGNBQU0sU0FBTixDQUFnQixDQUFoQixJQUFxQixXQUFXLENBQVgsQ0FBckI7QUFDSDtBQUNKLEM7OztBQTFERCxJQUFJLGFBQWE7QUFDYixZQURhLG9CQUNKLENBREksRUFDRCxDQURDLEVBQ0U7QUFDWCxZQUFJLFNBQVMsSUFBSSxLQUFLLEtBQVQsR0FBaUIsQ0FBOUI7QUFDQSxZQUFJLFFBQVEsS0FBSyxTQUFTLFVBQWQsQ0FBWjtBQUNBLFlBQUksT0FBTyxVQUFVLENBQXJCO0FBQ0EsYUFBSyxJQUFMLENBQVUsSUFBVixLQUFtQixLQUFLLEtBQXhCO0FBQ0gsS0FOWTtBQVFiLGNBUmEsc0JBUUYsQ0FSRSxFQVFDLENBUkQsRUFRSTtBQUNiLFlBQUksU0FBUyxJQUFJLEtBQUssS0FBVCxHQUFpQixDQUE5QjtBQUNBLFlBQUksUUFBUSxLQUFLLFNBQVMsVUFBZCxDQUFaO0FBQ0EsWUFBSSxPQUFPLFVBQVUsQ0FBckI7QUFDQSxhQUFLLElBQUwsQ0FBVSxJQUFWLEtBQW1CLEVBQUUsS0FBSyxLQUFQLENBQW5CO0FBQ0gsS0FiWTtBQWViLGVBZmEsdUJBZUQsQ0FmQyxFQWVFLENBZkYsRUFlSztBQUNkLFlBQUksU0FBUyxJQUFJLEtBQUssS0FBVCxHQUFpQixDQUE5QjtBQUNBLFlBQUksUUFBUSxLQUFLLFNBQVMsVUFBZCxDQUFaO0FBQ0EsWUFBSSxPQUFPLFVBQVUsQ0FBckI7QUFDQSxhQUFLLElBQUwsQ0FBVSxJQUFWLEtBQW1CLEtBQUssS0FBeEI7QUFDSCxLQXBCWTtBQXNCYixZQXRCYSxvQkFzQkosQ0F0QkksRUFzQkQsQ0F0QkMsRUFzQkU7QUFDWCxZQUFJLFNBQVMsSUFBSSxLQUFLLEtBQVQsR0FBaUIsQ0FBOUI7QUFDQSxZQUFJLFFBQVEsS0FBSyxTQUFTLFVBQWQsQ0FBWjtBQUNBLFlBQUksT0FBTyxVQUFVLENBQXJCO0FBQ0EsZUFBUSxLQUFLLElBQUwsQ0FBVSxJQUFWLElBQW1CLEtBQUssS0FBekIsR0FBbUMsQ0FBbkMsR0FBdUMsQ0FBOUM7QUFDSCxLQTNCWTtBQTZCYixVQTdCYSxrQkE2Qk4sS0E3Qk0sRUE2QkM7QUFDVixZQUFJLFFBQVEsS0FBSyxRQUFRLFVBQWIsQ0FBWjtBQUNBLFlBQUksT0FBTyxTQUFTLENBQXBCO0FBQ0EsYUFBSyxJQUFMLENBQVUsSUFBVixLQUFtQixLQUFLLEtBQXhCO0FBQ0gsS0FqQ1k7QUFtQ2IsWUFuQ2Esb0JBbUNKLEtBbkNJLEVBbUNHO0FBQ1osWUFBSSxRQUFRLEtBQUssUUFBUSxVQUFiLENBQVo7QUFDQSxZQUFJLE9BQU8sU0FBUyxDQUFwQjtBQUNBLGFBQUssSUFBTCxDQUFVLElBQVYsS0FBbUIsRUFBRSxLQUFLLEtBQVAsQ0FBbkI7QUFDSCxLQXZDWTtBQXlDYixhQXpDYSxxQkF5Q0gsS0F6Q0csRUF5Q0k7QUFDYixZQUFJLFFBQVEsS0FBSyxRQUFRLFVBQWIsQ0FBWjtBQUNBLFlBQUksT0FBTyxTQUFTLENBQXBCO0FBQ0EsYUFBSyxJQUFMLENBQVUsSUFBVixLQUFtQixLQUFLLEtBQXhCO0FBQ0gsS0E3Q1k7QUErQ2IsVUEvQ2Esa0JBK0NOLEtBL0NNLEVBK0NDO0FBQ1YsWUFBSSxRQUFRLEtBQUssUUFBUSxVQUFiLENBQVo7QUFDQSxZQUFJLE9BQU8sU0FBUyxDQUFwQjtBQUNBLGVBQVEsS0FBSyxJQUFMLENBQVUsSUFBVixJQUFtQixLQUFLLEtBQXpCLEdBQW1DLENBQW5DLEdBQXVDLENBQTlDO0FBQ0g7QUFuRFksQ0FBakI7Ozs7Ozs7O2tCQ0N3QixpQjs7QUFGeEI7Ozs7OztBQUVlLFNBQVMsaUJBQVQsR0FHSDtBQUFBLHFFQUFKLEVBQUk7O0FBQUEsNkJBRlIsUUFFUTtBQUFBLFFBRlIsUUFFUSxpQ0FGRyxJQUVIO0FBQUEsNEJBRFIsT0FDUTtBQUFBLFFBRFIsT0FDUSxnQ0FERSxHQUNGOztBQUNSLFNBQUssZ0JBQUwsQ0FBc0IsbUJBQXRCLEVBQTJDO0FBQ3ZDLGtCQUFVLENBQUMsQ0FBRCxFQUFJLEVBQUosQ0FENkI7QUFFdkMsb0JBQVksQ0FBQyxDQUFEO0FBRjJCLEtBQTNDOztBQUtBLFFBQUksZUFBZSxLQUFLLEdBQUwsQ0FBUyxPQUFULElBQW9CLEtBQUssR0FBTCxDQUFTLENBQVQsQ0FBdkM7QUFDQSxRQUFJLGlCQUFpQixLQUFLLEtBQUwsQ0FBVyxZQUFYLENBQXJCLEVBQStDO0FBQzNDLGNBQU0sSUFBSSxVQUFKLENBQWUsMERBQWYsQ0FBTjtBQUNIOztBQUVELFFBQUksV0FBVyxLQUFLLFFBQUwsR0FBZ0IsWUFBL0I7O0FBRUEsUUFBSSxPQUFPLEtBQUssSUFBaEI7QUFDQSxRQUFJLFNBQVMsd0JBQVMsS0FBSyxHQUFMLENBQVMsQ0FBVCxFQUFZLFlBQVosQ0FBVCxFQUFtQyxDQUFuQyxDQUFiO0FBQ0EsUUFBSSxVQUFVLEtBQUssR0FBTCxDQUFTLENBQVQsRUFBWSxlQUFlLENBQTNCLENBQWQ7QUFDQSxRQUFJLFVBQVUsS0FBSyxHQUFMLENBQVMsQ0FBVCxFQUFZLFlBQVosQ0FBZDs7QUFHQSxTQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksS0FBSyxNQUF6QixFQUFpQyxLQUFLLEtBQUssUUFBM0MsRUFBcUQ7QUFDakQsWUFBSSxPQUFPLENBQUUsS0FBSyxDQUFMLENBQUQsSUFBYSxRQUFkLElBQTBCLE9BQTFCLEdBQ1AsQ0FBRSxLQUFLLElBQUksQ0FBVCxDQUFELElBQWlCLFFBQWxCLElBQThCLE9BRHZCLElBRUwsS0FBSyxJQUFJLENBQVQsQ0FBRCxJQUFpQixRQUZYLENBQVg7QUFHQSxZQUFJLFlBQVksS0FBSyxLQUFyQixFQUE0QjtBQUN4QixtQkFBTyxJQUFQLEtBQWdCLEtBQUssSUFBSSxLQUFLLFFBQVQsR0FBb0IsQ0FBekIsSUFBOEIsS0FBSyxRQUFuRDtBQUNILFNBRkQsTUFFTztBQUNILG1CQUFPLElBQVA7QUFDSDtBQUNKOztBQUVELFdBQU8sTUFBUDtBQUNIOzs7Ozs7OztrQkNqQ3VCLGdCOzs7O0FBQVQsU0FBUyxnQkFBVCxHQUVIO0FBQUEscUVBQUosRUFBSTs7QUFBQSxRQURSLEtBQ1EsUUFEUixLQUNROztBQUNSLFNBQUssZ0JBQUwsQ0FBc0Isa0JBQXRCLEVBQTBDO0FBQ3RDLGtCQUFVLENBQUMsQ0FBRCxFQUFJLEVBQUosQ0FENEI7QUFFdEMsZUFBTztBQUYrQixLQUExQzs7QUFLQSxRQUFJLFFBQVEsQ0FBWjs7QUFFQSxRQUFJLFVBQVUsU0FBZCxFQUF5QjtBQUNyQixhQUFLLElBQUksSUFBSSxLQUFLLFVBQWxCLEVBQThCLElBQUksS0FBSyxJQUFMLENBQVUsTUFBNUMsRUFBb0QsS0FBSyxLQUFLLFFBQTlELEVBQXdFO0FBQ3BFLGdCQUFJLEtBQUssSUFBTCxDQUFVLENBQVYsTUFBaUIsS0FBckIsRUFBNEI7QUFDL0I7QUFDRCxlQUFPLEtBQVA7QUFDSCxLQUxELE1BS087O0FBRUgsZUFBTyxLQUFLLElBQVo7QUFDSDtBQUNKOzs7Ozs7OztRQ25CZSxZLEdBQUEsWTtRQWFBLGEsR0FBQSxhOztBQWhCaEI7Ozs7QUFDQTs7Ozs7O0FBRU8sU0FBUyxZQUFULEdBQXVFO0FBQUEscUVBQUosRUFBSTs7QUFBQSw2QkFBaEQsUUFBZ0Q7QUFBQSxRQUFoRCxRQUFnRCxpQ0FBckMsR0FBcUM7QUFBQSxRQUFoQyxPQUFnQyxRQUFoQyxPQUFnQztBQUFBLDZCQUF2QixRQUF1QjtBQUFBLFFBQXZCLFFBQXVCLGlDQUFaLElBQVk7O0FBQzFFLFNBQUssZ0JBQUwsQ0FBc0IsY0FBdEIsRUFBc0M7QUFDbEMsa0JBQVUsQ0FBQyxDQUFELEVBQUksRUFBSjtBQUR3QixLQUF0QztBQUdBLFFBQUksWUFBWSxTQUFoQixFQUEyQjtBQUN2QixZQUFJLEtBQUssVUFBTCxHQUFrQixDQUF0QixFQUF5QjtBQUNyQixrQkFBTSxJQUFJLFVBQUosQ0FBZSxpRkFBZixDQUFOO0FBQ0g7QUFDRCxrQkFBVSxDQUFWO0FBQ0g7QUFDRCxXQUFPLG9CQUFvQixJQUFwQixDQUF5QixJQUF6QixFQUErQixPQUEvQixFQUF3QyxRQUF4QyxFQUFrRCxRQUFsRCxDQUFQO0FBQ0g7O0FBRU0sU0FBUyxhQUFULEdBQStEO0FBQUEsc0VBQUosRUFBSTs7QUFBQSwrQkFBdkMsUUFBdUM7QUFBQSxRQUF2QyxRQUF1QyxrQ0FBNUIsR0FBNEI7QUFBQSwrQkFBdkIsUUFBdUI7QUFBQSxRQUF2QixRQUF1QixrQ0FBWixJQUFZOztBQUNsRSxTQUFLLGdCQUFMLENBQXNCLGVBQXRCLEVBQXVDO0FBQ25DLGtCQUFVLENBQUMsQ0FBRCxFQUFJLEVBQUo7QUFEeUIsS0FBdkM7QUFHQSxRQUFJLFVBQVUsSUFBSSxLQUFKLENBQVcsUUFBRCxHQUFhLEtBQUssVUFBbEIsR0FBK0IsS0FBSyxRQUE5QyxDQUFkO0FBQ0EsU0FBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLFFBQVEsTUFBNUIsRUFBb0MsR0FBcEMsRUFBeUM7QUFDckMsZ0JBQVEsQ0FBUixJQUFhLG9CQUFvQixJQUFwQixDQUF5QixJQUF6QixFQUErQixDQUEvQixFQUFrQyxRQUFsQyxFQUE0QyxRQUE1QyxDQUFiO0FBQ0g7QUFDRCxXQUFPLE9BQVA7QUFDSDs7QUFHRCxTQUFTLG1CQUFULENBQTZCLE9BQTdCLEVBQXNDLFFBQXRDLEVBQWdELFFBQWhELEVBQTBEO0FBQ3RELFFBQUksV0FBVyxLQUFLLElBQUwsQ0FBVSxRQUFWLENBQWY7QUFDQSxRQUFJLENBQUMseUJBQVUsUUFBVixDQUFMLEVBQTBCO0FBQ3RCLGNBQU0sSUFBSSxVQUFKLENBQWUsMkRBQWYsQ0FBTjtBQUNIOzs7OztBQUtELFFBQUksV0FBVyxDQUFmO0FBQ0EsUUFBSSxLQUFLLFFBQUwsR0FBZ0IsUUFBcEIsRUFBOEIsV0FBVyxLQUFLLFFBQUwsR0FBZ0IsUUFBM0I7O0FBRTlCLFFBQUksT0FBTyxLQUFLLElBQWhCO0FBQ0EsUUFBSSxTQUFTLHdCQUFTLEtBQUssR0FBTCxDQUFTLENBQVQsRUFBWSxLQUFLLEdBQUwsQ0FBUyxLQUFLLFFBQWQsRUFBd0IsUUFBeEIsQ0FBWixDQUFULEVBQXdELENBQXhELENBQWI7QUFDQSxRQUFJLFlBQVksS0FBSyxLQUFyQixFQUE0QjtBQUN4QixZQUFJLG1CQUFtQixLQUFLLFFBQUwsR0FBZ0IsT0FBaEIsR0FBMEIsQ0FBakQ7O0FBRUEsYUFBSyxJQUFJLElBQUksT0FBYixFQUFzQixJQUFJLEtBQUssTUFBL0IsRUFBdUMsS0FBSyxLQUFLLFFBQWpELEVBQTJEO0FBQ3ZELG1CQUFPLEtBQUssQ0FBTCxLQUFXLFFBQWxCLEtBQStCLEtBQUssSUFBSSxnQkFBVCxJQUE2QixLQUFLLFFBQWpFO0FBQ0g7QUFDSixLQU5ELE1BTU87QUFDSCxhQUFLLElBQUksS0FBSSxPQUFiLEVBQXNCLEtBQUksS0FBSyxNQUEvQixFQUF1QyxNQUFLLEtBQUssUUFBakQsRUFBMkQ7QUFDdkQsbUJBQU8sS0FBSyxFQUFMLEtBQVcsUUFBbEI7QUFDSDtBQUNKOztBQUVELFdBQU8sTUFBUDtBQUNIOzs7Ozs7OztrQkNuRHVCLEc7O0FBSnhCOzs7Ozs7OztBQUllLFNBQVMsR0FBVCxHQUFlO0FBQzFCLFNBQUssZ0JBQUwsQ0FBc0IsS0FBdEIsRUFBNkI7QUFDekIsa0JBQVUsQ0FBQyxDQUFELEVBQUksRUFBSjtBQURlLEtBQTdCOztBQUlBLFFBQUksU0FBUyx3QkFBUyxLQUFLLFFBQWQsRUFBdUIsQ0FBQyxRQUF4QixDQUFiOztBQUVBLFNBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxLQUFLLElBQUwsQ0FBVSxNQUE5QixFQUFzQyxLQUFLLEtBQUssUUFBaEQsRUFBMEQ7QUFDdEQsYUFBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLEtBQUssUUFBekIsRUFBbUMsR0FBbkMsRUFBd0M7QUFDcEMsZ0JBQUksS0FBSyxJQUFMLENBQVUsSUFBSSxDQUFkLElBQW1CLE9BQU8sQ0FBUCxDQUF2QixFQUFrQyxPQUFPLENBQVAsSUFBWSxLQUFLLElBQUwsQ0FBVSxJQUFJLENBQWQsQ0FBWjtBQUNyQztBQUNKO0FBQ0QsV0FBTyxNQUFQO0FBRUg7Ozs7Ozs7O2tCQ2R1QixJOztBQUp4Qjs7OztBQUllLFNBQVMsSUFBVCxHQUFnQjtBQUMzQixRQUFJLGFBQWEsS0FBSyxhQUFMLENBQW1CLEVBQUMsVUFBUyxLQUFLLFFBQUwsR0FBZ0IsQ0FBMUIsRUFBbkIsQ0FBakI7QUFDQSxRQUFJLFNBQVMsSUFBSSxLQUFKLENBQVUsV0FBVyxNQUFyQixDQUFiO0FBQ0EsU0FBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLFdBQVcsTUFBL0IsRUFBdUMsR0FBdkMsRUFBNEM7QUFDeEMsWUFBSSxZQUFZLFdBQVcsQ0FBWCxDQUFoQjtBQUNBLGVBQU8sQ0FBUCxJQUFZLHFCQUFjLFNBQWQsQ0FBWjtBQUNIO0FBQ0QsV0FBTyxNQUFQO0FBQ0g7Ozs7Ozs7O2tCQ1R1QixNOztBQUh4Qjs7OztBQUdlLFNBQVMsTUFBVCxHQUFrQjtBQUM3QixRQUFJLGFBQWEsS0FBSyxhQUFMLENBQW1CLEVBQUMsVUFBUyxLQUFLLFFBQUwsR0FBZ0IsQ0FBMUIsRUFBbkIsQ0FBakI7QUFDQSxRQUFJLFNBQVMsSUFBSSxLQUFKLENBQVUsV0FBVyxNQUFyQixDQUFiO0FBQ0EsU0FBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLFdBQVcsTUFBL0IsRUFBdUMsR0FBdkMsRUFBNEM7QUFDeEMsWUFBSSxZQUFZLFdBQVcsQ0FBWCxDQUFoQjtBQUNBLGVBQU8sQ0FBUCxJQUFZLHVCQUFnQixTQUFoQixDQUFaO0FBQ0g7QUFDRCxXQUFPLE1BQVA7QUFDSDs7Ozs7Ozs7a0JDUHVCLEc7O0FBSnhCOzs7Ozs7OztBQUllLFNBQVMsR0FBVCxHQUFlO0FBQzFCLFNBQUssZ0JBQUwsQ0FBc0IsS0FBdEIsRUFBNkI7QUFDekIsa0JBQVUsQ0FBQyxDQUFELEVBQUksRUFBSjtBQURlLEtBQTdCOztBQUlBLFFBQUksU0FBUyx3QkFBUyxLQUFLLFFBQWQsRUFBdUIsQ0FBQyxRQUF4QixDQUFiOztBQUVBLFNBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxLQUFLLElBQUwsQ0FBVSxNQUE5QixFQUFzQyxLQUFLLEtBQUssUUFBaEQsRUFBMEQ7QUFDdEQsYUFBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLEtBQUssUUFBekIsRUFBbUMsR0FBbkMsRUFBd0M7QUFDcEMsZ0JBQUksS0FBSyxJQUFMLENBQVUsSUFBSSxDQUFkLElBQW1CLE9BQU8sQ0FBUCxDQUF2QixFQUFrQyxPQUFPLENBQVAsSUFBWSxLQUFLLElBQUwsQ0FBVSxJQUFJLENBQWQsQ0FBWjtBQUNyQztBQUNKO0FBQ0QsV0FBTyxNQUFQO0FBRUg7Ozs7Ozs7O2tCQ2hCdUIsYzs7O0FBQVQsU0FBUyxjQUFULEdBQTBCO0FBQ3JDLFNBQUssZ0JBQUwsQ0FBc0IsZ0JBQXRCLEVBQXdDO0FBQ3BDLGtCQUFVLENBQUMsQ0FBRDtBQUQwQixLQUF4Qzs7QUFJQSxRQUFJLEtBQUssUUFBTCxLQUFrQixDQUF0QixFQUF5QjtBQUNyQixZQUFJLFNBQVMsSUFBSSxLQUFKLENBQVUsS0FBSyxJQUFmLENBQWI7QUFDQSxZQUFJLFVBQVUsQ0FBZDtBQUNBLGFBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxLQUFLLEtBQXpCLEVBQWdDLEdBQWhDLEVBQXFDO0FBQ2pDLGlCQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksS0FBSyxNQUF6QixFQUFpQyxHQUFqQyxFQUFzQztBQUNsQyxvQkFBSSxLQUFLLFFBQUwsQ0FBYyxDQUFkLEVBQWlCLENBQWpCLE1BQXdCLENBQTVCLEVBQStCO0FBQzNCLDJCQUFPLFNBQVAsSUFBb0IsQ0FBQyxDQUFELEVBQUksQ0FBSixDQUFwQjtBQUNIO0FBQ0o7QUFDSjtBQUNELGVBQU8sTUFBUCxHQUFnQixPQUFoQjtBQUNBLGVBQU8sTUFBUDtBQUNIO0FBQ0o7Ozs7Ozs7O2tCQ1R1QixtQjs7Ozs7Ozs7Ozs7O0FBQVQsU0FBUyxtQkFBVCxDQUE2QixXQUE3QixFQUEwQztBQUNyRCxRQUFJLFNBQVMsV0FBYixFQUEwQixPQUFPLENBQUMsQ0FBRCxFQUFHLENBQUgsQ0FBUDtBQUMxQixRQUFJLFdBQVcsQ0FBQyxDQUFELEVBQUcsQ0FBSCxDQUFmOztBQUVBLFFBQUksZUFBZSxJQUFuQjtBQUNBLFdBQU8sWUFBUCxFQUFxQjtBQUNqQixZQUFJLGlCQUFpQixXQUFyQixFQUFrQyxPQUFPLFFBQVA7QUFDbEMsWUFBSSxhQUFhLFFBQWpCLEVBQTJCO0FBQ3ZCLHFCQUFTLENBQVQsS0FBZSxhQUFhLFFBQWIsQ0FBc0IsQ0FBdEIsQ0FBZjtBQUNBLHFCQUFTLENBQVQsS0FBZSxhQUFhLFFBQWIsQ0FBc0IsQ0FBdEIsQ0FBZjtBQUNIO0FBQ0QsdUJBQWUsYUFBYSxNQUE1QjtBQUNIOztBQUVELFdBQU8sU0FBUDs7QUFFSDs7Ozs7Ozs7a0JDdkJ1QixHOztBQUp4Qjs7Ozs7Ozs7QUFJZSxTQUFTLEdBQVQsR0FBZTtBQUMxQixTQUFLLGdCQUFMLENBQXNCLEtBQXRCLEVBQTZCO0FBQ3pCLGtCQUFVLENBQUMsQ0FBRCxFQUFJLEVBQUo7QUFEZSxLQUE3Qjs7QUFJQSxRQUFJLFNBQVMsd0JBQVMsS0FBSyxRQUFkLEVBQXVCLENBQXZCLENBQWI7O0FBRUEsU0FBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLEtBQUssSUFBTCxDQUFVLE1BQTlCLEVBQXNDLEtBQUssS0FBSyxRQUFoRCxFQUEwRDtBQUN0RCxhQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksS0FBSyxRQUF6QixFQUFtQyxHQUFuQyxFQUF3QztBQUNwQyxtQkFBTyxDQUFQLEtBQWEsS0FBSyxJQUFMLENBQVUsSUFBSSxDQUFkLENBQWI7QUFDSDtBQUNKO0FBQ0QsV0FBTyxNQUFQO0FBRUg7Ozs7Ozs7O2tCQ2hCdUIsTTtBQUZ4QixJQUFJLFNBQVMsUUFBUSxXQUFSLENBQWI7O0FBRWUsU0FBUyxNQUFULEdBQWtCO0FBQzdCLFNBQUssZ0JBQUwsQ0FBc0IsUUFBdEIsRUFBZ0M7QUFDNUIsa0JBQVUsQ0FBQyxDQUFEO0FBRGtCLEtBQWhDOztBQUlBLFdBQU8sT0FBTyxFQUFQLENBQVUsR0FBVixDQUFjLEtBQUssV0FBbkIsQ0FBUDtBQUNIOzs7Ozs7OztBQ1JELElBQUksbUJBQUo7QUFBQSxJQUFnQixpQkFBaEI7QUFBQSxJQUEwQixlQUExQjtBQUFBLElBQWtDLGtCQUFsQztBQUFBLElBQTZDLDBCQUE3QztBQUFBLElBQWdFLFlBQWhFOztBQUVBLElBQUksT0FBTyxJQUFQLEtBQWdCLFdBQXBCLEVBQWlDO0FBQUE7O0FBQzdCLGdCQXdEZ0UsR0F4RGhFLFNBQU0sU0FBTjtBQUNBLFlBQU0sU0FBUyxLQUFLLFFBQUwsQ0FBYyxNQUE3QjtBQUNBLGdCQXNENkMsaUJBdEQ3Qyx1QkFBb0IsMkJBQVUsR0FBVixFQUFlO0FBQy9CLGdCQUFJO0FBQ0Esb0JBQUksWUFBWSxJQUFJLEtBQUssR0FBVCxDQUFhLEdBQWIsQ0FBaEI7QUFDQSx1QkFBTyxVQUFVLE1BQVYsS0FBcUIsTUFBNUI7QUFDSCxhQUhELENBR0UsT0FBTyxDQUFQLEVBQVU7O0FBRVIsdUJBQU8sS0FBUDtBQUNIO0FBQ0osU0FSRDs7QUFVQSxnQkE0Q2tDLFNBNUNsQyxlQUFZLEtBQUssU0FBakI7O0FBRUEsZ0JBMENnQixRQTFDaEIsY0FBVyxLQUFLLEtBQWhCO0FBQ0EsZ0JBeUMwQixNQXpDMUIsWUFBUyxTQUFTLE1BQVQsQ0FBZ0IsS0FBaEIsRUFBdUIsTUFBdkIsRUFBK0I7QUFDcEMsZ0JBQUksU0FBUyxLQUFLLFFBQUwsQ0FBYyxhQUFkLENBQTRCLFFBQTVCLENBQWI7QUFDQSxtQkFBTyxLQUFQLEdBQWUsS0FBZjtBQUNBLG1CQUFPLE1BQVAsR0FBZ0IsTUFBaEI7QUFDQSxtQkFBTyxNQUFQO0FBQ0gsU0FMRDs7QUFPQSxnQkFrQ0ksVUFsQ0osZ0JBQWEsb0JBQVUsR0FBVixFQUFlO0FBQ3hCLG1CQUFPLElBQUksT0FBSixDQUFZLFVBQVUsT0FBVixFQUFtQixNQUFuQixFQUEyQjtBQUMxQyxvQkFBSSxNQUFNLElBQUksS0FBSyxjQUFULEVBQVY7QUFDQSxvQkFBSSxJQUFKLENBQVMsS0FBVCxFQUFnQixHQUFoQixFQUFxQixJQUFyQjtBQUNBLG9CQUFJLFlBQUosR0FBbUIsYUFBbkI7O0FBRUEsb0JBQUksTUFBSixHQUFhLFVBQVUsQ0FBVixFQUFhO0FBQ3RCLHlCQUFLLE1BQUwsS0FBZ0IsR0FBaEIsR0FBc0IsUUFBUSxLQUFLLFFBQWIsQ0FBdEIsR0FBK0MsT0FBTyxjQUFQLEVBQXVCLENBQXZCLENBQS9DO0FBQ0gsaUJBRkQ7QUFHQSxvQkFBSSxPQUFKLEdBQWMsTUFBZDtBQUNBLG9CQUFJLElBQUo7QUFDSCxhQVZNLENBQVA7QUFXSCxTQVpEO0FBdkI2QjtBQW9DaEMsQ0FwQ0QsTUFvQ08sSUFBSSxPQUFPLE1BQVAsS0FBa0IsV0FBbEIsSUFBaUMsT0FBTyxPQUE1QyxFQUFxRDtBQUFBOztBQUN4RCxnQkFvQmdFLEdBcEJoRSxTQUFNLE1BQU47QUFDQSxnQkFtQjZDLGlCQW5CN0MsdUJBQW9CLDJCQUFVLEdBQVYsRUFBZTtBQUMvQixtQkFBTyxLQUFQO0FBQ0gsU0FGRDs7QUFJQSxZQUFNLFNBQVMsUUFBUSxRQUFSLENBQWY7QUFDQSxnQkFjZ0IsUUFkaEIsY0FBVyxPQUFPLEtBQWxCO0FBQ0EsZ0JBYTBCLE1BYjFCLFlBQVMsTUFBVDtBQUNBLGdCQVlrQyxTQVpsQyxlQUFZLE9BQU8sU0FBbkI7O0FBRUEsWUFBTSxLQUFLLFFBQVEsSUFBUixDQUFYO0FBQ0EsZ0JBU0ksVUFUSixnQkFBYSxvQkFBVSxJQUFWLEVBQWdCO0FBQ3pCLG1CQUFPLElBQUksT0FBSixDQUFZLFVBQVUsT0FBVixFQUFtQixNQUFuQixFQUEyQjtBQUMxQyxtQkFBRyxRQUFILENBQVksSUFBWixFQUFrQixVQUFVLEdBQVYsRUFBZSxJQUFmLEVBQXFCO0FBQ25DLDBCQUFNLE9BQU8sR0FBUCxDQUFOLEdBQW9CLFFBQVEsS0FBSyxNQUFiLENBQXBCO0FBQ0gsaUJBRkQ7QUFHSCxhQUpNLENBQVA7QUFLSCxTQU5EO0FBWndEO0FBbUIzRDs7UUFFTyxVLEdBQUEsVTtRQUFZLFEsR0FBQSxRO1FBQVUsTSxHQUFBLE07UUFBUSxTLEdBQUEsUztRQUFXLGlCLEdBQUEsaUI7UUFBbUIsRyxHQUFBLEc7Ozs7Ozs7O2tCQ0M1QyxNOztBQTNEeEI7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBR0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFHQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUdBOztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7Ozs7OztBQUVlLFNBQVMsTUFBVCxDQUFnQixLQUFoQixFQUF1QjtBQUNsQyxRQUFJLFVBQVUsRUFBQyxTQUFTLElBQVYsRUFBZDtBQUNBLFFBQUksZUFBZSxFQUFDLFNBQVMsSUFBVixFQUFnQixPQUFPLElBQXZCLEVBQW5CO0FBQ0EsUUFBSSxRQUFRLEVBQUMsT0FBTyxJQUFSLEVBQVo7O0FBRUEsVUFBTSxZQUFOLENBQW1CLGNBQW5CLDBCQUFpRCxPQUFqRDtBQUNBLFVBQU0sWUFBTixDQUFtQixnQkFBbkIsNEJBQXFELE9BQXJEO0FBQ0EsVUFBTSxZQUFOLENBQW1CLGFBQW5CLHlCQUErQyxPQUEvQztBQUNBLFVBQU0sWUFBTixDQUFtQixlQUFuQiwyQkFBbUQsT0FBbkQ7QUFDQSxVQUFNLFlBQU4sQ0FBbUIsYUFBbkIseUJBQStDLE9BQS9DO0FBQ0EsVUFBTSxZQUFOLENBQW1CLFFBQW5CLG9CQUFxQyxZQUFyQztBQUNBLFVBQU0sWUFBTixDQUFtQixrQkFBbkIsOEJBQXlELE9BQXpEO0FBQ0EsVUFBTSxZQUFOLENBQW1CLE9BQW5CLG1CQUFtQyxPQUFuQztBQUNBLFVBQU0sWUFBTixDQUFtQixLQUFuQixpQkFBK0IsT0FBL0I7QUFDQSxVQUFNLFlBQU4sQ0FBbUIsVUFBbkIsc0JBQXlDLE9BQXpDO0FBQ0EsVUFBTSxZQUFOLENBQW1CLFVBQW5CLHNCQUF5QyxPQUF6QztBQUNBLFVBQU0sWUFBTixDQUFtQixRQUFuQixvQkFBcUMsT0FBckM7QUFDQSxVQUFNLFlBQU4sQ0FBbUIsWUFBbkI7QUFDQSxVQUFNLFlBQU4sQ0FBbUIsZUFBbkI7O0FBRUEsVUFBTSxZQUFOLENBQW1CLFlBQW5CO0FBQ0EsVUFBTSxZQUFOLENBQW1CLGNBQW5CO0FBQ0EsVUFBTSxZQUFOLENBQW1CLGdCQUFuQjtBQUNBLFVBQU0sWUFBTixDQUFtQixhQUFuQjs7QUFFQSxVQUFNLFlBQU4sQ0FBbUIsTUFBbkIsa0JBQWlDLEtBQWpDO0FBQ0EsVUFBTSxZQUFOLENBQW1CLE9BQW5CLG1CQUFtQyxLQUFuQztBQUNBLFVBQU0sWUFBTixDQUFtQixLQUFuQjtBQUNBLFVBQU0sWUFBTixDQUFtQixLQUFuQjtBQUNBLFVBQU0sWUFBTixDQUFtQixPQUFuQjtBQUNBLFVBQU0sWUFBTixDQUFtQixNQUFuQixrQkFBaUMsWUFBakMsQ0FBOEMsTUFBOUM7QUFDQSxVQUFNLFlBQU4sQ0FBbUIsTUFBbkI7QUFDQSxVQUFNLFlBQU4sQ0FBbUIsS0FBbkI7QUFDQSxVQUFNLFlBQU4sQ0FBbUIsY0FBbkI7QUFDQSxVQUFNLFlBQU4sQ0FBbUIsWUFBbkI7QUFDQSxVQUFNLFlBQU4sQ0FBbUIsV0FBbkIsdUJBQTJDLE9BQTNDOztBQUVBLFVBQU0sWUFBTixDQUFtQixRQUFuQjtBQUNBLFVBQU0sWUFBTixDQUFtQixXQUFuQjs7QUFFQSxVQUFNLFlBQU4sQ0FBbUIsT0FBbkI7QUFDQSxVQUFNLFlBQU4sQ0FBbUIsWUFBbkI7QUFDQSxVQUFNLFlBQU4sQ0FBbUIsWUFBbkI7QUFDQSxVQUFNLFlBQU4sQ0FBbUIsZUFBbkI7QUFDQSxVQUFNLFlBQU4sQ0FBbUIsZUFBbkI7QUFDQSxVQUFNLFlBQU4sQ0FBbUIsY0FBbkI7O0FBRUEsVUFBTSxZQUFOLENBQW1CLFlBQW5CLHdCQUE2QyxPQUE3QztBQUNBLFVBQU0sWUFBTixDQUFtQixhQUFuQix5QkFBK0MsT0FBL0M7QUFDQSxVQUFNLFlBQU4sQ0FBbUIsU0FBbkI7QUFDQSxVQUFNLFlBQU4sQ0FBbUIsYUFBbkI7O0FBRUEsVUFBTSxZQUFOLENBQW1CLGtCQUFuQjtBQUNBLFVBQU0sWUFBTixDQUFtQixjQUFuQiwyQkFBaUQsY0FBakQsQ0FBZ0UsV0FBaEU7QUFDQSxVQUFNLFlBQU4sQ0FBbUIsZUFBbkIsNEJBQW1ELGNBQW5ELENBQWtFLFlBQWxFO0FBQ0EsVUFBTSxZQUFOLENBQW1CLG1CQUFuQiw0QkFBMkQsY0FBM0QsQ0FBMEUsZ0JBQTFFO0FBQ0EsVUFBTSxZQUFOLENBQW1CLFFBQW5CLGlCQUFxQyxjQUFyQyxDQUFvRCxLQUFwRDtBQUNBLFVBQU0sWUFBTixDQUFtQixRQUFuQixpQkFBcUMsY0FBckMsQ0FBb0QsS0FBcEQ7QUFDQSxVQUFNLFlBQU4sQ0FBbUIsUUFBbkIsaUJBQXFDLGNBQXJDLENBQW9ELEtBQXBEO0FBQ0EsVUFBTSxZQUFOLENBQW1CLFdBQW5CLGlCQUF3QyxjQUF4QyxDQUF1RCxRQUF2RDtBQUNBLFVBQU0sWUFBTixDQUFtQixTQUFuQixrQkFBdUMsY0FBdkMsQ0FBc0QsTUFBdEQ7QUFDQSxVQUFNLFlBQU4sQ0FBbUIsZ0JBQW5CLHlCQUFxRCxjQUFyRCxDQUFvRSxhQUFwRTtBQUNBLFVBQU0sWUFBTixDQUFtQixxQkFBbkI7QUFDQSxVQUFNLFlBQU4sQ0FBbUIsUUFBbkIsaUJBQXFDLGNBQXJDLENBQW9ELEtBQXBEO0FBQ0g7Ozs7Ozs7Ozs7a0JDeEh1QixHOztBQUp4Qjs7QUFDQTs7OztBQUNBOzs7O0FBRWUsU0FBUyxHQUFULENBQWEsS0FBYixFQUFxQztBQUFBLHFFQUFKLEVBQUk7O0FBQUEsUUFBaEIsUUFBZ0IsUUFBaEIsUUFBZ0I7O0FBQ2hELFNBQUssZ0JBQUwsQ0FBc0IsS0FBdEIsRUFBNkI7QUFDekIsa0JBQVUsQ0FBQyxDQUFELEVBQUksRUFBSjtBQURlLEtBQTdCOztBQUlBLGVBQVcsc0NBQXdCLElBQXhCLEVBQThCLEVBQUMsVUFBUyxRQUFWLEVBQTlCLENBQVg7QUFDQSxZQUFRLDZCQUFpQixLQUFqQixDQUFSOzs7QUFHQSxRQUFJLENBQUMsTUFBTSxLQUFOLENBQUwsRUFBbUI7QUFDZixhQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksU0FBUyxNQUE3QixFQUFxQyxHQUFyQyxFQUEwQztBQUN0QyxnQkFBSSxJQUFJLFNBQVMsQ0FBVCxDQUFSO0FBQ0EsaUJBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxLQUFLLElBQUwsQ0FBVSxNQUE5QixFQUFzQyxLQUFLLEtBQUssUUFBaEQsRUFBMEQ7QUFDdEQscUJBQUssSUFBTCxDQUFVLElBQUksQ0FBZCxJQUFtQixLQUFLLEdBQUwsQ0FBUyxLQUFLLFFBQWQsRUFBeUIsS0FBSyxJQUFMLENBQVUsSUFBSSxDQUFkLElBQW1CLEtBQXBCLElBQThCLENBQXRELENBQW5CO0FBQ0g7QUFDSjtBQUNKLEtBUEQsTUFPTztBQUNILFlBQUksS0FBSyxJQUFMLENBQVUsTUFBVixLQUFxQixNQUFNLE1BQS9CLEVBQXVDO0FBQ25DLGtCQUFNLElBQUksS0FBSixDQUFVLGlDQUFWLENBQU47QUFDSDtBQUNELGFBQUssSUFBSSxLQUFJLENBQWIsRUFBZ0IsS0FBSSxTQUFTLE1BQTdCLEVBQXFDLElBQXJDLEVBQTBDO0FBQ3RDLGdCQUFJLEtBQUksU0FBUyxFQUFULENBQVI7QUFDQSxpQkFBSyxJQUFJLEtBQUksQ0FBYixFQUFnQixLQUFJLEtBQUssSUFBTCxDQUFVLE1BQTlCLEVBQXNDLE1BQUssS0FBSyxRQUFoRCxFQUEwRDtBQUN0RCxxQkFBSyxJQUFMLENBQVUsS0FBSSxFQUFkLElBQW1CLEtBQUssR0FBTCxDQUFTLENBQVQsRUFBVyxLQUFLLEdBQUwsQ0FBUyxLQUFLLFFBQWQsRUFBeUIsS0FBSyxJQUFMLENBQVUsS0FBSSxFQUFkLElBQW1CLE1BQU0sS0FBSSxFQUFWLENBQXBCLElBQXFDLENBQTdELENBQVgsQ0FBbkI7QUFDSDtBQUNKO0FBQ0o7QUFDSjs7Ozs7Ozs7a0JDM0J1QixVOztBQUp4Qjs7OztBQUNBOzs7Ozs7O0FBR2UsU0FBUyxVQUFULENBQW9CLENBQXBCLEVBQXVCOztBQUVsQyxTQUFLLGdCQUFMLENBQXNCLFlBQXRCLEVBQW9DO0FBQ2hDLG9CQUFXLENBQUMsQ0FBRCxDQURxQjtBQUVoQyxrQkFBUyxDQUFDLENBQUQsRUFBRyxFQUFIO0FBRnVCLEtBQXBDOztBQUtBLFFBQUksSUFBSSxDQUFSLEVBQVc7QUFBQyxjQUFNLElBQUksS0FBSixDQUFVLDZDQUFWLENBQU47QUFBZ0U7O0FBRTVFLFFBQUksSUFBSSxJQUFJLENBQUosR0FBUSxDQUFoQjtBQUNBLFFBQUksT0FBTyxJQUFJLENBQWY7QUFDQSxRQUFJLFNBQVMsSUFBSSxLQUFKLENBQVUsSUFBVixDQUFiOztBQUVBLFNBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxPQUFPLE1BQTNCLEVBQW1DLEdBQW5DLEVBQXdDO0FBQ3BDLGVBQU8sQ0FBUCxJQUFZLENBQVo7QUFDSDs7QUFFRCxXQUFPLHNCQUFZLElBQVosQ0FBaUIsSUFBakIsRUFBdUIsTUFBdkIsQ0FBUDtBQUNIOzs7Ozs7OztrQkNsQnVCLEc7O0FBSnhCOztBQUNBOzs7O0FBQ0E7Ozs7QUFFZSxTQUFTLEdBQVQsQ0FBYSxLQUFiLEVBQXFDO0FBQUEscUVBQUosRUFBSTs7QUFBQSxRQUFoQixRQUFnQixRQUFoQixRQUFnQjs7QUFDaEQsU0FBSyxnQkFBTCxDQUFzQixRQUF0QixFQUFnQztBQUM1QixrQkFBVSxDQUFDLENBQUQsRUFBSSxFQUFKO0FBRGtCLEtBQWhDOztBQUlBLGVBQVcsc0NBQXdCLElBQXhCLEVBQThCLEVBQUMsVUFBUyxRQUFWLEVBQTlCLENBQVg7QUFDQSxZQUFRLDZCQUFpQixLQUFqQixDQUFSOztBQUVBLFFBQUksQ0FBQyxNQUFNLEtBQU4sQ0FBTCxFQUFtQjtBQUNmLGFBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxTQUFTLE1BQTdCLEVBQXFDLEdBQXJDLEVBQTBDO0FBQ3RDLGdCQUFJLElBQUksU0FBUyxDQUFULENBQVI7QUFDQSxpQkFBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLEtBQUssSUFBTCxDQUFVLE1BQTlCLEVBQXNDLEtBQUssS0FBSyxRQUFoRCxFQUEwRDtBQUN0RCxxQkFBSyxJQUFMLENBQVUsSUFBSSxDQUFkLElBQW1CLEtBQUssR0FBTCxDQUFTLEtBQUssUUFBZCxFQUF5QixLQUFLLElBQUwsQ0FBVSxJQUFJLENBQWQsSUFBbUIsS0FBcEIsSUFBOEIsQ0FBdEQsQ0FBbkI7QUFDSDtBQUNKO0FBQ0osS0FQRCxNQU9PO0FBQ0gsWUFBSSxLQUFLLElBQUwsQ0FBVSxNQUFWLEtBQXFCLE1BQU0sTUFBL0IsRUFBdUM7QUFDbkMsa0JBQU0sSUFBSSxLQUFKLENBQVUseUNBQVYsQ0FBTjtBQUNIO0FBQ0QsYUFBSyxJQUFJLEtBQUksQ0FBYixFQUFnQixLQUFJLFNBQVMsTUFBN0IsRUFBcUMsSUFBckMsRUFBMEM7QUFDdEMsZ0JBQUksS0FBSSxTQUFTLEVBQVQsQ0FBUjtBQUNBLGlCQUFLLElBQUksS0FBSSxDQUFiLEVBQWdCLEtBQUksS0FBSyxJQUFMLENBQVUsTUFBOUIsRUFBc0MsTUFBSyxLQUFLLFFBQWhELEVBQTBEO0FBQ3RELHFCQUFLLElBQUwsQ0FBVSxLQUFJLEVBQWQsSUFBbUIsS0FBSyxHQUFMLENBQVMsQ0FBVCxFQUFZLEtBQUssR0FBTCxDQUFTLEtBQUssUUFBZCxFQUF5QixLQUFLLElBQUwsQ0FBVSxLQUFJLEVBQWQsSUFBbUIsTUFBTSxLQUFJLEVBQVYsQ0FBcEIsSUFBcUMsQ0FBN0QsQ0FBWixDQUFuQjtBQUNIO0FBQ0o7QUFDSjtBQUNKOzs7Ozs7OztrQkMzQnVCLGM7O0FBSHhCOzs7O0FBQ0E7Ozs7OztBQUVlLFNBQVMsY0FBVCxHQUtOO0FBQUEsa0VBQUosRUFBSTs7QUFBQSx3QkFKUixNQUlRO0FBQUEsS0FKUixNQUlRLCtCQUpDLENBSUQ7QUFBQSxLQUhSLEtBR1EsUUFIUixLQUdRO0FBQUEsS0FGUixRQUVRLFFBRlIsUUFFUTtBQUFBLHdCQURSLE1BQ1E7QUFBQSxLQURSLE1BQ1EsK0JBREMsTUFDRDs7O0FBRVIsTUFBSyxnQkFBTCxDQUFzQixnQkFBdEIsRUFBd0M7QUFDdkMsWUFBVSxDQUFDLENBQUQsRUFBSSxFQUFKO0FBRDZCLEVBQXhDOztBQUlBLEtBQUksZUFBSjtBQUNBLEtBQUksS0FBSixFQUFXO0FBQ1YsV0FBUyxlQUFlLEtBQWYsQ0FBVDtBQUNBLEVBRkQsTUFFTzs7QUFFTixVQUFRLE9BQU8sU0FBUyxDQUFoQixJQUFxQixHQUE3QjtBQUNBLFdBQVMsVUFBVSxNQUFWLEVBQWtCLEtBQWxCLENBQVQ7QUFDQTs7QUFFRCxRQUFPLHNCQUFZLElBQVosQ0FBaUIsSUFBakIsRUFBdUIsTUFBdkIsRUFBK0I7QUFDckMsVUFBUSxNQUQ2QjtBQUVyQyxZQUFVO0FBRjJCLEVBQS9CLENBQVA7QUFJQTs7QUFFRCxTQUFTLFNBQVQsQ0FBbUIsTUFBbkIsRUFBMkIsS0FBM0IsRUFBa0M7QUFDakMsS0FBSSxTQUFTLENBQWIsRUFBZ0I7QUFDZixRQUFNLElBQUksVUFBSixDQUFlLGdDQUFmLENBQU47QUFDQTtBQUNELEtBQUksSUFBSSxJQUFJLE1BQUosR0FBYSxDQUFyQjs7QUFFQSxLQUFJLFNBQVMsSUFBSSxLQUFKLENBQVUsSUFBSSxDQUFkLENBQWI7OztBQUdBLEtBQUksU0FBUyxLQUFLLFFBQVEsS0FBYixDQUFiLEM7QUFDQSxLQUFJLFlBQVksS0FBSyxFQUFMLEdBQVUsTUFBMUIsQzs7QUFFQSxNQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLEtBQUssTUFBckIsRUFBNkIsR0FBN0IsRUFBa0M7QUFDakMsT0FBSyxJQUFJLElBQUksQ0FBYixFQUFnQixLQUFLLE1BQXJCLEVBQTZCLEdBQTdCLEVBQWtDO0FBQ2pDLE9BQUksUUFBUSxLQUFLLEdBQUwsQ0FBUyxFQUFHLElBQUksQ0FBTCxHQUFXLElBQUksQ0FBakIsSUFBdUIsTUFBaEMsSUFBMEMsU0FBdEQ7QUFDQSxVQUFPLENBQUMsSUFBSSxNQUFMLElBQWUsQ0FBZixJQUFvQixJQUFJLE1BQXhCLENBQVAsSUFBMEMsS0FBMUM7QUFDQSxVQUFPLENBQUMsSUFBSSxNQUFMLElBQWUsQ0FBZixJQUFvQixDQUFDLENBQUQsR0FBSyxNQUF6QixDQUFQLElBQTJDLEtBQTNDO0FBQ0EsVUFBTyxDQUFDLENBQUMsQ0FBRCxHQUFLLE1BQU4sSUFBZ0IsQ0FBaEIsSUFBcUIsSUFBSSxNQUF6QixDQUFQLElBQTJDLEtBQTNDO0FBQ0EsVUFBTyxDQUFDLENBQUMsQ0FBRCxHQUFLLE1BQU4sSUFBZ0IsQ0FBaEIsSUFBcUIsQ0FBQyxDQUFELEdBQUssTUFBMUIsQ0FBUCxJQUE0QyxLQUE1QztBQUNBLFVBQU8sQ0FBQyxJQUFJLE1BQUwsSUFBZSxDQUFmLElBQW9CLElBQUksTUFBeEIsQ0FBUCxJQUEwQyxLQUExQztBQUNBLFVBQU8sQ0FBQyxJQUFJLE1BQUwsSUFBZSxDQUFmLElBQW9CLENBQUMsQ0FBRCxHQUFLLE1BQXpCLENBQVAsSUFBMkMsS0FBM0M7QUFDQSxVQUFPLENBQUMsQ0FBQyxDQUFELEdBQUssTUFBTixJQUFnQixDQUFoQixJQUFxQixJQUFJLE1BQXpCLENBQVAsSUFBMkMsS0FBM0M7QUFDQSxVQUFPLENBQUMsQ0FBQyxDQUFELEdBQUssTUFBTixJQUFnQixDQUFoQixJQUFxQixDQUFDLENBQUQsR0FBSyxNQUExQixDQUFQLElBQTRDLEtBQTVDO0FBQ0E7QUFDRDtBQUNELFFBQU8sTUFBUDtBQUNBOztBQUVELFNBQVMsY0FBVCxDQUF3QixLQUF4QixFQUErQjtBQUM5QixLQUFJLFNBQVMsQ0FBYixFQUFnQjtBQUNmLFFBQU0sSUFBSSxVQUFKLENBQWUsK0JBQWYsQ0FBTjtBQUNBO0FBQ0QsS0FBSSxTQUFTLEtBQUssUUFBUSxLQUFiLENBQWIsQztBQUNBLEtBQUksWUFBWSxLQUFLLEVBQUwsR0FBVSxNQUExQixDO0FBQ0EsS0FBSSxRQUFRLElBQUksU0FBaEI7QUFDQSxLQUFJLE1BQU0sS0FBVjtBQUNBLEtBQUksWUFBWSxDQUFoQjs7QUFFQSxRQUFPLE1BQU0sSUFBYixFQUFtQjtBQUNsQjtBQUNBLFVBQVEsS0FBSyxHQUFMLENBQVMsRUFBRSxZQUFZLFNBQWQsSUFBMkIsTUFBcEMsSUFBOEMsU0FBdEQ7QUFDQSxTQUFPLElBQUksS0FBWDtBQUNBLE9BQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxTQUFwQixFQUErQixHQUEvQixFQUFvQztBQUNuQyxXQUFRLEtBQUssR0FBTCxDQUFTLEVBQUcsSUFBSSxDQUFMLEdBQVcsWUFBWSxTQUF6QixJQUF1QyxNQUFoRCxJQUEwRCxTQUFsRTtBQUNBLFVBQU8sSUFBSSxLQUFYO0FBQ0E7QUFDRCxVQUFRLElBQUksS0FBSyxHQUFMLENBQVMsRUFBRSxJQUFJLFNBQUosR0FBZ0IsU0FBbEIsSUFBK0IsTUFBeEMsQ0FBSixHQUFzRCxTQUE5RDtBQUNBLFNBQVEsS0FBUjtBQUNBOzs7QUFHRCxLQUFJLE1BQU0sQ0FBVixFQUFhO0FBQ1osUUFBTSxJQUFJLEtBQUosQ0FBVSx1QkFBVixDQUFOO0FBQ0E7O0FBRUQsUUFBTyxVQUFVLFNBQVYsRUFBcUIsS0FBckIsQ0FBUDtBQUNBOzs7Ozs7OztrQkNsRnVCLGE7O0FBSHhCOztBQUNBOzs7Ozs7QUFFZSxTQUFTLGFBQVQsQ0FBdUIsV0FBdkIsRUFBb0MsTUFBcEMsRUFBNEMsT0FBNUMsRUFBcUQ7QUFDaEUsUUFBTSxRQUFRLHdDQUEwQixXQUExQixFQUF1QyxNQUF2QyxFQUErQyxPQUEvQyxDQUFkO0FBQ0EsUUFBTSxpQkFBaUIsSUFBSSxLQUFKLENBQVUsS0FBSyxJQUFmLENBQXZCO0FBQ0EsU0FBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLEtBQUssS0FBekIsRUFBZ0MsR0FBaEMsRUFBcUM7QUFDakMsYUFBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLEtBQUssTUFBekIsRUFBaUMsR0FBakMsRUFBc0M7QUFDbEMsMkJBQWUsSUFBSSxLQUFLLEtBQVQsR0FBaUIsQ0FBaEMsSUFBcUMsQ0FBQyxDQUFELEVBQUksQ0FBSixDQUFyQztBQUNIO0FBQ0o7QUFDRCxRQUFNLFNBQVMsTUFBTSxPQUFOLENBQWMsY0FBZCxDQUFmO0FBQ0EsUUFBTSxhQUFhLGdCQUFNLFVBQU4sQ0FBaUIsSUFBakIsQ0FBbkI7QUFDQSxTQUFLLElBQUksS0FBSSxDQUFiLEVBQWdCLEtBQUksS0FBSyxJQUF6QixFQUErQixJQUEvQixFQUFvQztBQUNoQyxtQkFBVyxJQUFYLENBQWdCLEVBQWhCLElBQXFCLEtBQUssR0FBTCxDQUFTLEtBQUssUUFBZCxFQUF3QixLQUFLLEdBQUwsQ0FBUyxDQUFULEVBQVksT0FBTyxFQUFQLEVBQVUsQ0FBVixDQUFaLENBQXhCLENBQXJCO0FBQ0g7QUFDRCxXQUFPLFVBQVA7QUFDSDs7Ozs7Ozs7a0JDZHVCLFU7O0FBSHhCOztBQUNBOzs7Ozs7QUFFZSxTQUFTLFVBQVQsQ0FBb0IsVUFBcEIsRUFBMkQ7QUFBQSxxRUFBSixFQUFJOztBQUFBLFFBQTFCLFFBQTBCLFFBQTFCLFFBQTBCO0FBQUEsUUFBaEIsUUFBZ0IsUUFBaEIsUUFBZ0I7O0FBQ3RFLFNBQUssZ0JBQUwsQ0FBc0IsWUFBdEIsRUFBb0M7QUFDaEMsa0JBQVUsQ0FBQyxDQUFELEVBQUksRUFBSixFQUFRLEVBQVI7QUFEc0IsS0FBcEM7QUFHQSxRQUFJLEtBQUssS0FBTCxLQUFlLFdBQVcsS0FBMUIsSUFBbUMsS0FBSyxNQUFMLEtBQWdCLFdBQVcsTUFBbEUsRUFBMEU7QUFDdEUsY0FBTSxJQUFJLEtBQUosQ0FBVSxpREFBVixDQUFOO0FBQ0g7QUFDRCxRQUFJLEtBQUssS0FBTCxLQUFlLFdBQVcsS0FBMUIsSUFBbUMsS0FBSyxRQUFMLEtBQWtCLFdBQVcsUUFBcEUsRUFBOEU7QUFDMUUsY0FBTSxJQUFJLEtBQUosQ0FBVSwrREFBVixDQUFOO0FBQ0g7QUFDRCxRQUFJLEtBQUssUUFBTCxLQUFrQixXQUFXLFFBQWpDLEVBQTJDO0FBQ3ZDLGNBQU0sSUFBSSxLQUFKLENBQVUsK0RBQVYsQ0FBTjtBQUNIOztBQUVELFFBQUksV0FBVyxnQkFBTSxVQUFOLENBQWlCLElBQWpCLEVBQXVCLEVBQUMsVUFBUyxRQUFWLEVBQXZCLENBQWY7O0FBRUEsZUFBVyxzQ0FBd0IsSUFBeEIsRUFBOEIsRUFBQyxVQUFTLFFBQVYsRUFBOUIsQ0FBWDs7QUFFQSxRQUFJLFVBQVUsU0FBUyxTQUF2Qjs7QUFFQSxTQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksU0FBUyxNQUE3QixFQUFxQyxHQUFyQyxFQUEwQztBQUN0QyxZQUFJLElBQUksU0FBUyxDQUFULENBQVI7QUFDQSxhQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksS0FBSyxJQUFMLENBQVUsTUFBOUIsRUFBc0MsS0FBSyxLQUFLLFFBQWhELEVBQTBEO0FBQ3RELGdCQUFJLFFBQVEsS0FBSyxJQUFMLENBQVUsS0FBSyxJQUFMLENBQVUsQ0FBVixJQUFlLEtBQUssSUFBTCxDQUFVLENBQVYsQ0FBZixHQUE4QixXQUFXLElBQVgsQ0FBZ0IsQ0FBaEIsSUFBcUIsV0FBVyxJQUFYLENBQWdCLENBQWhCLENBQTdELENBQVo7QUFDQSxnQkFBSSxPQUFKLEVBQWE7O0FBQ1QseUJBQVMsSUFBVCxDQUFjLENBQWQsSUFBbUIsS0FBSyxHQUFMLENBQVMsS0FBSyxHQUFMLENBQVMsS0FBSyxLQUFMLENBQVcsS0FBWCxDQUFULEVBQTJCLENBQTNCLENBQVQsRUFBdUMsU0FBUyxRQUFoRCxDQUFuQjtBQUNILGFBRkQsTUFFTztBQUNILHlCQUFTLElBQVQsQ0FBYyxDQUFkLElBQW1CLEtBQW5CO0FBQ0g7QUFDSjtBQUNKOztBQUVELFdBQU8sUUFBUDtBQUNIOzs7Ozs7OztrQkNoQ3VCLE07O0FBRnhCOztBQUVlLFNBQVMsTUFBVCxHQUFpQztBQUFBLHFFQUFKLEVBQUk7O0FBQUEsUUFBaEIsUUFBZ0IsUUFBaEIsUUFBZ0I7O0FBQzVDLFNBQUssZ0JBQUwsQ0FBc0IsZUFBdEIsRUFBdUM7QUFDbkMsa0JBQVUsQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFPLEVBQVA7QUFEeUIsS0FBdkM7O0FBSUEsUUFBSSxLQUFLLFFBQUwsS0FBa0IsQ0FBdEIsRUFBeUI7Ozs7QUFJckIsWUFBSSxPQUFPLEtBQUssSUFBaEI7QUFDQSxhQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksS0FBSyxNQUF6QixFQUFpQyxHQUFqQyxFQUFzQztBQUNsQyxpQkFBSyxDQUFMLElBQVUsQ0FBQyxLQUFLLENBQUwsQ0FBWDtBQUNIO0FBQ0osS0FSRCxNQVFPO0FBQ0gsbUJBQVcsc0NBQXdCLElBQXhCLEVBQThCLFFBQTlCLEVBQXdDLElBQXhDLENBQVg7O0FBRUEsWUFBSSxRQUFPLEtBQUssSUFBaEI7Ozs7QUFJQSxhQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksU0FBUyxNQUE3QixFQUFxQyxHQUFyQyxFQUEwQztBQUN0QyxnQkFBSSxJQUFJLFNBQVMsQ0FBVCxDQUFSO0FBQ0EsaUJBQUssSUFBSSxLQUFJLENBQWIsRUFBZ0IsS0FBSSxNQUFLLE1BQXpCLEVBQWlDLE1BQUssS0FBSyxRQUEzQyxFQUFxRDtBQUNqRCxzQkFBSyxFQUFMLElBQVUsS0FBSyxRQUFMLEdBQWdCLE1BQUssRUFBTCxDQUExQjtBQUNIO0FBQ0o7QUFDSjtBQUNKLEM7Ozs7Ozs7O2tCQ3hCdUIsVzs7Ozs7Ozs7QUFBVCxTQUFTLFdBQVQsR0FBdUI7O0FBSWxDLFFBQUksS0FBSyxRQUFMLEtBQWtCLENBQXRCLEVBQXlCOzs7O0FBSXJCLFlBQUksT0FBTyxLQUFLLElBQWhCO0FBQ0EsYUFBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLEtBQUssTUFBekIsRUFBaUMsR0FBakMsRUFBc0M7QUFDbEMsaUJBQUssQ0FBTCxJQUFVLENBQUMsS0FBSyxDQUFMLENBQVg7QUFDSDtBQUNKLEtBUkQsTUFRTztBQUNILGFBQUssZ0JBQUwsQ0FBc0IsYUFBdEIsRUFBcUM7QUFDakMsc0JBQVUsQ0FBQyxDQUFELEVBQUksRUFBSjtBQUR1QixTQUFyQztBQUdBLGFBQUssS0FBTCxDQUFXLFVBQVUsS0FBVixFQUFpQjtBQUN4QixpQkFBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLEtBQUssVUFBekIsRUFBcUMsR0FBckMsRUFBMEM7QUFDdEMscUJBQUssSUFBTCxDQUFVLFFBQVEsQ0FBbEIsSUFBdUIsS0FBSyxRQUFMLEdBQWdCLEtBQUssSUFBTCxDQUFVLFFBQVEsQ0FBbEIsQ0FBdkM7QUFDSDtBQUNKLFNBSkQ7QUFLSDtBQUNKOzs7Ozs7OztrQkM3QnVCLGdCO0FBQVQsU0FBUyxnQkFBVCxHQUE0QjtBQUN2QyxTQUFLLGdCQUFMLENBQXNCLGtCQUF0QixFQUEwQztBQUN0QyxrQkFBVSxDQUFDLENBQUQ7QUFENEIsS0FBMUM7O0FBSUEsU0FBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLEtBQUssSUFBekIsRUFBK0IsR0FBL0IsRUFBb0M7QUFDaEMsYUFBSyxTQUFMLENBQWUsQ0FBZjtBQUNIO0FBQ0o7Ozs7Ozs7O2tCQ1J1QixNO0FBQVQsU0FBUyxNQUFULEdBQWtCO0FBQzdCLFNBQUssZ0JBQUwsQ0FBc0IsUUFBdEIsRUFBZ0M7QUFDNUIsa0JBQVUsQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFPLEVBQVA7QUFEa0IsS0FBaEM7O0FBSUEsUUFBSSxLQUFLLFFBQUwsS0FBa0IsQ0FBdEIsRUFBeUI7Ozs7QUFJckIsWUFBSSxPQUFPLEtBQUssSUFBaEI7QUFDQSxhQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksS0FBSyxNQUF6QixFQUFpQyxHQUFqQyxFQUFzQztBQUNsQyxpQkFBSyxDQUFMLElBQVUsQ0FBQyxLQUFLLENBQUwsQ0FBWDtBQUNIO0FBQ0osS0FSRCxNQVFPO0FBQ0gsYUFBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLEtBQUssS0FBekIsRUFBZ0MsR0FBaEMsRUFBcUM7QUFDakMsaUJBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxLQUFLLE1BQXpCLEVBQWlDLEdBQWpDLEVBQXNDO0FBQ2xDLHFCQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksS0FBSyxVQUF6QixFQUFxQyxHQUFyQyxFQUEwQztBQUN0Qyx3QkFBSSxRQUFRLEtBQUssVUFBTCxDQUFnQixDQUFoQixFQUFtQixDQUFuQixFQUFzQixDQUF0QixDQUFaO0FBQ0EseUJBQUssVUFBTCxDQUFnQixDQUFoQixFQUFtQixDQUFuQixFQUFzQixDQUF0QixFQUF5QixLQUFLLFFBQUwsR0FBZ0IsS0FBekM7QUFDSDtBQUNKO0FBQ0o7QUFDSjtBQUNKOzs7Ozs7OztrQkN2QnVCLGM7QUFBVCxTQUFTLGNBQVQsR0FBMEI7QUFDckMsU0FBSyxnQkFBTCxDQUFzQixRQUF0QixFQUFnQztBQUM1QixrQkFBVSxDQUFDLENBQUQsRUFBSSxDQUFKLEVBQU8sRUFBUDtBQURrQixLQUFoQzs7QUFJQSxRQUFJLEtBQUssUUFBTCxLQUFrQixDQUF0QixFQUF5Qjs7OztBQUlyQixZQUFJLE9BQU8sS0FBSyxJQUFoQjtBQUNBLGFBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxLQUFLLE1BQXpCLEVBQWlDLEdBQWpDLEVBQXNDO0FBQ2xDLGlCQUFLLENBQUwsSUFBVSxDQUFDLEtBQUssQ0FBTCxDQUFYO0FBQ0g7QUFDSixLQVJELE1BUU87QUFDSCx5QkFBMkIsS0FBSyxNQUFMLEVBQTNCLEVBQTBDO0FBQUEsZ0JBQWhDLEtBQWdDLFFBQWhDLEtBQWdDO0FBQUEsZ0JBQXpCLEtBQXlCLFFBQXpCLEtBQXlCOztBQUN0QyxpQkFBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLEtBQUssVUFBekIsRUFBcUMsR0FBckMsRUFBMEM7QUFDdEMscUJBQUssUUFBTCxDQUFjLEtBQWQsRUFBcUIsQ0FBckIsRUFBd0IsS0FBSyxRQUFMLEdBQWdCLE1BQU0sQ0FBTixDQUF4QztBQUNIO0FBQ0o7QUFDSjtBQUNKOzs7Ozs7OztrQkNwQnVCLGE7QUFBVCxTQUFTLGFBQVQsR0FBeUI7QUFDcEMsU0FBSyxnQkFBTCxDQUFzQixlQUF0QixFQUF1QztBQUNuQyxrQkFBVSxDQUFDLENBQUQsRUFBSSxFQUFKO0FBRHlCLEtBQXZDOztBQUlBLFFBQUksT0FBTyxLQUFLLElBQWhCO0FBQ0EsU0FBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLEtBQUssTUFBekIsRUFBaUMsS0FBSyxLQUFLLFFBQTNDLEVBQXFEO0FBQ2pELGFBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxLQUFLLFVBQXpCLEVBQXFDLEdBQXJDLEVBQTBDO0FBQ3RDLGlCQUFLLElBQUksQ0FBVCxJQUFjLEtBQUssUUFBTCxHQUFnQixLQUFLLElBQUksQ0FBVCxDQUE5QjtBQUNIO0FBQ0o7QUFDSjs7Ozs7Ozs7a0JDTnVCLFc7Ozs7OztBQUFULFNBQVMsV0FBVCxHQUF1QjtBQUNsQyxTQUFLLGdCQUFMLENBQXNCLGFBQXRCLEVBQXFDO0FBQ2pDLGtCQUFVLENBQUMsQ0FBRCxFQUFJLEVBQUo7QUFEdUIsS0FBckM7O0FBS0EsU0FBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLEtBQUssS0FBekIsRUFBZ0MsR0FBaEMsRUFBcUM7QUFDakMsYUFBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLEtBQUssTUFBekIsRUFBaUMsR0FBakMsRUFBc0M7QUFDbEMsZ0JBQUksUUFBUSxLQUFLLFVBQUwsQ0FBZ0IsQ0FBaEIsRUFBbUIsQ0FBbkIsQ0FBWjtBQUNBLGlCQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksS0FBSyxVQUF6QixFQUFxQyxHQUFyQyxFQUEwQztBQUN0QyxzQkFBTSxDQUFOLElBQVcsS0FBSyxRQUFMLEdBQWdCLE1BQU0sQ0FBTixDQUEzQjtBQUNIO0FBQ0QsaUJBQUssVUFBTCxDQUFnQixDQUFoQixFQUFtQixDQUFuQixFQUFzQixLQUF0QjtBQUNIO0FBQ0o7QUFFSjs7Ozs7Ozs7a0JDakJ1QixLOztBQUp4Qjs7OztBQUVBOzs7O0FBRWUsU0FBUyxLQUFULEdBS0g7QUFBQSxxRUFBSixFQUFJOztBQUFBLDhCQUpSLFNBSVE7QUFBQSxRQUpSLFNBSVEsa0NBSkksT0FJSjtBQUFBLFFBSFIsUUFHUSxRQUhSLFFBR1E7QUFBQSx3QkFGUixHQUVRO0FBQUEsUUFGUixHQUVRLDRCQUZGLEtBQUssR0FFSDtBQUFBLHdCQURSLEdBQ1E7QUFBQSxRQURSLEdBQ1EsNEJBREYsS0FBSyxHQUNIOztBQUNSLFNBQUssZ0JBQUwsQ0FBc0IsT0FBdEIsRUFBK0I7QUFDM0Isa0JBQVUsQ0FBQyxDQUFELEVBQUksRUFBSjtBQURpQixLQUEvQjs7QUFJQSxlQUFXLHNDQUF3QixJQUF4QixFQUE4QixFQUFDLFVBQVMsUUFBVixFQUE5QixDQUFYOztBQUVBLFlBQVEsU0FBUjs7QUFFSSxhQUFLLE9BQUw7QUFDSSxnQkFBSSxNQUFNLENBQVYsRUFBYSxNQUFNLENBQU47QUFDYixnQkFBSSxNQUFNLEtBQUssUUFBZixFQUF5QixNQUFNLEtBQUssUUFBWDs7QUFFekIsZ0JBQUksQ0FBQyxNQUFNLE9BQU4sQ0FBYyxHQUFkLENBQUwsRUFBeUIsTUFBTSx3QkFBUyxTQUFTLE1BQWxCLEVBQTBCLEdBQTFCLENBQU47QUFDekIsZ0JBQUksQ0FBQyxNQUFNLE9BQU4sQ0FBYyxHQUFkLENBQUwsRUFBeUIsTUFBTSx3QkFBUyxTQUFTLE1BQWxCLEVBQTBCLEdBQTFCLENBQU47O0FBRXpCLHlCQUFhLElBQWIsRUFBbUIsR0FBbkIsRUFBd0IsR0FBeEIsRUFBNkIsUUFBN0I7QUFDQTs7QUFFSjtBQUNJLGtCQUFNLElBQUksS0FBSixDQUFVLHFDQUFxQyxTQUEvQyxDQUFOO0FBYlI7QUFlSDs7QUFFRCxTQUFTLFlBQVQsQ0FBc0IsS0FBdEIsRUFBNkIsR0FBN0IsRUFBa0MsR0FBbEMsRUFBdUMsUUFBdkMsRUFBaUQ7QUFDN0MsUUFBSSxRQUFRLElBQVosQztBQUNBLFFBQUksU0FBUyxJQUFJLEtBQUosQ0FBVSxNQUFNLFFBQWhCLENBQWI7O0FBRUEsU0FBSyxJQUFJLENBQVQsSUFBYyxRQUFkLEVBQXdCO0FBQ3BCLFlBQUksSUFBSSxDQUFKLE1BQVcsQ0FBWCxJQUFnQixJQUFJLENBQUosTUFBVyxNQUFNLFFBQXJDLEVBQStDO0FBQzNDLG1CQUFPLENBQVAsSUFBWSxDQUFaO0FBQ0gsU0FGRCxNQUVPLElBQUksSUFBSSxDQUFKLE1BQVcsSUFBSSxDQUFKLENBQWYsRUFBdUI7QUFDMUIsbUJBQU8sQ0FBUCxJQUFZLENBQVo7QUFDSCxTQUZNLE1BRUE7QUFDSCxtQkFBTyxDQUFQLElBQVksQ0FBQyxNQUFNLFFBQU4sR0FBaUIsQ0FBakIsR0FBcUIsS0FBdEIsS0FBZ0MsSUFBSSxDQUFKLElBQVMsSUFBSSxDQUFKLENBQXpDLENBQVo7QUFDSDtBQUNELFlBQUksQ0FBSixLQUFXLENBQUMsTUFBTSxRQUFRLENBQWYsSUFBb0IsT0FBTyxDQUFQLENBQS9CO0FBQ0g7Ozs7Ozs7OztBQVVELFNBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxTQUFTLE1BQTdCLEVBQXFDLEdBQXJDLEVBQTBDO0FBQ3RDLFlBQUksS0FBSSxTQUFTLENBQVQsQ0FBUjtBQUNBLFlBQUksT0FBTyxFQUFQLE1BQWMsQ0FBbEIsRUFBcUI7QUFDakIsaUJBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxNQUFNLElBQU4sQ0FBVyxNQUEvQixFQUF1QyxLQUFLLE1BQU0sUUFBbEQsRUFBNEQ7QUFDeEQsc0JBQU0sSUFBTixDQUFXLElBQUksRUFBZixJQUFvQixLQUFLLEdBQUwsQ0FBUyxLQUFLLEdBQUwsQ0FBUyxDQUFULEVBQWEsQ0FBQyxNQUFNLElBQU4sQ0FBVyxJQUFJLEVBQWYsSUFBb0IsSUFBSSxFQUFKLENBQXJCLElBQStCLE9BQU8sRUFBUCxDQUEvQixHQUEyQyxHQUE1QyxHQUFtRCxDQUEvRCxDQUFULEVBQTRFLE1BQU0sUUFBbEYsQ0FBcEI7QUFDSDtBQUNKO0FBQ0o7QUFDSjs7Ozs7Ozs7a0JDekR1QixZOztBQUp4Qjs7QUFDQTs7Ozs7Ozs7O0FBR2UsU0FBUyxZQUFULENBQXNCLE1BQXRCLEVBQThCLFFBQTlCLEVBQXlEO0FBQUEsUUFBakIsTUFBaUIseURBQVIsTUFBUTs7QUFDcEUsU0FBSyxnQkFBTCxDQUFzQixjQUF0QixFQUFzQztBQUNsQyxrQkFBUyxDQUFDLENBQUQsRUFBRyxFQUFIO0FBRHlCLEtBQXRDOztBQUlBLFFBQUksU0FBUyxDQUFiLEVBQWdCO0FBQ1osY0FBTSxJQUFJLEtBQUosQ0FBVSx3Q0FBVixDQUFOO0FBQ0g7O0FBRUQsZUFBVyxzQ0FBd0IsSUFBeEIsRUFBOEIsUUFBOUIsRUFBd0MsSUFBeEMsQ0FBWDs7QUFFQSxRQUFJLFNBQVMsTUFBYjtBQUNBLFFBQUksVUFBVSxNQUFkO0FBQ0EsUUFBSSxXQUFXLGdCQUFNLFVBQU4sQ0FBaUIsSUFBakIsQ0FBZjs7QUFFQSxRQUFJLE9BQU8sQ0FBQyxTQUFTLENBQVQsR0FBYSxDQUFkLEtBQW9CLFVBQVUsQ0FBVixHQUFjLENBQWxDLENBQVg7QUFDQSxRQUFJLFNBQVMsS0FBSyxLQUFMLENBQVcsT0FBTyxDQUFsQixDQUFiO0FBQ0EsUUFBSSxTQUFTLElBQUksS0FBSixDQUFVLElBQVYsQ0FBYjs7QUFFQSxTQUFLLElBQUksVUFBVSxDQUFuQixFQUFzQixVQUFVLFNBQVMsTUFBekMsRUFBaUQsU0FBakQsRUFBNEQ7QUFDeEQsWUFBSSxJQUFJLFNBQVMsT0FBVCxDQUFSO0FBQ0EsYUFBSyxJQUFJLElBQUksT0FBYixFQUFzQixJQUFJLEtBQUssTUFBTCxHQUFjLE9BQXhDLEVBQWlELEdBQWpELEVBQXNEO0FBQ2xELGlCQUFLLElBQUksSUFBSSxNQUFiLEVBQXFCLElBQUksS0FBSyxLQUFMLEdBQWEsTUFBdEMsRUFBOEMsR0FBOUMsRUFBbUQ7QUFDL0Msb0JBQUksSUFBSSxDQUFSO0FBQ0EscUJBQUssSUFBSSxJQUFJLENBQUMsT0FBZCxFQUF1QixLQUFLLE9BQTVCLEVBQXFDLEdBQXJDLEVBQTBDO0FBQ3RDLHlCQUFLLElBQUksSUFBSSxDQUFDLE1BQWQsRUFBc0IsS0FBSyxNQUEzQixFQUFtQyxHQUFuQyxFQUF3QztBQUNwQyw0QkFBSSxTQUFRLENBQUMsQ0FBQyxJQUFJLENBQUwsSUFBVSxLQUFLLEtBQWYsR0FBdUIsQ0FBdkIsR0FBMkIsQ0FBNUIsSUFBaUMsS0FBSyxRQUF0QyxHQUFpRCxDQUE3RDtBQUNBLCtCQUFPLEdBQVAsSUFBYyxLQUFLLElBQUwsQ0FBVSxNQUFWLENBQWQ7QUFDSDtBQUNKO0FBQ0Qsb0JBQUksUUFBUSxDQUFDLElBQUksS0FBSyxLQUFULEdBQWlCLENBQWxCLElBQXVCLEtBQUssUUFBNUIsR0FBdUMsQ0FBbkQ7QUFDQSxvQkFBSSxXQUFXLE9BQU8sSUFBUCxHQUFjLE1BQWQsQ0FBZjtBQUNBLHlCQUFTLElBQVQsQ0FBYyxLQUFkLElBQXVCLFFBQXZCO0FBQ0g7QUFDSjtBQUNKOztBQUVELFFBQUksS0FBSyxLQUFMLElBQWMsU0FBUyxPQUFULENBQWlCLEtBQUssUUFBdEIsTUFBb0MsQ0FBQyxDQUF2RCxFQUEwRDtBQUN0RCxhQUFLLElBQUksS0FBSSxLQUFLLFVBQWxCLEVBQThCLEtBQUksS0FBSyxJQUFMLENBQVUsTUFBNUMsRUFBb0QsS0FBSSxLQUFJLEtBQUssUUFBakUsRUFBMkU7QUFDdkUscUJBQVMsSUFBVCxDQUFjLEVBQWQsSUFBbUIsS0FBSyxJQUFMLENBQVUsRUFBVixDQUFuQjtBQUNIO0FBQ0o7O0FBRUQsYUFBUyxTQUFULENBQW1CLEVBQUMsTUFBSyxDQUFDLE1BQUQsRUFBUyxPQUFULENBQU4sRUFBeUIsV0FBVyxNQUFwQyxFQUFuQjs7QUFFQSxXQUFPLFFBQVA7QUFFSCxDOzs7Ozs7OztrQkNsRHVCLEc7O0FBSnhCOztBQUNBOzs7O0FBQ0E7Ozs7QUFFZSxTQUFTLEdBQVQsQ0FBYSxLQUFiLEVBQXFDO0FBQUEscUVBQUosRUFBSTs7QUFBQSxRQUFoQixRQUFnQixRQUFoQixRQUFnQjs7QUFDaEQsU0FBSyxnQkFBTCxDQUFzQixVQUF0QixFQUFrQztBQUM5QixrQkFBVSxDQUFDLENBQUQsRUFBSSxFQUFKO0FBRG9CLEtBQWxDO0FBR0EsUUFBSSxTQUFTLENBQWIsRUFBZ0IsTUFBTSxJQUFJLEtBQUosQ0FBVSw0Q0FBVixDQUFOOztBQUVoQixlQUFXLHNDQUF3QixJQUF4QixFQUE4QixFQUFDLFVBQVMsUUFBVixFQUE5QixDQUFYO0FBQ0EsWUFBUSw2QkFBaUIsS0FBakIsQ0FBUjs7QUFFQSxRQUFJLENBQUMsTUFBTSxLQUFOLENBQUwsRUFBbUI7QUFDZixhQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksU0FBUyxNQUE3QixFQUFxQyxHQUFyQyxFQUEwQztBQUN0QyxnQkFBSSxJQUFJLFNBQVMsQ0FBVCxDQUFSO0FBQ0EsaUJBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxLQUFLLElBQUwsQ0FBVSxNQUE5QixFQUFzQyxLQUFLLEtBQUssUUFBaEQsRUFBMEQ7QUFDdEQscUJBQUssSUFBTCxDQUFVLElBQUksQ0FBZCxJQUFtQixLQUFLLEdBQUwsQ0FBUyxLQUFLLFFBQWQsRUFBeUIsS0FBSyxJQUFMLENBQVUsSUFBSSxDQUFkLElBQW1CLEtBQXBCLElBQThCLENBQXRELENBQW5CO0FBQ0g7QUFDSjtBQUNKLEtBUEQsTUFPTztBQUNILFlBQUksS0FBSyxJQUFMLENBQVUsTUFBVixLQUFxQixNQUFNLE1BQS9CLEVBQXVDO0FBQ25DLGtCQUFNLElBQUksS0FBSixDQUFVLHNDQUFWLENBQU47QUFDSDtBQUNELGFBQUssSUFBSSxLQUFJLENBQWIsRUFBZ0IsS0FBSSxTQUFTLE1BQTdCLEVBQXFDLElBQXJDLEVBQTBDO0FBQ3RDLGdCQUFJLEtBQUksU0FBUyxFQUFULENBQVI7QUFDQSxpQkFBSyxJQUFJLEtBQUksQ0FBYixFQUFnQixLQUFJLEtBQUssSUFBTCxDQUFVLE1BQTlCLEVBQXNDLE1BQUssS0FBSyxRQUFoRCxFQUEwRDtBQUN0RCxxQkFBSyxJQUFMLENBQVUsS0FBSSxFQUFkLElBQW1CLEtBQUssR0FBTCxDQUFTLENBQVQsRUFBWSxLQUFLLEdBQUwsQ0FBUyxLQUFLLFFBQWQsRUFBeUIsS0FBSyxJQUFMLENBQVUsS0FBSSxFQUFkLElBQW1CLE1BQU0sS0FBSSxFQUFWLENBQXBCLElBQXFDLENBQTdELENBQVosQ0FBbkI7QUFDSDtBQUNKO0FBQ0o7QUFDSjs7Ozs7Ozs7a0JDM0J1QixXOztBQUp4Qjs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFFZSxTQUFTLFdBQVQsR0FLTjtBQUFBLGtFQUFKLEVBQUk7O0FBQUEseUJBSlIsT0FJUTtBQUFBLEtBSlIsT0FJUTtBQUFBLHlCQUhSLE9BR1E7QUFBQSxLQUhSLE9BR1E7QUFBQSx3QkFGUixNQUVRO0FBQUEsS0FGUixNQUVRLCtCQUZDLE1BRUQ7QUFBQSxLQURSLFFBQ1EsUUFEUixRQUNROzs7QUFFUixNQUFLLGdCQUFMLENBQXNCLGFBQXRCLEVBQXFDO0FBQ3BDLFlBQVUsQ0FBQyxDQUFELEVBQUksRUFBSjtBQUQwQixFQUFyQzs7QUFJQSxLQUFJLEtBQUssc0JBQVksSUFBWixDQUFpQixJQUFqQixFQUF1QixPQUF2QixFQUFnQztBQUN4QyxZQUFVLFFBRDhCO0FBRXhDLFVBQVEsTUFGZ0M7QUFHeEMsWUFBVTtBQUg4QixFQUFoQyxDQUFUOztBQU1BLEtBQUksS0FBSyxzQkFBWSxJQUFaLENBQWlCLElBQWpCLEVBQXVCLE9BQXZCLEVBQWdDO0FBQ3hDLFlBQVUsUUFEOEI7QUFFeEMsVUFBUSxNQUZnQztBQUd4QyxZQUFVO0FBSDhCLEVBQWhDLENBQVQ7O0FBTUEsUUFBTyxHQUFHLFVBQUgsQ0FBYyxFQUFkLEVBQWtCLEVBQUMsVUFBVSxLQUFLLFFBQWhCLEVBQTBCLFVBQVUsUUFBcEMsRUFBbEIsQ0FBUDtBQUNBOzs7Ozs7OztrQkN4QnVCLFE7O0FBSnhCOztBQUNBOzs7O0FBQ0E7Ozs7QUFFZSxTQUFTLFFBQVQsQ0FBa0IsS0FBbEIsRUFBMEM7QUFBQSxxRUFBSixFQUFJOztBQUFBLFFBQWhCLFFBQWdCLFFBQWhCLFFBQWdCOztBQUNyRCxTQUFLLGdCQUFMLENBQXNCLFVBQXRCLEVBQWtDO0FBQzlCLGtCQUFVLENBQUMsQ0FBRCxFQUFJLEVBQUo7QUFEb0IsS0FBbEM7O0FBSUEsZUFBVyxzQ0FBd0IsSUFBeEIsRUFBOEIsRUFBQyxVQUFTLFFBQVYsRUFBOUIsQ0FBWDtBQUNBLFlBQVEsNkJBQWlCLEtBQWpCLENBQVI7O0FBRUEsUUFBSSxDQUFDLE1BQU0sS0FBTixDQUFMLEVBQW1CO0FBQ2YsYUFBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLFNBQVMsTUFBN0IsRUFBcUMsR0FBckMsRUFBMEM7QUFDdEMsZ0JBQUksSUFBSSxTQUFTLENBQVQsQ0FBUjtBQUNBLGlCQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksS0FBSyxJQUFMLENBQVUsTUFBOUIsRUFBc0MsS0FBSyxLQUFLLFFBQWhELEVBQTBEO0FBQ3RELHFCQUFLLElBQUwsQ0FBVSxJQUFJLENBQWQsSUFBbUIsS0FBSyxHQUFMLENBQVMsQ0FBVCxFQUFhLEtBQUssSUFBTCxDQUFVLElBQUksQ0FBZCxJQUFtQixLQUFwQixJQUE4QixDQUExQyxDQUFuQjtBQUNIO0FBQ0o7QUFDSixLQVBELE1BT087QUFDSCxZQUFJLEtBQUssSUFBTCxDQUFVLE1BQVYsS0FBcUIsTUFBTSxNQUEvQixFQUF1QztBQUNuQyxrQkFBTSxJQUFJLEtBQUosQ0FBVSx1Q0FBVixDQUFOO0FBQ0g7QUFDRCxhQUFLLElBQUksS0FBSSxDQUFiLEVBQWdCLEtBQUksU0FBUyxNQUE3QixFQUFxQyxJQUFyQyxFQUEwQztBQUN0QyxnQkFBSSxLQUFJLFNBQVMsRUFBVCxDQUFSO0FBQ0EsaUJBQUssSUFBSSxLQUFJLENBQWIsRUFBZ0IsS0FBSSxLQUFLLElBQUwsQ0FBVSxNQUE5QixFQUFzQyxNQUFLLEtBQUssUUFBaEQsRUFBMEQ7QUFDdEQscUJBQUssSUFBTCxDQUFVLEtBQUksRUFBZCxJQUFtQixLQUFLLEdBQUwsQ0FBUyxDQUFULEVBQVksS0FBSyxHQUFMLENBQVMsS0FBSyxRQUFkLEVBQXlCLEtBQUssSUFBTCxDQUFVLEtBQUksRUFBZCxJQUFtQixNQUFNLEtBQUksRUFBVixDQUFwQixJQUFxQyxDQUE3RCxDQUFaLENBQW5CO0FBQ0g7QUFDSjtBQUNKO0FBQ0o7Ozs7Ozs7OztBQzlCRDs7QUFDQTs7QUFDQTs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7O0FBQ0E7O0FBQ0E7Ozs7QUFDQTs7QUFDQTs7OztBQUNBOztBQUNBOzs7Ozs7OztBQUVBLElBQUksNkJBQTZCO0FBQzdCLGtCQUFjLElBRGU7QUFFN0IsZ0JBQVksS0FGaUI7QUFHN0IsU0FBSztBQUh3QixDQUFqQzs7QUFNZSxNQUFNLEtBQU4sQ0FBWTtBQUN2QixnQkFBWSxLQUFaLEVBQW1CLE1BQW5CLEVBQTJCLElBQTNCLEVBQWlDLE9BQWpDLEVBQTBDO0FBQ3RDLFlBQUksVUFBVSxTQUFkLEVBQXlCLFFBQVEsQ0FBUjtBQUN6QixZQUFJLFdBQVcsU0FBZixFQUEwQixTQUFTLENBQVQ7OztBQUcxQixZQUFJLE9BQU8sS0FBUCxLQUFpQixRQUFyQixFQUErQjtBQUMzQixnQkFBTSxhQUFhLEtBQW5CO0FBQ0EsZ0JBQU0sWUFBWSxXQUFXLElBQTdCO0FBQ0Esb0JBQVEsV0FBVyxLQUFuQjtBQUNBLHFCQUFTLFdBQVcsTUFBcEI7QUFDQSxtQkFBTyxZQUFZLFdBQVcsSUFBWCxDQUFnQixLQUFoQixFQUFaLEdBQXNDLFdBQVcsSUFBeEQ7QUFDQSxzQkFBVTtBQUNOLDBCQUFVLFdBQVcsUUFEZjtBQUVOLDRCQUFZLFdBQVcsVUFGakI7QUFHTix1QkFBTyxXQUFXLEtBSFo7QUFJTiwwQkFBVSxXQUFXLFFBSmY7QUFLTiw0QkFBWSxXQUFXO0FBTGpCLGFBQVY7QUFPSDs7QUFFRCxZQUFJLFFBQVEsQ0FBQyxLQUFLLE1BQWxCLEVBQTBCO0FBQ3RCLHNCQUFVLElBQVY7QUFDQSxtQkFBTyxJQUFQO0FBQ0g7QUFDRCxZQUFJLFlBQVksU0FBaEIsRUFBMkIsVUFBVSxFQUFWOztBQUUzQixhQUFLLEtBQUwsR0FBYSxLQUFiO0FBQ0EsYUFBSyxNQUFMLEdBQWMsTUFBZDs7QUFFQSxZQUFJLEtBQUssS0FBTCxJQUFjLENBQWxCLEVBQXFCO0FBQ2pCLGtCQUFNLElBQUksVUFBSixDQUFlLDhCQUFmLENBQU47QUFDSDtBQUNELFlBQUksS0FBSyxNQUFMLElBQWUsQ0FBbkIsRUFBc0I7QUFDbEIsa0JBQU0sSUFBSSxVQUFKLENBQWUsK0JBQWYsQ0FBTjtBQUNIOzs7O0FBSUQsZUFBTyxjQUFQLENBQXNCLElBQXRCLEVBQTRCLFFBQTVCLEVBQXNDO0FBQ2xDLHdCQUFZLEtBRHNCO0FBRWxDLHNCQUFVO0FBRndCLFNBQXRDO0FBSUEsYUFBSyxNQUFMLEdBQWMsUUFBUSxNQUF0QjtBQUNBLGFBQUssUUFBTCxHQUFnQixRQUFRLFFBQVIsSUFBb0IsQ0FBQyxDQUFELEVBQUksQ0FBSixDQUFwQzs7QUFFQSxZQUFJLGdCQUFKO0FBQ0EsWUFBSSxPQUFPLFFBQVEsSUFBZixLQUF3QixRQUE1QixFQUFzQztBQUNsQyxzQkFBVSxtQkFBUSxRQUFRLElBQWhCLENBQVY7QUFDQSxnQkFBSSxDQUFDLE9BQUwsRUFBYyxNQUFNLElBQUksVUFBSixDQUFlLHlCQUF5QixRQUFRLElBQWhELENBQU47QUFDakIsU0FIRCxNQUdPO0FBQ0gsc0JBQVUsbUNBQVY7QUFDSDs7QUFFRCxZQUFJLGlCQUFpQixzQkFBYSxFQUFiLEVBQWlCLE9BQWpCLEVBQTBCLE9BQTFCLENBQXJCO0FBQ0EsYUFBSyxVQUFMLEdBQWtCLGVBQWUsVUFBakM7QUFDQSxhQUFLLEtBQUwsR0FBYSxlQUFlLEtBQWYsR0FBdUIsQ0FBcEM7QUFDQSxhQUFLLFFBQUwsR0FBZ0IsZUFBZSxRQUEvQjtBQUNBLGFBQUssVUFBTCxHQUFrQixlQUFlLFVBQWpDOztBQUVBLGFBQUssUUFBTCxHQUFnQixJQUFoQjs7QUFFQSxhQUFLLFVBQUw7O0FBRUEsWUFBSSxDQUFDLElBQUwsRUFDSSw0QkFBaUIsSUFBakIsRUFESixLQUVLO0FBQ0QsZ0JBQUksU0FBUyx3Q0FBNkIsSUFBN0IsQ0FBYjtBQUNBLGdCQUFJLFdBQVcsS0FBSyxNQUFwQixFQUE0QjtBQUN4QixzQkFBTSxJQUFJLFVBQUosQ0FBZ0IsbUNBQWlDLE1BQU8sZ0JBQWEsS0FBSyxNQUFPLEdBQWpGLENBQU47QUFDSDtBQUNELGlCQUFLLElBQUwsR0FBWSxJQUFaO0FBQ0g7QUFDSjs7QUFFRCxpQkFBYTtBQUNULGFBQUssSUFBTCxHQUFZLEtBQUssS0FBTCxHQUFhLEtBQUssTUFBOUI7QUFDQSxhQUFLLEtBQUwsR0FBYSxDQUFDLEtBQUssS0FBTixFQUFhLEtBQUssTUFBbEIsQ0FBYjtBQUNBLGFBQUssUUFBTCxHQUFnQixLQUFLLFVBQUwsR0FBa0IsS0FBSyxLQUF2QztBQUNBLFlBQUksS0FBSyxRQUFMLEtBQWtCLEVBQXRCLEVBQTBCO0FBQ3RCLGlCQUFLLFFBQUwsR0FBZ0IsT0FBTyxTQUF2QjtBQUNILFNBRkQsTUFFTztBQUNILGlCQUFLLFFBQUwsR0FBZ0IsS0FBSyxHQUFMLENBQVMsQ0FBVCxFQUFZLEtBQUssUUFBakIsSUFBNkIsQ0FBN0MsQztBQUNIOztBQUVELGFBQUssV0FBTCxHQUFtQixLQUFLLFFBQXhCO0FBQ0EsYUFBSyxXQUFMLEdBQW1CLEtBQUssUUFBTCxHQUFnQixLQUFLLEtBQXhDO0FBQ0EsYUFBSyxTQUFMLEdBQWlCLEtBQUssUUFBTCxHQUFnQixFQUFqQztBQUNBLGFBQUssV0FBTCxHQUFtQixDQUFDLENBQUQsRUFBRyxDQUFILENBQW5CLEM7QUFDSDs7QUFHRCxXQUFPLElBQVAsQ0FBWSxHQUFaLEVBQWlCO0FBQ2IsZUFBTyxtQkFBUSxHQUFSLENBQVA7QUFDSDs7QUFFRCxXQUFPLFlBQVAsQ0FBb0IsSUFBcEIsRUFBMEIsTUFBMUIsRUFBOEc7QUFBQSx5RUFBSixFQUFJOztBQUFBLGdDQUEzRSxPQUEyRTtBQUFBLFlBQTNFLE9BQTJFLGdDQUFqRSxLQUFpRTtBQUFBLG1DQUExRCxVQUEwRDtBQUFBLFlBQTFELFVBQTBELG1DQUE3QyxJQUE2QztBQUFBLG9DQUF2QyxXQUF1QztBQUFBLFlBQXZDLFdBQXVDLG9DQUF6QixFQUF5QjtBQUFBLDhCQUFyQixLQUFxQjtBQUFBLFlBQXJCLEtBQXFCLDhCQUFiLEtBQWE7O0FBQzFHLFlBQUksT0FBSixFQUFhO0FBQ1Qsa0JBQU0sU0FBTixDQUFnQixJQUFoQixJQUF3QixZQUFtQjs7QUFFdkMscUJBQUssUUFBTCxHQUFnQixJQUFoQjs7QUFGdUMsa0RBQU4sSUFBTTtBQUFOLHdCQUFNO0FBQUE7O0FBR3ZDLG9CQUFJLFNBQVMsT0FBTyxLQUFQLENBQWEsSUFBYiwrQkFBdUIsV0FBdkIsR0FBdUMsSUFBdkMsRUFBYjtBQUNBLG9CQUFJLFVBQUosRUFDSSxPQUFPLElBQVA7QUFDSix1QkFBTyxNQUFQO0FBQ0gsYUFQRDtBQVFBLGdCQUFJLEtBQUosRUFBVztBQUNQLG9CQUFNLFlBQVksT0FBTyxLQUFQLEtBQWlCLFFBQWpCLEdBQTRCLEtBQTVCLEdBQW9DLElBQXREO0FBQ0Esb0JBQUksVUFBSixFQUFnQjtBQUNaLG9DQUFNLFNBQU4sQ0FBZ0IsU0FBaEIsSUFBNkIsWUFBbUI7QUFDNUMsNkJBQUssSUFBSSxLQUFULElBQWtCLElBQWxCLEVBQXdCO0FBQ3BCLGtDQUFNLElBQU47QUFDSDtBQUNELCtCQUFPLElBQVA7QUFDSCxxQkFMRDtBQU1ILGlCQVBELE1BT087QUFDSCxvQ0FBTSxTQUFOLENBQWdCLFNBQWhCLElBQTZCLFlBQW1CO0FBQzVDLDRCQUFJLFNBQVMsb0JBQVUsS0FBSyxNQUFmLENBQWI7QUFDQSw2QkFBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLEtBQUssTUFBekIsRUFBaUMsR0FBakMsRUFBc0M7QUFBQTs7QUFDbEMsbUNBQU8sQ0FBUCxJQUFZLFdBQUssQ0FBTCxHQUFRLElBQVIsc0JBQVo7QUFDSDtBQUNELCtCQUFPLE1BQVA7QUFDSCxxQkFORDtBQU9IO0FBQ0o7QUFDSixTQTVCRCxNQTRCTztBQUNILGtCQUFNLFNBQU4sQ0FBZ0IsSUFBaEIsSUFBd0IsWUFBbUI7QUFBQSxtREFBTixJQUFNO0FBQU4sd0JBQU07QUFBQTs7QUFDdkMsdUJBQU8sT0FBTyxLQUFQLENBQWEsSUFBYiwrQkFBdUIsV0FBdkIsR0FBdUMsSUFBdkMsRUFBUDtBQUNILGFBRkQ7QUFHQSxnQkFBSSxLQUFKLEVBQVc7QUFDUCxvQkFBTSxhQUFZLE9BQU8sS0FBUCxLQUFpQixRQUFqQixHQUE0QixLQUE1QixHQUFvQyxJQUF0RDtBQUNBLGdDQUFNLFNBQU4sQ0FBZ0IsVUFBaEIsSUFBNkIsWUFBbUI7QUFDNUMsd0JBQUksU0FBUyxvQkFBVSxLQUFLLE1BQWYsQ0FBYjtBQUNBLHlCQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksS0FBSyxNQUF6QixFQUFpQyxHQUFqQyxFQUFzQztBQUFBOztBQUNsQywrQkFBTyxDQUFQLElBQVksWUFBSyxDQUFMLEdBQVEsSUFBUix1QkFBWjtBQUNIO0FBQ0QsMkJBQU8sTUFBUDtBQUNILGlCQU5EO0FBT0g7QUFDSjtBQUNELGVBQU8sS0FBUDtBQUNIOztBQUVELFdBQU8sY0FBUCxDQUFzQixJQUF0QixFQUE0QixNQUE1QixFQUE2RDtBQUFBLDBFQUFKLEVBQUk7O0FBQUEsc0NBQXhCLFdBQXdCO0FBQUEsWUFBeEIsV0FBd0IscUNBQVYsRUFBVTs7QUFDekQsbUNBQTJCLEdBQTNCLEdBQWlDLFlBQVk7QUFDekMsZ0JBQUksS0FBSyxRQUFMLEtBQWtCLElBQXRCLEVBQTRCO0FBQ3hCLHFCQUFLLFFBQUwsR0FBZ0IsRUFBaEI7QUFDSCxhQUZELE1BRU8sSUFBSSxLQUFLLFFBQUwsQ0FBYyxjQUFkLENBQTZCLElBQTdCLENBQUosRUFBd0M7QUFDM0MsdUJBQU8sS0FBSyxRQUFMLENBQWMsSUFBZCxDQUFQO0FBQ0g7QUFDRCxnQkFBSSxTQUFTLE9BQU8sS0FBUCxDQUFhLElBQWIsRUFBbUIsV0FBbkIsQ0FBYjtBQUNBLGlCQUFLLFFBQUwsQ0FBYyxJQUFkLElBQXNCLE1BQXRCO0FBQ0EsbUJBQU8sTUFBUDtBQUNILFNBVEQ7QUFVQSxlQUFPLGNBQVAsQ0FBc0IsTUFBTSxTQUE1QixFQUF1QyxJQUF2QyxFQUE2QywwQkFBN0M7QUFDQSxlQUFPLEtBQVA7QUFDSDs7QUFHRCxXQUFPLFVBQVAsQ0FBa0IsS0FBbEIsRUFBeUIsT0FBekIsRUFBa0M7QUFDOUIsWUFBSSxhQUFhO0FBQ2IsbUJBQU8sTUFBTSxLQURBO0FBRWIsb0JBQVEsTUFBTSxNQUZEO0FBR2Isc0JBQVUsTUFBTSxRQUhIO0FBSWIsd0JBQVksTUFBTSxVQUpMO0FBS2IsbUJBQU8sTUFBTSxLQUxBO0FBTWIsd0JBQVksTUFBTSxVQU5MO0FBT2Isc0JBQVUsTUFBTSxRQVBIO0FBUWIsb0JBQVE7QUFSSyxTQUFqQjtBQVVBLDhCQUFhLFVBQWIsRUFBeUIsT0FBekI7QUFDQSxlQUFPLElBQUksS0FBSixDQUFVLFdBQVcsS0FBckIsRUFBNEIsV0FBVyxNQUF2QyxFQUErQyxVQUEvQyxDQUFQO0FBQ0g7O0FBRUQsV0FBTyxlQUFQLENBQXVCLElBQXZCLEVBQWtEO0FBQUEsWUFBckIsU0FBcUIseURBQVQsT0FBUzs7QUFDOUMsWUFBSSxPQUFPLElBQVAsS0FBZ0IsUUFBcEIsRUFBOEI7QUFDMUIsa0JBQU0sSUFBSSxTQUFKLENBQWMsZ0NBQWQsQ0FBTjtBQUNIO0FBQ0QsZUFBTyx5QkFBUSxJQUFSLENBQVA7QUFDQSxZQUFJLGNBQWMsT0FBbEIsRUFBMkI7QUFDdkIsbUJBQU8sMEJBQVMsSUFBVCxDQUFQO0FBQ0gsU0FGRCxNQUVPO0FBQ0gsa0JBQU0sSUFBSSxTQUFKLENBQWMsd0JBQXdCLFNBQXRDLENBQU47QUFDSDtBQUNKOztBQUVELGtCQUFjLE9BQWQsRUFBdUI7QUFDbkIsWUFBSSxRQUFRLENBQVo7QUFDQSxhQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksUUFBUSxNQUE1QixFQUFvQyxHQUFwQyxFQUF5QztBQUNyQyxxQkFBUyxLQUFLLFdBQUwsQ0FBaUIsQ0FBakIsSUFBc0IsUUFBUSxDQUFSLENBQS9CO0FBQ0g7QUFDRCxlQUFPLEtBQVA7QUFDSDs7QUFFRCxlQUFXLENBQVgsRUFBYyxDQUFkLEVBQWlCLE9BQWpCLEVBQTBCLEtBQTFCLEVBQWlDO0FBQzdCLGFBQUssSUFBTCxDQUFVLENBQUMsSUFBSSxLQUFLLEtBQVQsR0FBaUIsQ0FBbEIsSUFBdUIsS0FBSyxRQUE1QixHQUF1QyxPQUFqRCxJQUE0RCxLQUE1RDtBQUNBLGFBQUssUUFBTCxHQUFnQixJQUFoQjtBQUNBLGVBQU8sSUFBUDtBQUNIOztBQUVELGVBQVcsQ0FBWCxFQUFjLENBQWQsRUFBaUIsT0FBakIsRUFBMEI7QUFDdEIsZUFBTyxLQUFLLElBQUwsQ0FBVSxDQUFDLElBQUksS0FBSyxLQUFULEdBQWlCLENBQWxCLElBQXVCLEtBQUssUUFBNUIsR0FBdUMsT0FBakQsQ0FBUDtBQUNIOztBQUVELGFBQVMsS0FBVCxFQUFnQixPQUFoQixFQUF5QixLQUF6QixFQUFnQztBQUM1QixhQUFLLElBQUwsQ0FBVSxRQUFRLEtBQUssUUFBYixHQUF3QixPQUFsQyxJQUE2QyxLQUE3QztBQUNBLGFBQUssUUFBTCxHQUFnQixJQUFoQjtBQUNBLGVBQU8sSUFBUDtBQUNIOztBQUVELGFBQVMsS0FBVCxFQUFnQixPQUFoQixFQUF5QjtBQUNyQixlQUFPLEtBQUssSUFBTCxDQUFVLFFBQVEsS0FBSyxRQUFiLEdBQXdCLE9BQWxDLENBQVA7QUFDSDs7QUFFRCxlQUFXLENBQVgsRUFBYyxDQUFkLEVBQWlCLEtBQWpCLEVBQXdCO0FBQ3BCLGVBQU8sS0FBSyxRQUFMLENBQWMsSUFBSSxLQUFLLEtBQVQsR0FBaUIsQ0FBL0IsRUFBa0MsS0FBbEMsQ0FBUDtBQUNIOztBQUVELGVBQVcsQ0FBWCxFQUFjLENBQWQsRUFBaUI7QUFDYixlQUFPLEtBQUssUUFBTCxDQUFjLElBQUksS0FBSyxLQUFULEdBQWlCLENBQS9CLENBQVA7QUFDSDs7QUFFRCxhQUFTLEtBQVQsRUFBZ0IsS0FBaEIsRUFBdUI7QUFDbkIsWUFBSSxTQUFTLFFBQVEsS0FBSyxRQUExQjtBQUNBLGFBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxNQUFNLE1BQTFCLEVBQWtDLEdBQWxDLEVBQXVDO0FBQ25DLGlCQUFLLElBQUwsQ0FBVSxTQUFTLENBQW5CLElBQXdCLE1BQU0sQ0FBTixDQUF4QjtBQUNIO0FBQ0QsYUFBSyxRQUFMLEdBQWdCLElBQWhCO0FBQ0EsZUFBTyxJQUFQO0FBQ0g7O0FBRUQsYUFBUyxLQUFULEVBQWdCO0FBQ1osWUFBSSxRQUFRLElBQUksS0FBSixDQUFVLEtBQUssUUFBZixDQUFaO0FBQ0EsWUFBSSxTQUFTLFFBQVEsS0FBSyxRQUExQjtBQUNBLGFBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxLQUFLLFFBQXpCLEVBQW1DLEdBQW5DLEVBQXdDO0FBQ3BDLGtCQUFNLENBQU4sSUFBVyxLQUFLLElBQUwsQ0FBVSxTQUFTLENBQW5CLENBQVg7QUFDSDtBQUNELGVBQU8sS0FBUDtBQUNIOztBQUVELGdCQUE4QjtBQUFBLFlBQXBCLElBQW9CLHlEQUFiLFdBQWE7O0FBQzFCLGVBQU8sS0FBSyxTQUFMLEdBQWlCLFNBQWpCLENBQTJCLHlCQUFRLElBQVIsQ0FBM0IsQ0FBUDtBQUNIOztBQUVELGdCQUFZO0FBQ1IsWUFBSSxPQUFPLDJCQUFjLEtBQUssV0FBTCxFQUFkLEVBQWtDLEtBQUssS0FBdkMsRUFBOEMsS0FBSyxNQUFuRCxDQUFYO0FBQ0EsWUFBSSxTQUFTLHdCQUFXLEtBQUssS0FBaEIsRUFBdUIsS0FBSyxNQUE1QixDQUFiO0FBQ0EsWUFBSSxNQUFNLE9BQU8sVUFBUCxDQUFrQixJQUFsQixDQUFWO0FBQ0EsWUFBSSxZQUFKLENBQWlCLElBQWpCLEVBQXVCLENBQXZCLEVBQTBCLENBQTFCO0FBQ0EsZUFBTyxNQUFQO0FBQ0g7O0FBRUQsa0JBQWM7QUFDVixhQUFLLGdCQUFMLENBQXNCLGFBQXRCLEVBQXFDO0FBQ2pDLHdCQUFZLENBQUMsQ0FBRCxFQUFJLENBQUosQ0FEcUI7QUFFakMsc0JBQVUsQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFPLEVBQVA7QUFGdUIsU0FBckM7QUFJQSxZQUFJLE9BQU8sS0FBSyxJQUFoQjtBQUNBLFlBQUksVUFBVSxJQUFJLGlCQUFKLENBQXNCLEtBQUssS0FBTCxHQUFhLEtBQUssTUFBbEIsR0FBMkIsQ0FBakQsQ0FBZDtBQUNBLFlBQUksS0FBSyxRQUFMLEtBQWtCLENBQXRCLEVBQXlCO0FBQ3JCLGlCQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksSUFBcEIsRUFBMEIsR0FBMUIsRUFBK0I7QUFDM0Isb0JBQUksUUFBUSxLQUFLLE1BQUwsQ0FBWSxDQUFaLENBQVo7QUFDQSx3QkFBUSxJQUFJLENBQVosSUFBaUIsUUFBUSxHQUF6QjtBQUNBLHdCQUFRLElBQUksQ0FBSixHQUFRLENBQWhCLElBQXFCLFFBQVEsR0FBN0I7QUFDQSx3QkFBUSxJQUFJLENBQUosR0FBUSxDQUFoQixJQUFxQixRQUFRLEdBQTdCO0FBQ0g7QUFDSixTQVBELE1BT087QUFDSCxnQkFBSSxLQUFLLFVBQUwsS0FBb0IsQ0FBeEIsRUFBMkI7QUFDdkIscUJBQUssSUFBSSxNQUFJLENBQWIsRUFBZ0IsTUFBSSxJQUFwQixFQUEwQixLQUExQixFQUErQjtBQUMzQiw0QkFBUSxNQUFJLENBQVosSUFBaUIsS0FBSyxJQUFMLENBQVUsTUFBSSxLQUFLLFFBQW5CLE1BQWtDLEtBQUssUUFBTCxHQUFnQixDQUFuRTtBQUNBLDRCQUFRLE1BQUksQ0FBSixHQUFRLENBQWhCLElBQXFCLEtBQUssSUFBTCxDQUFVLE1BQUksS0FBSyxRQUFuQixNQUFrQyxLQUFLLFFBQUwsR0FBZ0IsQ0FBdkU7QUFDQSw0QkFBUSxNQUFJLENBQUosR0FBUSxDQUFoQixJQUFxQixLQUFLLElBQUwsQ0FBVSxNQUFJLEtBQUssUUFBbkIsTUFBa0MsS0FBSyxRQUFMLEdBQWdCLENBQXZFO0FBQ0g7QUFDSixhQU5ELE1BTU8sSUFBSSxLQUFLLFVBQUwsS0FBb0IsQ0FBeEIsRUFBMkI7QUFDOUIscUJBQUssZ0JBQUwsQ0FBc0IsYUFBdEIsRUFBcUMsRUFBQyxZQUFZLFlBQWIsRUFBckM7QUFDQSxvQkFBSSxLQUFLLFVBQUwsZUFBSixFQUE2QjtBQUN6Qix5QkFBSyxJQUFJLE1BQUksQ0FBYixFQUFnQixNQUFJLElBQXBCLEVBQTBCLEtBQTFCLEVBQStCO0FBQzNCLGdDQUFRLE1BQUksQ0FBWixJQUFpQixLQUFLLElBQUwsQ0FBVSxNQUFJLEtBQUssUUFBbkIsTUFBa0MsS0FBSyxRQUFMLEdBQWdCLENBQW5FO0FBQ0EsZ0NBQVEsTUFBSSxDQUFKLEdBQVEsQ0FBaEIsSUFBcUIsS0FBSyxJQUFMLENBQVUsTUFBSSxLQUFLLFFBQVQsR0FBb0IsQ0FBOUIsTUFBc0MsS0FBSyxRQUFMLEdBQWdCLENBQTNFO0FBQ0EsZ0NBQVEsTUFBSSxDQUFKLEdBQVEsQ0FBaEIsSUFBcUIsS0FBSyxJQUFMLENBQVUsTUFBSSxLQUFLLFFBQVQsR0FBb0IsQ0FBOUIsTUFBc0MsS0FBSyxRQUFMLEdBQWdCLENBQTNFO0FBQ0g7QUFDSjtBQUNKO0FBQ0o7QUFDRCxZQUFJLEtBQUssS0FBVCxFQUFnQjtBQUNaLGlCQUFLLGdCQUFMLENBQXNCLGFBQXRCLEVBQXFDLEVBQUMsVUFBVSxDQUFDLENBQUQsRUFBSSxFQUFKLENBQVgsRUFBckM7QUFDQSxpQkFBSyxJQUFJLE1BQUksQ0FBYixFQUFnQixNQUFJLElBQXBCLEVBQTBCLEtBQTFCLEVBQStCO0FBQzNCLHdCQUFRLE1BQUksQ0FBSixHQUFRLENBQWhCLElBQXFCLEtBQUssSUFBTCxDQUFVLE1BQUksS0FBSyxRQUFULEdBQW9CLEtBQUssVUFBbkMsS0FBbUQsS0FBSyxRQUFMLEdBQWdCLENBQXhGO0FBQ0g7QUFDSixTQUxELE1BS087QUFDSCxpQkFBSyxJQUFJLE1BQUksQ0FBYixFQUFnQixNQUFJLElBQXBCLEVBQTBCLEtBQTFCLEVBQStCO0FBQzNCLHdCQUFRLE1BQUksQ0FBSixHQUFRLENBQWhCLElBQXFCLEdBQXJCO0FBQ0g7QUFDSjtBQUNELGVBQU8sT0FBUDtBQUNIOztBQUVELGtCQUFjLElBQWQsRUFBb0IsT0FBcEIsRUFBNkI7QUFDekIsZUFBTyxzQkFBZSxJQUFmLEVBQXFCLE9BQXJCLENBQVA7QUFDSDs7QUFFRCxZQUE4QjtBQUFBLDBFQUFKLEVBQUk7O0FBQUEsbUNBQXZCLFFBQXVCO0FBQUEsWUFBdkIsUUFBdUIsa0NBQVosSUFBWTs7QUFDMUIsZUFBTyxJQUFJLEtBQUosQ0FBVSxJQUFWLEVBQWdCLFFBQWhCLENBQVA7QUFDSDs7QUFFRCxTQUFLLElBQUwsRUFBa0M7QUFBQSwwRUFBSixFQUFJOztBQUFBLGlDQUF0QixNQUFzQjtBQUFBLFlBQXRCLE1BQXNCLGdDQUFiLEtBQWE7O0FBQzlCLGVBQU8sSUFBSSxPQUFKLENBQVksQ0FBQyxPQUFELEVBQVUsTUFBVixLQUFxQjtBQUNwQyxnQkFBSSxNQUFNLDJCQUFrQixJQUFsQixDQUFWO0FBQ0EsZ0JBQUksU0FBUyxLQUFLLFNBQUwsRUFBYjtBQUNBLGdCQUFJLGVBQUo7QUFDQSxvQkFBUSxPQUFPLFdBQVAsRUFBUjtBQUNJLHFCQUFLLEtBQUw7QUFDSSw2QkFBUyxPQUFPLFNBQVAsRUFBVDtBQUNBO0FBQ0oscUJBQUssS0FBTDtBQUNBLHFCQUFLLE1BQUw7QUFDSSw2QkFBUyxPQUFPLFVBQVAsRUFBVDtBQUNBO0FBQ0o7QUFDSSwyQkFBTyxPQUFPLElBQUksVUFBSixDQUFlLDRCQUE0QixNQUEzQyxDQUFQLENBQVA7QUFUUjtBQVdBLGdCQUFJLEVBQUosQ0FBTyxRQUFQLEVBQWlCLE9BQWpCO0FBQ0EsZ0JBQUksRUFBSixDQUFPLE9BQVAsRUFBZ0IsTUFBaEI7QUFDQSxtQkFBTyxJQUFQLENBQVksR0FBWjtBQUNILFNBbEJNLENBQVA7QUFtQkg7OztBQUdELHFCQUFpQixXQUFqQixFQUE4RTtBQUFBLDBFQUFKLEVBQUk7O0FBQUEsWUFBL0MsUUFBK0MsU0FBL0MsUUFBK0M7QUFBQSxZQUFyQyxLQUFxQyxTQUFyQyxLQUFxQztBQUFBLFlBQTlCLFVBQThCLFNBQTlCLFVBQThCO0FBQUEsWUFBbEIsVUFBa0IsU0FBbEIsVUFBa0I7O0FBQzFFLFlBQUksT0FBTyxXQUFQLEtBQXVCLFFBQTNCLEVBQXFDO0FBQ2pDLGtCQUFNLElBQUksU0FBSixDQUFjLHlFQUFkLENBQU47QUFDSDtBQUNELFlBQUksUUFBSixFQUFjO0FBQ1YsZ0JBQUksQ0FBQyxNQUFNLE9BQU4sQ0FBYyxRQUFkLENBQUwsRUFBOEIsV0FBVyxDQUFDLFFBQUQsQ0FBWDtBQUM5QixnQkFBSSxTQUFTLE9BQVQsQ0FBaUIsS0FBSyxRQUF0QixNQUFvQyxDQUFDLENBQXpDLEVBQTRDO0FBQ3hDLHNCQUFNLElBQUksU0FBSixDQUFjLGtCQUFrQixXQUFsQixHQUFnQywyQ0FBaEMsR0FBOEUsUUFBNUYsQ0FBTjtBQUNIO0FBQ0o7QUFDRCxZQUFJLEtBQUosRUFBVztBQUNQLGdCQUFJLENBQUMsTUFBTSxPQUFOLENBQWMsS0FBZCxDQUFMLEVBQTJCLFFBQVEsQ0FBQyxLQUFELENBQVI7QUFDM0IsZ0JBQUksTUFBTSxPQUFOLENBQWMsS0FBSyxLQUFuQixNQUE4QixDQUFDLENBQW5DLEVBQXNDO0FBQ2xDLHNCQUFNLElBQUksU0FBSixDQUFjLGtCQUFrQixXQUFsQixHQUFnQyx1Q0FBaEMsR0FBMEUsS0FBeEYsQ0FBTjtBQUNIO0FBQ0o7QUFDRCxZQUFJLFVBQUosRUFBZ0I7QUFDWixnQkFBSSxDQUFDLE1BQU0sT0FBTixDQUFjLFVBQWQsQ0FBTCxFQUFnQyxhQUFhLENBQUMsVUFBRCxDQUFiO0FBQ2hDLGdCQUFJLFdBQVcsT0FBWCxDQUFtQixLQUFLLFVBQXhCLE1BQXdDLENBQUMsQ0FBN0MsRUFBZ0Q7QUFDNUMsc0JBQU0sSUFBSSxTQUFKLENBQWMsa0JBQWtCLFdBQWxCLEdBQWdDLDZDQUFoQyxHQUFnRixVQUE5RixDQUFOO0FBQ0g7QUFDSjtBQUNELFlBQUksVUFBSixFQUFnQjtBQUNaLGdCQUFJLENBQUMsTUFBTSxPQUFOLENBQWMsVUFBZCxDQUFMLEVBQWdDLGFBQWEsQ0FBQyxVQUFELENBQWI7QUFDaEMsZ0JBQUksV0FBVyxPQUFYLENBQW1CLEtBQUssVUFBeEIsTUFBd0MsQ0FBQyxDQUE3QyxFQUFnRDtBQUM1QyxzQkFBTSxJQUFJLFNBQUosQ0FBYyxrQkFBa0IsV0FBbEIsR0FBZ0Msd0RBQWhDLEdBQTJGLFVBQXpHLENBQU47QUFDSDtBQUNKO0FBQ0o7O0FBRUQsZ0JBQVksTUFBWixFQUFvQjtBQUNoQixZQUFLLFNBQVMsQ0FBVixJQUFpQixVQUFVLEtBQUssS0FBcEMsRUFBNEM7QUFDeEMsa0JBQU0sSUFBSSxVQUFKLENBQWdCLHlEQUF1RCxLQUFLLEtBQUwsR0FBYSxDQUFFLHNCQUFtQixNQUFPLEdBQWhILENBQU47QUFDSDtBQUNKOztBQUVELGFBQVMsR0FBVCxFQUFjO0FBQ1YsWUFBSyxNQUFNLENBQVAsSUFBYyxPQUFPLEtBQUssTUFBOUIsRUFBdUM7QUFDbkMsa0JBQU0sSUFBSSxVQUFKLENBQWdCLG1EQUFpRCxLQUFLLE1BQUwsR0FBYyxDQUFFLHNCQUFtQixHQUFJLEdBQXhHLENBQU47QUFDSDtBQUNKOztBQUVELGlCQUFhLE9BQWIsRUFBc0I7QUFDbEIsWUFBSyxVQUFVLENBQVgsSUFBa0IsV0FBVyxLQUFLLFFBQXRDLEVBQWlEO0FBQzdDLGtCQUFNLElBQUksVUFBSixDQUFnQiwyREFBeUQsS0FBSyxRQUFMLEdBQWdCLENBQUUsc0JBQW1CLE9BQVEsR0FBdEgsQ0FBTjtBQUNIO0FBQ0o7O0FBR0QsVUFBTSxNQUFOLEVBQWM7QUFDVixhQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksS0FBSyxNQUF6QixFQUFpQyxHQUFqQyxFQUFzQztBQUNsQyxpQkFBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLEtBQUssS0FBekIsRUFBZ0MsR0FBaEMsRUFBcUM7QUFDakMsb0JBQUksUUFBUSxDQUFDLElBQUksS0FBSyxLQUFULEdBQWlCLENBQWxCLElBQXVCLEtBQUssUUFBeEM7QUFDQSx1QkFBTyxJQUFQLENBQVksSUFBWixFQUFrQixLQUFsQjtBQUVIO0FBQ0o7QUFDSjtBQWpZc0I7O2tCQUFOLEs7QUFvWXJCLHNCQUFPLEtBQVA7QUFDQSwwQkFBVyxLQUFYOzs7Ozs7OztRQ2xYZ0IsTyxHQUFBLE87UUFJQSw0QixHQUFBLDRCO1FBUUEsZ0IsR0FBQSxnQjs7QUFsRGhCOztJQUFZLEk7O0FBQ1o7Ozs7QUFFQSxJQUFNLFFBQVEsRUFBZDs7QUFFQSxNQUFNLEtBQUssTUFBWCxJQUFxQjtBQUNqQixnQkFBWSxDQURLO0FBRWpCLFdBQU8sQ0FGVTtBQUdqQixjQUFVO0FBSE8sQ0FBckI7O0FBTUEsTUFBTSxLQUFLLEtBQVgsSUFBb0I7QUFDaEIsZ0JBQVksQ0FESTtBQUVoQixXQUFPLENBRlM7QUFHaEIsY0FBVTtBQUhNLENBQXBCOztBQU1BLE1BQU0sS0FBSyxJQUFYLElBQW1CO0FBQ2YsZ0JBQVksQ0FERztBQUVmLFdBQU8sQ0FGUTtBQUdmLGNBQVU7QUFISyxDQUFuQjs7QUFNQSxNQUFNLEtBQUssSUFBWCxJQUFtQjtBQUNmLGdCQUFZLENBREc7QUFFZixXQUFPLENBRlE7QUFHZixjQUFVLENBSEs7QUFJZjtBQUplLENBQW5COztBQU9BLE1BQU0sS0FBSyxHQUFYLElBQWtCO0FBQ2QsZ0JBQVksQ0FERTtBQUVkLFdBQU8sQ0FGTztBQUdkLGNBQVUsQ0FISTtBQUlkO0FBSmMsQ0FBbEI7O0FBUU8sU0FBUyxPQUFULENBQWlCLElBQWpCLEVBQXVCO0FBQzFCLFdBQU8sTUFBTSxJQUFOLENBQVA7QUFDSDs7QUFFTSxTQUFTLDRCQUFULENBQXNDLEtBQXRDLEVBQTZDO0FBQ2hELFFBQUksU0FBUyxNQUFNLFFBQU4sR0FBaUIsTUFBTSxJQUFwQztBQUNBLFFBQUksTUFBTSxRQUFOLEtBQW1CLENBQXZCLEVBQTBCO0FBQ3RCLGlCQUFTLEtBQUssSUFBTCxDQUFVLFNBQVMsQ0FBbkIsQ0FBVDtBQUNIO0FBQ0QsV0FBTyxNQUFQO0FBQ0g7O0FBRU0sU0FBUyxnQkFBVCxDQUEwQixLQUExQixFQUFpQztBQUNwQyxRQUFJLFNBQVMsTUFBTSxRQUFOLEdBQWlCLE1BQU0sSUFBcEM7QUFDQSxRQUFJLFlBQUo7QUFDQSxZQUFRLE1BQU0sUUFBZDtBQUNJLGFBQUssQ0FBTDtBQUNJLGtCQUFNLElBQUksVUFBSixDQUFlLEtBQUssSUFBTCxDQUFVLFNBQVMsQ0FBbkIsQ0FBZixDQUFOO0FBQ0E7QUFDSixhQUFLLENBQUw7QUFDSSxrQkFBTSxJQUFJLGlCQUFKLENBQXNCLE1BQXRCLENBQU47QUFDQTtBQUNKLGFBQUssRUFBTDtBQUNJLGtCQUFNLElBQUksV0FBSixDQUFnQixNQUFoQixDQUFOO0FBQ0E7QUFDSixhQUFLLEVBQUw7QUFDSSxrQkFBTSxJQUFJLFlBQUosQ0FBaUIsTUFBakIsQ0FBTjtBQUNBO0FBQ0o7QUFDSSxrQkFBTSxJQUFJLEtBQUosQ0FBVSw2Q0FBNkMsTUFBTSxRQUE3RCxDQUFOO0FBZFI7OztBQWtCQSxRQUFJLE1BQU0sS0FBVixFQUFpQjtBQUNiLGFBQUssSUFBSSxJQUFJLE1BQU0sVUFBbkIsRUFBK0IsSUFBSSxJQUFJLE1BQXZDLEVBQStDLEtBQUssTUFBTSxRQUExRCxFQUFvRTtBQUNoRSxnQkFBSSxDQUFKLElBQVMsTUFBTSxRQUFmO0FBQ0g7QUFDSjtBQUNELFVBQU0sSUFBTixHQUFhLEdBQWI7QUFDSDs7Ozs7Ozs7OztBQzNFTSxJQUFNLDBCQUFTLFFBQWY7QUFDQSxJQUFNLHdCQUFRLE9BQWQ7QUFDQSxJQUFNLHNCQUFPLE1BQWI7QUFDQSxJQUFNLG9CQUFNLEtBQVo7QUFDQSxJQUFNLHNCQUFPLE1BQWI7Ozs7Ozs7O1FDaUJTLE8sR0FBQSxPOztBQXZCaEI7Ozs7QUFDQTs7OztBQUNBOztBQUNBOztBQUNBOztBQUNBOzs7Ozs7QUFFQSxJQUFNLFlBQVksZ0NBQWxCO0FBQ0EsSUFBTSxRQUFRLFNBQWQ7QUFDQSxJQUFNLFNBQVMsV0FBZjs7QUFFQSxTQUFTLE1BQVQsQ0FBZ0IsR0FBaEIsRUFBcUI7QUFDakIsUUFBTSxNQUFNLElBQUksVUFBSixDQUFlLElBQUksTUFBbkIsQ0FBWjtBQUNBLFNBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxJQUFJLE1BQXhCLEVBQWdDLEdBQWhDLEVBQXFDO0FBQ2pDLFlBQUksQ0FBSixJQUFTLElBQUksVUFBSixDQUFlLENBQWYsQ0FBVDtBQUNIO0FBQ0QsV0FBTyxHQUFQO0FBQ0g7O0FBRUQsU0FBUyxNQUFULENBQWdCLEdBQWhCLEVBQXFCO0FBQ2pCLFdBQVEsQ0FBQyxNQUFNLElBQVAsS0FBZ0IsQ0FBakIsR0FBd0IsT0FBTyxDQUFSLEdBQWEsSUFBM0M7QUFDSDs7QUFFTSxTQUFTLE9BQVQsQ0FBaUIsR0FBakIsRUFBc0I7QUFDekIsUUFBTSxVQUFVLElBQUksS0FBSixDQUFVLENBQVYsRUFBYSxFQUFiLEVBQWlCLEtBQWpCLENBQXVCLFNBQXZCLENBQWhCO0FBQ0EsUUFBSSxPQUFKLEVBQWE7QUFDVCxZQUFNLFdBQVcsUUFBUSxDQUFSLENBQWpCO0FBQ0EsWUFBTSxTQUFTLFFBQVEsQ0FBUixFQUFXLE1BQTFCO0FBQ0EsWUFBSSxhQUFhLEtBQWpCLEVBQXdCO0FBQ3BCLGdCQUFJLFFBQVEsSUFBSSxLQUFKLENBQVUsTUFBVixDQUFaO0FBQ0EsbUJBQU8sUUFBUSxPQUFSLENBQWdCLE9BQU8sd0JBQUssS0FBTCxDQUFQLENBQWhCLEVBQXFDLElBQXJDLENBQTBDLE9BQTFDLENBQVA7QUFDSCxTQUhELE1BR08sSUFBSSxhQUFhLE1BQWpCLEVBQXlCO0FBQzVCLGdCQUFJLFNBQVEsSUFBSSxLQUFKLENBQVUsTUFBVixDQUFaO0FBQ0EsbUJBQU8sUUFBUSxPQUFSLENBQWdCLE9BQU8sd0JBQUssTUFBTCxDQUFQLENBQWhCLEVBQXFDLElBQXJDLENBQTBDLFFBQTFDLENBQVA7QUFDSDtBQUNKOztBQUVELFFBQUksTUFBTSxJQUFOLENBQVcsR0FBWCxDQUFKLEVBQXFCO0FBQ2pCLGVBQU8sNkJBQVcsR0FBWCxFQUFnQixJQUFoQixDQUFxQixPQUFyQixDQUFQO0FBQ0gsS0FGRCxNQUVPLElBQUksT0FBTyxJQUFQLENBQVksR0FBWixDQUFKLEVBQXNCO0FBQ3pCLGVBQU8sNkJBQVcsR0FBWCxFQUFnQixJQUFoQixDQUFxQixRQUFyQixDQUFQO0FBQ0g7O0FBRUQsV0FBTyxZQUFZLEdBQVosQ0FBUDtBQUNIOztBQUVELFNBQVMsT0FBVCxDQUFpQixJQUFqQixFQUF1QjtBQUNuQixRQUFNLFVBQVUsd0JBQWUsSUFBZixDQUFoQjtBQUNBLFFBQU0sTUFBTSxRQUFRLE1BQVIsRUFBWjtBQUNBLFFBQU0sV0FBVyxJQUFJLFFBQXJCO0FBQ0EsUUFBTSxTQUFTLElBQUksSUFBSixDQUFTLE1BQXhCO0FBQ0EsUUFBSSxlQUFKO0FBQ0EsUUFBSSxhQUFhLENBQWpCLEVBQW9CO0FBQ2hCLGlCQUFTLElBQUksaUJBQUosQ0FBc0IsTUFBdEIsQ0FBVDtBQUNILEtBRkQsTUFFTyxJQUFJLGFBQWEsRUFBakIsRUFBcUI7QUFDeEIsaUJBQVMsSUFBSSxXQUFKLENBQWdCLE1BQWhCLENBQVQ7QUFDQSxhQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksT0FBTyxNQUEzQixFQUFtQyxHQUFuQyxFQUF3QztBQUNwQyxtQkFBTyxDQUFQLElBQVksT0FBTyxPQUFPLENBQVAsQ0FBUCxDQUFaO0FBQ0g7QUFDSjs7QUFFRCxRQUFNLE9BQU8sSUFBSSxVQUFqQjtBQUNBLFFBQUksbUJBQUo7QUFBQSxRQUFnQixRQUFRLENBQXhCO0FBQ0EsWUFBUSxJQUFSO0FBQ0ksYUFBSyxDQUFMO0FBQVEseUJBQWEsQ0FBYixDQUFnQjtBQUN4QixhQUFLLENBQUw7QUFBUSx5QkFBYSxDQUFiLENBQWdCO0FBQ3hCLGFBQUssQ0FBTDtBQUFRLHlCQUFhLENBQWIsQ0FBZ0IsUUFBUSxDQUFSLENBQVc7QUFDbkMsYUFBSyxDQUFMO0FBQVEseUJBQWEsQ0FBYixDQUFnQixRQUFRLENBQVIsQ0FBVztBQUp2Qzs7QUFPQSxXQUFPLG9CQUFVLElBQUksS0FBZCxFQUFxQixJQUFJLE1BQXpCLEVBQWlDLE1BQWpDLEVBQXlDLEVBQUMsc0JBQUQsRUFBYSxZQUFiLEVBQW9CLGtCQUFwQixFQUF6QyxDQUFQO0FBQ0g7O0FBRUQsU0FBUyxRQUFULENBQWtCLElBQWxCLEVBQXdCO0FBQ3BCLFFBQUksVUFBVSxzQkFBZ0IsSUFBaEIsQ0FBZDtBQUNBLFFBQUksU0FBUyxRQUFRLE1BQVIsRUFBYjtBQUNBLFFBQUksT0FBTyxHQUFQLENBQVcsTUFBWCxLQUFzQixDQUExQixFQUE2QjtBQUN6QixlQUFPLGdCQUFnQixPQUFPLEdBQVAsQ0FBVyxDQUFYLENBQWhCLENBQVA7QUFDSCxLQUZELE1BRU87QUFDSCxlQUFPLG9CQUFVLE9BQU8sR0FBUCxDQUFXLEdBQVgsQ0FBZSxlQUFmLENBQVYsQ0FBUDtBQUNIO0FBQ0o7O0FBRUQsU0FBUyxlQUFULENBQXlCLEtBQXpCLEVBQWdDO0FBQzVCLFdBQU8sb0JBQVUsTUFBTSxLQUFoQixFQUF1QixNQUFNLE1BQTdCLEVBQXFDLE1BQU0sSUFBM0MsRUFBaUQ7QUFDcEQsb0JBQVksQ0FEd0M7QUFFcEQsZUFBTyxDQUY2QztBQUdwRCxvQkFBWSxJQUh3QztBQUlwRCxrQkFBVSxNQUFNO0FBSm9DLEtBQWpELENBQVA7QUFNSDs7QUFFRCxTQUFTLFdBQVQsQ0FBcUIsR0FBckIsRUFBMEI7QUFDdEIsV0FBTyxJQUFJLE9BQUosQ0FBWSxVQUFVLE9BQVYsRUFBbUIsTUFBbkIsRUFBMkI7QUFDMUMsWUFBSSxRQUFRLDJCQUFaOztBQUVBLFlBQUksb0NBQWtCLEdBQWxCLENBQUosRUFBNEI7O0FBRXhCLGtCQUFNLFdBQU4sR0FBb0IsV0FBcEI7QUFDSDs7QUFFRCxjQUFNLE1BQU4sR0FBZSxZQUFZO0FBQ3ZCLGdCQUFJLElBQUksTUFBTSxLQUFkO0FBQUEsZ0JBQXFCLElBQUksTUFBTSxNQUEvQjtBQUNBLGdCQUFJLFNBQVMsd0JBQVcsQ0FBWCxFQUFjLENBQWQsQ0FBYjtBQUNBLGdCQUFJLE1BQU0sT0FBTyxVQUFQLENBQWtCLElBQWxCLENBQVY7QUFDQSxnQkFBSSxTQUFKLENBQWMsS0FBZCxFQUFxQixDQUFyQixFQUF3QixDQUF4QixFQUEyQixDQUEzQixFQUE4QixDQUE5QjtBQUNBLGdCQUFJLE9BQU8sSUFBSSxZQUFKLENBQWlCLENBQWpCLEVBQW9CLENBQXBCLEVBQXVCLENBQXZCLEVBQTBCLENBQTFCLEVBQTZCLElBQXhDO0FBQ0Esb0JBQVEsb0JBQVUsQ0FBVixFQUFhLENBQWIsRUFBZ0IsSUFBaEIsQ0FBUjtBQUNILFNBUEQ7QUFRQSxjQUFNLE9BQU4sR0FBZ0IsWUFBWTtBQUN4QixtQkFBTyxJQUFJLEtBQUosQ0FBVSxvQkFBb0IsR0FBOUIsQ0FBUDtBQUNILFNBRkQ7QUFHQSxjQUFNLEdBQU4sR0FBWSxHQUFaO0FBQ0gsS0FwQk0sQ0FBUDtBQXFCSDs7Ozs7Ozs7UUMvRmUsUSxHQUFBLFE7UUFzQkEsTyxHQUFBLE87O0FBekNoQjs7OztBQUNBOztBQUNBOzs7Ozs7QUFFQSxJQUFJLFFBQVEsSUFBSSxHQUFKLEVBQVo7QUFDQSxJQUFJLGNBQUo7O0FBRUEsU0FBUyxZQUFULENBQXNCLElBQXRCLEVBQTRCO0FBQ3hCLFFBQUksQ0FBQyxLQUFMLEVBQVk7QUFDUixnQkFBUSxvQkFBVSxDQUFWLEVBQWEsQ0FBYixDQUFSO0FBQ0g7QUFDRCxRQUFJLFVBQVUsTUFBTSxHQUFOLENBQVUsSUFBVixDQUFkO0FBQ0EsUUFBSSxDQUFDLE9BQUwsRUFBYztBQUNWLGtCQUFVLElBQUksU0FBSixDQUFjLElBQWQsQ0FBVjtBQUNBLGNBQU0sR0FBTixDQUFVLElBQVYsRUFBZ0IsT0FBaEI7QUFDSDtBQUNELFdBQU8sT0FBUDtBQUNIOztBQUVNLFNBQVMsUUFBVCxDQUFrQixJQUFsQixFQUF3QjtBQUMzQixRQUFJLHFCQUFRLE1BQVIsSUFBa0IsU0FBUyxXQUEvQixFQUE0QztBQUN4QyxlQUFPLEtBQVAsQztBQUNILEtBRkQsTUFFTztBQUNILGVBQU8sYUFBYSxJQUFiLEVBQW1CLFFBQW5CLEVBQVA7QUFDSDtBQUNKOztBQUVELE1BQU0sU0FBTixDQUFnQjtBQUNaLGdCQUFZLElBQVosRUFBa0I7QUFDZCxhQUFLLElBQUwsR0FBWSxJQUFaO0FBQ0EsYUFBSyxTQUFMLEdBQWlCLElBQWpCO0FBQ0g7O0FBRUQsZUFBVztBQUNQLFlBQUksS0FBSyxTQUFMLEtBQW1CLElBQXZCLEVBQTZCO0FBQ3pCLGlCQUFLLFNBQUwsR0FBaUIsTUFBTSxTQUFOLENBQWdCLEtBQUssSUFBckIsRUFBMkIsVUFBM0IsQ0FBc0MsVUFBVSxLQUFLLElBQXJELENBQWpCO0FBQ0g7QUFDRCxlQUFPLEtBQUssU0FBWjtBQUNIO0FBWFc7O0FBY1QsU0FBUyxPQUFULENBQWlCLElBQWpCLEVBQXVCO0FBQzFCLFFBQUksQ0FBQyw4QkFBUyxJQUFULEVBQWUsR0FBZixDQUFMLEVBQTBCO0FBQ3RCLGVBQU8sV0FBVyxJQUFsQjtBQUNIO0FBQ0QsV0FBTyxJQUFQO0FBQ0g7Ozs7Ozs7O0FDOUNNLElBQU0sb0JBQU0sS0FBWjtBQUNBLElBQU0sb0JBQU0sS0FBWjtBQUNBLElBQU0sb0JBQU0sS0FBWjs7Ozs7Ozs7a0JDV2lCLFc7O0FBWnhCOzs7O0FBQ0E7O0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUFVZSxTQUFTLFdBQVQsQ0FBcUIsTUFBckIsRUFBeUc7QUFBQSxxRUFBSixFQUFJOztBQUFBLFFBQTNFLFFBQTJFLFFBQTNFLFFBQTJFO0FBQUEsUUFBakUsUUFBaUUsUUFBakUsUUFBaUU7QUFBQSw4QkFBdkQsU0FBdUQ7QUFBQSxRQUF2RCxTQUF1RCxrQ0FBM0MsS0FBMkM7QUFBQSw0QkFBcEMsT0FBb0M7QUFBQSxRQUFwQyxPQUFvQyxnQ0FBMUIsQ0FBMEI7QUFBQSwyQkFBdkIsTUFBdUI7QUFBQSxRQUF2QixNQUF1QiwrQkFBZCxNQUFjOzs7QUFFcEgsUUFBSSxXQUFXLGdCQUFNLFVBQU4sQ0FBaUIsSUFBakIsRUFBdUIsRUFBQyxVQUFVLFFBQVgsRUFBdkIsQ0FBZjs7QUFFQSxlQUFXLHNDQUF3QixJQUF4QixFQUE4QixRQUE5QixFQUF3QyxJQUF4QyxDQUFYOztBQUVBLFFBQUksZUFBSjtBQUFBLFFBQVksZ0JBQVo7Ozs7O0FBTm9ILDBCQU92Riw0QkFBZSxNQUFmLENBUHVGOztBQU9sSCxVQVBrSCxtQkFPbEgsTUFQa0g7QUFPMUcsV0FQMEcsbUJBTzFHLE9BUDBHO0FBT2pHLFVBUGlHLG1CQU9qRyxNQVBpRztBQVVwSCxRQUFJLFNBQUosRUFBZTtBQUNYLGtCQUFVLENBQVY7QUFDQSxhQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksT0FBTyxNQUEzQixFQUFtQyxHQUFuQztBQUNJLGlCQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksT0FBTyxDQUFQLEVBQVUsTUFBOUIsRUFBc0MsR0FBdEM7QUFDSSwyQkFBVyxPQUFPLENBQVAsRUFBVSxDQUFWLENBQVg7QUFESjtBQURKO0FBR0g7O0FBRUQsUUFBSSxZQUFZLENBQWhCLEVBQW1CO0FBQ2YsY0FBTSxJQUFJLFVBQUosQ0FBZSwyQ0FBZixDQUFOO0FBQ0g7O0FBR0QsUUFBSSxVQUFVLFNBQVMsU0FBdkI7O0FBRUEsU0FBSyxJQUFJLFVBQVUsQ0FBbkIsRUFBc0IsVUFBVSxTQUFTLE1BQXpDLEVBQWlELFNBQWpELEVBQTREO0FBQ3hELFlBQUksSUFBSSxTQUFTLE9BQVQsQ0FBUjtBQUNBLGFBQUssSUFBSSxJQUFJLE9BQWIsRUFBc0IsSUFBSSxLQUFLLE1BQUwsR0FBYyxPQUF4QyxFQUFpRCxHQUFqRCxFQUFzRDtBQUNsRCxpQkFBSyxJQUFJLElBQUksTUFBYixFQUFxQixJQUFJLEtBQUssS0FBTCxHQUFhLE1BQXRDLEVBQThDLEdBQTlDLEVBQW1EO0FBQy9DLG9CQUFJLE1BQU0sQ0FBVjtBQUNBLHFCQUFLLElBQUksS0FBSSxDQUFDLE9BQWQsRUFBdUIsTUFBSyxPQUE1QixFQUFxQyxJQUFyQyxFQUEwQztBQUN0Qyx5QkFBSyxJQUFJLEtBQUksQ0FBQyxNQUFkLEVBQXNCLE1BQUssTUFBM0IsRUFBbUMsSUFBbkMsRUFBd0M7QUFDcEMsNEJBQUksT0FBTyxPQUFPLFVBQVUsRUFBakIsRUFBb0IsU0FBUyxFQUE3QixDQUFYO0FBQ0EsNEJBQUksU0FBUSxDQUFDLENBQUMsSUFBSSxFQUFMLElBQVUsS0FBSyxLQUFmLEdBQXVCLENBQXZCLEdBQTJCLEVBQTVCLElBQWlDLEtBQUssUUFBdEMsR0FBaUQsQ0FBN0Q7QUFDQSwrQkFBTyxLQUFLLElBQUwsQ0FBVSxNQUFWLElBQW1CLElBQTFCO0FBQ0g7QUFDSjs7QUFFRCxvQkFBSSxRQUFRLENBQUMsSUFBSSxLQUFLLEtBQVQsR0FBaUIsQ0FBbEIsSUFBdUIsS0FBSyxRQUE1QixHQUF1QyxDQUFuRDtBQUNBLG9CQUFJLE9BQUosRUFBYTs7QUFDVCw2QkFBUyxJQUFULENBQWMsS0FBZCxJQUF1QixLQUFLLEdBQUwsQ0FBUyxLQUFLLEdBQUwsQ0FBUyxLQUFLLEtBQUwsQ0FBVyxNQUFNLE9BQWpCLENBQVQsRUFBb0MsQ0FBcEMsQ0FBVCxFQUFpRCxTQUFTLFFBQTFELENBQXZCO0FBQ0gsaUJBRkQsTUFFTztBQUNILDZCQUFTLElBQVQsQ0FBYyxLQUFkLElBQXVCLE1BQU0sT0FBN0I7QUFDSDtBQUNKO0FBQ0o7QUFDSjs7Ozs7QUFLRCxRQUFJLEtBQUssS0FBTCxJQUFjLFNBQVMsT0FBVCxDQUFpQixLQUFLLFFBQXRCLE1BQW9DLENBQUMsQ0FBdkQsRUFBMEQ7QUFDdEQsYUFBSyxJQUFJLE1BQUksS0FBSyxVQUFsQixFQUE4QixNQUFJLEtBQUssSUFBTCxDQUFVLE1BQTVDLEVBQW9ELE1BQUksTUFBSSxLQUFLLFFBQWpFLEVBQTJFO0FBQ3ZFLHFCQUFTLElBQVQsQ0FBYyxHQUFkLElBQW1CLEtBQUssSUFBTCxDQUFVLEdBQVYsQ0FBbkI7QUFDSDtBQUNKOztBQUVELGFBQVMsU0FBVCxDQUFtQixFQUFDLE1BQUssQ0FBQyxNQUFELEVBQVMsT0FBVCxDQUFOLEVBQXlCLFdBQVcsTUFBcEMsRUFBbkI7O0FBRUEsV0FBTyxRQUFQO0FBQ0g7Ozs7Ozs7O2tCQ25FdUIsTzs7QUFGeEI7Ozs7OztBQUVlLFNBQVMsT0FBVCxDQUFpQixJQUFqQixFQUVLO0FBQUEscUVBQUosRUFBSTs7QUFBQSwwQkFEaEIsS0FDZ0I7QUFBQSxRQURoQixLQUNnQiw4QkFEUixDQUNRO0FBQUEsUUFBaEIsUUFBZ0IsUUFBaEIsUUFBZ0I7OztBQUVoQixTQUFLLGdCQUFMLENBQXNCLFNBQXRCLEVBQWlDO0FBQzdCLGtCQUFVLENBQUMsQ0FBRCxFQUFJLEVBQUo7QUFEbUIsS0FBakM7OztBQUtBLFFBQUksQ0FBQyxRQUFMLEVBQWU7QUFDWCxtQkFBVyxLQUFLLG1CQUFMLENBQXlCLElBQXpCLENBQVg7QUFDQSxZQUFJLENBQUMsUUFBTCxFQUFlO0FBQ1gsa0JBQU0sSUFBSSxLQUFKLENBQVUsaUZBQ1osa0ZBREUsQ0FBTjtBQUVIO0FBQ0o7QUFDRCxRQUFJLFVBQVUsZ0JBQU0sVUFBTixDQUFpQixJQUFqQixFQUF1QjtBQUNqQyxlQUFPLEtBQUssS0FEcUI7QUFFakMsZ0JBQVEsS0FBSyxNQUZvQjtBQUdqQyxlQUFPLENBSDBCLEU7QUFJakMsa0JBQVUsUUFKdUI7QUFLakMsZ0JBQVE7QUFMeUIsS0FBdkIsQ0FBZDs7QUFVQSxTQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksS0FBSyxLQUF6QixFQUFnQyxHQUFoQyxFQUFxQztBQUNqQyxhQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksS0FBSyxNQUF6QixFQUFpQyxHQUFqQyxFQUFzQzs7QUFFbEMsaUJBQUssSUFBSSxVQUFVLENBQW5CLEVBQXNCLFVBQVUsS0FBSyxRQUFyQyxFQUErQyxTQUEvQyxFQUEwRDtBQUN0RCxvQkFBSSxRQUFRLEtBQUssVUFBTCxDQUFnQixJQUFJLFNBQVMsQ0FBVCxDQUFwQixFQUFpQyxJQUFJLFNBQVMsQ0FBVCxDQUFyQyxFQUFrRCxPQUFsRCxDQUFaO0FBQ0Esd0JBQVEsVUFBUixDQUFtQixDQUFuQixFQUFzQixDQUF0QixFQUF5QixPQUF6QixFQUFrQyxLQUFsQztBQUNIOztBQUVELGdCQUFJLENBQUMsS0FBSyxRQUFMLENBQWMsQ0FBZCxFQUFpQixDQUFqQixDQUFMLEVBQTBCO0FBQ3RCLHdCQUFRLFVBQVIsQ0FBbUIsQ0FBbkIsRUFBc0IsQ0FBdEIsRUFBeUIsS0FBSyxVQUE5QixFQUEwQyxDQUExQztBQUNIO0FBQ0o7QUFDSjs7QUFFRCxXQUFPLE9BQVA7QUFDSCxDOzs7Ozs7OztrQkM1Q3VCLFU7O0FBRnhCOztBQUVlLFNBQVMsVUFBVCxDQUFvQixLQUFwQixFQUVIO0FBQUEscUVBQUosRUFBSTs7QUFBQSwwQkFEUixLQUNRO0FBQUEsUUFEUixLQUNRLDhCQURBLENBQUMsS0FBSyxRQUFOLEVBQWdCLENBQWhCLEVBQW1CLENBQW5CLENBQ0E7OztBQUVSLFNBQUssZ0JBQUwsQ0FBc0IsWUFBdEIsRUFBb0M7QUFDaEMsb0JBQVksQ0FEb0I7QUFFaEMsa0JBQVUsQ0FBQyxDQUFELEVBQUksRUFBSixDQUZzQjtBQUdoQztBQUhnQyxLQUFwQzs7QUFNQSxRQUFJLENBQUMsTUFBTSxPQUFOLENBQWMsS0FBZCxDQUFMLEVBQTJCLFFBQVEsQ0FBQyxLQUFELENBQVI7O0FBRTNCLFFBQUksaUJBQWlCLEtBQUssR0FBTCxDQUFTLEtBQUssUUFBZCxFQUF3QixNQUFNLE1BQTlCLENBQXJCOztBQUlBLFNBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxNQUFNLE1BQTFCLEVBQWtDLEdBQWxDLEVBQXVDO0FBQ25DLFlBQUksTUFBTSxNQUFNLENBQU4sQ0FBVjs7O0FBR0EsYUFBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLElBQUksS0FBeEIsRUFBK0IsR0FBL0IsRUFBb0M7QUFDaEMsaUJBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxJQUFJLE1BQXhCLEVBQWdDLEdBQWhDLEVBQXFDO0FBQ2pDLG9CQUFJLElBQUksUUFBSixDQUFhLENBQWIsRUFBZ0IsQ0FBaEIsQ0FBSixFQUF3QjtBQUNwQix5QkFBSyxJQUFJLFVBQVUsQ0FBbkIsRUFBc0IsVUFBVSxjQUFoQyxFQUFnRCxTQUFoRCxFQUEyRDtBQUN2RCw2QkFBSyxVQUFMLENBQWdCLElBQUksSUFBSSxRQUFKLENBQWEsQ0FBYixDQUFwQixFQUFxQyxJQUFJLElBQUksUUFBSixDQUFhLENBQWIsQ0FBekMsRUFBMEQsT0FBMUQsRUFBbUUsTUFBTSxPQUFOLENBQW5FO0FBQ0g7QUFDSjtBQUNKO0FBQ0o7QUFDSjtBQUNKOzs7Ozs7OztrQkM3QnVCLFc7O0FBSHhCOztBQUNBOzs7Ozs7QUFFZSxTQUFTLFdBQVQsQ0FBcUIsTUFBckIsRUFFRTtBQUFBLHFFQUFKLEVBQUk7O0FBQUEsMEJBRGIsS0FDYTtBQUFBLFFBRGIsS0FDYSw4QkFETCxDQUFDLEtBQUssUUFBTixFQUFnQixDQUFoQixFQUFtQixDQUFuQixDQUNLO0FBQUEsUUFBYixLQUFhLFFBQWIsS0FBYTs7O0FBRWIsU0FBSyxnQkFBTCxDQUFzQixhQUF0QixFQUFxQztBQUNqQyxvQkFBWSxDQURxQjtBQUVqQyxrQkFBVSxDQUFDLENBQUQsRUFBSSxFQUFKLENBRnVCO0FBR2pDO0FBSGlDLEtBQXJDOztBQU1BLFFBQUksY0FBZSxvQkFBVSxLQUFWLENBQUQsQ0FBbUIsU0FBbkIsRUFBbEI7O0FBRUEsUUFBSSxpQkFBaUIsS0FBSyxHQUFMLENBQVMsS0FBSyxRQUFkLEVBQXdCLE1BQU0sTUFBOUIsQ0FBckI7O0FBRUEsU0FBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLE9BQU8sTUFBM0IsRUFBbUMsR0FBbkMsRUFBd0M7QUFDcEMsWUFBSSxLQUFLLE9BQU8sQ0FBUCxFQUFVLENBQVYsQ0FBVDtBQUNBLFlBQUksS0FBSyxPQUFPLENBQVAsRUFBVSxDQUFWLENBQVQ7QUFDQSxhQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksWUFBWSxNQUFoQyxFQUF3QyxHQUF4QyxFQUE2QztBQUN6QyxnQkFBSSxLQUFLLFlBQVksQ0FBWixFQUFlLENBQWYsQ0FBVDtBQUNBLGdCQUFJLEtBQUssWUFBWSxDQUFaLEVBQWUsQ0FBZixDQUFUO0FBQ0EsZ0JBQ00sS0FBSyxFQUFOLElBQWEsQ0FBZCxJQUNFLEtBQUssRUFBTixJQUFhLENBRGQsSUFFRSxLQUFLLEVBQU4sR0FBWSxLQUFLLEtBRmxCLElBR0UsS0FBSyxFQUFOLEdBQVksS0FBSyxNQUp0QixFQUtFO0FBQ0Usb0JBQUksV0FBVyxDQUFDLEtBQUssRUFBTCxHQUFVLENBQUMsS0FBSyxFQUFOLElBQVksS0FBSyxLQUE1QixJQUFxQyxLQUFLLFFBQXpEO0FBQ0EscUJBQUssSUFBSSxVQUFVLENBQW5CLEVBQXNCLFVBQVUsY0FBaEMsRUFBZ0QsU0FBaEQsRUFBMkQ7QUFDdkQseUJBQUssSUFBTCxDQUFVLFdBQVcsT0FBckIsSUFBZ0MsTUFBTSxPQUFOLENBQWhDO0FBQ0g7QUFDSjtBQUNKO0FBQ0o7QUFDSjs7Ozs7Ozs7QUNwQ2MsTUFBTSxNQUFOLENBQWE7QUFDeEIsZ0JBQVksTUFBWixFQUFvQixNQUFwQixFQUE0QixVQUE1QixFQUF3QyxVQUF4QyxFQUFvRDtBQUNoRCxhQUFLLE1BQUwsR0FBYyxNQUFkO0FBQ0EsYUFBSyxLQUFMLEdBQWEsT0FBTyxLQUFwQjtBQUNBLGFBQUssTUFBTCxHQUFjLE9BQU8sTUFBckI7QUFDQSxhQUFLLE1BQUwsR0FBYyxNQUFkLEM7QUFDQSxhQUFLLFFBQUwsR0FBZ0IsQ0FBQyxVQUFqQixDO0FBQ0EsYUFBSyxRQUFMLEdBQWdCLFVBQWhCLEM7QUFDQSxhQUFLLEtBQUwsR0FBYSxhQUFhLFVBQTFCLEM7QUFDSDtBQVR1QjtrQkFBUCxNOzs7Ozs7OztrQkNTRyxTOztBQVR4Qjs7Ozs7Ozs7Ozs7O0FBU2UsU0FBUyxTQUFULENBQW1CLE1BQW5CLEVBQTJCOztBQUV0QyxRQUFJLE9BQU8sT0FBTyxLQUFsQjtBQUNBLFFBQUksT0FBTyxJQUFJLEtBQUosQ0FBVSxJQUFWLENBQVg7QUFDQSxTQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksSUFBcEIsRUFBMEIsR0FBMUIsRUFBK0I7QUFDM0IsWUFBSSxRQUFRLENBQUMsT0FBTyxRQUFSLEdBQW1CLENBQS9CO0FBQ0EsWUFBSSxLQUFLLE9BQU8sUUFBaEIsRUFBMEI7QUFDMUIsYUFBSyxDQUFMLElBQVUsa0JBQVEsTUFBUixFQUFnQixLQUFoQixDQUFWO0FBQ0g7QUFDRCxRQUFJLFNBQVMsT0FBTyxNQUFwQjs7QUFFQSxRQUFJLFFBQVEsT0FBTyxNQUFQLENBQWMsS0FBMUI7QUFDQSxRQUFJLFNBQVMsT0FBTyxNQUFQLENBQWMsTUFBM0I7O0FBRUEsU0FBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLEtBQXBCLEVBQTJCLEdBQTNCLEVBQWdDO0FBQzVCLGFBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxNQUFwQixFQUE0QixHQUE1QixFQUFpQztBQUM3QixnQkFBSSxTQUFTLElBQUksS0FBSixHQUFZLENBQXpCO0FBQ0EsZ0JBQUksT0FBTyxNQUFQLE1BQW1CLENBQXZCLEVBQTBCO0FBQ3RCLG9CQUFJLFNBQVEsT0FBTyxNQUFQLElBQWlCLE9BQU8sUUFBcEM7QUFDQSxvQkFBSSxTQUFRLE9BQU8sUUFBbkIsRUFBNkI7QUFDN0Isb0JBQUksSUFBSSxLQUFLLE1BQUwsRUFBWSxJQUFwQixFQUEwQixLQUFLLE1BQUwsRUFBWSxJQUFaLEdBQW1CLENBQW5CO0FBQzFCLG9CQUFJLElBQUksS0FBSyxNQUFMLEVBQVksSUFBcEIsRUFBMEIsS0FBSyxNQUFMLEVBQVksSUFBWixHQUFtQixDQUFuQjtBQUMxQixvQkFBSSxJQUFJLEtBQUssTUFBTCxFQUFZLElBQXBCLEVBQTBCLEtBQUssTUFBTCxFQUFZLElBQVosR0FBbUIsQ0FBbkI7QUFDMUIsb0JBQUksSUFBSSxLQUFLLE1BQUwsRUFBWSxJQUFwQixFQUEwQixLQUFLLE1BQUwsRUFBWSxJQUFaLEdBQW1CLENBQW5CO0FBQzFCLHFCQUFLLE1BQUwsRUFBWSxLQUFaLElBQXFCLENBQXJCO0FBQ0EscUJBQUssTUFBTCxFQUFZLEtBQVosSUFBcUIsQ0FBckI7QUFDQSxxQkFBSyxNQUFMLEVBQVksT0FBWjtBQUNIO0FBQ0o7QUFDSjtBQUNELFNBQUssSUFBSSxLQUFJLENBQWIsRUFBZ0IsS0FBSSxJQUFwQixFQUEwQixJQUExQixFQUErQjtBQUMzQixZQUFJLFVBQVEsQ0FBQyxPQUFPLFFBQVIsR0FBbUIsRUFBL0I7QUFDQSxZQUFJLE1BQUssT0FBTyxRQUFoQixFQUEwQjtBQUMxQixhQUFLLEVBQUwsRUFBUSxLQUFSLElBQWlCLEtBQUssRUFBTCxFQUFRLE9BQXpCO0FBQ0EsYUFBSyxFQUFMLEVBQVEsS0FBUixJQUFpQixLQUFLLEVBQUwsRUFBUSxPQUF6QjtBQUNIO0FBQ0QsV0FBTyxJQUFQO0FBQ0g7Ozs7Ozs7O2tCQzVDdUIsdUI7O0FBRnhCOzs7Ozs7QUFFZSxTQUFTLHVCQUFULEdBS2I7QUFBQSxxRUFEd0IsRUFDeEI7O0FBQUEsZ0NBSE0sV0FHTjtBQUFBLFFBSE0sV0FHTixvQ0FIb0IsSUFHcEI7QUFBQSxRQUZNLE9BRU4sUUFGTSxPQUVOO0FBQUEsMkJBRE0sTUFDTjtBQUFBLFFBRE0sTUFDTiwrQkFEZSxLQUNmOzs7QUFFRSxRQUFJLFFBQVEsSUFBWjtBQUNBLFVBQU0sZ0JBQU4sQ0FBdUIseUJBQXZCLEVBQWlELEVBQUMsWUFBVyxDQUFDLENBQUQsQ0FBWixFQUFqRDs7QUFHQSxRQUFNLGNBQWMsQ0FBcEI7QUFDQSxRQUFNLGlCQUFpQixDQUF2Qjs7O0FBR0EsUUFBSSxhQUFhLENBQWpCO0FBQ0EsUUFBSSxhQUFhLENBQWpCOztBQUVBLFFBQUksWUFBWSxDQUFDLEtBQWpCOztBQUVBLFFBQUksU0FBUyxJQUFJLFVBQUosQ0FBZSxNQUFNLElBQXJCLENBQWIsQztBQUNBLFFBQUksWUFBWSxJQUFJLFNBQUosQ0FBYyxNQUFNLElBQXBCLENBQWhCO0FBQ0EsUUFBSSxhQUFhLElBQUksWUFBSixDQUFpQixNQUFNLElBQXZCLENBQWpCOztBQUdBLFFBQUksWUFBWSxRQUFoQixDO0FBQ0EsUUFBSSxhQUFhLElBQUksV0FBSixDQUFnQixZQUFZLENBQTVCLENBQWpCLEM7QUFDQSxRQUFJLGFBQWEsSUFBSSxXQUFKLENBQWdCLFlBQVksQ0FBNUIsQ0FBakIsQzs7QUFHQSxRQUFJLE9BQU8sQ0FBWDtBQUNBLFFBQUksS0FBSyxDQUFUOztBQUdBLFFBQUksZ0JBQWdCLElBQUksV0FBSixDQUFnQixZQUFZLENBQTVCLENBQXBCLEM7QUFDQSxRQUFJLGdCQUFnQixJQUFJLFdBQUosQ0FBZ0IsWUFBWSxDQUE1QixDQUFwQixDOztBQUVBLFFBQUksVUFBVSxDQUFkO0FBQ0EsUUFBSSxRQUFRLENBQVo7O0FBRUEsa0JBQWMsS0FBZCxFQUFxQixFQUFDLFFBQU8sQ0FBQyxNQUFULEVBQXJCOztBQUVBLFdBQU8sT0FBTyxFQUFkLEVBQWtCO0FBQ2QsWUFBSSxXQUFXLFdBQVcsT0FBTyxTQUFsQixDQUFmO0FBQ0EsWUFBSSxXQUFXLFdBQVcsT0FBTyxTQUFsQixDQUFmO0FBQ0EsZ0JBQVEsUUFBUixFQUFrQixRQUFsQixFQUE0QixjQUE1QjtBQUNBO0FBQ0g7O0FBR0QsV0FBTyxxQkFBVyxLQUFYLEVBQWtCLE1BQWxCLEVBQTBCLFVBQTFCLEVBQXNDLFVBQXRDLENBQVA7Ozs7O0FBS0EsYUFBUyxhQUFULFFBQXdDO0FBQUEsaUNBQWhCLE1BQWdCO0FBQUEsWUFBaEIsTUFBZ0IsZ0NBQVAsSUFBTzs7QUFDcEMsYUFBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLE1BQU0sTUFBTixHQUFlLENBQW5DLEVBQXNDLEdBQXRDLEVBQTJDO0FBQ3ZDLGlCQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksTUFBTSxLQUFOLEdBQWMsQ0FBbEMsRUFBcUMsR0FBckMsRUFBMEM7QUFDdEMsb0JBQUksUUFBUSxJQUFJLElBQUksTUFBTSxLQUExQjtBQUNBLG9CQUFJLFVBQVUsS0FBVixNQUFxQixDQUF6QixFQUE0QjtBQUN4Qix3QkFBSSxlQUFnQixNQUFELEdBQVcsTUFBTSxJQUFOLENBQVcsS0FBWCxDQUFYLEdBQStCLENBQUMsTUFBTSxJQUFOLENBQVcsSUFBSSxJQUFJLE1BQU0sS0FBekIsQ0FBbkQ7QUFDQSx3QkFBSSxNQUFNLElBQU4sQ0FBVyxJQUFJLE1BQU0sS0FBVixHQUFrQixDQUFsQixHQUFzQixDQUFqQyxJQUFzQyxZQUExQyxFQUF3RDs7QUFDcEQ7QUFDSDtBQUNELHdCQUFJLE1BQU0sSUFBTixDQUFXLElBQUksTUFBTSxLQUFWLEdBQWtCLENBQWxCLEdBQXNCLENBQWpDLElBQXNDLFlBQTFDLEVBQXdEOztBQUNwRDtBQUNIO0FBQ0Qsd0JBQUksTUFBTSxJQUFOLENBQVcsQ0FBQyxJQUFJLENBQUwsSUFBVSxNQUFNLEtBQWhCLEdBQXdCLENBQW5DLElBQXdDLFlBQTVDLEVBQTBEOztBQUN0RDtBQUNIO0FBQ0Qsd0JBQUksTUFBTSxJQUFOLENBQVcsQ0FBQyxJQUFJLENBQUwsSUFBVSxNQUFNLEtBQWhCLEdBQXdCLENBQW5DLElBQXdDLFlBQTVDLEVBQTBEOztBQUN0RDtBQUNIO0FBQ0Qsd0JBQUksV0FBSixFQUFpQjtBQUNiLDRCQUFJLE1BQU0sSUFBTixDQUFXLENBQUMsSUFBSSxDQUFMLElBQVUsTUFBTSxLQUFoQixHQUF3QixDQUF4QixHQUE0QixDQUF2QyxJQUE0QyxZQUFoRCxFQUE4RDs7QUFDMUQ7QUFDSDtBQUNELDRCQUFJLE1BQU0sSUFBTixDQUFXLENBQUMsSUFBSSxDQUFMLElBQVUsTUFBTSxLQUFoQixHQUF3QixDQUF4QixHQUE0QixDQUF2QyxJQUE0QyxZQUFoRCxFQUE4RDs7QUFDMUQ7QUFDSDtBQUNELDRCQUFJLE1BQU0sSUFBTixDQUFXLENBQUMsSUFBSSxDQUFMLElBQVUsTUFBTSxLQUFoQixHQUF3QixDQUF4QixHQUE0QixDQUF2QyxJQUE0QyxZQUFoRCxFQUE4RDs7QUFDMUQ7QUFDSDtBQUNELDRCQUFJLE1BQU0sSUFBTixDQUFXLENBQUMsSUFBSSxDQUFMLElBQVUsTUFBTSxLQUFoQixHQUF3QixDQUF4QixHQUE0QixDQUF2QyxJQUE0QyxZQUFoRCxFQUE4RDs7QUFDMUQ7QUFDSDtBQUNKOztBQUVELDJCQUFPLEtBQVAsSUFBaUIsTUFBRCxHQUFXLEVBQUUsVUFBYixHQUEwQixFQUFFLFVBQTVDOzs7O0FBSUEsd0JBQUksUUFBTSxXQUFXLENBQVgsRUFBYyxDQUFkLEVBQWlCLFdBQWpCLENBQVY7QUFDQSx3QkFBSSxDQUFFLEtBQU4sRUFBYyxNQUFELEdBQVcsRUFBRSxVQUFiLEdBQTBCLEVBQUUsVUFBNUI7QUFDaEI7QUFDSjtBQUNKO0FBQ0o7Ozs7OztBQU1ELGFBQVMsVUFBVCxDQUFvQixVQUFwQixFQUFnQyxVQUFoQyxFQUE0Qzs7QUFFeEMsWUFBSSxZQUFZLEVBQWhCLEM7QUFDQSxrQkFBVSxDQUFWO0FBQ0EsZ0JBQVEsQ0FBUjtBQUNBLHNCQUFjLENBQWQsSUFBbUIsVUFBbkI7QUFDQSxzQkFBYyxDQUFkLElBQW1CLFVBQW5CO0FBQ0EsWUFBSSxRQUFRLElBQVo7QUFDQSxlQUFPLFVBQVUsS0FBakIsRUFBd0I7QUFDcEIsZ0JBQUksWUFBVyxjQUFjLFVBQVUsU0FBeEIsQ0FBZjtBQUNBLGdCQUFJLFlBQVcsY0FBYyxVQUFVLFNBQXhCLENBQWY7QUFDQSxxQkFBUyxRQUFRLFNBQVIsRUFBa0IsU0FBbEIsRUFBNEIsV0FBNUIsQ0FBVDtBQUNBO0FBQ0g7QUFDRCxZQUFJLENBQUMsS0FBTCxFQUFZOzs7QUFHUixpQkFBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLEtBQXBCLEVBQTJCLEdBQTNCLEVBQWdDO0FBQzVCLG9CQUFJLGFBQVcsY0FBYyxJQUFJLFNBQWxCLENBQWY7QUFDQSxvQkFBSSxhQUFXLGNBQWMsSUFBSSxTQUFsQixDQUFmO0FBQ0Esb0JBQUksUUFBUSxhQUFXLE1BQU0sS0FBakIsR0FBeUIsVUFBckM7QUFDQSx1QkFBTyxLQUFQLElBQWdCLENBQWhCO0FBQ0g7QUFDRCxpQkFBSyxTQUFMO0FBQ0g7QUFDRCxlQUFPLEtBQVA7QUFDSDs7Ozs7Ozs7QUFRRCxhQUFTLE9BQVQsQ0FBaUIsT0FBakIsRUFBMEIsT0FBMUIsRUFBbUMsSUFBbkMsRUFBeUM7O0FBRXJDLFlBQUksWUFBWSxPQUFPLFVBQVUsTUFBTSxLQUFoQixHQUF3QixPQUEvQixDQUFoQjtBQUNBLFlBQUksZUFBZSxNQUFNLElBQU4sQ0FBVyxVQUFVLE1BQU0sS0FBaEIsR0FBd0IsT0FBbkMsQ0FBbkI7QUFDQSxZQUFJLG1CQUFtQixXQUFXLFVBQVUsTUFBTSxLQUFoQixHQUF3QixPQUFuQyxDQUF2QjtBQUNBLGFBQUssSUFBSSxJQUFJLFVBQVUsQ0FBdkIsRUFBMEIsS0FBSyxVQUFVLENBQXpDLEVBQTRDLEdBQTVDLEVBQWlEO0FBQzdDLGlCQUFLLElBQUksSUFBSSxVQUFVLENBQXZCLEVBQTBCLEtBQUssVUFBVSxDQUF6QyxFQUE0QyxHQUE1QyxFQUFpRDtBQUM3QyxvQkFBSSxRQUFRLElBQUksTUFBTSxLQUFWLEdBQWtCLENBQTlCO0FBQ0Esb0JBQUksVUFBVSxLQUFWLE1BQXFCLENBQXpCLEVBQTRCO0FBQ3hCLDhCQUFVLEtBQVYsSUFBbUIsQ0FBbkI7O0FBRUEsK0JBQVcsS0FBWCxJQUFvQixNQUFNLElBQU4sQ0FBVyxLQUFYLElBQW9CLFlBQXhDO0FBQ0EsNEJBQVEsSUFBUjtBQUNJLDZCQUFLLFdBQUw7O0FBRUksZ0NBQUksV0FBVyxLQUFYLE1BQXNCLENBQTFCLEVBQTZCOzs7O0FBR3pCLG9DQUFJLE1BQU0sQ0FBTixJQUFXLE1BQU0sQ0FBakIsSUFBc0IsTUFBTyxNQUFNLEtBQU4sR0FBYyxDQUEzQyxJQUFpRCxNQUFPLE1BQU0sTUFBTixHQUFlLENBQTNFLEVBQStFLE9BQU8sS0FBUDtBQUMvRSx1Q0FBTyxLQUFQLElBQWdCLFNBQWhCO0FBQ0EsOENBQWMsUUFBUSxTQUF0QixJQUFtQyxDQUFuQztBQUNBLDhDQUFjLFFBQVEsU0FBdEIsSUFBbUMsQ0FBbkM7QUFDQTtBQUNILDZCQVJELE1BUU8sSUFBSSxXQUFXLEtBQVgsSUFBb0IsQ0FBeEIsRUFBMkI7OztBQUU5Qix1Q0FBTyxLQUFQO0FBQ0gsNkJBSE0sTUFHQTs7QUFDSCxvQ0FBSSxDQUFDLE9BQUwsRUFBYztBQUNWLDJDQUFPLEtBQVAsSUFBZ0IsU0FBaEI7QUFDQSwrQ0FBVyxLQUFLLFNBQWhCLElBQTZCLENBQTdCO0FBQ0EsK0NBQVcsS0FBSyxTQUFoQixJQUE2QixDQUE3QjtBQUNBO0FBQ0g7QUFDSjtBQUNEO0FBQ0osNkJBQUssY0FBTDtBQUNJLGdDQUFJLFdBQVcsS0FBWCxLQUFxQixDQUF6QixFQUE0Qjs7QUFDeEIsdUNBQU8sS0FBUCxJQUFnQixTQUFoQjtBQUNBLDJDQUFXLEtBQUssU0FBaEIsSUFBNkIsQ0FBN0I7QUFDQSwyQ0FBVyxLQUFLLFNBQWhCLElBQTZCLENBQTdCO0FBQ0E7QUFDSDtBQUNEO0FBOUJSO0FBaUNIO0FBQ0o7QUFDSjtBQUNELGVBQU8sSUFBUDtBQUNIO0FBQ0o7Ozs7Ozs7O2tCQ3ZMdUIsb0I7O0FBRnhCOzs7Ozs7QUFFZSxTQUFTLG9CQUFULENBQThCLElBQTlCLEVBQWdFO0FBQUEscUVBQUosRUFBSTs7QUFBQSxnQ0FBM0IsV0FBMkI7QUFBQSxRQUEzQixXQUEyQixvQ0FBYixLQUFhOzs7O0FBRzNFLFFBQUksU0FBUyxJQUFJLFVBQUosQ0FBZSxLQUFLLElBQXBCLENBQWIsQzs7O0FBR0EsUUFBSSxhQUFhLENBQWpCO0FBQ0EsUUFBSSxhQUFhLENBQWpCOztBQUVBLFFBQUksWUFBWSxRQUFoQixDO0FBQ0EsUUFBSSxhQUFhLElBQUksV0FBSixDQUFnQixZQUFZLENBQTVCLENBQWpCLEM7QUFDQSxRQUFJLGFBQWEsSUFBSSxXQUFKLENBQWdCLFlBQVksQ0FBNUIsQ0FBakIsQzs7QUFHQSxTQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksS0FBSyxLQUF6QixFQUFnQyxHQUFoQyxFQUFxQztBQUNqQyxhQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksS0FBSyxNQUF6QixFQUFpQyxHQUFqQyxFQUFzQztBQUNsQyxnQkFBSSxPQUFPLElBQUksS0FBSyxLQUFULEdBQWlCLENBQXhCLE1BQStCLENBQW5DLEVBQXNDOztBQUVsQywrQkFBZSxDQUFmLEVBQWtCLENBQWxCO0FBQ0g7QUFDSjtBQUNKOztBQUVELGFBQVMsY0FBVCxDQUF3QixDQUF4QixFQUEyQixDQUEzQixFQUE4QjtBQUMxQixZQUFJLE9BQU8sQ0FBWDtBQUNBLFlBQUksS0FBSyxDQUFUO0FBQ0EsWUFBSSxjQUFjLEtBQUssUUFBTCxDQUFjLENBQWQsRUFBaUIsQ0FBakIsQ0FBbEI7QUFDQSxZQUFJLEtBQUssY0FBYyxFQUFFLFVBQWhCLEdBQTZCLEVBQUUsVUFBeEM7QUFDQSxtQkFBVyxDQUFYLElBQWdCLENBQWhCO0FBQ0EsbUJBQVcsQ0FBWCxJQUFnQixDQUFoQjtBQUNBLGVBQU8sUUFBUSxFQUFmLEVBQW1CO0FBQ2YsZ0JBQUksV0FBVyxXQUFXLE9BQU8sU0FBbEIsQ0FBZjtBQUNBLGdCQUFJLFdBQVcsV0FBVyxPQUFPLFNBQWxCLENBQWY7QUFDQSxtQkFBTyxXQUFXLEtBQUssS0FBaEIsR0FBd0IsUUFBL0IsSUFBMkMsRUFBM0M7O0FBRUEsZ0JBQUksV0FBVyxDQUFYLElBQWdCLE9BQU8sV0FBVyxLQUFLLEtBQWhCLEdBQXdCLFFBQXhCLEdBQW1DLENBQTFDLE1BQWlELENBQWpFLElBQ0EsS0FBSyxRQUFMLENBQWMsV0FBVyxDQUF6QixFQUE0QixRQUE1QixNQUEwQyxXQUQ5QyxFQUMyRDs7QUFFdkQ7QUFDQSwyQkFBVyxLQUFLLFNBQWhCLElBQTZCLFdBQVcsQ0FBeEM7QUFDQSwyQkFBVyxLQUFLLFNBQWhCLElBQTZCLFFBQTdCO0FBQ0EsdUJBQU8sV0FBVyxLQUFLLEtBQWhCLEdBQXdCLFFBQXhCLEdBQW1DLENBQTFDLElBQStDLENBQUMsS0FBaEQ7QUFDSDtBQUNELGdCQUFJLFdBQVcsQ0FBWCxJQUFnQixPQUFPLENBQUMsV0FBVyxDQUFaLElBQWlCLEtBQUssS0FBdEIsR0FBOEIsUUFBckMsTUFBbUQsQ0FBbkUsSUFDQSxLQUFLLFFBQUwsQ0FBYyxRQUFkLEVBQXdCLFdBQVcsQ0FBbkMsTUFBMEMsV0FEOUMsRUFDMkQ7O0FBRXZEO0FBQ0EsMkJBQVcsS0FBSyxTQUFoQixJQUE2QixRQUE3QjtBQUNBLDJCQUFXLEtBQUssU0FBaEIsSUFBNkIsV0FBVyxDQUF4QztBQUNBLHVCQUFPLENBQUMsV0FBVyxDQUFaLElBQWlCLEtBQUssS0FBdEIsR0FBOEIsUUFBckMsSUFBaUQsQ0FBQyxLQUFsRDtBQUNIO0FBQ0QsZ0JBQUksV0FBVyxLQUFLLEtBQUwsR0FBYSxDQUF4QixJQUE2QixPQUFPLFdBQVcsS0FBSyxLQUFoQixHQUF3QixRQUF4QixHQUFtQyxDQUExQyxNQUFpRCxDQUE5RSxJQUNBLEtBQUssUUFBTCxDQUFjLFdBQVcsQ0FBekIsRUFBNEIsUUFBNUIsTUFBMEMsV0FEOUMsRUFDMkQ7O0FBRXZEO0FBQ0EsMkJBQVcsS0FBSyxTQUFoQixJQUE2QixXQUFXLENBQXhDO0FBQ0EsMkJBQVcsS0FBSyxTQUFoQixJQUE2QixRQUE3QjtBQUNBLHVCQUFPLFdBQVcsS0FBSyxLQUFoQixHQUF3QixRQUF4QixHQUFtQyxDQUExQyxJQUErQyxDQUFDLEtBQWhEO0FBQ0g7QUFDRCxnQkFBSSxXQUFXLEtBQUssTUFBTCxHQUFjLENBQXpCLElBQThCLE9BQU8sQ0FBQyxXQUFXLENBQVosSUFBaUIsS0FBSyxLQUF0QixHQUE4QixRQUFyQyxNQUFtRCxDQUFqRixJQUNBLEtBQUssUUFBTCxDQUFjLFFBQWQsRUFBd0IsV0FBVyxDQUFuQyxNQUEwQyxXQUQ5QyxFQUMyRDs7QUFFdkQ7QUFDQSwyQkFBVyxLQUFLLFNBQWhCLElBQTZCLFFBQTdCO0FBQ0EsMkJBQVcsS0FBSyxTQUFoQixJQUE2QixXQUFXLENBQXhDO0FBQ0EsdUJBQU8sQ0FBQyxXQUFXLENBQVosSUFBaUIsS0FBSyxLQUF0QixHQUE4QixRQUFyQyxJQUFpRCxDQUFDLEtBQWxEO0FBQ0g7QUFDRCxnQkFBSSxXQUFKLEVBQWlCO0FBQ2Isb0JBQUksV0FBVyxDQUFYLElBQWdCLFdBQVcsQ0FBM0IsSUFBZ0MsT0FBTyxDQUFDLFdBQVcsQ0FBWixJQUFpQixLQUFLLEtBQXRCLEdBQThCLFFBQTlCLEdBQXlDLENBQWhELE1BQXVELENBQXZGLElBQ0EsS0FBSyxRQUFMLENBQWMsV0FBVyxDQUF6QixFQUE0QixXQUFXLENBQXZDLE1BQThDLFdBRGxELEVBQytEOztBQUUzRDtBQUNBLCtCQUFXLEtBQUssU0FBaEIsSUFBNkIsV0FBVyxDQUF4QztBQUNBLCtCQUFXLEtBQUssU0FBaEIsSUFBNkIsV0FBVyxDQUF4QztBQUNBLDJCQUFPLENBQUMsV0FBVyxDQUFaLElBQWlCLEtBQUssS0FBdEIsR0FBOEIsUUFBOUIsR0FBeUMsQ0FBaEQsSUFBcUQsQ0FBQyxLQUF0RDtBQUNIO0FBQ0Qsb0JBQUksV0FBVyxLQUFLLEtBQUwsR0FBYSxDQUF4QixJQUE2QixXQUFXLENBQXhDLElBQTZDLE9BQU8sQ0FBQyxXQUFXLENBQVosSUFBaUIsS0FBSyxLQUF0QixHQUE4QixRQUE5QixHQUF5QyxDQUFoRCxNQUF1RCxDQUFwRyxJQUNBLEtBQUssUUFBTCxDQUFjLFdBQVcsQ0FBekIsRUFBNEIsV0FBVyxDQUF2QyxNQUE4QyxXQURsRCxFQUMrRDs7QUFFM0Q7QUFDQSwrQkFBVyxLQUFLLFNBQWhCLElBQTZCLFdBQVcsQ0FBeEM7QUFDQSwrQkFBVyxLQUFLLFNBQWhCLElBQTZCLFdBQVcsQ0FBeEM7QUFDQSwyQkFBTyxDQUFDLFdBQVcsQ0FBWixJQUFpQixLQUFLLEtBQXRCLEdBQThCLFFBQTlCLEdBQXlDLENBQWhELElBQXFELENBQUMsS0FBdEQ7QUFDSDtBQUNELG9CQUFJLFdBQVcsQ0FBWCxJQUFnQixXQUFXLEtBQUssTUFBTCxHQUFjLENBQXpDLElBQThDLE9BQU8sQ0FBQyxXQUFXLENBQVosSUFBaUIsS0FBSyxLQUF0QixHQUE4QixRQUE5QixHQUF5QyxDQUFoRCxNQUF1RCxDQUFyRyxJQUNBLEtBQUssUUFBTCxDQUFjLFdBQVcsQ0FBekIsRUFBNEIsV0FBVyxDQUF2QyxNQUE4QyxXQURsRCxFQUMrRDs7QUFFM0Q7QUFDQSwrQkFBVyxLQUFLLFNBQWhCLElBQTZCLFdBQVcsQ0FBeEM7QUFDQSwrQkFBVyxLQUFLLFNBQWhCLElBQTZCLFdBQVcsQ0FBeEM7QUFDQSwyQkFBTyxDQUFDLFdBQVcsQ0FBWixJQUFpQixLQUFLLEtBQXRCLEdBQThCLFFBQTlCLEdBQXlDLENBQWhELElBQXFELENBQUMsS0FBdEQ7QUFDSDtBQUNELG9CQUFJLFdBQVcsS0FBSyxLQUFMLEdBQWEsQ0FBeEIsSUFBNkIsV0FBVyxLQUFLLE1BQUwsR0FBYyxDQUF0RCxJQUEyRCxPQUFPLENBQUMsV0FBVyxDQUFaLElBQWlCLEtBQUssS0FBdEIsR0FBOEIsUUFBOUIsR0FBeUMsQ0FBaEQsTUFBdUQsQ0FBbEgsSUFDQSxLQUFLLFFBQUwsQ0FBYyxXQUFXLENBQXpCLEVBQTRCLFdBQVcsQ0FBdkMsTUFBOEMsV0FEbEQsRUFDK0Q7O0FBRTNEO0FBQ0EsK0JBQVcsS0FBSyxTQUFoQixJQUE2QixXQUFXLENBQXhDO0FBQ0EsK0JBQVcsS0FBSyxTQUFoQixJQUE2QixXQUFXLENBQXhDO0FBQ0EsMkJBQU8sQ0FBQyxXQUFXLENBQVosSUFBaUIsS0FBSyxLQUF0QixHQUE4QixRQUE5QixHQUF5QyxDQUFoRCxJQUFxRCxDQUFDLEtBQXREO0FBQ0g7QUFDSjs7QUFHRDs7QUFFQSxnQkFBSyxLQUFLLElBQU4sR0FBYyxTQUFsQixFQUE2QjtBQUN6QixzQkFBTSxJQUFJLEtBQUosQ0FBVSxxRkFDWiw4Q0FERSxDQUFOO0FBRUg7QUFDSjtBQUNKOztBQUVELFdBQU8scUJBQVcsSUFBWCxFQUFpQixNQUFqQixFQUF5QixVQUF6QixFQUFxQyxVQUFyQyxDQUFQO0FBRUgsQzs7Ozs7Ozs7OztrQkNqSHVCLGU7O0FBSHhCOzs7O0FBQ0E7Ozs7Ozs7Ozs7QUFFZSxTQUFTLGVBQVQsQ0FBeUIsYUFBekIsRUFBc0Q7QUFBQSxRQUFkLE9BQWMseURBQUosRUFBSTs7QUFDakUsUUFBSSxRQUFRLG9CQUFVLE9BQVYsQ0FBWjs7O0FBR0EsUUFBSSxZQUFZLElBQUksVUFBSixDQUFlLEtBQUssSUFBcEIsQ0FBaEIsQztBQUNBLFFBQUksYUFBYSxDQUFqQjtBQUNBLFFBQUksY0FBYyxNQUFNLFNBQU4sRUFBbEI7QUFDQSxTQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksY0FBYyxNQUFsQyxFQUEwQyxHQUExQyxFQUErQztBQUMzQztBQUNBLFlBQUksS0FBSyxjQUFjLENBQWQsRUFBaUIsQ0FBakIsQ0FBVDtBQUNBLFlBQUksS0FBSyxjQUFjLENBQWQsRUFBaUIsQ0FBakIsQ0FBVDtBQUNBLGFBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxZQUFZLE1BQWhDLEVBQXdDLEdBQXhDLEVBQTZDO0FBQ3pDLGdCQUFJLEtBQUssWUFBWSxDQUFaLEVBQWUsQ0FBZixDQUFUO0FBQ0EsZ0JBQUksS0FBSyxZQUFZLENBQVosRUFBZSxDQUFmLENBQVQ7QUFDQSxnQkFDTSxLQUFLLEVBQU4sSUFBYSxDQUFkLElBQ0UsS0FBSyxFQUFOLElBQWEsQ0FEZCxJQUVFLEtBQUssRUFBTixHQUFZLEtBQUssS0FGbEIsSUFHRSxLQUFLLEVBQU4sR0FBWSxLQUFLLE1BSnRCLEVBS0U7QUFDRSwwQkFBVSxLQUFLLEVBQUwsR0FBVSxDQUFDLEtBQUssRUFBTixJQUFZLEtBQUssS0FBckMsSUFBOEMsVUFBOUM7QUFDSDtBQUNKO0FBQ0o7QUFDRCxXQUFPLHFCQUFXLElBQVgsRUFBaUIsU0FBakIsRUFBNEIsQ0FBNUIsRUFBK0IsVUFBL0IsQ0FBUDtBQUNIOzs7Ozs7Ozs7QUNoQ0Q7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7Ozs7QUFHZSxNQUFNLFVBQU4sQ0FBaUI7O0FBRTVCLGdCQUFZLEtBQVosRUFBaUM7QUFBQSxZQUFkLE9BQWMseURBQUosRUFBSTs7QUFDN0IsYUFBSyxNQUFMLEdBQWMsS0FBZDtBQUNBLGFBQUssUUFBTCxHQUFnQixPQUFoQjtBQUNBLFlBQUksQ0FBQyxLQUFLLFFBQUwsQ0FBYyxLQUFuQixFQUEwQixLQUFLLFFBQUwsQ0FBYyxLQUFkLEdBQXNCLFNBQXRCO0FBQzFCLGFBQUssT0FBTCxHQUFlLEVBQWY7QUFDQSxhQUFLLFFBQUwsR0FBZ0IsSUFBaEI7QUFDSDs7QUFFRCw2QkFBcUM7QUFBQSxZQUFkLE9BQWMseURBQUosRUFBSTs7QUFDakMsWUFBSSxNQUFNLHNCQUFhLEVBQWIsRUFBaUIsS0FBSyxRQUF0QixFQUFnQyxPQUFoQyxDQUFWO0FBQ0EsWUFBSSxTQUFTLHNCQUFZLElBQVosQ0FBaUIsS0FBSyxNQUF0QixFQUE4QixPQUE5QixDQUFiO0FBQ0EsYUFBSyxPQUFMLENBQWEsSUFBSSxLQUFqQixJQUEwQixJQUFJLFFBQUosQ0FBYSxNQUFiLEVBQXFCLEdBQXJCLENBQTFCO0FBQ0g7O0FBRUQsY0FBVSxNQUFWLEVBQWdDO0FBQUEsWUFBZCxPQUFjLHlEQUFKLEVBQUk7O0FBQzVCLFlBQUksTUFBTSxzQkFBYSxFQUFiLEVBQWlCLEtBQUssUUFBdEIsRUFBZ0MsT0FBaEMsQ0FBVjtBQUNBLFlBQUksU0FBUyxxQkFBZ0IsSUFBaEIsQ0FBcUIsS0FBSyxNQUExQixFQUFrQyxNQUFsQyxFQUEwQyxPQUExQyxDQUFiO0FBQ0EsYUFBSyxPQUFMLENBQWEsSUFBSSxLQUFqQixJQUEwQixJQUFJLFFBQUosQ0FBYSxNQUFiLEVBQXFCLEdBQXJCLENBQTFCO0FBQ0g7O0FBRUQsV0FBTyxNQUFQLEVBQTZCO0FBQUEsWUFBZCxPQUFjLHlEQUFKLEVBQUk7O0FBQ3pCLFlBQUksTUFBTSxzQkFBYSxFQUFiLEVBQWlCLEtBQUssUUFBdEIsRUFBZ0MsT0FBaEMsQ0FBVjtBQUNBLGFBQUssT0FBTCxDQUFhLElBQUksS0FBakIsSUFBMEIsSUFBSSxRQUFKLENBQWEsTUFBYixFQUFxQixHQUFyQixDQUExQjtBQUNIOztBQUVELFlBQVEsSUFBUixFQUE0QjtBQUFBLFlBQWQsT0FBYyx5REFBSixFQUFJOztBQUN4QixZQUFJLE1BQU0sc0JBQWEsRUFBYixFQUFpQixLQUFLLFFBQXRCLEVBQWdDLE9BQWhDLENBQVY7QUFDQSxZQUFJLFNBQVMsbUJBQVMsSUFBVCxDQUFjLEtBQUssTUFBbkIsRUFBMkIsSUFBM0IsRUFBaUMsT0FBakMsQ0FBYjtBQUNBLGFBQUssT0FBTCxDQUFhLElBQUksS0FBakIsSUFBMEIsSUFBSSxRQUFKLENBQWEsTUFBYixFQUFxQixHQUFyQixDQUExQjtBQUNIOztBQUVELGFBQXFCO0FBQUEsWUFBZCxPQUFjLHlEQUFKLEVBQUk7O0FBQ2pCLFlBQUksTUFBTSxzQkFBYSxFQUFiLEVBQWlCLEtBQUssUUFBdEIsRUFBZ0MsT0FBaEMsQ0FBVjtBQUNBLFlBQUksQ0FBQyxLQUFLLE9BQUwsQ0FBYSxJQUFJLEtBQWpCLENBQUwsRUFBOEI7QUFDOUIsZUFBTyxLQUFLLE9BQUwsQ0FBYSxJQUFJLEtBQWpCLEVBQXdCLE1BQS9CO0FBQ0g7O0FBRUQsZ0JBQXdCO0FBQUEsWUFBZCxPQUFjLHlEQUFKLEVBQUk7O0FBQ3BCLFlBQUksT0FBTyxLQUFLLE1BQUwsQ0FBWSxPQUFaLENBQVg7QUFDQSxZQUFJLENBQUMsSUFBTCxFQUFXO0FBQ1gsWUFBSSxNQUFNLElBQUksS0FBSixDQUFVLEtBQUssTUFBZixDQUFWO0FBQ0EsYUFBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLEtBQUssTUFBekIsRUFBaUMsR0FBakMsRUFBc0M7QUFDbEMsZ0JBQUksQ0FBSixJQUFTLEtBQUssQ0FBTCxFQUFRLEVBQWpCO0FBQ0g7QUFDRCxlQUFPLEdBQVA7QUFDSDs7QUFFRCxhQU1ZO0FBQUEseUVBQUosRUFBSTs7QUFBQSw4QkFMUixLQUtRO0FBQUEsWUFMUixLQUtRLDhCQUxBLEtBQUssUUFBTCxDQUFjLEtBS2Q7QUFBQSxpQ0FKUixRQUlRO0FBQUEsWUFKUixRQUlRLGlDQUpHLElBSUg7QUFBQSxpQ0FIUixRQUdRO0FBQUEsWUFIUixRQUdRLGlDQUhHLElBR0g7QUFBQSxtQ0FGUixVQUVRO0FBQUEsWUFGUixVQUVRLG1DQUZLLENBRUw7QUFBQSxtQ0FEUixVQUNRO0FBQUEsWUFEUixVQUNRLG1DQURLLE9BQU8saUJBQ1o7OztBQUVSLFlBQUksVUFBVSxLQUFLLE9BQUwsQ0FBYSxLQUFiLEVBQW9CLEdBQWxDO0FBQ0EsWUFBSSxPQUFPLElBQUksS0FBSixDQUFVLFFBQVEsTUFBbEIsQ0FBWDtBQUNBLFlBQUksTUFBTSxDQUFWO0FBQ0EsYUFBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLFFBQVEsTUFBNUIsRUFBb0MsR0FBcEMsRUFBeUM7QUFDckMsZ0JBQUksTUFBTSxRQUFRLENBQVIsQ0FBVjtBQUNBLGdCQUFJLENBQUUsSUFBSSxFQUFKLEdBQVMsQ0FBVCxJQUFjLFFBQWYsSUFBNEIsSUFBSSxFQUFKLEdBQVMsQ0FBVCxJQUFjLFFBQTNDLEtBQ0csSUFBSSxPQUFKLElBQWUsVUFEbEIsSUFFRyxJQUFJLE9BQUosSUFBZSxVQUZ0QixFQUVrQztBQUM5QixxQkFBSyxLQUFMLElBQWMsR0FBZDtBQUNIO0FBQ0o7QUFDRCxhQUFLLE1BQUwsR0FBYyxHQUFkO0FBQ0EsZUFBTyxJQUFQO0FBQ0g7O0FBRUQsa0JBQTBCO0FBQUEsWUFBZCxPQUFjLHlEQUFKLEVBQUk7O0FBQ3RCLFlBQUksT0FBTyxLQUFLLE1BQUwsQ0FBWSxPQUFaLENBQVg7QUFDQSxZQUFJLFFBQVEsSUFBSSxLQUFKLENBQVUsS0FBSyxNQUFmLENBQVo7QUFDQSxhQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksS0FBSyxNQUF6QixFQUFpQyxHQUFqQyxFQUFzQztBQUNsQyxrQkFBTSxDQUFOLElBQVcsS0FBSyxDQUFMLEVBQVEsSUFBbkI7QUFDSDtBQUNELGVBQU8sS0FBUDtBQUNIOztBQUVELGdCQUF3QjtBQUFBLFlBQWQsT0FBYyx5REFBSixFQUFJOztBQUNwQixZQUFJLE1BQU0sc0JBQWEsRUFBYixFQUFpQixLQUFLLFFBQXRCLEVBQWdDLE9BQWhDLENBQVY7QUFDQSxZQUFJLEtBQUssT0FBTCxDQUFhLElBQUksS0FBakIsQ0FBSixFQUE2QjtBQUN6QixtQkFBTyxLQUFLLE9BQUwsQ0FBYSxJQUFJLEtBQWpCLEVBQXdCLE1BQXhCLENBQStCLE1BQXRDO0FBQ0g7QUFDSjs7QUFFRCxZQUFvQjtBQUFBLFlBQWQsT0FBYyx5REFBSixFQUFJOztBQUNoQixZQUFJLENBQUMsS0FBSyxRQUFWLEVBQW9CLEtBQUssUUFBTCxHQUFnQixLQUFLLE1BQUwsQ0FBWSxLQUFaLEVBQWhCO0FBQ3BCLFlBQUksUUFBUSxLQUFLLFdBQUwsQ0FBaUIsT0FBakIsQ0FBWjtBQUNBLGFBQUssUUFBTCxDQUFjLFVBQWQsQ0FBeUIsS0FBekIsRUFBZ0MsT0FBaEM7QUFDQSxlQUFPLEtBQUssUUFBWjtBQUNIOzs7QUFHRCxjQUFzQjtBQUFBLFlBQWQsT0FBYyx5REFBSixFQUFJOztBQUNsQixZQUFJLE9BQU8sb0JBQVUsS0FBSyxNQUFMLENBQVksS0FBdEIsRUFBNkIsS0FBSyxNQUFMLENBQVksTUFBekMsRUFBaUQsRUFBQyxNQUFLLFFBQU4sRUFBakQsQ0FBWDtBQUNBLFlBQUksUUFBUSxLQUFLLFdBQUwsQ0FBaUIsT0FBakIsQ0FBWjtBQUNBLGFBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxNQUFNLE1BQTFCLEVBQWtDLEdBQWxDLEVBQXVDO0FBQ25DLGdCQUFJLE1BQU0sTUFBTSxDQUFOLENBQVY7OztBQUdBLGlCQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksSUFBSSxLQUF4QixFQUErQixHQUEvQixFQUFvQztBQUNoQyxxQkFBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLElBQUksTUFBeEIsRUFBZ0MsR0FBaEMsRUFBcUM7QUFDakMsd0JBQUksSUFBSSxRQUFKLENBQWEsQ0FBYixFQUFnQixDQUFoQixDQUFKLEVBQXdCO0FBQ3BCLDZCQUFLLFFBQUwsQ0FBYyxJQUFJLElBQUksUUFBSixDQUFhLENBQWIsQ0FBbEIsRUFBbUMsSUFBSSxJQUFJLFFBQUosQ0FBYSxDQUFiLENBQXZDO0FBQ0g7QUFDSjtBQUNKO0FBQ0o7QUFDRCxlQUFPLElBQVA7QUFDSDs7QUFHRCxpQkFBYSxLQUFiLEVBQW9CO0FBQ2hCLGFBQUssUUFBTCxHQUFnQixLQUFoQjtBQUNIO0FBckgyQjs7a0JBQVgsVTtBQXdIckIsTUFBTSxRQUFOLENBQWU7QUFDWCxnQkFBWSxNQUFaLEVBQW9CLE9BQXBCLEVBQTZCO0FBQ3pCLGFBQUssTUFBTCxHQUFjLE1BQWQ7QUFDQSxhQUFLLE9BQUwsR0FBZSxPQUFmO0FBQ0EsYUFBSyxHQUFMLEdBQVcseUJBQVUsS0FBSyxNQUFmLENBQVg7QUFDSDtBQUxVOzs7Ozs7Ozs7QUNoSWY7Ozs7QUFDQTs7SUFBWSxTOzs7Ozs7QUFFRyxNQUFNLEdBQU4sQ0FBVTs7QUFFckIsZ0JBQVksR0FBWixFQUFpQixFQUFqQixFQUFxQjtBQUNqQixhQUFLLEdBQUwsR0FBVyxHQUFYO0FBQ0EsYUFBSyxFQUFMLEdBQVUsRUFBVjtBQUNBLGFBQUssSUFBTCxHQUFZLE9BQU8saUJBQW5CO0FBQ0EsYUFBSyxJQUFMLEdBQVksT0FBTyxpQkFBbkI7QUFDQSxhQUFLLElBQUwsR0FBWSxPQUFPLGlCQUFuQjtBQUNBLGFBQUssSUFBTCxHQUFZLE9BQU8saUJBQW5CO0FBQ0EsYUFBSyxLQUFMLEdBQWEsQ0FBYjtBQUNBLGFBQUssS0FBTCxHQUFhLENBQWI7QUFDQSxhQUFLLE9BQUwsR0FBZSxDQUFmO0FBQ0EsYUFBSyxRQUFMLEdBQWdCLEVBQWhCO0FBQ0g7O0FBRUQsY0FBd0M7QUFBQSx5RUFBSixFQUFJOztBQUFBLDZCQUEvQixJQUErQjtBQUFBLFlBQS9CLElBQStCLDZCQUF4QixLQUF3QjtBQUFBLDhCQUFqQixLQUFpQjtBQUFBLFlBQWpCLEtBQWlCLDhCQUFULENBQVM7O0FBQ3BDLFlBQUksYUFBSjtBQUNBLFlBQUksSUFBSixFQUFVO0FBQ04sbUJBQU8sS0FBSyxVQUFaO0FBQ0gsU0FGRCxNQUVPO0FBQ0gsbUJBQU8sS0FBSyxJQUFaO0FBQ0g7O0FBRUQsWUFBSSxRQUFRLENBQVosRUFBZTtBQUNYLG1CQUFPLEtBQUssWUFBTCxDQUFrQixLQUFsQixDQUFQO0FBQ0g7O0FBRUQsZUFBTyxJQUFQO0FBQ0g7O0FBRUQsUUFBSSxLQUFKLEdBQVk7QUFDUixlQUFPLEtBQUssSUFBTCxHQUFZLEtBQUssSUFBakIsR0FBd0IsQ0FBL0I7QUFDSDs7QUFFRCxRQUFJLE1BQUosR0FBYTtBQUNULGVBQU8sS0FBSyxJQUFMLEdBQVksS0FBSyxJQUFqQixHQUF3QixDQUEvQjtBQUNIOztBQUVELFFBQUksUUFBSixHQUFlO0FBQ1gsWUFBSSxLQUFLLFFBQUwsQ0FBYyxRQUFsQixFQUE0QixPQUFPLEtBQUssUUFBTCxDQUFjLFFBQXJCO0FBQzVCLGVBQU8sS0FBSyxRQUFMLENBQWMsUUFBZCxHQUF5QixrQkFBa0IsSUFBbEIsQ0FBaEM7QUFDSDs7QUFFRCxRQUFJLGNBQUosR0FBcUI7QUFDakIsWUFBSSxLQUFLLFFBQUwsQ0FBYyxjQUFsQixFQUFrQyxPQUFPLEtBQUssUUFBTCxDQUFjLGNBQXJCO0FBQ2xDLGVBQU8sS0FBSyxRQUFMLENBQWMsY0FBZCxHQUErQixrQkFBa0IsSUFBbEIsQ0FBdEM7QUFDSDs7QUFFRCxRQUFJLFFBQUosR0FBZTs7QUFDWCxZQUFJLEtBQUssUUFBTCxDQUFjLFFBQWxCLEVBQTRCLE9BQU8sS0FBSyxRQUFMLENBQWMsUUFBckI7QUFDNUIsZUFBTyxLQUFLLFFBQUwsQ0FBYyxRQUFkLEdBQXlCLFlBQVksSUFBWixDQUFoQztBQUNIOztBQUVELFFBQUksT0FBSixHQUFjO0FBQ1YsWUFBSSxLQUFLLFFBQUwsQ0FBYyxPQUFsQixFQUEyQixPQUFPLEtBQUssUUFBTCxDQUFjLE9BQXJCO0FBQzNCLGVBQU8sS0FBSyxRQUFMLENBQWMsT0FBZCxHQUF3QixXQUFXLElBQVgsQ0FBL0I7QUFDSDs7QUFFRCxRQUFJLE1BQUosR0FBYTtBQUNULFlBQUksS0FBSyxRQUFMLENBQWMsTUFBbEIsRUFBMEIsT0FBTyxLQUFLLFFBQUwsQ0FBYyxNQUFyQjtBQUMxQixlQUFPLEtBQUssUUFBTCxDQUFjLE1BQWQsR0FBdUIsVUFBVSxJQUFWLENBQTlCO0FBQ0g7O0FBRUQsUUFBSSxJQUFKLEdBQVc7QUFDUCxZQUFJLEtBQUssUUFBTCxDQUFjLElBQWxCLEVBQXdCLE9BQU8sS0FBSyxRQUFMLENBQWMsSUFBckI7O0FBRXhCLFlBQUksTUFBTSxvQkFBVSxLQUFLLEtBQWYsRUFBc0IsS0FBSyxNQUEzQixFQUFtQztBQUN6QyxrQkFBTSxVQUFVLE1BRHlCO0FBRXpDLHNCQUFVLENBQUMsS0FBSyxJQUFOLEVBQVksS0FBSyxJQUFqQixDQUYrQjtBQUd6QyxvQkFBUSxLQUFLLEdBQUwsQ0FBUztBQUh3QixTQUFuQyxDQUFWOztBQU1BLGFBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxLQUFLLEtBQXpCLEVBQWdDLEdBQWhDLEVBQXFDO0FBQ2pDLGlCQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksS0FBSyxNQUF6QixFQUFpQyxHQUFqQyxFQUFzQztBQUNsQyxvQkFBSSxLQUFLLEdBQUwsQ0FBUyxNQUFULENBQWdCLElBQUksS0FBSyxJQUFULEdBQWdCLENBQUMsSUFBSSxLQUFLLElBQVYsSUFBa0IsS0FBSyxHQUFMLENBQVMsS0FBM0QsTUFBc0UsS0FBSyxFQUEvRSxFQUFtRjtBQUMvRSx3QkFBSSxRQUFKLENBQWEsQ0FBYixFQUFnQixDQUFoQjtBQUNIO0FBQ0o7QUFDSjtBQUNELGVBQU8sS0FBSyxRQUFMLENBQWMsSUFBZCxHQUFxQixHQUE1QjtBQUNIOztBQUVELFFBQUksVUFBSixHQUFpQjtBQUNiLFlBQUksS0FBSyxRQUFMLENBQWMsVUFBbEIsRUFBOEIsT0FBTyxLQUFLLFFBQUwsQ0FBYyxVQUFyQjs7QUFFOUIsWUFBSSxNQUFNLG9CQUFVLEtBQUssS0FBZixFQUFzQixLQUFLLE1BQTNCLEVBQW1DO0FBQ3pDLGtCQUFNLFVBQVUsTUFEeUI7QUFFekMsc0JBQVUsQ0FBQyxLQUFLLElBQU4sRUFBWSxLQUFLLElBQWpCLENBRitCO0FBR3pDLG9CQUFRLEtBQUssR0FBTCxDQUFTO0FBSHdCLFNBQW5DLENBQVY7O0FBTUEsYUFBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLEtBQUssS0FBekIsRUFBZ0MsR0FBaEMsRUFBcUM7QUFDakMsaUJBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxLQUFLLE1BQXpCLEVBQWlDLEdBQWpDLEVBQXNDO0FBQ2xDLG9CQUFJLFNBQVMsSUFBSSxLQUFLLElBQVQsR0FBZ0IsQ0FBQyxJQUFJLEtBQUssSUFBVixJQUFrQixLQUFLLEdBQUwsQ0FBUyxLQUF4RDtBQUNBLG9CQUFJLEtBQUssY0FBTCxDQUFvQixPQUFwQixDQUE0QixLQUFLLEdBQUwsQ0FBUyxNQUFULENBQWdCLE1BQWhCLENBQTVCLEtBQXdELENBQTVELEVBQStEO0FBQzNELHdCQUFJLFFBQUosQ0FBYSxDQUFiLEVBQWdCLENBQWhCO0FBQ0gsaUI7QUFDSjtBQUNKOztBQUVELGVBQU8sS0FBSyxRQUFMLENBQWMsVUFBZCxHQUEyQixHQUFsQztBQUNIO0FBckdvQjs7a0JBQUosRzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBMkhyQixTQUFTLGlCQUFULENBQTJCLEdBQTNCLEVBQWdDO0FBQzVCLFFBQUksY0FBYyxJQUFJLEtBQUosQ0FBVSxDQUFWLENBQWxCOztBQUVBLFFBQUksTUFBTSxDQUFWO0FBQ0EsUUFBSSxTQUFTLElBQUksR0FBakI7QUFDQSxRQUFJLFNBQVMsT0FBTyxNQUFwQjs7QUFFQSxRQUFJLFFBQVEsS0FBSyxHQUFMLENBQVMsSUFBSSxJQUFiLEVBQW1CLENBQW5CLENBQVo7QUFDQSxRQUFJLE1BQU0sS0FBSyxHQUFMLENBQVMsSUFBSSxLQUFiLEVBQW9CLE9BQU8sS0FBUCxHQUFlLENBQW5DLENBQVY7OztBQUdBLFNBQUssSUFBSSxDQUFULElBQWMsQ0FBQyxDQUFELEVBQUksSUFBSSxNQUFKLEdBQWEsQ0FBakIsQ0FBZCxFQUFtQztBQUMvQixhQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksSUFBSSxLQUF4QixFQUErQixHQUEvQixFQUFvQztBQUNoQyxnQkFBSSxTQUFTLENBQUMsSUFBSSxJQUFJLElBQVQsSUFBaUIsT0FBTyxLQUF4QixHQUFnQyxDQUFoQyxHQUFvQyxJQUFJLElBQXJEO0FBQ0EsZ0JBQUssSUFBSSxJQUFJLElBQVQsR0FBaUIsQ0FBakIsSUFBc0IsT0FBTyxNQUFQLE1BQW1CLElBQUksRUFBN0MsSUFBbUQsT0FBTyxTQUFTLENBQWhCLE1BQXVCLElBQUksRUFBbEYsRUFBc0Y7QUFDbEYsb0JBQUksUUFBUSxPQUFPLFNBQVMsQ0FBaEIsQ0FBWjtBQUNBLG9CQUFJLFlBQVksT0FBWixDQUFvQixLQUFwQixNQUErQixDQUFDLENBQXBDLEVBQXVDO0FBQ25DLGdDQUFZLEtBQVosSUFBcUIsS0FBckI7QUFDSDtBQUNKO0FBQ0QsZ0JBQUssT0FBTyxLQUFQLEdBQWUsQ0FBZixHQUFtQixJQUFJLElBQXhCLEdBQWdDLENBQWhDLElBQXFDLE9BQU8sTUFBUCxNQUFtQixJQUFJLEVBQTVELElBQWtFLE9BQU8sU0FBUyxDQUFoQixNQUF1QixJQUFJLEVBQWpHLEVBQXFHO0FBQ2pHLG9CQUFJLFNBQVEsT0FBTyxTQUFTLENBQWhCLENBQVo7QUFDQSxvQkFBSSxZQUFZLE9BQVosQ0FBb0IsTUFBcEIsTUFBK0IsQ0FBQyxDQUFwQyxFQUF1QztBQUNuQyxnQ0FBWSxLQUFaLElBQXFCLE1BQXJCO0FBQ0g7QUFDSjtBQUNKO0FBQ0o7OztBQUlELFFBQUksUUFBUSxLQUFLLEdBQUwsQ0FBUyxJQUFJLElBQWIsRUFBbUIsQ0FBbkIsQ0FBWjtBQUNBLFFBQUksTUFBTSxLQUFLLEdBQUwsQ0FBUyxJQUFJLE1BQWIsRUFBcUIsT0FBTyxNQUFQLEdBQWdCLENBQXJDLENBQVY7O0FBRUEsU0FBSyxJQUFJLEdBQVQsSUFBYyxDQUFDLENBQUQsRUFBSSxJQUFJLEtBQUosR0FBWSxDQUFoQixDQUFkLEVBQWtDO0FBQzlCLGFBQUssSUFBSSxLQUFJLENBQWIsRUFBZ0IsS0FBSSxJQUFJLE1BQXhCLEVBQWdDLElBQWhDLEVBQXFDO0FBQ2pDLGdCQUFJLFVBQVMsQ0FBQyxLQUFJLElBQUksSUFBVCxJQUFpQixPQUFPLEtBQXhCLEdBQWdDLEdBQWhDLEdBQW9DLElBQUksSUFBckQ7QUFDQSxnQkFBSyxLQUFJLElBQUksSUFBVCxHQUFpQixDQUFqQixJQUFzQixPQUFPLE9BQVAsTUFBbUIsSUFBSSxFQUE3QyxJQUFtRCxPQUFPLFVBQVMsT0FBTyxLQUF2QixNQUFrQyxJQUFJLEVBQTdGLEVBQWlHO0FBQzdGLG9CQUFJLFVBQVEsT0FBTyxVQUFTLE9BQU8sS0FBdkIsQ0FBWjtBQUNBLG9CQUFJLFlBQVksT0FBWixDQUFvQixPQUFwQixNQUErQixDQUFDLENBQXBDLEVBQXVDO0FBQ25DLGdDQUFZLEtBQVosSUFBcUIsT0FBckI7QUFDSDtBQUNKO0FBQ0QsZ0JBQUssT0FBTyxNQUFQLEdBQWdCLEVBQWhCLEdBQW9CLElBQUksSUFBekIsR0FBaUMsQ0FBakMsSUFBc0MsT0FBTyxPQUFQLE1BQW1CLElBQUksRUFBN0QsSUFBbUUsT0FBTyxVQUFTLE9BQU8sS0FBdkIsTUFBa0MsSUFBSSxFQUE3RyxFQUFpSDtBQUM3RyxvQkFBSSxVQUFRLE9BQU8sVUFBUyxPQUFPLEtBQXZCLENBQVo7QUFDQSxvQkFBSSxZQUFZLE9BQVosQ0FBb0IsT0FBcEIsTUFBK0IsQ0FBQyxDQUFwQyxFQUF1QztBQUNuQyxnQ0FBWSxLQUFaLElBQXFCLE9BQXJCO0FBQ0g7QUFDSjtBQUNKO0FBQ0o7QUFDRCxRQUFJLFlBQVksQ0FBWixNQUFtQixTQUF2QixFQUFrQyxPQUFPLENBQUMsQ0FBRCxDQUFQO0FBQ2xDLFdBQU8sV0FBUCxDO0FBQ0g7Ozs7Ozs7OztBQVVELFNBQVMsV0FBVCxDQUFxQixHQUFyQixFQUEwQjtBQUN0QixRQUFJLFFBQVEsQ0FBWjtBQUNBLFFBQUksU0FBUyxJQUFJLEdBQWpCO0FBQ0EsUUFBSSxTQUFTLE9BQU8sTUFBcEI7O0FBRUEsUUFBSSxZQUFZLENBQUMsQ0FBRCxDQUFoQjtBQUNBLFFBQUksSUFBSSxNQUFKLEdBQWEsQ0FBakIsRUFBb0IsVUFBVSxDQUFWLElBQWUsSUFBSSxNQUFKLEdBQWEsQ0FBNUI7QUFDcEIsU0FBSyxJQUFJLENBQVQsSUFBYyxTQUFkLEVBQXlCO0FBQ3JCLGFBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxJQUFJLEtBQUosR0FBWSxDQUFoQyxFQUFtQyxHQUFuQyxFQUF3QztBQUNwQyxnQkFBSSxTQUFTLENBQUMsSUFBSSxJQUFJLElBQVQsSUFBaUIsT0FBTyxLQUF4QixHQUFnQyxDQUFoQyxHQUFvQyxJQUFJLElBQXJEO0FBQ0EsZ0JBQUksT0FBTyxNQUFQLE1BQW1CLElBQUksRUFBM0IsRUFBK0I7QUFDM0I7QUFDSDtBQUNKO0FBQ0o7O0FBRUQsUUFBSSxZQUFZLENBQUMsQ0FBRCxDQUFoQjtBQUNBLFFBQUksSUFBSSxLQUFKLEdBQVksQ0FBaEIsRUFBbUIsVUFBVSxDQUFWLElBQWUsSUFBSSxLQUFKLEdBQVksQ0FBM0I7QUFDbkIsU0FBSyxJQUFJLEdBQVQsSUFBYyxTQUFkLEVBQXlCO0FBQ3JCLGFBQUssSUFBSSxNQUFJLENBQWIsRUFBZ0IsTUFBSSxJQUFJLE1BQXhCLEVBQWdDLEtBQWhDLEVBQXFDO0FBQ2pDLGdCQUFJLFdBQVMsQ0FBQyxNQUFJLElBQUksSUFBVCxJQUFpQixPQUFPLEtBQXhCLEdBQWdDLEdBQWhDLEdBQW9DLElBQUksSUFBckQ7QUFDQSxnQkFBSSxPQUFPLFFBQVAsTUFBbUIsSUFBSSxFQUEzQixFQUErQjtBQUMzQjtBQUNIO0FBQ0o7QUFDSjtBQUNELFdBQU8sS0FBUDtBQUNIOzs7Ozs7Ozs7QUFTRCxTQUFTLFNBQVQsQ0FBbUIsR0FBbkIsRUFBd0I7QUFDcEIsUUFBSSxRQUFRLENBQVo7QUFDQSxRQUFJLFNBQVMsSUFBSSxHQUFqQjtBQUNBLFFBQUksU0FBUyxPQUFPLE1BQXBCOztBQUVBLFNBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxJQUFJLEtBQUosR0FBWSxDQUFoQyxFQUFtQyxHQUFuQyxFQUF3QztBQUNwQyxhQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksSUFBSSxNQUFKLEdBQWEsQ0FBakMsRUFBb0MsR0FBcEMsRUFBeUM7QUFDckMsZ0JBQUksU0FBUyxDQUFDLElBQUksSUFBSSxJQUFULElBQWlCLE9BQU8sS0FBeEIsR0FBZ0MsQ0FBaEMsR0FBb0MsSUFBSSxJQUFyRDtBQUNBLGdCQUFJLE9BQU8sTUFBUCxNQUFtQixJQUFJLEVBQTNCLEVBQStCOztBQUUzQixvQkFBSyxPQUFPLFNBQVMsQ0FBaEIsTUFBdUIsSUFBSSxFQUE1QixJQUNDLE9BQU8sU0FBUyxDQUFoQixNQUF1QixJQUFJLEVBRDVCLElBRUMsT0FBTyxTQUFTLE9BQU8sS0FBdkIsTUFBa0MsSUFBSSxFQUZ2QyxJQUdDLE9BQU8sU0FBUyxPQUFPLEtBQXZCLE1BQWtDLElBQUksRUFIM0MsRUFHZ0Q7QUFDNUM7QUFDSDtBQUNKO0FBQ0o7QUFDSjtBQUNELFdBQU8sUUFBUSxJQUFJLFFBQW5CO0FBQ0g7Ozs7Ozs7O0FBUUQsU0FBUyxVQUFULENBQW9CLEdBQXBCLEVBQXlCO0FBQ3JCLFFBQUksUUFBUSxDQUFaO0FBQ0EsUUFBSSxTQUFTLElBQUksR0FBakI7QUFDQSxRQUFJLFNBQVMsT0FBTyxNQUFwQjs7QUFFQSxTQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksSUFBSSxLQUFKLEdBQVksQ0FBaEMsRUFBbUMsR0FBbkMsRUFBd0M7QUFDcEMsYUFBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLElBQUksTUFBSixHQUFhLENBQWpDLEVBQW9DLEdBQXBDLEVBQXlDO0FBQ3JDLGdCQUFJLFNBQVMsQ0FBQyxJQUFJLElBQUksSUFBVCxJQUFpQixPQUFPLEtBQXhCLEdBQWdDLENBQWhDLEdBQW9DLElBQUksSUFBckQ7QUFDQSxnQkFBSSxPQUFPLE1BQVAsTUFBbUIsSUFBSSxFQUEzQixFQUErQjs7QUFFM0Isb0JBQUssSUFBSSxRQUFKLENBQWEsT0FBYixDQUFxQixPQUFPLFNBQVMsQ0FBaEIsQ0FBckIsTUFBNkMsQ0FBQyxDQUEvQyxJQUNDLElBQUksUUFBSixDQUFhLE9BQWIsQ0FBcUIsT0FBTyxTQUFTLENBQWhCLENBQXJCLE1BQTZDLENBQUMsQ0FEL0MsSUFFQyxJQUFJLFFBQUosQ0FBYSxPQUFiLENBQXFCLE9BQU8sU0FBUyxPQUFPLEtBQXZCLENBQXJCLE1BQXdELENBQUMsQ0FGMUQsSUFHQyxJQUFJLFFBQUosQ0FBYSxPQUFiLENBQXFCLE9BQU8sU0FBUyxPQUFPLEtBQXZCLENBQXJCLE1BQXdELENBQUMsQ0FIOUQsRUFHa0U7QUFDOUQ7QUFDSDtBQUNKO0FBQ0o7QUFDSjtBQUNELFdBQU8sUUFBUSxJQUFJLFFBQW5CO0FBQ0g7Ozs7OztBQU1ELFNBQVMsaUJBQVQsQ0FBMkIsR0FBM0IsRUFBZ0M7QUFDNUIsUUFBSSxXQUFXLENBQUMsSUFBSSxFQUFMLENBQWY7QUFDQSxRQUFJLFNBQVMsSUFBSSxHQUFqQjtBQUNBLFFBQUksU0FBUyxPQUFPLE1BQXBCOztBQUlBLFFBQUksSUFBSSxNQUFKLEdBQWEsQ0FBakIsRUFBb0I7QUFDaEIsYUFBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLElBQUksS0FBeEIsRUFBK0IsR0FBL0IsRUFBb0M7QUFDaEMsZ0JBQUksU0FBVSxJQUFJLElBQUwsR0FBYSxPQUFPLEtBQXBCLEdBQTRCLENBQTVCLEdBQWdDLElBQUksSUFBakQ7QUFDQSxnQkFBSSxTQUFTLE9BQVQsQ0FBaUIsT0FBTyxNQUFQLENBQWpCLEtBQW9DLENBQXhDLEVBQTJDO0FBQ3ZDLG9CQUFJLEtBQUssT0FBTyxTQUFTLE9BQU8sS0FBdkIsQ0FBVDtBQUNBLG9CQUFLLFNBQVMsT0FBVCxDQUFpQixFQUFqQixNQUF5QixDQUFDLENBQTNCLElBQWtDLElBQUksUUFBSixDQUFhLE9BQWIsQ0FBcUIsRUFBckIsTUFBNkIsQ0FBQyxDQUFwRSxFQUF3RTtBQUNwRSw2QkFBUyxJQUFULENBQWMsRUFBZDtBQUNIO0FBQ0o7QUFDSjtBQUNKOztBQUVELFFBQUksUUFBUSxJQUFJLEtBQUosQ0FBVSxDQUFWLENBQVo7QUFDQSxTQUFLLElBQUksTUFBSSxDQUFiLEVBQWdCLE1BQUksSUFBSSxLQUFKLEdBQVksQ0FBaEMsRUFBbUMsS0FBbkMsRUFBd0M7QUFDcEMsYUFBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLElBQUksTUFBSixHQUFhLENBQWpDLEVBQW9DLEdBQXBDLEVBQXlDO0FBQ3JDLGdCQUFJLFdBQVMsQ0FBQyxJQUFJLElBQUksSUFBVCxJQUFpQixPQUFPLEtBQXhCLEdBQWdDLEdBQWhDLEdBQW9DLElBQUksSUFBckQ7QUFDQSxnQkFBSSxTQUFTLE9BQVQsQ0FBaUIsT0FBTyxRQUFQLENBQWpCLEtBQW9DLENBQXhDLEVBQTJDOzs7QUFHdkMsc0JBQU0sQ0FBTixJQUFXLE9BQU8sV0FBUyxDQUFoQixDQUFYO0FBQ0Esc0JBQU0sQ0FBTixJQUFXLE9BQU8sV0FBUyxDQUFoQixDQUFYO0FBQ0Esc0JBQU0sQ0FBTixJQUFXLE9BQU8sV0FBUyxPQUFPLEtBQXZCLENBQVg7QUFDQSxzQkFBTSxDQUFOLElBQVcsT0FBTyxXQUFTLE9BQU8sS0FBdkIsQ0FBWDs7QUFFQSxxQkFBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLENBQXBCLEVBQXVCLEdBQXZCLEVBQTRCO0FBQ3hCLHdCQUFJLE1BQUssTUFBTSxDQUFOLENBQVQ7QUFDQSx3QkFBSyxTQUFTLE9BQVQsQ0FBaUIsR0FBakIsTUFBeUIsQ0FBQyxDQUEzQixJQUFrQyxJQUFJLFFBQUosQ0FBYSxPQUFiLENBQXFCLEdBQXJCLE1BQTZCLENBQUMsQ0FBcEUsRUFBd0U7QUFDcEUsaUNBQVMsSUFBVCxDQUFjLEdBQWQ7QUFDSDtBQUNKO0FBQ0o7QUFDSjtBQUNKOztBQUVELFdBQU8sUUFBUDtBQUNIOzs7Ozs7OztrQkMvVHVCLFU7O0FBRnhCOzs7Ozs7QUFFZSxTQUFTLFVBQVQsR0FBdUM7QUFBQSxRQUFuQixhQUFtQix5REFBSCxDQUFHOzs7QUFFbEQsU0FBSyxnQkFBTCxDQUFzQixZQUF0QixFQUFvQztBQUNoQyxrQkFBVSxDQUFDLENBQUQsRUFBSSxFQUFKO0FBRHNCLEtBQXBDOztBQUlBLFFBQUksQ0FBQyxDQUFDLENBQUMsQ0FBRCxFQUFHLEVBQUgsRUFBTyxPQUFQLENBQWUsYUFBZixDQUFOLEVBQXFDLE1BQU0sTUFBTSxtREFBTixDQUFOOztBQUVyQyxRQUFJLEtBQUssUUFBTCxLQUFrQixhQUF0QixFQUFxQyxPQUFPLEtBQUssS0FBTCxFQUFQOztBQUVyQyxRQUFJLFdBQVcsZ0JBQU0sVUFBTixDQUFpQixJQUFqQixFQUF1QixFQUFDLFVBQVUsYUFBWCxFQUF2QixDQUFmOztBQUVBLFFBQUksa0JBQWtCLENBQXRCLEVBQXlCO0FBQ3JCLGFBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxLQUFLLElBQUwsQ0FBVSxNQUE5QixFQUFzQyxHQUF0QyxFQUEyQztBQUN2QyxxQkFBUyxJQUFULENBQWMsQ0FBZCxJQUFtQixLQUFLLElBQUwsQ0FBVSxDQUFWLEtBQWdCLENBQW5DO0FBQ0g7QUFDSixLQUpELE1BSU87QUFDSCxhQUFLLElBQUksS0FBSSxDQUFiLEVBQWdCLEtBQUksS0FBSyxJQUFMLENBQVUsTUFBOUIsRUFBc0MsSUFBdEMsRUFBMkM7QUFDdkMscUJBQVMsSUFBVCxDQUFjLEVBQWQsSUFBbUIsS0FBSyxJQUFMLENBQVUsRUFBVixLQUFnQixDQUFoQixHQUFvQixLQUFLLElBQUwsQ0FBVSxFQUFWLENBQXZDO0FBQ0g7QUFDSjs7QUFFRCxXQUFPLFFBQVA7QUFDSDs7Ozs7Ozs7a0JDdkJ1QixJOztBQUZ4Qjs7Ozs7O0FBRWUsU0FBUyxJQUFULEdBS0g7QUFBQSxxRUFBSixFQUFJOztBQUFBLHNCQUpSLENBSVE7QUFBQSxRQUpSLENBSVEsMEJBSkosQ0FJSTtBQUFBLHNCQUhSLENBR1E7QUFBQSxRQUhSLENBR1EsMEJBSEosQ0FHSTtBQUFBLDBCQUZSLEtBRVE7QUFBQSxRQUZSLEtBRVEsOEJBRkEsS0FBSyxLQUFMLEdBQWEsQ0FFYjtBQUFBLDJCQURSLE1BQ1E7QUFBQSxRQURSLE1BQ1EsK0JBREMsS0FBSyxNQUFMLEdBQWMsQ0FDZjs7O0FBRVIsUUFBSSxJQUFLLEtBQUssS0FBTCxHQUFhLENBQWxCLElBQXdCLElBQUssS0FBSyxNQUFMLEdBQWMsQ0FBL0MsRUFDSSxNQUFNLElBQUksVUFBSixDQUFnQixvQkFBa0IsQ0FBRSxTQUFNLENBQUUscUJBQWtCLEtBQUssS0FBTCxHQUFhLENBQUUsT0FBSSxLQUFLLE1BQUwsR0FBYyxDQUFFLElBQWpHLENBQU47QUFDSixRQUFJLFNBQVMsQ0FBVCxJQUFjLFVBQVUsQ0FBNUIsRUFDSSxNQUFNLElBQUksVUFBSixDQUFnQixrQ0FBZ0MsS0FBTSxjQUFXLE1BQU8sNkJBQXhFLENBQU47QUFDSixRQUFJLElBQUksQ0FBSixJQUFTLElBQUksQ0FBakIsRUFDSSxNQUFNLElBQUksVUFBSixDQUFnQixxQkFBbUIsQ0FBRSxTQUFNLENBQUUsNkJBQTdDLENBQU47QUFDSixRQUFJLFFBQVMsS0FBSyxLQUFMLEdBQWEsQ0FBdEIsSUFBNEIsU0FBVSxLQUFLLE1BQUwsR0FBYyxDQUF4RCxFQUNJLE1BQU0sSUFBSSxVQUFKLENBQWdCLGNBQVksQ0FBRSxTQUFNLENBQUUsYUFBVSxLQUFNLGNBQVcsTUFBTyx5QkFBeEUsQ0FBTjs7QUFFSixRQUFJLFdBQVcsZ0JBQU0sVUFBTixDQUFpQixJQUFqQixFQUF1QixFQUFDLFlBQUQsRUFBUSxjQUFSLEVBQXZCLENBQWY7O0FBRUEsUUFBSSxTQUFTLFFBQVEsS0FBSyxRQUExQjtBQUNBLFFBQUksS0FBSyxJQUFJLE1BQWI7O0FBRUEsUUFBSSxNQUFNLENBQVYsQzs7QUFFQSxRQUFJLFFBQVEsSUFBSSxLQUFLLFFBQXJCOztBQUVBLFNBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxFQUFwQixFQUF3QixHQUF4QixFQUE2QjtBQUN6QixZQUFJLElBQUssSUFBSSxLQUFLLEtBQVQsR0FBaUIsS0FBSyxRQUF2QixHQUFtQyxLQUEzQztBQUNBLFlBQUksS0FBSyxJQUFJLE1BQWI7QUFDQSxlQUFPLElBQUksRUFBWCxFQUFlLEdBQWYsRUFBb0I7QUFDaEIscUJBQVMsSUFBVCxDQUFjLEtBQWQsSUFBdUIsS0FBSyxJQUFMLENBQVUsQ0FBVixDQUF2QjtBQUNIO0FBQ0o7O0FBRUQsV0FBTyxRQUFQO0FBQ0g7Ozs7Ozs7O2tCQ3BDdUIsTztBQUFULFNBQVMsT0FBVCxDQUFpQixRQUFqQixFQUEyQjtBQUN0QyxRQUFJLE1BQU0sQ0FBVjtBQUNBLFNBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxLQUFLLElBQUwsQ0FBVSxNQUE5QixFQUFzQyxLQUFLLEtBQUssUUFBaEQsRUFBMEQ7QUFDdEQsaUJBQVMsSUFBVCxDQUFjLEtBQWQsSUFBdUIsQ0FBQyxLQUFLLElBQUwsQ0FBVSxDQUFWLElBQWUsS0FBSyxJQUFMLENBQVUsSUFBSSxDQUFkLENBQWYsR0FBa0MsS0FBSyxJQUFMLENBQVUsSUFBSSxDQUFkLENBQW5DLElBQXVELENBQTlFO0FBQ0EsWUFBSSxLQUFLLEtBQVQsRUFBZ0I7QUFDWixxQkFBUyxJQUFULENBQWMsS0FBZCxJQUF1QixLQUFLLElBQUwsQ0FBVSxJQUFJLENBQWQsQ0FBdkI7QUFDSDtBQUNKO0FBQ0o7Ozs7Ozs7O2tCQ0N1QixJOztBQVR4Qjs7OztBQUNBOztBQUVBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7OztBQUVlLFNBQVMsSUFBVCxHQUE0QztBQUFBLHFFQUFKLEVBQUk7O0FBQUEsOEJBQTdCLFNBQTZCO0FBQUEsUUFBN0IsU0FBNkIsa0NBQWpCLFNBQWlCOzs7QUFFdkQsUUFBSSxLQUFLLFVBQUwsS0FBb0IsQ0FBeEIsRUFBMkI7QUFDdkIsZUFBTyxLQUFLLEtBQUwsRUFBUDtBQUNIOztBQUVELFNBQUssZ0JBQUwsQ0FBc0IsTUFBdEIsRUFBOEIsRUFBQyxzQkFBRCxFQUE5Qjs7QUFFQSxRQUFJLFdBQVcsZ0JBQU0sVUFBTixDQUFpQixJQUFqQixFQUF1QjtBQUNsQyxvQkFBWSxDQURzQjtBQUVsQyxvQkFBWTtBQUZzQixLQUF2QixDQUFmOztBQUtBLFlBQVEsVUFBVSxXQUFWLEVBQVI7QUFDSSxhQUFLLFNBQUw7O0FBQ0ksMkJBQVEsSUFBUixDQUFhLElBQWIsRUFBbUIsUUFBbkI7QUFDQTtBQUNKLGFBQUssU0FBTDs7QUFDSSwyQkFBUSxJQUFSLENBQWEsSUFBYixFQUFtQixRQUFuQjtBQUNBO0FBQ0osYUFBSyxRQUFMOztBQUNJLDZCQUFPLElBQVAsQ0FBWSxJQUFaLEVBQWtCLFFBQWxCO0FBQ0E7QUFDSixhQUFLLFNBQUw7QUFDSSw4QkFBUSxJQUFSLENBQWEsSUFBYixFQUFtQixRQUFuQjtBQUNBO0FBQ0osYUFBSyxTQUFMOztBQUNJLDhCQUFRLElBQVIsQ0FBYSxJQUFiLEVBQW1CLFFBQW5CO0FBQ0E7QUFDSjtBQUNJLGtCQUFNLElBQUksS0FBSixDQUFVLGlDQUFpQyxTQUEzQyxDQUFOO0FBakJSOztBQW9CQSxXQUFPLFFBQVA7QUFDSDs7Ozs7Ozs7a0JDM0N1QixPO0FBQVQsU0FBUyxPQUFULENBQWlCLFFBQWpCLEVBQTJCO0FBQ3RDLFFBQUksTUFBTSxDQUFWO0FBQ0EsU0FBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLEtBQUssSUFBTCxDQUFVLE1BQTlCLEVBQXNDLEtBQUssS0FBSyxRQUFoRCxFQUEwRDtBQUN0RCxpQkFBUyxJQUFULENBQWMsS0FBZCxJQUF1QixLQUFLLElBQUwsQ0FBVSxDQUFWLElBQWUsS0FBZixHQUF1QixLQUFLLElBQUwsQ0FBVSxJQUFJLENBQWQsSUFBbUIsS0FBMUMsR0FBa0QsS0FBSyxJQUFMLENBQVUsSUFBSSxDQUFkLElBQW1CLEtBQTVGO0FBQ0EsWUFBSSxLQUFLLEtBQVQsRUFBZ0I7QUFDWixxQkFBUyxJQUFULENBQWMsS0FBZCxJQUF1QixLQUFLLElBQUwsQ0FBVSxJQUFJLENBQWQsQ0FBdkI7QUFDSDtBQUNKO0FBQ0o7Ozs7Ozs7O2tCQ1J1QixPO0FBQVQsU0FBUyxPQUFULENBQWlCLFFBQWpCLEVBQTJCO0FBQ3RDLFFBQUksTUFBTSxDQUFWO0FBQ0EsU0FBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLEtBQUssSUFBTCxDQUFVLE1BQTlCLEVBQXNDLEtBQUssS0FBSyxRQUFoRCxFQUEwRDtBQUN0RCxpQkFBUyxJQUFULENBQWMsS0FBZCxJQUF1QixLQUFLLElBQUwsQ0FBVSxDQUFWLElBQWUsTUFBZixHQUF3QixLQUFLLElBQUwsQ0FBVSxJQUFJLENBQWQsSUFBbUIsTUFBM0MsR0FBb0QsS0FBSyxJQUFMLENBQVUsSUFBSSxDQUFkLElBQW1CLE1BQTlGO0FBQ0EsWUFBSSxLQUFLLEtBQVQsRUFBZ0I7QUFDWixxQkFBUyxJQUFULENBQWMsS0FBZCxJQUF1QixLQUFLLElBQUwsQ0FBVSxJQUFJLENBQWQsQ0FBdkI7QUFDSDtBQUNKO0FBQ0o7Ozs7Ozs7O2tCQ1J1QixPO0FBQVQsU0FBUyxPQUFULENBQWlCLFFBQWpCLEVBQTJCO0FBQ3RDLFFBQUksTUFBTSxDQUFWO0FBQ0EsU0FBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLEtBQUssSUFBTCxDQUFVLE1BQTlCLEVBQXNDLEtBQUssS0FBSyxRQUFoRCxFQUEwRDtBQUN0RCxpQkFBUyxJQUFULENBQWMsS0FBZCxJQUF1QixLQUFLLEdBQUwsQ0FBUyxLQUFLLElBQUwsQ0FBVSxDQUFWLENBQVQsRUFBdUIsS0FBSyxJQUFMLENBQVUsSUFBSSxDQUFkLENBQXZCLEVBQXlDLEtBQUssSUFBTCxDQUFVLElBQUksQ0FBZCxDQUF6QyxDQUF2QjtBQUNBLFlBQUksS0FBSyxLQUFULEVBQWdCO0FBQ1oscUJBQVMsSUFBVCxDQUFjLEtBQWQsSUFBdUIsS0FBSyxJQUFMLENBQVUsSUFBSSxDQUFkLENBQXZCO0FBQ0g7QUFDSjtBQUNKOzs7Ozs7OztrQkNSdUIsTTtBQUFULFNBQVMsTUFBVCxDQUFnQixRQUFoQixFQUEwQjtBQUNyQyxRQUFJLE1BQU0sQ0FBVjtBQUNBLFNBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxLQUFLLElBQUwsQ0FBVSxNQUE5QixFQUFzQyxLQUFLLEtBQUssUUFBaEQsRUFBMEQ7QUFDdEQsaUJBQVMsSUFBVCxDQUFjLEtBQWQsSUFBdUIsQ0FBQyxLQUFLLEdBQUwsQ0FBUyxLQUFLLElBQUwsQ0FBVSxDQUFWLENBQVQsRUFBdUIsS0FBSyxJQUFMLENBQVUsSUFBSSxDQUFkLENBQXZCLEVBQXlDLEtBQUssSUFBTCxDQUFVLElBQUksQ0FBZCxDQUF6QyxJQUE2RCxLQUFLLEdBQUwsQ0FBUyxLQUFLLElBQUwsQ0FBVSxDQUFWLENBQVQsRUFBdUIsS0FBSyxJQUFMLENBQVUsSUFBSSxDQUFkLENBQXZCLEVBQXlDLEtBQUssSUFBTCxDQUFVLElBQUksQ0FBZCxDQUF6QyxDQUE5RCxJQUE0SCxDQUFuSjtBQUNBLFlBQUksS0FBSyxLQUFULEVBQWdCO0FBQ1oscUJBQVMsSUFBVCxDQUFjLEtBQWQsSUFBdUIsS0FBSyxJQUFMLENBQVUsSUFBSSxDQUFkLENBQXZCO0FBQ0g7QUFDSjtBQUNKOzs7Ozs7OztrQkNGdUIsRzs7QUFIeEI7O0FBQ0E7Ozs7Ozs7OztBQUVlLFNBQVMsR0FBVCxHQUFlO0FBQzFCLFNBQUssZ0JBQUwsQ0FBc0IsS0FBdEIsRUFBNkI7QUFDekIsa0JBQVUsQ0FBQyxDQUFELEVBQUksRUFBSixDQURlO0FBRXpCLGVBQU8sQ0FBQyxDQUFELEVBQUcsQ0FBSCxDQUZrQjtBQUd6QixvQkFBWTtBQUhhLEtBQTdCOztBQU1BLFFBQUksV0FBVyxnQkFBTSxVQUFOLENBQWlCLElBQWpCLEVBQXVCO0FBQ2xDO0FBRGtDLEtBQXZCLENBQWY7O0FBSUEsUUFBSSxZQUFZLEtBQUssS0FBTCxDQUFXLEtBQUssUUFBTCxHQUFnQixDQUEzQixDQUFoQjtBQUNBLFFBQUksTUFBTSxDQUFWO0FBQ0EsUUFBSSxPQUFPLEtBQUssSUFBaEI7QUFDQSxTQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksS0FBSyxNQUF6QixFQUFpQyxLQUFLLEtBQUssUUFBM0MsRUFBcUQ7QUFDakQsWUFBSSxNQUFNLEtBQUssQ0FBTCxDQUFWO0FBQ0EsWUFBSSxRQUFRLEtBQUssSUFBSSxDQUFULENBQVo7QUFDQSxZQUFJLE9BQU8sS0FBSyxJQUFJLENBQVQsQ0FBWDs7QUFFQSxZQUFJLE1BQU0sS0FBSyxHQUFMLENBQVMsR0FBVCxFQUFjLEtBQWQsRUFBcUIsSUFBckIsQ0FBVjtBQUNBLFlBQUksTUFBTSxLQUFLLEdBQUwsQ0FBUyxHQUFULEVBQWMsS0FBZCxFQUFxQixJQUFyQixDQUFWO0FBQ0EsWUFBSSxNQUFNLENBQVY7QUFDQSxZQUFJLGFBQWEsQ0FBakI7QUFDQSxZQUFJLFlBQVksQ0FBQyxNQUFNLEdBQVAsSUFBYyxDQUE5QjtBQUNBLFlBQUksUUFBUSxHQUFaLEVBQWlCO0FBQ2IsZ0JBQUksUUFBUSxNQUFNLEdBQWxCO0FBQ0EseUJBQWEsWUFBWSxTQUFaLEdBQXdCLFNBQVMsSUFBSSxHQUFKLEdBQVUsR0FBbkIsQ0FBeEIsR0FBa0QsU0FBUyxNQUFNLEdBQWYsQ0FBL0Q7QUFDQSxvQkFBUSxHQUFSO0FBQ0kscUJBQUssR0FBTDtBQUNJLDBCQUFNLENBQUMsUUFBUSxJQUFULElBQWlCLEtBQWpCLElBQTBCLFFBQVEsSUFBUixHQUFlLENBQWYsR0FBbUIsQ0FBN0MsQ0FBTjtBQUNBO0FBQ0oscUJBQUssS0FBTDtBQUNJLDBCQUFNLENBQUMsT0FBTyxHQUFSLElBQWUsS0FBZixHQUF1QixDQUE3QjtBQUNBO0FBQ0oscUJBQUssSUFBTDtBQUNJLDBCQUFNLENBQUMsTUFBTSxLQUFQLElBQWdCLEtBQWhCLEdBQXdCLENBQTlCO0FBQ0E7QUFUUjtBQVdBLG1CQUFPLENBQVA7QUFDSDs7QUFHRCxpQkFBUyxJQUFULENBQWMsS0FBZCxJQUF1QixNQUFNLEtBQUssUUFBbEM7QUFDQSxpQkFBUyxJQUFULENBQWMsS0FBZCxJQUF1QixhQUFhLEtBQUssUUFBekM7QUFDQSxpQkFBUyxJQUFULENBQWMsS0FBZCxJQUF1QixTQUF2QjtBQUNBLFlBQUksS0FBSyxLQUFULEVBQWdCO0FBQ1oscUJBQVMsSUFBVCxDQUFjLEtBQWQsSUFBdUIsS0FBSyxJQUFJLENBQVQsQ0FBdkI7QUFDSDtBQUNKOztBQUVELFdBQU8sUUFBUDtBQUNIOzs7Ozs7OztrQkNwRHVCLEc7O0FBSHhCOztBQUNBOzs7Ozs7OztBQUVlLFNBQVMsR0FBVCxHQUFlO0FBQzFCLFNBQUssZ0JBQUwsQ0FBc0IsS0FBdEIsRUFBNkI7QUFDekIsa0JBQVUsQ0FBQyxDQUFELEVBQUksRUFBSixDQURlO0FBRXpCLGVBQU8sQ0FBQyxDQUFELEVBQUcsQ0FBSCxDQUZrQjtBQUd6QixvQkFBWTtBQUhhLEtBQTdCOztBQU1BLFFBQUksV0FBVyxnQkFBTSxVQUFOLENBQWlCLElBQWpCLEVBQXVCO0FBQ2xDO0FBRGtDLEtBQXZCLENBQWY7O0FBSUEsUUFBSSxNQUFNLENBQVY7QUFDQSxRQUFJLE9BQU8sS0FBSyxJQUFoQjtBQUNBLFNBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxLQUFLLE1BQXpCLEVBQWlDLEtBQUssS0FBSyxRQUEzQyxFQUFxRDtBQUNqRCxZQUFJLE1BQU0sS0FBSyxDQUFMLENBQVY7QUFDQSxZQUFJLFFBQVEsS0FBSyxJQUFJLENBQVQsQ0FBWjtBQUNBLFlBQUksT0FBTyxLQUFLLElBQUksQ0FBVCxDQUFYOztBQUVBLFlBQUksTUFBTSxLQUFLLEdBQUwsQ0FBUyxHQUFULEVBQWMsS0FBZCxFQUFxQixJQUFyQixDQUFWO0FBQ0EsWUFBSSxNQUFNLEtBQUssR0FBTCxDQUFTLEdBQVQsRUFBYyxLQUFkLEVBQXFCLElBQXJCLENBQVY7QUFDQSxZQUFJLFFBQVEsTUFBTSxHQUFsQjtBQUNBLFlBQUksTUFBTSxDQUFWO0FBQ0EsWUFBSSxhQUFhLFFBQVEsQ0FBUixHQUFZLENBQVosR0FBZ0IsUUFBUSxHQUF6QztBQUNBLFlBQUksUUFBUSxHQUFaOztBQUVBLFlBQUksUUFBUSxHQUFaLEVBQWlCO0FBQ2Isb0JBQVEsR0FBUjtBQUNJLHFCQUFLLEdBQUw7QUFDSSwwQkFBTSxDQUFDLFFBQVEsSUFBVCxJQUFpQixLQUFqQixJQUEwQixRQUFRLElBQVIsR0FBZSxDQUFmLEdBQW1CLENBQTdDLENBQU47QUFDQTtBQUNKLHFCQUFLLEtBQUw7QUFDSSwwQkFBTSxDQUFDLE9BQU8sR0FBUixJQUFlLEtBQWYsR0FBdUIsQ0FBN0I7QUFDQTtBQUNKLHFCQUFLLElBQUw7QUFDSSwwQkFBTSxDQUFDLE1BQU0sS0FBUCxJQUFnQixLQUFoQixHQUF3QixDQUE5QjtBQUNBO0FBVFI7QUFXQSxtQkFBTyxDQUFQO0FBQ0g7O0FBRUQsaUJBQVMsSUFBVCxDQUFjLEtBQWQsSUFBdUIsTUFBTSxLQUFLLFFBQWxDO0FBQ0EsaUJBQVMsSUFBVCxDQUFjLEtBQWQsSUFBdUIsYUFBYSxLQUFLLFFBQXpDO0FBQ0EsaUJBQVMsSUFBVCxDQUFjLEtBQWQsSUFBdUIsS0FBdkI7QUFDQSxZQUFJLEtBQUssS0FBVCxFQUFnQjtBQUNaLHFCQUFTLElBQVQsQ0FBYyxLQUFkLElBQXVCLEtBQUssSUFBSSxDQUFULENBQXZCO0FBQ0g7QUFDSjs7QUFFRCxXQUFPLFFBQVA7QUFDSDs7Ozs7Ozs7a0JDOUN1QixLOzs7Ozs7Ozs7QUFBVCxTQUFTLEtBQVQsQ0FBZSxTQUFmLEVBQTBCOztBQUVyQyxRQUFJLFlBQVksQ0FBaEI7QUFDQSxTQUFLLElBQUksS0FBSyxDQUFkLEVBQWlCLEtBQUssVUFBVSxNQUFoQyxFQUF3QyxJQUF4QyxFQUE4QztBQUMxQyxZQUFJLFVBQVUsRUFBVixNQUFrQixDQUF0QixFQUF5QjtBQUNyQix3QkFBWSxFQUFaO0FBQ0E7QUFDSDtBQUNKOzs7QUFHRCxRQUFJLFdBQVcsVUFBVSxNQUFWLEdBQW1CLENBQWxDO0FBQ0EsU0FBSyxJQUFJLE1BQUssVUFBVSxNQUFWLEdBQW1CLENBQWpDLEVBQW9DLE9BQU0sU0FBMUMsRUFBcUQsS0FBckQsRUFBMkQ7QUFDdkQsWUFBSSxVQUFVLEdBQVYsTUFBa0IsQ0FBdEIsRUFBeUI7QUFDckIsdUJBQVcsR0FBWDtBQUNBO0FBQ0g7QUFDSjs7QUFFRCxRQUFJLE9BQU8sT0FBTyxXQUFXLFNBQWxCLENBQVg7QUFDQSxRQUFJLE9BQU8sSUFBSSxLQUFKLENBQVUsVUFBVSxNQUFwQixDQUFYO0FBQ0EsUUFBSSxVQUFVLENBQWQ7QUFDQSxRQUFJLFVBQVUsQ0FBZDtBQUNBLFNBQUssSUFBSSxPQUFLLFNBQWQsRUFBeUIsT0FBSyxVQUFVLE1BQXhDLEVBQWdELE1BQWhELEVBQXNEO0FBQ2xELG1CQUFXLE9BQUssVUFBVSxJQUFWLENBQWhCO0FBQ0EsbUJBQVcsVUFBVSxJQUFWLENBQVg7QUFDQSxhQUFLLElBQUwsSUFBVyxVQUFVLE9BQXJCO0FBQ0g7O0FBRUQsUUFBSSxPQUFPLElBQUksS0FBSixDQUFVLFVBQVUsTUFBcEIsQ0FBWDtBQUNBLGNBQVUsVUFBVSxDQUFwQjtBQUNBLFNBQUssSUFBSSxPQUFLLFFBQWQsRUFBd0IsT0FBSyxDQUE3QixFQUFnQyxNQUFoQyxFQUFzQztBQUNsQyxtQkFBVyxPQUFLLFVBQVUsSUFBVixDQUFoQjtBQUNBLG1CQUFXLFVBQVUsSUFBVixDQUFYO0FBQ0EsYUFBSyxPQUFLLENBQVYsSUFBZSxVQUFXLE9BQTFCO0FBQ0g7OztBQUdELFFBQUksWUFBWSxDQUFDLENBQWpCO0FBQ0EsUUFBSSxVQUFVLE9BQU8sU0FBckI7QUFDQSxTQUFLLElBQUksS0FBSyxDQUFkLEVBQWlCLEtBQUssVUFBVSxNQUFoQyxFQUF3QyxJQUF4QyxFQUE4QztBQUMxQyxZQUFJLE1BQU0sQ0FBVjtBQUNBLFlBQUksYUFBSjtBQUNBLGFBQUssSUFBSSxPQUFLLENBQWQsRUFBaUIsUUFBTSxFQUF2QixFQUEyQixNQUEzQixFQUFpQzs7QUFFN0IsbUJBQU8sS0FBSyxJQUFJLE9BQU8sS0FBSyxHQUFMLENBQVMsT0FBSyxLQUFLLEVBQUwsQ0FBZCxDQUFoQixDQUFQO0FBQ0EsZ0JBQUksRUFBRyxPQUFRLEtBQVQsSUFBb0IsT0FBTyxRQUE3QixDQUFKLEVBQTZDOztBQUV6Qyx1QkFBTyxVQUFVLElBQVYsS0FBaUIsQ0FBQyxJQUFELEdBQVEsS0FBSyxHQUFMLENBQVUsSUFBVixDQUFSLEdBQTBCLENBQUMsSUFBSSxJQUFMLElBQWEsS0FBSyxHQUFMLENBQVUsSUFBSSxJQUFkLENBQXhELENBQVA7QUFDSDtBQUNKOztBQUVELGFBQUssSUFBSSxPQUFLLEtBQUssQ0FBbkIsRUFBc0IsT0FBSyxVQUFVLE1BQXJDLEVBQTZDLE1BQTdDLEVBQW1EOztBQUUvQyxtQkFBTyxLQUFLLElBQUksT0FBTyxLQUFLLEdBQUwsQ0FBVSxPQUFLLEtBQUssRUFBTCxDQUFmLENBQWhCLENBQVA7QUFDQSxnQkFBSSxFQUFHLE9BQVEsS0FBVCxJQUFvQixPQUFPLFFBQTdCLENBQUosRUFBNkM7O0FBRXpDLHVCQUFPLFVBQVUsSUFBVixLQUFpQixDQUFDLElBQUQsR0FBUSxLQUFLLEdBQUwsQ0FBVSxJQUFWLENBQVIsR0FBMEIsQ0FBQyxJQUFJLElBQUwsSUFBYSxLQUFLLEdBQUwsQ0FBUyxJQUFJLElBQWIsQ0FBeEQsQ0FBUDtBQUNIO0FBQ0o7O0FBRUQsWUFBSSxNQUFNLE9BQVYsRUFBbUI7QUFDZixzQkFBVSxHQUFWO0FBQ0Esd0JBQVksRUFBWjtBQUNIO0FBQ0o7QUFDRCxXQUFPLFNBQVA7QUFDSDs7Ozs7Ozs7a0JDbkV1QixVOzs7Ozs7Ozs7QUFBVCxTQUFTLFVBQVQsQ0FBb0IsU0FBcEIsRUFBK0I7QUFDMUMsUUFBSSxTQUFTLFVBQVUsS0FBVixFQUFiO0FBQ0EsUUFBSSxPQUFPLENBQVg7QUFDQSxXQUFPLENBQUMsWUFBWSxNQUFaLENBQVIsRUFBNkI7O0FBRXpCLFlBQUksV0FBVyxDQUFmO0FBQUEsWUFBa0IsVUFBVSxDQUE1QjtBQUFBLFlBQStCLE9BQU8sT0FBTyxDQUFQLENBQXRDO0FBQ0EsYUFBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLFVBQVUsTUFBVixHQUFtQixDQUF2QyxFQUEwQyxHQUExQyxFQUErQztBQUMzQyx1QkFBVyxPQUFYO0FBQ0Esc0JBQVUsSUFBVjtBQUNBLG1CQUFPLE9BQU8sSUFBSSxDQUFYLENBQVA7QUFDQSxtQkFBTyxDQUFQLElBQVksQ0FBQyxXQUFXLE9BQVgsR0FBcUIsSUFBdEIsSUFBOEIsQ0FBMUM7QUFDSDtBQUNELGVBQU8sVUFBVSxNQUFWLEdBQW1CLENBQTFCLElBQStCLENBQUMsVUFBVSxJQUFYLElBQW1CLENBQWxEO0FBQ0E7QUFDQSxZQUFJLE9BQU8sS0FBWCxFQUFrQjtBQUNkLGtCQUFNLElBQUksS0FBSixDQUFVLHVEQUFWLENBQU47QUFDSDtBQUNKOzs7QUFHRCxRQUFJLEtBQUssQ0FBVDtBQUNBLFNBQUssSUFBSSxLQUFJLENBQWIsRUFBZ0IsS0FBSSxVQUFVLE1BQVYsR0FBbUIsQ0FBdkMsRUFBMEMsSUFBMUMsRUFBK0M7QUFDM0MsWUFBSSxPQUFPLEtBQUksQ0FBWCxJQUFnQixPQUFPLEVBQVAsQ0FBaEIsSUFBNkIsT0FBTyxLQUFJLENBQVgsSUFBZ0IsT0FBTyxFQUFQLENBQWpELEVBQTREO0FBQ3hELGtCQUFNLEVBQU47QUFDSDtBQUNKO0FBQ0QsV0FBTyxLQUFLLEtBQUwsQ0FBVyxLQUFLLEdBQWhCLENBQVA7QUFDSDs7QUFFRCxTQUFTLFdBQVQsQ0FBcUIsTUFBckIsRUFBNkI7QUFDekIsUUFBSSxJQUFJLEtBQVI7QUFDQSxRQUFJLFFBQVEsQ0FBWjs7QUFFQSxTQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksT0FBTyxNQUFQLEdBQWdCLENBQXBDLEVBQXVDLEdBQXZDLEVBQTRDO0FBQ3hDLFlBQUksT0FBTyxJQUFJLENBQVgsSUFBZ0IsT0FBTyxDQUFQLENBQWhCLElBQTZCLE9BQU8sSUFBSSxDQUFYLElBQWdCLE9BQU8sQ0FBUCxDQUFqRCxFQUE0RDtBQUN4RDtBQUNBLGdCQUFJLFFBQVEsQ0FBWixFQUFlO0FBQ1gsdUJBQU8sS0FBUDtBQUNIO0FBQ0o7QUFDSjtBQUNELFFBQUksVUFBVSxDQUFkLEVBQWlCO0FBQ2IsWUFBSSxJQUFKO0FBQ0g7QUFDRCxXQUFPLENBQVA7QUFDSDs7Ozs7Ozs7a0JDL0N1QixPOzs7Ozs7O0FBQVQsU0FBUyxPQUFULENBQWlCLFNBQWpCLEVBQTRCOztBQUV2QyxRQUFJLFVBQUosQztBQUNBLFFBQUksYUFBSixDO0FBQ0EsUUFBSSxhQUFKLEM7QUFDQSxRQUFJLFVBQUosQztBQUNBLFFBQUksSUFBSSxDQUFSLEM7O0FBRUEsU0FBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLFVBQVUsTUFBOUIsRUFBc0MsR0FBdEMsRUFBMkM7QUFDdkMsWUFBSSxVQUFVLENBQVYsSUFBZSxDQUFuQixFQUFzQjtBQUNsQixnQkFBSSxJQUFJLENBQVI7QUFDQTtBQUNIO0FBQ0o7O0FBRUQsV0FBTyxJQUFQLEVBQWE7QUFDVCxZQUFJLENBQUo7QUFDQSxlQUFPLENBQVA7QUFDQSxhQUFLLElBQUksS0FBSSxDQUFiLEVBQWdCLEtBQUksQ0FBcEIsRUFBdUIsSUFBdkIsRUFBNEI7QUFDeEIsbUJBQU8sT0FBTyxVQUFVLEVBQVYsQ0FBZDtBQUNBLGdCQUFJLElBQUssVUFBVSxFQUFWLElBQWUsRUFBeEI7QUFDSDtBQUNELFlBQUksQ0FBSjtBQUNBLGVBQU8sQ0FBUDtBQUNBLGFBQUssSUFBSSxNQUFJLElBQUksQ0FBakIsRUFBb0IsTUFBSSxVQUFVLE1BQWxDLEVBQTBDLEtBQTFDLEVBQStDO0FBQzNDLG9CQUFRLFVBQVUsR0FBVixDQUFSO0FBQ0EsaUJBQU0sVUFBVSxHQUFWLElBQWUsR0FBckI7QUFDSDtBQUNELFlBQUksT0FBTyxDQUFQLElBQVksT0FBTyxDQUF2QixFQUEwQjtBQUN0QixpQkFBSyxJQUFMO0FBQ0EsaUJBQUssSUFBTDtBQUNBLGdCQUFJLE1BQU8sS0FBSyxLQUFMLENBQVcsQ0FBQyxJQUFJLENBQUwsSUFBVSxHQUFyQixDQUFYLEVBQ0k7QUFDUDtBQUNEO0FBQ0EsWUFBSSxJQUFJLFVBQVUsTUFBVixHQUFtQixDQUEzQixFQUE4QjtBQUMxQixrQkFBTSxJQUFJLEtBQUosQ0FBVSxxQkFBVixDQUFOO0FBQ0g7QUFDSjtBQUNELFdBQU8sQ0FBUDtBQUNIOzs7Ozs7OztrQkMvQnVCLEU7Ozs7Ozs7Ozs7Ozs7OztBQUFULFNBQVMsRUFBVCxDQUFZLFNBQVosRUFBdUIsS0FBdkIsRUFBOEI7O0FBRXpDLFFBQUksa0JBQUo7QUFDQSxRQUFJLGlCQUFKLEM7QUFDQSxRQUFJLGdCQUFKLEM7QUFDQSxRQUFJLGlCQUFKLEM7QUFDQSxRQUFJLGdCQUFKLEM7QUFDQSxRQUFJLG1CQUFKO0FBQ0EsUUFBSSxtQkFBSjtBQUNBLFFBQUksa0JBQUosQztBQUNBLFFBQUksaUJBQUosQztBQUNBLFFBQUksYUFBSixDO0FBQ0EsUUFBSSxrQkFBSixDO0FBQ0EsUUFBSSxhQUFKO0FBQ0EsZ0JBQVksR0FBWjs7O0FBR0EsV0FBTyxHQUFQO0FBQ0EsU0FBSyxJQUFJLEtBQUssQ0FBZCxFQUFpQixLQUFLLFVBQVUsTUFBaEMsRUFBd0MsSUFBeEMsRUFBOEM7QUFDMUMsZ0JBQVEsS0FBSyxVQUFVLEVBQVYsQ0FBYjtBQUNIOztBQUVELFlBQVEsS0FBUjs7QUFFQSxpQkFBYSxJQUFiOztBQUVBLE9BQUc7QUFDQyxxQkFBYSxVQUFiO0FBQ0Esb0JBQWEsYUFBYSxHQUFkLEdBQW1CLENBQS9CLEM7Ozs7QUFJQSxtQkFBVyxDQUFYO0FBQ0EsbUJBQVcsQ0FBWDs7QUFFQSxhQUFLLElBQUksTUFBSyxDQUFkLEVBQWlCLE9BQU0sU0FBdkIsRUFBa0MsS0FBbEMsRUFBd0M7QUFDcEMsd0JBQVksTUFBSyxVQUFVLEdBQVYsQ0FBakI7QUFDQSx3QkFBWSxVQUFVLEdBQVYsQ0FBWjtBQUNIO0FBQ0Qsb0JBQWEsYUFBYSxDQUFiLEdBQWlCLEdBQWpCLEdBQXdCLFdBQVcsUUFBaEQ7OztBQUdBLGtCQUFVLENBQVY7QUFDQSxrQkFBVSxDQUFWO0FBQ0EsYUFBSyxJQUFJLE9BQUssWUFBWSxDQUExQixFQUE2QixPQUFLLFVBQVUsTUFBNUMsRUFBb0QsTUFBcEQsRUFBMEQ7QUFDdEQsdUJBQVcsT0FBSyxVQUFVLElBQVYsQ0FBaEI7QUFDQSx1QkFBVyxVQUFVLElBQVYsQ0FBWDtBQUNIO0FBQ0QsbUJBQVksWUFBWSxDQUFaLEdBQWdCLEdBQWhCLEdBQXVCLFVBQVUsT0FBN0M7QUFDQSxlQUFPLENBQUMsWUFBWSxRQUFiLEtBQTBCLEtBQUssR0FBTCxDQUFTLFNBQVQsSUFBc0IsS0FBSyxHQUFMLENBQVMsUUFBVCxDQUFoRCxDQUFQOztBQUVBLFlBQUksT0FBTyxDQUFDLE9BQU8sT0FBbkIsRUFBNEI7QUFDeEIseUJBQWMsT0FBTyxHQUFSLEdBQWEsQ0FBMUI7QUFDSCxTQUZELE1BR0s7QUFDRCx5QkFBYyxPQUFPLEdBQVIsR0FBYSxDQUExQjtBQUNIOzs7QUFHSixLQWpDRCxRQWtDTyxLQUFLLEdBQUwsQ0FBUyxhQUFhLFVBQXRCLElBQW9DLFNBbEMzQzs7QUFvQ0EsV0FBTyxTQUFQO0FBQ0g7Ozs7Ozs7O2tCQ3JEdUIsSTs7QUF6QnhCOzs7O0FBRUE7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7Ozs7OztBQVFlLFNBQVMsSUFBVCxHQUtIO0FBQUEscUVBQUosRUFBSTs7QUFBQSw4QkFKUixTQUlRO0FBQUEsUUFKUixTQUlRLGtDQUpJLFdBSUo7QUFBQSw4QkFIUixTQUdRO0FBQUEsUUFIUixTQUdRLGtDQUhJLEdBR0o7QUFBQSw2QkFGUixRQUVRO0FBQUEsUUFGUixRQUVRLGlDQUZHLElBRUg7QUFBQSwyQkFEUixNQUNRO0FBQUEsUUFEUixNQUNRLCtCQURDLEtBQ0Q7OztBQUVSLFNBQUssZ0JBQUwsQ0FBc0IsTUFBdEIsRUFBOEI7QUFDMUIsb0JBQVksQ0FEYztBQUUxQixrQkFBVSxDQUFDLENBQUQsRUFBRyxFQUFIO0FBRmdCLEtBQTlCOztBQUtBLFFBQUksWUFBWSxLQUFLLFlBQUwsRUFBaEI7QUFDQSxZQUFRLFVBQVUsV0FBVixFQUFSO0FBQ0ksYUFBSyxXQUFMO0FBQ0ksd0JBQVksNkJBQWEsU0FBYixFQUF3QixLQUFLLFFBQTdCLENBQVo7QUFDQTtBQUNKLGFBQUssT0FBTDtBQUNJLHdCQUFZLHFCQUFNLFNBQU4sQ0FBWjtBQUNBO0FBQ0osYUFBSyxZQUFMO0FBQ0ksd0JBQVksMEJBQVcsU0FBWCxDQUFaO0FBQ0E7QUFDSixhQUFLLFNBQUw7QUFDSSx3QkFBWSx1QkFBUSxTQUFSLENBQVo7QUFDQTtBQUNKLGFBQUssSUFBTDtBQUNJLHdCQUFZLGtCQUFHLFNBQUgsRUFBYyxLQUFLLElBQW5CLENBQVo7QUFDQTtBQUNKLGFBQUssWUFBTDtBQUNJLHdCQUFZLDBCQUFXLFNBQVgsRUFBc0IsS0FBSyxJQUEzQixDQUFaO0FBQ0E7QUFDSixhQUFLLE1BQUw7QUFDSSx3QkFBWSxvQkFBSyxTQUFMLEVBQWdCLEtBQUssSUFBckIsQ0FBWjtBQUNBO0FBQ0osYUFBSyxVQUFMO0FBQ0ksd0JBQVksd0JBQVMsU0FBVCxFQUFvQixLQUFLLElBQXpCLENBQVo7QUFDQTtBQUNKLGFBQUssU0FBTDtBQUNJLHdCQUFZLHVCQUFRLFNBQVIsQ0FBWjtBQUNBO0FBQ0osYUFBSyxTQUFMO0FBQ0ksd0JBQVksdUJBQVEsU0FBUixFQUFtQixLQUFLLElBQXhCLENBQVo7QUFDQTtBQUNKLGFBQUssTUFBTDtBQUNJLHdCQUFZLG9CQUFLLFNBQUwsRUFBZ0IsS0FBSyxJQUFyQixDQUFaO0FBQ0E7QUFDSixhQUFLLFlBQUw7QUFDSSx3QkFBWSwwQkFBVyxTQUFYLENBQVo7QUFDQTtBQUNKLGFBQUssY0FBTDtBQUNJLHdCQUFZLDRCQUFhLFNBQWIsRUFBd0IsS0FBSyxJQUE3QixDQUFaO0FBQ0E7QUFDSixhQUFLLFVBQUw7QUFDSSx3QkFBWSx3QkFBUyxTQUFULEVBQW9CLEtBQUssSUFBekIsQ0FBWjtBQUNBO0FBQ0osYUFBSyxVQUFMO0FBQ0ksd0JBQVksd0JBQVMsU0FBVCxDQUFaO0FBQ0E7QUFDSixhQUFLLEtBQUw7QUFDSSx3QkFBWSxtQkFBSSxTQUFKLEVBQWUsS0FBSyxJQUFwQixDQUFaO0FBQ0E7QUFDSjtBQUNJLGtCQUFNLElBQUksS0FBSixDQUFVLHVDQUF1QyxTQUFqRCxDQUFOO0FBbERSOztBQXFEQSxRQUFJLFdBQVcsb0JBQVcsS0FBSyxLQUFoQixFQUF1QixLQUFLLE1BQTVCLEVBQW9DO0FBQy9DLGNBQU0sUUFEeUM7QUFFL0MsZ0JBQVE7QUFGdUMsS0FBcEMsQ0FBZjs7QUFLQSxRQUFJLE1BQU0sQ0FBVjtBQUNBLFFBQUksS0FBSyxLQUFMLElBQWMsUUFBbEIsRUFBNEI7QUFDeEIsYUFBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLEtBQUssSUFBTCxDQUFVLE1BQTlCLEVBQXNDLEtBQUssS0FBSyxRQUFoRCxFQUEwRDtBQUN0RCxnQkFBSSxRQUFRLEtBQUssSUFBTCxDQUFVLENBQVYsSUFBZSxDQUFDLEtBQUssUUFBTCxHQUFnQixLQUFLLElBQUwsQ0FBVSxDQUFWLENBQWpCLEtBQWtDLEtBQUssUUFBTCxHQUFnQixLQUFLLElBQUwsQ0FBVSxJQUFJLENBQWQsQ0FBbEQsSUFBc0UsS0FBSyxRQUF0RztBQUNBLGdCQUFLLFVBQVUsU0FBUyxTQUFwQixJQUFtQyxDQUFDLE1BQUQsSUFBVyxTQUFTLFNBQTNELEVBQXVFO0FBQ25FLHlCQUFTLE1BQVQsQ0FBZ0IsR0FBaEI7QUFDSDtBQUNEO0FBQ0g7QUFDSixLQVJELE1BUU87QUFDSCxhQUFLLElBQUksS0FBSSxDQUFiLEVBQWdCLEtBQUksS0FBSyxJQUFMLENBQVUsTUFBOUIsRUFBc0MsTUFBSyxLQUFLLFFBQWhELEVBQTBEO0FBQ3RELGdCQUFLLFVBQVUsS0FBSyxJQUFMLENBQVUsRUFBVixLQUFnQixTQUEzQixJQUEwQyxDQUFDLE1BQUQsSUFBVyxLQUFLLElBQUwsQ0FBVSxFQUFWLEtBQWdCLFNBQXpFLEVBQXFGO0FBQ2pGLHlCQUFTLE1BQVQsQ0FBZ0IsR0FBaEI7QUFDSDtBQUNEO0FBQ0g7QUFDSjtBQUNELFdBQU8sUUFBUDtBQUNIOzs7Ozs7OztrQkN4R3VCLFU7Ozs7Ozs7Ozs7O0FBQVQsU0FBUyxVQUFULENBQW9CLFNBQXBCLEVBQStCLEtBQS9CLEVBQXNDO0FBQ2pELFFBQUksYUFBYSxJQUFJLEtBQUosQ0FBVSxVQUFVLE1BQXBCLENBQWpCLEM7QUFDQSxTQUFLLElBQUksS0FBSyxDQUFkLEVBQWlCLEtBQUssVUFBVSxNQUFoQyxFQUF3QyxJQUF4QztBQUNJLG1CQUFXLEVBQVgsSUFBaUIsVUFBVSxFQUFWLElBQWdCLEtBQWpDO0FBREosS0FHQSxJQUFJLEtBQUssSUFBSSxLQUFKLENBQVUsVUFBVSxNQUFwQixDQUFULEM7QUFDQSxRQUFJLEtBQUssSUFBSSxLQUFKLENBQVUsVUFBVSxNQUFwQixDQUFUO0FBQ0EsT0FBRyxDQUFILElBQVEsV0FBVyxDQUFYLENBQVI7QUFDQSxPQUFHLENBQUgsSUFBUSxNQUFNLEdBQUcsQ0FBSCxDQUFkOztBQUVBLFNBQUssSUFBSSxNQUFLLENBQWQsRUFBaUIsTUFBSyxVQUFVLE1BQWhDLEVBQXdDLEtBQXhDLEVBQThDO0FBQzFDLFdBQUcsR0FBSCxJQUFTLEdBQUcsTUFBSyxDQUFSLElBQWEsV0FBVyxHQUFYLENBQXRCO0FBQ0EsV0FBRyxHQUFILElBQVMsTUFBTSxHQUFHLEdBQUgsQ0FBZjtBQUNIOzs7QUFHRCxRQUFJLFlBQVksQ0FBaEI7QUFDQSxTQUFLLElBQUksT0FBSyxDQUFkLEVBQWlCLE9BQUssVUFBVSxNQUFoQyxFQUF3QyxNQUF4QyxFQUE4QztBQUMxQyxZQUFJLEtBQUssR0FBTCxDQUFTLEdBQUcsSUFBSCxDQUFULEtBQW9CLE9BQU8sT0FBL0IsRUFBd0M7QUFDcEMsd0JBQVksSUFBWjtBQUNBO0FBQ0g7QUFDSjs7O0FBR0QsUUFBSSxXQUFXLFVBQVUsTUFBVixHQUFtQixDQUFsQztBQUNBLFNBQUssSUFBSSxPQUFLLFVBQVUsTUFBVixHQUFtQixDQUFqQyxFQUFvQyxRQUFNLFNBQTFDLEVBQXFELE1BQXJELEVBQTJEO0FBQ3ZELFlBQUksS0FBSyxHQUFMLENBQVMsR0FBRyxJQUFILENBQVQsS0FBb0IsT0FBTyxPQUEvQixFQUF3QztBQUNwQyx1QkFBVyxJQUFYO0FBQ0E7QUFDSDtBQUNKOzs7O0FBSUQsUUFBSSxZQUFZLENBQUMsQ0FBakI7QUFDQSxRQUFJLGdCQUFKLEM7QUFDQSxRQUFJLFVBQVUsT0FBTyxTQUFyQixDO0FBQ0EsUUFBSSxpQkFBSixDO0FBQ0EsUUFBSSxnQkFBSixDOztBQUVBLFNBQUssSUFBSSxLQUFLLFNBQWQsRUFBeUIsTUFBTSxRQUEvQixFQUF5QyxJQUF6QyxFQUErQzs7QUFFM0MsbUJBQVcsR0FBWDtBQUNBLGFBQUssSUFBSSxPQUFLLENBQWQsRUFBaUIsUUFBTSxFQUF2QixFQUEyQixNQUEzQixFQUFpQztBQUM3QixnQkFBSSxVQUFVLElBQVYsTUFBa0IsQ0FBdEIsRUFBeUI7QUFDckIsNEJBQWEsV0FBVyxJQUFYLElBQWlCLEdBQUcsRUFBSCxDQUFsQixHQUE0QixLQUFLLEdBQUwsQ0FBUyxXQUFXLElBQVgsSUFBaUIsR0FBRyxFQUFILENBQTFCLENBQXhDO0FBQ0g7QUFDSjs7O0FBR0Qsa0JBQVUsR0FBVjtBQUNBLGFBQUssSUFBSSxPQUFLLEtBQUssQ0FBbkIsRUFBc0IsT0FBSyxVQUFVLE1BQXJDLEVBQTZDLE1BQTdDLEVBQW1EO0FBQy9DLGdCQUFJLFVBQVUsSUFBVixNQUFrQixDQUF0QixFQUF5QjtBQUNyQiwyQkFBWSxXQUFXLElBQVgsSUFBaUIsR0FBRyxFQUFILENBQWxCLEdBQTRCLEtBQUssR0FBTCxDQUFTLFdBQVcsSUFBWCxJQUFpQixHQUFHLEVBQUgsQ0FBMUIsQ0FBdkM7QUFDSDtBQUNKOzs7QUFHRCxrQkFBVSxXQUFXLE9BQXJCOztBQUVBLFlBQUksVUFBVSxPQUFkLEVBQXVCO0FBQ25CLHNCQUFVLE9BQVY7QUFDQSx3QkFBWSxFQUFaO0FBQ0g7QUFDSjtBQUNELFdBQU8sU0FBUDtBQUNIOzs7Ozs7OztrQkNwRXVCLEk7Ozs7Ozs7Ozs7QUFBVCxTQUFTLElBQVQsQ0FBYyxTQUFkLEVBQXlCLEtBQXpCLEVBQWdDO0FBQzNDLFFBQUksTUFBTSxDQUFWO0FBQ0EsU0FBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLFVBQVUsTUFBOUIsRUFBc0MsR0FBdEMsRUFBMkM7QUFDdkMsZUFBTyxJQUFJLFVBQVUsQ0FBVixDQUFYO0FBQ0g7QUFDRCxXQUFPLEtBQUssS0FBTCxDQUFXLE1BQU0sS0FBakIsQ0FBUDtBQUNIOzs7Ozs7OztrQkNOdUIsUTs7Ozs7Ozs7OztBQUFULFNBQVMsUUFBVCxDQUFrQixTQUFsQixFQUE2QixLQUE3QixFQUFvQzs7QUFFL0MsUUFBSSxrQkFBSjtBQUNBLFFBQUksUUFBUSxDQUFDLENBQWI7QUFDQSxRQUFJLFdBQUo7QUFBQSxRQUFRLFdBQVI7QUFBQSxRQUFZLFVBQVo7QUFBQSxRQUFlLFVBQWY7QUFBQSxRQUFrQixlQUFsQjtBQUFBLFFBQTBCLGFBQTFCO0FBQUEsUUFBZ0MsV0FBaEM7QUFBQSxRQUFvQyxXQUFwQztBQUFBLFFBQXdDLFdBQXhDO0FBQUEsUUFBNEMsZUFBNUM7QUFBQSxRQUFvRCxhQUFwRDs7O0FBR0EsUUFBSSxPQUFPLEdBQVg7QUFDQSxTQUFLLElBQUksS0FBSyxDQUFkLEVBQWlCLEtBQUssVUFBVSxNQUFoQyxFQUF3QyxJQUF4QyxFQUE4QztBQUMxQyxnQkFBUSxLQUFLLFVBQVUsRUFBVixDQUFiO0FBQ0g7O0FBRUQsWUFBUSxLQUFSOztBQUVBLGdCQUFZLElBQVo7O0FBRUEsV0FBTyxjQUFjLEtBQXJCLEVBQTRCOztBQUV4QixZQUFJLFFBQVEsS0FBSyxTQUFMLEVBQWdCLFNBQWhCLENBQVo7QUFDQSxZQUFJLFFBQVEsS0FBSyxTQUFMLEVBQWdCLFVBQVUsTUFBVixHQUFtQixDQUFuQyxDQUFaO0FBQ0EsWUFBSSxRQUFRLEtBQUssU0FBTCxFQUFnQixTQUFoQixDQUFaO0FBQ0EsWUFBSSxRQUFRLEtBQUssU0FBTCxFQUFnQixVQUFVLE1BQVYsR0FBbUIsQ0FBbkMsQ0FBWjtBQUNBLFlBQUksUUFBUSxLQUFLLFNBQUwsRUFBZ0IsU0FBaEIsQ0FBWjtBQUNBLFlBQUksUUFBUSxLQUFLLFNBQUwsRUFBZ0IsVUFBVSxNQUFWLEdBQW1CLENBQW5DLENBQVo7O0FBRUEsYUFBSyxRQUFRLEtBQWI7QUFDQSxhQUFLLENBQUMsUUFBUSxLQUFULEtBQW1CLFFBQVEsS0FBM0IsQ0FBTDtBQUNBLFlBQUksUUFBUSxLQUFaO0FBQ0EsWUFBSSxDQUFDLFFBQVEsS0FBVCxJQUFrQixLQUF0QjtBQUNBLGlCQUFTLFFBQVEsS0FBUixHQUFpQixLQUFLLEVBQS9CO0FBQ0EsZUFBTyxDQUFDLFFBQVEsS0FBVCxLQUFtQixRQUFRLEtBQTNCLElBQXFDLEtBQUssRUFBakQ7OztBQUdBLGFBQUssTUFBTSxNQUFOLEdBQWUsTUFBTSxJQUExQjtBQUNBLGFBQUssS0FBSyxNQUFMLEdBQWMsS0FBSyxJQUF4QjtBQUNBLGFBQU0sS0FBSyxFQUFOLEdBQVksTUFBWixHQUFzQixLQUFLLEVBQU4sR0FBWSxJQUFqQyxHQUF3QyxLQUFLLEtBQUwsQ0FBWSxVQUFVLElBQUksQ0FBZCxDQUFELElBQXNCLFFBQVEsSUFBSSxDQUFaLENBQXRCLENBQVgsQ0FBN0M7OztBQUdBLGlCQUFVLEtBQUssRUFBTixHQUFZLEtBQUssRUFBMUI7QUFDQSxZQUFJLFNBQVMsQ0FBYixFQUFnQjtBQUNaLG1CQUFPLFNBQVA7QUFDSDs7O0FBR0QsZ0JBQVEsU0FBUjtBQUNBLGVBQU8sQ0FBQyxLQUFLLEtBQUssSUFBTCxDQUFVLE1BQVYsQ0FBTixJQUEyQixFQUFsQzs7QUFFQSxZQUFJLE1BQU0sSUFBTixDQUFKLEVBQWlCO0FBQ2Isd0JBQVksS0FBWjtBQUNILFNBRkQsTUFHSztBQUNELHdCQUFZLEtBQUssS0FBTCxDQUFXLElBQVgsQ0FBWjtBQUNIO0FBRUo7QUFDRCxXQUFPLFNBQVA7QUFDSDs7OztBQUlELFNBQVMsSUFBVCxDQUFjLENBQWQsRUFBaUIsQ0FBakIsRUFBb0I7QUFDaEIsUUFBSSxJQUFJLENBQVI7QUFDQSxTQUFLLElBQUksSUFBSSxDQUFiLEVBQWUsS0FBSyxDQUFwQixFQUF1QixHQUF2QixFQUE0QjtBQUN4QixhQUFLLEVBQUUsQ0FBRixDQUFMO0FBQ0g7QUFDRCxXQUFPLENBQVA7QUFDSDs7QUFFRCxTQUFTLElBQVQsQ0FBYyxDQUFkLEVBQWlCLENBQWpCLEVBQW9CO0FBQ2hCLFFBQUksSUFBSSxDQUFSO0FBQ0EsU0FBSyxJQUFJLElBQUksQ0FBYixFQUFnQixLQUFLLENBQXJCLEVBQXdCLEdBQXhCLEVBQTZCO0FBQ3pCLGFBQUssSUFBSSxFQUFFLENBQUYsQ0FBVDtBQUNIO0FBQ0QsV0FBTyxDQUFQO0FBQ0g7O0FBRUQsU0FBUyxJQUFULENBQWMsQ0FBZCxFQUFpQixDQUFqQixFQUFvQjtBQUNoQixRQUFJLElBQUksQ0FBUjtBQUNBLFNBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsS0FBSyxDQUFyQixFQUF3QixHQUF4QixFQUE2QjtBQUN6QixhQUFLLElBQUksQ0FBSixHQUFRLEVBQUUsQ0FBRixDQUFiO0FBQ0g7QUFDRCxXQUFPLENBQVA7QUFDSDs7Ozs7Ozs7a0JDcEZ1QixPOzs7Ozs7OztBQUFULFNBQVMsT0FBVCxDQUFpQixTQUFqQixFQUE0QjtBQUN2QyxRQUFJLFVBQVUsTUFBVixHQUFtQixDQUF2QixFQUEwQjs7QUFDdEIsZUFBTyxDQUFQO0FBQ0g7QUFDRCxRQUFJLGFBQWEsQ0FBakIsQztBQUNBLFFBQUksWUFBWSxDQUFDLENBQWpCO0FBQ0EsUUFBSSxNQUFNLENBQUMsQ0FBWCxDO0FBQ0EsUUFBSSxnQkFBZ0IsSUFBSSxLQUFKLENBQVUsVUFBVSxNQUFwQixDQUFwQixDO0FBQ0EsU0FBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLFVBQVUsTUFBOUIsRUFBc0MsR0FBdEMsRUFBMkM7QUFDdkMsc0JBQWMsQ0FBZCxJQUFtQixVQUFVLENBQVYsQ0FBbkI7QUFDQSxZQUFJLFVBQVUsQ0FBVixJQUFlLENBQW5CLEVBQXNCO0FBQ2xCLGtCQUFNLENBQU47QUFDSDtBQUNKO0FBQ0QsV0FBTyxDQUFDLFlBQVksYUFBWixDQUFSLEVBQW9DO0FBQ2hDLHdCQUFnQixTQUFTLGFBQVQsQ0FBaEI7QUFDQTtBQUNBLFlBQUksYUFBYSxLQUFqQixFQUF3Qjs7QUFDcEIsbUJBQU8sU0FBUDtBQUNIO0FBQ0o7QUFDRCxnQkFBWSxvQkFBb0IsYUFBcEIsRUFBbUMsR0FBbkMsQ0FBWjtBQUNBLFdBQU8sU0FBUDtBQUNIO0FBQ0QsU0FBUyxRQUFULENBQWtCLFNBQWxCLEVBQTZCOztBQUN6QixRQUFJLGNBQWMsSUFBSSxLQUFKLENBQVUsVUFBVSxNQUFwQixDQUFsQixDO0FBQ0EsU0FBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLFVBQVUsTUFBVixHQUFtQixDQUF2QyxFQUEwQyxHQUExQyxFQUErQztBQUMzQyxvQkFBWSxDQUFaLElBQWlCLENBQUMsVUFBVSxJQUFJLENBQWQsSUFBbUIsVUFBVSxDQUFWLENBQW5CLEdBQWtDLFVBQVUsSUFBSSxDQUFkLENBQW5DLElBQXVELENBQXhFO0FBQ0g7QUFDRCxnQkFBWSxDQUFaLElBQWlCLENBQUMsVUFBVSxDQUFWLElBQWUsVUFBVSxDQUFWLENBQWhCLElBQWdDLENBQWpEO0FBQ0EsZ0JBQVksVUFBVSxNQUFWLEdBQW1CLENBQS9CLElBQW9DLENBQUMsVUFBVSxVQUFVLE1BQVYsR0FBbUIsQ0FBN0IsSUFBa0MsVUFBVSxVQUFVLE1BQVYsR0FBbUIsQ0FBN0IsQ0FBbkMsSUFBc0UsQ0FBMUc7QUFDQSxXQUFPLFdBQVA7QUFDSDtBQUNELFNBQVMsbUJBQVQsQ0FBNkIsZ0JBQTdCLEVBQStDLEdBQS9DLEVBQW9EO0FBQ2hELFFBQUksa0JBQUo7QUFDQSxTQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksR0FBcEIsRUFBeUIsR0FBekIsRUFBOEI7QUFDMUIsWUFBSSxpQkFBaUIsSUFBSSxDQUFyQixJQUEwQixpQkFBaUIsQ0FBakIsQ0FBMUIsSUFBaUQsaUJBQWlCLElBQUksQ0FBckIsS0FBMkIsaUJBQWlCLENBQWpCLENBQWhGLEVBQXFHO0FBQ2pHLHdCQUFZLENBQVo7QUFDQTtBQUNIO0FBQ0o7QUFDRCxXQUFPLFNBQVA7QUFDSDtBQUNELFNBQVMsV0FBVCxDQUFxQixTQUFyQixFQUFnQzs7QUFDNUIsUUFBSSxNQUFNLFVBQVUsTUFBcEI7QUFDQSxRQUFJLFlBQVksS0FBaEI7QUFDQSxRQUFJLFFBQVEsQ0FBWjtBQUNBLFNBQUssSUFBSSxJQUFJLENBQWIsRUFBZSxJQUFJLE1BQU0sQ0FBekIsRUFBMkIsR0FBM0IsRUFBZ0M7QUFDNUIsWUFBSSxVQUFVLElBQUksQ0FBZCxJQUFtQixVQUFVLENBQVYsQ0FBbkIsSUFBbUMsVUFBVSxJQUFJLENBQWQsSUFBbUIsVUFBVSxDQUFWLENBQTFELEVBQXdFO0FBQ3BFO0FBQ0EsZ0JBQUksUUFBUSxDQUFaLEVBQ0ksT0FBTyxLQUFQO0FBQ1A7QUFDSjtBQUNELFFBQUksVUFBVSxDQUFkLEVBQ0ksWUFBWSxJQUFaO0FBQ0osV0FBTyxTQUFQO0FBQ0g7Ozs7Ozs7O2tCQ3hEdUIsTzs7Ozs7Ozs7O0FBQVQsU0FBUyxPQUFULENBQWlCLFNBQWpCLEVBQTJCLEtBQTNCLEVBQWtDOztBQUU3QyxRQUFJLEtBQUssR0FBVDtBQUNBLFFBQUksS0FBSyxHQUFUO0FBQ0EsUUFBSSxLQUFLLEdBQVQ7QUFDQSxRQUFJLEtBQUssR0FBVDtBQUNBLFFBQUksTUFBTSxHQUFWO0FBQ0EsUUFBSSxXQUFKO0FBQ0EsUUFBSSxXQUFKO0FBQUEsUUFBUSxXQUFSO0FBQUEsUUFBWSxXQUFaO0FBQUEsUUFBZ0IsV0FBaEI7QUFBQSxRQUFvQixXQUFwQixDO0FBQ0EsUUFBSSxZQUFZLENBQUMsQ0FBakI7QUFDQSxRQUFJLGtCQUFrQixVQUFVLE1BQWhDO0FBQ0EsUUFBSSxzQkFBc0IsSUFBSSxLQUFKLENBQVUsZUFBVixDQUExQjtBQUNBLFNBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxlQUFwQixFQUFxQyxHQUFyQyxFQUEwQztBQUN0Qyw0QkFBb0IsQ0FBcEIsSUFBeUIsVUFBVSxDQUFWLElBQWUsS0FBeEM7QUFDSDs7QUFFRCxTQUFLLElBQUksS0FBSSxDQUFiLEVBQWdCLEtBQUksZUFBcEIsRUFBcUMsSUFBckMsRUFBMEM7QUFDdEMsY0FBTSxLQUFJLG9CQUFvQixFQUFwQixDQUFWO0FBQ0EsY0FBTSxLQUFJLEVBQUosR0FBUSxvQkFBb0IsRUFBcEIsQ0FBZDtBQUNBLGNBQU0sS0FBSSxFQUFKLEdBQVEsRUFBUixHQUFZLG9CQUFvQixFQUFwQixDQUFsQjtBQUNIOzs7Ozs7QUFNRCxTQUFLLEtBQUssRUFBTCxHQUFVLEtBQUssRUFBcEIsQztBQUNBLFNBQUssQ0FBQyxDQUFDLEVBQUQsR0FBTSxFQUFOLEdBQVcsS0FBSyxFQUFqQixJQUF1QixFQUE1QjtBQUNBLFNBQUssQ0FBQyxLQUFLLENBQUMsRUFBTixHQUFXLEtBQUssRUFBakIsSUFBdUIsRUFBNUI7O0FBRUEsU0FBSyxPQUFPLENBQUMsRUFBRCxHQUFNLEtBQUssSUFBTCxDQUFXLEtBQUssRUFBTCxHQUFVLE1BQU0sRUFBM0IsQ0FBYixDQUFMO0FBQ0EsU0FBSyxPQUFPLENBQUMsRUFBRCxHQUFNLEtBQUssSUFBTCxDQUFXLEtBQUssRUFBTCxHQUFVLE1BQU0sRUFBM0IsQ0FBYixDQUFMO0FBQ0EsU0FBSyxDQUFDLEtBQUssRUFBTixLQUFhLEtBQUssRUFBbEIsQ0FBTCxDOztBQUVBLFNBQUssSUFBSSxNQUFJLENBQWIsRUFBZ0IsTUFBSSxlQUFwQixFQUFxQyxLQUFyQyxFQUEwQztBQUN0QyxlQUFPLG9CQUFvQixHQUFwQixDQUFQO0FBQ0EsWUFBSSxNQUFNLEVBQVYsRUFBYztBQUNWLHdCQUFZLEdBQVo7QUFDQTtBQUNIO0FBQ0o7QUFDRCxXQUFPLFNBQVA7QUFDSDtBQUNELFNBQVMsVUFBVCxDQUFvQixTQUFwQixFQUErQixNQUEvQixFQUF1Qzs7QUFDbkMsUUFBSSxNQUFNLENBQVY7QUFDQSxTQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLEtBQUssTUFBckIsRUFBNkIsR0FBN0IsRUFBa0M7QUFDOUIsZUFBTyxVQUFVLENBQVYsQ0FBUDtBQUNIO0FBQ0QsV0FBTyxHQUFQO0FBQ0g7Ozs7Ozs7O2tCQ2xEdUIsSTs7Ozs7Ozs7QUFBVCxTQUFTLElBQVQsQ0FBYyxTQUFkLEVBQXlCLEtBQXpCLEVBQWdDOztBQUUzQyxRQUFJLE1BQU0sQ0FBVixDO0FBQ0EsUUFBSSxPQUFPLENBQVgsQztBQUNBLFFBQUksS0FBSyxDQUFULEM7QUFDQSxRQUFJLEtBQUssQ0FBVCxDO0FBQ0EsUUFBSSxXQUFKLEM7QUFDQSxRQUFJLFdBQUosQztBQUNBLFFBQUksTUFBTSxHQUFWLEM7QUFDQSxRQUFJLFVBQVUsR0FBZCxDO0FBQ0EsUUFBSSxZQUFZLEdBQWhCOztBQUdBLFNBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxVQUFVLE1BQTlCLEVBQXNDLEVBQUUsQ0FBeEMsRUFBMkM7QUFDdkMsZUFBTyxJQUFJLFVBQVUsQ0FBVixDQUFYO0FBQ0g7O0FBRUQsU0FBSyxJQUFJLEtBQUksQ0FBYixFQUFnQixLQUFLLFVBQVUsTUFBL0IsRUFBdUMsRUFBRSxFQUF6QyxFQUE0QztBQUN4QyxjQUFNLFVBQVUsRUFBVixDQUFOOztBQUVBLFlBQUksT0FBTyxDQUFYLEVBQ0k7QUFDSixhQUFLLFFBQVEsRUFBYjtBQUNBLFlBQUksT0FBTyxDQUFYLEVBQ0k7O0FBRUosZ0JBQVEsS0FBSSxVQUFVLEVBQVYsQ0FBWjtBQUNBLGFBQUssT0FBTyxFQUFaO0FBQ0EsYUFBSyxDQUFDLE1BQU0sSUFBUCxJQUFlLEVBQXBCO0FBQ0Esa0JBQVUsS0FBSyxFQUFMLElBQVcsS0FBSyxFQUFoQixLQUF1QixLQUFLLEVBQTVCLENBQVY7O0FBRUEsWUFBSSxXQUFXLEdBQWYsRUFBb0I7QUFDaEIsd0JBQVksRUFBWjtBQUNBLGtCQUFNLE9BQU47QUFDSDtBQUNKO0FBQ0QsV0FBTyxTQUFQO0FBQ0g7Ozs7Ozs7O2tCQzVDdUIsVTtBQUFULFNBQVMsVUFBVCxDQUFvQixTQUFwQixFQUErQjs7Ozs7Ozs7O0FBUzFDLFFBQUksWUFBWSxDQUFDLENBQWpCO0FBQ0EsUUFBSSxhQUFhLEdBQWpCLEM7QUFDQSxRQUFJLE9BQU8sSUFBSSxLQUFKLENBQVUsVUFBVSxNQUFwQixDQUFYOztBQUVBLFFBQUksUUFBUSxXQUFXLFNBQVgsRUFBc0IsVUFBVSxNQUFWLEdBQW1CLENBQXpDLENBQVo7QUFDQSxRQUFJLE9BQU8sR0FBWDs7QUFFQSxTQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksVUFBVSxNQUE5QixFQUFzQyxHQUF0QyxFQUEyQztBQUN2QyxhQUFLLENBQUwsSUFBVSxLQUFLLEdBQUwsQ0FBVSxXQUFXLFNBQVgsRUFBc0IsQ0FBdEIsSUFBMkIsS0FBNUIsR0FBcUMsVUFBOUMsQ0FBVjtBQUNBLFlBQUksS0FBSyxDQUFMLElBQVUsSUFBZCxFQUFvQjtBQUNoQixtQkFBTyxLQUFLLENBQUwsQ0FBUDtBQUNBLHdCQUFZLENBQVo7QUFDSDtBQUNKOztBQUVELFdBQU8sU0FBUDtBQUNIOztBQUVELFNBQVMsVUFBVCxDQUFvQixTQUFwQixFQUErQixRQUEvQixFQUF5QztBQUNyQyxRQUFJLElBQUksQ0FBUjtBQUNBLFNBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsS0FBSyxRQUFyQixFQUErQixHQUEvQixFQUFvQztBQUNoQyxhQUFLLFVBQVUsQ0FBVixDQUFMO0FBQ0g7QUFDRCxXQUFPLENBQVA7QUFDSDs7Ozs7Ozs7a0JDekJ1QixZOzs7Ozs7Ozs7QUFBVCxTQUFTLFlBQVQsQ0FBc0IsU0FBdEIsRUFBaUMsS0FBakMsRUFBd0M7QUFDbkQsUUFBSSxzQkFBSixDO0FBQ0EsUUFBSSxrQkFBSixDO0FBQ0EsUUFBSSxpQkFBSixDOztBQUVBLFFBQUksYUFBYSxJQUFJLEtBQUosQ0FBVSxVQUFVLE1BQXBCLENBQWpCLEM7QUFDQSxRQUFJLEtBQUssSUFBSSxLQUFKLENBQVUsVUFBVSxNQUFwQixDQUFULEM7QUFDQSxRQUFJLEtBQUssSUFBSSxLQUFKLENBQVUsVUFBVSxNQUFwQixDQUFULEM7OztBQUdBLFFBQUksYUFBYSxDQUFqQjtBQUNBLFFBQUksYUFBYSxDQUFqQjtBQUNBLFFBQUksYUFBYSxDQUFqQjtBQUNBLFFBQUksV0FBVyxHQUFmO0FBQ0EsUUFBSSxXQUFXLEdBQWY7QUFDQSxRQUFJLFdBQVcsR0FBZjtBQUNBLFFBQUksU0FBUyxHQUFiO0FBQ0EsUUFBSSxRQUFRLE9BQU8sTUFBTSxNQUFiLENBQVo7QUFDQSxRQUFJLFNBQVMsR0FBYjtBQUNBLFFBQUksUUFBUSxPQUFPLE1BQU0sTUFBYixDQUFaOztBQUVBLFNBQUssSUFBSSxLQUFLLENBQWQsRUFBaUIsS0FBSyxVQUFVLE1BQWhDLEVBQXdDLElBQXhDO0FBQ0ksbUJBQVcsRUFBWCxJQUFpQixVQUFVLEVBQVYsSUFBZ0IsS0FBakM7QUFESixLQUdBLEdBQUcsQ0FBSCxJQUFRLFdBQVcsQ0FBWCxDQUFSO0FBQ0EsT0FBRyxDQUFILElBQVEsTUFBTSxHQUFHLENBQUgsQ0FBZDtBQUNBLFNBQUssSUFBSSxNQUFLLENBQWQsRUFBaUIsTUFBSyxVQUFVLE1BQWhDLEVBQXdDLEtBQXhDLEVBQThDO0FBQzFDLFdBQUcsR0FBSCxJQUFTLEdBQUcsTUFBSyxDQUFSLElBQWEsV0FBVyxHQUFYLENBQXRCO0FBQ0EsV0FBRyxHQUFILElBQVMsTUFBTSxHQUFHLEdBQUgsQ0FBZjtBQUNIOzs7QUFHRCxnQkFBWSxDQUFaO0FBQ0EsU0FBSyxJQUFJLE9BQUssQ0FBZCxFQUFpQixPQUFLLFVBQVUsTUFBaEMsRUFBd0MsTUFBeEMsRUFBOEM7QUFDMUMsWUFBSSxLQUFLLEdBQUwsQ0FBUyxHQUFHLElBQUgsQ0FBVCxLQUFvQixPQUFPLE9BQS9CLEVBQXdDO0FBQ3BDLHdCQUFZLElBQVo7QUFDQTtBQUNIO0FBQ0o7OztBQUdELGVBQVcsVUFBVSxNQUFWLEdBQW1CLENBQTlCO0FBQ0EsU0FBSyxJQUFJLE9BQUssVUFBVSxNQUFWLEdBQW1CLENBQWpDLEVBQW9DLFFBQU0sU0FBMUMsRUFBcUQsTUFBckQsRUFBMkQ7QUFDdkQsWUFBSSxLQUFLLEdBQUwsQ0FBUyxHQUFHLElBQUgsQ0FBVCxLQUFvQixPQUFPLE9BQS9CLEVBQXdDO0FBQ3BDLHVCQUFXLElBQVg7QUFDQTtBQUNIO0FBQ0o7Ozs7Ozs7QUFPRCxTQUFLLElBQUksS0FBSyxTQUFkLEVBQXlCLE1BQU0sUUFBL0IsRUFBeUMsSUFBekMsRUFBK0M7O0FBRTNDLFlBQUksWUFBWSxHQUFoQjtBQUNBLFlBQUksWUFBWSxHQUFoQjtBQUNBLFlBQUksWUFBWSxHQUFoQjtBQUNBLGFBQUssSUFBSSxPQUFLLENBQWQsRUFBaUIsUUFBTSxFQUF2QixFQUEyQixNQUEzQixFQUFpQztBQUM3QixnQkFBSSxVQUFVLElBQVYsTUFBa0IsQ0FBdEIsRUFBeUI7QUFDckIsNkJBQWMsV0FBVyxJQUFYLElBQWlCLEdBQUcsRUFBSCxDQUFsQixHQUE0QixLQUFLLEdBQUwsQ0FBUyxXQUFXLElBQVgsSUFBaUIsR0FBRyxFQUFILENBQTFCLENBQXpDO0FBQ0g7QUFDRCx5QkFBYSxLQUFLLElBQUwsQ0FBVSxXQUFXLElBQVgsSUFBaUIsR0FBRyxFQUFILENBQTNCLENBQWI7QUFDQSx5QkFBYyxXQUFXLElBQVgsSUFBaUIsV0FBVyxJQUFYLENBQWxCLElBQXFDLEdBQUcsRUFBSCxJQUFTLEdBQUcsRUFBSCxDQUE5QyxDQUFiO0FBQ0g7OztBQUdELFlBQUksV0FBVyxHQUFmO0FBQ0EsWUFBSSxXQUFXLEdBQWY7QUFDQSxZQUFJLFdBQVcsR0FBZjtBQUNBLGFBQUssSUFBSSxPQUFLLEtBQUssQ0FBbkIsRUFBc0IsT0FBSyxVQUFVLE1BQXJDLEVBQTZDLE1BQTdDLEVBQW1EO0FBQy9DLGdCQUFJLFVBQVUsSUFBVixNQUFrQixDQUF0QixFQUF5QjtBQUNyQiw0QkFBYSxXQUFXLElBQVgsSUFBaUIsR0FBRyxFQUFILENBQWxCLEdBQTRCLEtBQUssR0FBTCxDQUFTLFdBQVcsSUFBWCxJQUFpQixHQUFHLEVBQUgsQ0FBMUIsQ0FBeEM7QUFDSDtBQUNELHdCQUFZLEtBQUssSUFBTCxDQUFVLFdBQVcsSUFBWCxJQUFpQixHQUFHLEVBQUgsQ0FBM0IsQ0FBWjtBQUNBLHdCQUFhLFdBQVcsSUFBWCxJQUFpQixXQUFXLElBQVgsQ0FBbEIsSUFBcUMsR0FBRyxFQUFILElBQVMsR0FBRyxFQUFILENBQTlDLENBQVo7QUFDSDs7O0FBR0QsWUFBSSxXQUFXLFlBQVksUUFBM0I7QUFDQSxZQUFJLFdBQVcsU0FBVSxZQUFZLFFBQWIsR0FBeUIsR0FBekIsR0FBK0IsS0FBSyxHQUFMLENBQVMsWUFBWSxRQUFyQixDQUEvQixHQUFnRSxHQUF6RSxDQUFmO0FBQ0EsWUFBSSxXQUFXLFNBQVUsWUFBWSxRQUFiLEdBQXlCLEdBQXpCLEdBQStCLEtBQUssR0FBTCxDQUFTLFlBQVksUUFBckIsQ0FBL0IsR0FBZ0UsR0FBekUsQ0FBZjs7QUFFQSxZQUFJLFdBQVcsUUFBZixFQUF5QjtBQUNyQix1QkFBVyxRQUFYO0FBQ0EseUJBQWEsRUFBYjtBQUNIOztBQUVELFlBQUksV0FBVyxRQUFmLEVBQXlCO0FBQ3JCLHVCQUFXLFFBQVg7QUFDQSx5QkFBYSxFQUFiO0FBQ0g7O0FBRUQsWUFBSSxXQUFXLFFBQWYsRUFBeUI7QUFDckIsdUJBQVcsUUFBWDtBQUNBLHlCQUFhLEVBQWI7QUFDSDtBQUNKOzs7QUFHRCxRQUFJLFVBQVUsQ0FBQyxVQUFELEVBQWEsVUFBYixFQUF5QixVQUF6QixDQUFkO0FBQ0EsWUFBUSxJQUFSOztBQUVBLFFBQUksY0FBSjs7O0FBR0EsUUFBSSxLQUFLLEdBQUwsQ0FBUyxRQUFRLENBQVIsSUFBYSxRQUFRLENBQVIsQ0FBdEIsS0FBcUMsQ0FBekMsRUFBNEM7QUFDeEMsWUFBSSxLQUFLLEdBQUwsQ0FBUyxRQUFRLENBQVIsSUFBYSxRQUFRLENBQVIsQ0FBdEIsS0FBcUMsQ0FBekMsRUFBNEM7QUFDeEMsb0JBQVEsQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFPLENBQVAsQ0FBUjtBQUNILFNBRkQsTUFHSztBQUNELG9CQUFRLENBQUMsQ0FBRCxFQUFJLENBQUosRUFBTyxDQUFQLENBQVI7QUFDSDtBQUNKLEtBUEQsTUFRSztBQUNELFlBQUksS0FBSyxHQUFMLENBQVMsUUFBUSxDQUFSLElBQWEsUUFBUSxDQUFSLENBQXRCLEtBQXFDLENBQXpDLEVBQTRDO0FBQ3hDLG9CQUFRLENBQUMsQ0FBRCxFQUFJLENBQUosRUFBTyxDQUFQLENBQVI7QUFDSCxTQUZELE1BR0s7QUFDRCxvQkFBUSxDQUFDLENBQUQsRUFBSSxDQUFKLEVBQU8sQ0FBUCxDQUFSO0FBQ0g7QUFDSjs7O0FBR0QsUUFBSSxRQUFRLEdBQUcsUUFBUSxDQUFSLENBQUgsSUFBaUIsR0FBRyxRQUFRLENBQVIsQ0FBSCxDQUE3QjtBQUNBLG9CQUFnQixLQUFLLEtBQUwsQ0FBVyxRQUFRLENBQVIsS0FBYyxHQUFHLFFBQVEsQ0FBUixDQUFILElBQWlCLE9BQU8sS0FBUCxHQUFlLE1BQU0sQ0FBTixDQUE5QyxJQUEwRCxPQUFPLFFBQVEsQ0FBUixDQUFQLEdBQW9CLEtBQXBCLEdBQTRCLE1BQU0sQ0FBTixDQUF0RixHQUFpRyxRQUFRLENBQVIsS0FBYyxHQUFHLFFBQVEsQ0FBUixDQUFILElBQWlCLE9BQU8sS0FBUCxHQUFlLE1BQU0sQ0FBTixDQUE5QyxDQUE1RyxDQUFoQjs7QUFFQSxXQUFPLGFBQVA7QUFDSDs7Ozs7Ozs7a0JDcEl1QixROzs7Ozs7QUFBVCxTQUFTLFFBQVQsQ0FBa0IsU0FBbEIsRUFBNkIsS0FBN0IsRUFBb0M7QUFDL0MsUUFBSSxhQUFhLElBQUksS0FBSixDQUFVLFVBQVUsTUFBcEIsQ0FBakIsQztBQUNBLFNBQUssSUFBSSxLQUFLLENBQWQsRUFBaUIsS0FBSyxVQUFVLE1BQWhDLEVBQXdDLElBQXhDO0FBQ0ksbUJBQVcsRUFBWCxJQUFpQixVQUFVLEVBQVYsSUFBZ0IsS0FBakM7QUFESixLQUdBLElBQUksS0FBSyxJQUFJLEtBQUosQ0FBVSxVQUFVLE1BQXBCLENBQVQsQztBQUNBLFFBQUksS0FBSyxJQUFJLEtBQUosQ0FBVSxVQUFVLE1BQXBCLENBQVQ7QUFDQSxPQUFHLENBQUgsSUFBUSxXQUFXLENBQVgsQ0FBUjtBQUNBLE9BQUcsQ0FBSCxJQUFRLE1BQU0sR0FBRyxDQUFILENBQWQ7QUFDQSxTQUFLLElBQUksTUFBSyxDQUFkLEVBQWlCLE1BQUssVUFBVSxNQUFoQyxFQUF3QyxLQUF4QyxFQUE4QztBQUMxQyxXQUFHLEdBQUgsSUFBUyxHQUFHLE1BQUssQ0FBUixJQUFhLFdBQVcsR0FBWCxDQUF0QjtBQUNBLFdBQUcsR0FBSCxJQUFTLE1BQU0sR0FBRyxHQUFILENBQWY7QUFDSDs7O0FBR0QsUUFBSSxZQUFZLENBQWhCO0FBQ0EsU0FBSyxJQUFJLE9BQUssQ0FBZCxFQUFpQixPQUFLLFVBQVUsTUFBaEMsRUFBd0MsTUFBeEMsRUFBOEM7QUFDMUMsWUFBSSxLQUFLLEdBQUwsQ0FBUyxHQUFHLElBQUgsQ0FBVCxLQUFvQixPQUFPLE9BQS9CLEVBQXdDO0FBQ3BDLHdCQUFZLElBQVo7QUFDQTtBQUNIO0FBQ0o7OztBQUdELFFBQUksV0FBVyxVQUFVLE1BQVYsR0FBbUIsQ0FBbEM7QUFDQSxTQUFLLElBQUksT0FBSyxVQUFVLE1BQVYsR0FBbUIsQ0FBakMsRUFBb0MsUUFBTSxTQUExQyxFQUFxRCxNQUFyRCxFQUEyRDtBQUN2RCxZQUFJLEtBQUssR0FBTCxDQUFTLEdBQUcsSUFBSCxDQUFULEtBQW9CLE9BQU8sT0FBL0IsRUFBd0M7QUFDcEMsdUJBQVcsSUFBWDtBQUNBO0FBQ0g7QUFDSjs7OztBQUlELFFBQUksWUFBWSxDQUFDLENBQWpCO0FBQ0EsUUFBSSxVQUFVLE9BQU8sU0FBckIsQzs7QUFFQSxRQUFJLGFBQUo7QUFDQSxRQUFJLGdCQUFKLEM7QUFDQSxRQUFJLGlCQUFKLEM7QUFDQSxRQUFJLGdCQUFKLEM7QUFDQSxTQUFLLElBQUksS0FBSyxTQUFkLEVBQXlCLE1BQU0sUUFBL0IsRUFBeUMsSUFBekMsRUFBK0M7O0FBRTNDLG1CQUFXLEdBQVg7QUFDQSxlQUFPLE1BQU0sR0FBRyxFQUFILENBQWI7QUFDQSxhQUFLLElBQUksT0FBSyxDQUFkLEVBQWlCLFFBQU0sRUFBdkIsRUFBMkIsTUFBM0IsRUFBa0M7QUFDOUIsd0JBQVksV0FBVyxJQUFYLElBQWlCLEtBQUssR0FBTCxDQUFTLE1BQU0sT0FBTyxHQUFHLE9BQUssQ0FBUixDQUF0QixDQUE3QjtBQUNIO0FBQ0Qsb0JBQVksSUFBWjs7O0FBR0Esa0JBQVUsR0FBVjtBQUNBLGVBQU8sTUFBTSxHQUFHLEVBQUgsQ0FBYjtBQUNBLGFBQUssSUFBSSxPQUFLLEtBQUssQ0FBbkIsRUFBc0IsT0FBSyxVQUFVLE1BQXJDLEVBQTZDLE1BQTdDLEVBQW1EO0FBQy9DLHVCQUFXLFdBQVcsSUFBWCxJQUFpQixLQUFLLEdBQUwsQ0FBUyxNQUFNLE9BQU8sR0FBRyxJQUFILENBQXRCLENBQTVCO0FBQ0g7QUFDRCxtQkFBVyxJQUFYOzs7QUFHQSxrQkFBVSxLQUFLLEdBQUwsQ0FBUyxXQUFXLE9BQXBCLENBQVY7O0FBRUEsWUFBSSxVQUFVLE9BQWQsRUFBdUI7QUFDbkIsc0JBQVUsT0FBVjtBQUNBLHdCQUFZLEVBQVo7QUFDSDtBQUNKO0FBQ0QsV0FBTyxTQUFQO0FBQ0g7Ozs7Ozs7O2tCQ2pFdUIsUTs7Ozs7Ozs7QUFBVCxTQUFTLFFBQVQsQ0FBa0IsU0FBbEIsRUFBNkI7OztBQUd4QyxRQUFJLE1BQU0sQ0FBVjtBQUFBLFFBQWEsT0FBTyxDQUFwQjtBQUFBLFFBQXVCLE1BQU0sQ0FBN0I7QUFBQSxRQUFnQyxPQUFPLENBQXZDO0FBQ0EsU0FBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLFVBQVUsTUFBOUIsRUFBc0MsR0FBdEMsRUFBMkM7QUFDdkMsWUFBSSxVQUFVLENBQVYsSUFBZSxDQUFuQixFQUFzQjtBQUNsQixrQkFBTSxDQUFOO0FBQ0E7QUFDSDtBQUNKO0FBQ0QsUUFBSSxNQUFNLENBQVYsRUFBYSxNOzs7Ozs7O0FBT2IsU0FBSyxJQUFJLEtBQUksVUFBVSxNQUFWLEdBQW1CLENBQWhDLEVBQW1DLEtBQUksQ0FBdkMsRUFBMEMsSUFBMUMsRUFBK0M7QUFDM0MsWUFBSSxVQUFVLEVBQVYsSUFBZSxDQUFuQixFQUFzQjtBQUNsQixtQkFBTyxFQUFQO0FBQ0E7QUFDSDtBQUNKO0FBQ0QsUUFBSSxPQUFPLFVBQVUsTUFBVixHQUFtQixDQUE5QixFQUFpQyxPOztBQUVqQyxTQUFLLElBQUksTUFBSSxDQUFiLEVBQWdCLE1BQUksVUFBVSxNQUE5QixFQUFzQyxLQUF0QyxFQUEyQztBQUN2QyxZQUFJLFVBQVUsR0FBVixJQUFlLElBQW5CLEVBQXlCO0FBQ3JCLGtCQUFNLEdBQU47QUFDQSxtQkFBTyxVQUFVLEdBQVYsQ0FBUDtBQUNIO0FBQ0o7OztBQUdELFFBQUksV0FBVyxLQUFmO0FBQ0EsUUFBSyxNQUFNLEdBQVAsR0FBZSxPQUFPLEdBQTFCLEVBQWdDOztBQUU1QixtQkFBVyxJQUFYO0FBQ0EsWUFBSSxPQUFRLENBQVosQztBQUNBLFlBQUksUUFBUSxVQUFVLE1BQVYsR0FBbUIsQ0FBL0IsQztBQUNBLGVBQU8sT0FBTyxLQUFkLEVBQXFCOztBQUVqQixnQkFBSSxPQUFPLFVBQVUsSUFBVixDQUFYO0FBQ0Esc0JBQVUsSUFBVixJQUFtQixVQUFVLEtBQVYsQ0FBbkI7QUFDQSxzQkFBVSxLQUFWLElBQW1CLElBQW5COztBQUVBO0FBQ0E7QUFDSDtBQUNELGNBQU0sVUFBVSxNQUFWLEdBQW1CLENBQW5CLEdBQXVCLElBQTdCO0FBQ0EsY0FBTSxVQUFVLE1BQVYsR0FBbUIsQ0FBbkIsR0FBdUIsR0FBN0I7QUFDSDs7QUFFRCxRQUFJLFFBQVEsR0FBWixFQUNJLE9BQU8sR0FBUDs7O0FBR0osUUFBSSxXQUFKO0FBQUEsUUFBUSxXQUFSO0FBQUEsUUFBWSxVQUFaOztBQUVBLFNBQUssVUFBVSxHQUFWLENBQUwsQztBQUNBLFNBQUssTUFBTSxHQUFYO0FBQ0EsUUFBSSxLQUFLLElBQUwsQ0FBVSxLQUFLLEVBQUwsR0FBVSxLQUFLLEVBQXpCLENBQUo7QUFDQSxVQUFNLENBQU47QUFDQSxVQUFNLENBQU47QUFDQSxRQUFJLEtBQUssR0FBTCxHQUFXLEtBQUssVUFBVSxHQUFWLENBQXBCOzs7QUFHQSxRQUFJLFFBQVEsR0FBWjtBQUNBLFFBQUksZ0JBQWdCLENBQXBCO0FBQ0EsU0FBSyxJQUFJLE1BQUksTUFBTSxDQUFuQixFQUFzQixPQUFLLEdBQTNCLEVBQWdDLEtBQWhDLEVBQXFDO0FBQ2pDLFlBQUksY0FBYyxLQUFLLEdBQUwsR0FBUyxLQUFLLFVBQVUsR0FBVixDQUFkLEdBQTZCLENBQS9DO0FBQ0EsWUFBSSxjQUFjLGFBQWxCLEVBQWlDO0FBQzdCLG9CQUFRLEdBQVI7QUFDQSw0QkFBZ0IsV0FBaEI7QUFDSDtBQUNKO0FBQ0Q7O0FBRUEsUUFBSSxRQUFKLEVBQWM7O0FBRVYsWUFBSSxRQUFRLENBQVo7QUFDQSxZQUFJLFNBQVEsVUFBVSxNQUFWLEdBQW1CLENBQS9CO0FBQ0EsZUFBTyxRQUFPLE1BQWQsRUFBcUI7QUFDakIsZ0JBQUksUUFBTyxVQUFVLEtBQVYsQ0FBWDtBQUNBLHNCQUFVLEtBQVYsSUFBbUIsVUFBVSxNQUFWLENBQW5CO0FBQ0Esc0JBQVUsTUFBVixJQUFtQixLQUFuQjtBQUNBO0FBQ0E7QUFDSDtBQUNELGVBQVEsVUFBVSxNQUFWLEdBQW1CLENBQW5CLEdBQXVCLEtBQS9CO0FBQ0gsS0FaRCxNQWNJLE9BQU8sS0FBUDtBQUNQOzs7Ozs7OztrQkNyRnVCLEc7Ozs7Ozs7Ozs7Ozs7OztBQUFULFNBQVMsR0FBVCxDQUFhLFNBQWIsRUFBd0IsS0FBeEIsRUFBK0I7QUFDMUMsUUFBSSxhQUFhLElBQUksS0FBSixDQUFVLFVBQVUsTUFBcEIsQ0FBakIsQztBQUNBLFNBQUssSUFBSSxLQUFLLENBQWQsRUFBaUIsS0FBSyxVQUFVLE1BQWhDLEVBQXdDLElBQXhDO0FBQ0ksbUJBQVcsRUFBWCxJQUFpQixVQUFVLEVBQVYsSUFBZ0IsS0FBakM7QUFESixLQUdBLElBQUksS0FBSyxJQUFJLEtBQUosQ0FBVSxVQUFVLE1BQXBCLENBQVQsQztBQUNBLE9BQUcsQ0FBSCxJQUFRLFdBQVcsQ0FBWCxDQUFSO0FBQ0EsU0FBSyxJQUFJLE1BQUssQ0FBZCxFQUFpQixNQUFLLFVBQVUsTUFBaEMsRUFBd0MsS0FBeEM7QUFDSSxXQUFHLEdBQUgsSUFBUyxHQUFHLE1BQUssQ0FBUixJQUFhLFdBQVcsR0FBWCxDQUF0QjtBQURKLEtBR0EsSUFBSSxRQUFRLElBQUksS0FBSixDQUFVLFVBQVUsTUFBcEIsQ0FBWjtBQUNBLFVBQU0sQ0FBTixJQUFXLFdBQVcsQ0FBWCxJQUFnQixXQUFXLENBQVgsQ0FBM0I7QUFDQSxTQUFLLElBQUksT0FBSyxDQUFkLEVBQWlCLE9BQUssVUFBVSxNQUFoQyxFQUF3QyxNQUF4QztBQUNJLGNBQU0sSUFBTixJQUFZLE1BQU0sT0FBSyxDQUFYLElBQWdCLFdBQVcsSUFBWCxJQUFpQixXQUFXLElBQVgsQ0FBN0M7QUFESixLQUdBLElBQUksUUFBUSxJQUFJLEtBQUosQ0FBVSxVQUFVLE1BQXBCLENBQVo7QUFDQSxVQUFNLFVBQVUsTUFBVixHQUFtQixDQUF6QixJQUE4QixHQUE5QjtBQUNBLFNBQUssSUFBSSxPQUFLLFVBQVUsTUFBVixHQUFtQixDQUFqQyxFQUFvQyxRQUFNLENBQTFDLEVBQTZDLE1BQTdDO0FBQ0ksY0FBTSxJQUFOLElBQVksTUFBTSxPQUFLLENBQVgsSUFBZ0IsV0FBVyxPQUFLLENBQWhCLElBQXFCLFdBQVcsT0FBSyxDQUFoQixDQUFqRDtBQURKLEs7QUFJQSxRQUFJLFlBQVksQ0FBQyxDQUFqQjtBQUNBLFFBQUksV0FBVyxPQUFPLFNBQXRCO0FBQ0EsUUFBSSxhQUFKO0FBQ0EsU0FBSyxJQUFJLEtBQUssQ0FBZCxFQUFpQixLQUFLLFVBQVUsTUFBaEMsRUFBd0MsSUFBeEMsRUFBOEM7QUFDMUMsZUFBTyxDQUFDLEdBQUQsSUFBUyxNQUFNLEVBQU4sSUFBWSxNQUFNLEVBQU4sQ0FBYixHQUEwQixHQUExQixHQUFnQyxLQUFLLEdBQUwsQ0FBUyxNQUFNLEVBQU4sSUFBWSxNQUFNLEVBQU4sQ0FBckIsQ0FBaEMsR0FBa0UsR0FBMUUsSUFBaUYsS0FBTSxHQUFHLEVBQUgsS0FBVSxNQUFNLEdBQUcsRUFBSCxDQUFoQixDQUFELEdBQTRCLEdBQTVCLEdBQWtDLEtBQUssR0FBTCxDQUFTLEdBQUcsRUFBSCxLQUFVLE1BQU0sR0FBRyxFQUFILENBQWhCLENBQVQsQ0FBbEMsR0FBc0UsR0FBM0UsQ0FBeEY7QUFDQSxZQUFJLE9BQU8sUUFBWCxFQUFxQjtBQUNqQix1QkFBVyxJQUFYO0FBQ0Esd0JBQVksRUFBWjtBQUNIO0FBQ0o7QUFDRCxXQUFPLFNBQVA7QUFDSDs7Ozs7Ozs7a0JDekN1QixHOztBQUx4Qjs7OztBQUNBOzs7O0FBRUE7Ozs7OztBQUVlLFNBQVMsR0FBVCxHQUlIO0FBQUEscUVBQUosRUFBSTs7QUFBQSx5QkFIUixJQUdRO0FBQUEsUUFIUixJQUdRLDZCQUhELENBR0M7QUFBQSw4QkFGUixTQUVRO0FBQUEsUUFGUixTQUVRLGtDQUZJLE1BRUo7QUFBQSxRQURSLEtBQ1EsUUFEUixLQUNROzs7QUFFUixTQUFLLGdCQUFMLENBQXNCLEtBQXRCLEVBQTZCO0FBQ3pCLGtCQUFVLENBQUMsQ0FBRCxFQUFJLEVBQUo7QUFEZSxLQUE3Qjs7QUFJQSxRQUFJLGNBQWMsS0FBbEIsRUFBeUI7QUFDckIsWUFBSSxNQUFNLE1BQU4sS0FBaUIsS0FBSyxRQUExQixFQUFvQztBQUNoQyxrQkFBTSxJQUFJLEtBQUosQ0FBVSxxRkFBcUYsS0FBSyxRQUFwRyxDQUFOO0FBQ0g7QUFDRCxhQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksTUFBTSxNQUExQixFQUFrQyxHQUFsQyxFQUF1QztBQUNuQyxnQkFBSSxNQUFNLENBQU4sTUFBYSxDQUFqQixFQUFvQixNQUFNLENBQU4sSUFBVyxLQUFYO0FBQ3ZCO0FBQ0osS0FQRCxNQU9PO0FBQ0gsZ0JBQVEsd0JBQU0sS0FBSyxRQUFYLEVBQXFCLElBQXJCLENBQVI7QUFDSDs7QUFFRCxRQUFJLENBQUMsTUFBTSxPQUFOLENBQWMsSUFBZCxDQUFMLEVBQTBCO0FBQ3RCLGVBQU8sQ0FBQyxJQUFELEVBQU0sSUFBTixDQUFQO0FBQ0g7O0FBRUQsUUFBSSxXQUFXLEtBQUssS0FBTCxHQUFhLEtBQUssQ0FBTCxJQUFVLENBQXRDO0FBQ0EsUUFBSSxZQUFZLEtBQUssTUFBTCxHQUFjLEtBQUssQ0FBTCxJQUFVLENBQXhDO0FBQ0EsUUFBSSxXQUFXLEtBQUssUUFBcEI7O0FBRUEsUUFBSSxXQUFXLGdCQUFNLFVBQU4sQ0FBaUIsSUFBakIsRUFBdUIsRUFBQyxPQUFPLFFBQVIsRUFBa0IsUUFBUSxTQUExQixFQUF2QixDQUFmOztBQUVBLHdCQUFLLElBQUwsRUFBVyxRQUFYLEVBQXFCLEtBQUssQ0FBTCxDQUFyQixFQUE4QixLQUFLLENBQUwsQ0FBOUI7O0FBSUEsU0FBSyxJQUFJLEtBQUksS0FBSyxDQUFMLENBQWIsRUFBc0IsS0FBSSxXQUFXLEtBQUssQ0FBTCxDQUFyQyxFQUE4QyxJQUE5QyxFQUFtRDtBQUMvQyxhQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksUUFBcEIsRUFBOEIsR0FBOUIsRUFBbUM7QUFDL0IsZ0JBQUksUUFBUSxNQUFNLENBQU4sS0FBWSxTQUFTLElBQVQsQ0FBYyxDQUFDLEtBQUssQ0FBTCxJQUFVLFFBQVYsR0FBcUIsRUFBdEIsSUFBMkIsUUFBM0IsR0FBc0MsQ0FBcEQsQ0FBeEI7QUFDQSxpQkFBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLEtBQUssQ0FBTCxDQUFwQixFQUE2QixHQUE3QixFQUFrQztBQUM5Qix5QkFBUyxJQUFULENBQWMsQ0FBQyxJQUFJLFFBQUosR0FBZSxFQUFoQixJQUFxQixRQUFyQixHQUFnQyxDQUE5QyxJQUFtRCxLQUFuRDtBQUNIO0FBQ0Qsb0JBQVEsTUFBTSxDQUFOLEtBQVksU0FBUyxJQUFULENBQWMsQ0FBQyxDQUFDLFlBQVksS0FBSyxDQUFMLENBQVosR0FBc0IsQ0FBdkIsSUFBNEIsUUFBNUIsR0FBdUMsRUFBeEMsSUFBNkMsUUFBN0MsR0FBd0QsQ0FBdEUsQ0FBcEI7QUFDQSxpQkFBSyxJQUFJLEtBQUksWUFBWSxLQUFLLENBQUwsQ0FBekIsRUFBa0MsS0FBSSxTQUF0QyxFQUFpRCxJQUFqRCxFQUFzRDtBQUNsRCx5QkFBUyxJQUFULENBQWMsQ0FBQyxLQUFJLFFBQUosR0FBZSxFQUFoQixJQUFxQixRQUFyQixHQUFnQyxDQUE5QyxJQUFtRCxLQUFuRDtBQUNIO0FBQ0o7QUFDSjs7QUFFRCxTQUFLLElBQUksTUFBSSxDQUFiLEVBQWdCLE1BQUksU0FBcEIsRUFBK0IsS0FBL0IsRUFBb0M7QUFDaEMsYUFBSyxJQUFJLEtBQUksQ0FBYixFQUFnQixLQUFJLFFBQXBCLEVBQThCLElBQTlCLEVBQW1DO0FBQy9CLGdCQUFJLFNBQVEsTUFBTSxFQUFOLEtBQVksU0FBUyxJQUFULENBQWMsQ0FBQyxNQUFJLFFBQUosR0FBZSxLQUFLLENBQUwsQ0FBaEIsSUFBMkIsUUFBM0IsR0FBc0MsRUFBcEQsQ0FBeEI7QUFDQSxpQkFBSyxJQUFJLE1BQUksQ0FBYixFQUFnQixNQUFJLEtBQUssQ0FBTCxDQUFwQixFQUE2QixLQUE3QixFQUFrQztBQUM5Qix5QkFBUyxJQUFULENBQWMsQ0FBQyxNQUFJLFFBQUosR0FBZSxHQUFoQixJQUFxQixRQUFyQixHQUFnQyxFQUE5QyxJQUFtRCxNQUFuRDtBQUNIO0FBQ0QscUJBQVEsTUFBTSxFQUFOLEtBQVksU0FBUyxJQUFULENBQWMsQ0FBQyxNQUFJLFFBQUosR0FBZSxRQUFmLEdBQTBCLEtBQUssQ0FBTCxDQUExQixHQUFvQyxDQUFyQyxJQUEwQyxRQUExQyxHQUFxRCxFQUFuRSxDQUFwQjtBQUNBLGlCQUFLLElBQUksTUFBSSxXQUFXLEtBQUssQ0FBTCxDQUF4QixFQUFpQyxNQUFJLFFBQXJDLEVBQStDLEtBQS9DLEVBQW9EO0FBQ2hELHlCQUFTLElBQVQsQ0FBYyxDQUFDLE1BQUksUUFBSixHQUFlLEdBQWhCLElBQXFCLFFBQXJCLEdBQWdDLEVBQTlDLElBQW1ELE1BQW5EO0FBQ0g7QUFDSjtBQUNKOztBQUVELFdBQU8sUUFBUDtBQUNIOzs7Ozs7OztrQkM3RHVCLFk7O0FBTnhCOzs7O0FBQ0E7O0lBQVksUzs7Ozs7Ozs7O0FBS0csU0FBUyxZQUFULEdBQWlEO0FBQUEsUUFBM0IsS0FBMkIseURBQW5CLEdBQW1CO0FBQUEsUUFBZCxPQUFjLHlEQUFKLEVBQUk7O0FBQzVELFNBQUssZ0JBQUwsQ0FBc0IsY0FBdEIsRUFBc0M7QUFDbEMsa0JBQVUsQ0FBQyxDQUFEO0FBRHdCLEtBQXRDOztBQUlBLFFBQUksUUFBUSxLQUFLLEtBQUwsQ0FBVyxLQUFLLEtBQUwsR0FBYSxLQUF4QixDQUFaO0FBQ0EsUUFBSSxTQUFTLEtBQUssS0FBTCxDQUFXLEtBQUssTUFBTCxHQUFjLEtBQXpCLENBQWI7QUFDQSxRQUFJLFNBQVMsS0FBSyxLQUFMLENBQVcsQ0FBQyxLQUFLLEtBQUwsR0FBYSxLQUFkLElBQXVCLENBQWxDLENBQWI7QUFDQSxRQUFJLFNBQVMsS0FBSyxLQUFMLENBQVcsQ0FBQyxLQUFLLE1BQUwsR0FBYyxNQUFmLElBQXlCLENBQXBDLENBQWI7O0FBRUEsUUFBSSxXQUFXLGdCQUFNLFVBQU4sQ0FBaUIsSUFBakIsRUFBdUI7QUFDbEMsY0FBTSxVQUFVLE1BRGtCO0FBRWxDLGVBQU8sS0FGMkI7QUFHbEMsZ0JBQVEsTUFIMEI7QUFJbEMsa0JBQVUsQ0FBQyxNQUFELEVBQVMsTUFBVDtBQUp3QixLQUF2QixDQUFmOztBQU9BLFNBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxLQUFLLEtBQXpCLEVBQWdDLEdBQWhDLEVBQXFDO0FBQ2pDLGFBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxLQUFLLE1BQXpCLEVBQWlDLEdBQWpDLEVBQXNDO0FBQ2xDLGdCQUFJLEtBQUssUUFBTCxDQUFjLENBQWQsRUFBZ0IsQ0FBaEIsQ0FBSixFQUF3QjtBQUNwQix5QkFBUyxRQUFULENBQWtCLEtBQUssS0FBTCxDQUFXLElBQUksS0FBZixDQUFsQixFQUF5QyxLQUFLLEtBQUwsQ0FBVyxJQUFJLEtBQWYsQ0FBekM7QUFDSDtBQUNKO0FBQ0o7O0FBRUQsV0FBTyxRQUFQO0FBQ0g7Ozs7Ozs7O2tCQzdCdUIsSzs7QUFIeEI7Ozs7QUFDQTs7OztBQUVlLFNBQVMsS0FBVCxHQUFpQjs7QUFFNUIsUUFBSSxXQUFXLG9CQUFVLEtBQUssS0FBZixFQUFzQixLQUFLLE1BQTNCLEVBQW1DO0FBQzlDLGNBQUs7QUFEeUMsS0FBbkMsQ0FBZjs7QUFJQSxhQUFTLElBQVQsR0FBZ0IsS0FBSyxXQUFMLEVBQWhCO0FBQ0EsV0FBTyxRQUFQO0FBQ0g7Ozs7Ozs7O2tCQ1h1QixlO0FBQVQsU0FBUyxlQUFULENBQXlCLFFBQXpCLEVBQW1DLFFBQW5DLEVBQTZDLFNBQTdDLEVBQXdEO0FBQ25FLFFBQU0sU0FBUyxLQUFLLEtBQUwsR0FBYSxRQUE1QjtBQUNBLFFBQU0sU0FBUyxLQUFLLE1BQUwsR0FBYyxTQUE3QjtBQUNBLFNBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxRQUFwQixFQUE4QixHQUE5QixFQUFtQztBQUMvQixZQUFNLElBQUksS0FBSyxLQUFMLENBQVcsQ0FBQyxJQUFJLEdBQUwsSUFBWSxNQUF2QixDQUFWO0FBQ0EsYUFBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLFNBQXBCLEVBQStCLEdBQS9CLEVBQW9DO0FBQ2hDLGdCQUFNLElBQUksS0FBSyxLQUFMLENBQVcsQ0FBQyxJQUFJLEdBQUwsSUFBWSxNQUF2QixDQUFWO0FBQ0EsaUJBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxLQUFLLFFBQXpCLEVBQW1DLEdBQW5DLEVBQXdDO0FBQ3BDLHlCQUFTLFVBQVQsQ0FBb0IsQ0FBcEIsRUFBdUIsQ0FBdkIsRUFBMEIsQ0FBMUIsRUFBNkIsS0FBSyxVQUFMLENBQWdCLENBQWhCLEVBQW1CLENBQW5CLEVBQXNCLENBQXRCLENBQTdCO0FBQ0g7QUFDSjtBQUNKO0FBQ0o7Ozs7Ozs7O2tCQ1B1QixLOztBQUx4Qjs7OztBQUVBOzs7O0FBQ0E7Ozs7QUFFZSxTQUFTLEtBQVQsR0FLSDtBQUFBLHFFQUFKLEVBQUk7O0FBQUEsMEJBSlIsS0FJUTtBQUFBLFFBSlIsS0FJUSw4QkFKQSxLQUFLLEtBSUw7QUFBQSwyQkFIUixNQUdRO0FBQUEsUUFIUixNQUdRLCtCQUhDLEtBQUssTUFHTjtBQUFBLDJCQUZSLE1BRVE7QUFBQSxRQUZSLE1BRVEsK0JBRkMsQ0FFRDtBQUFBLDhCQURSLFNBQ1E7QUFBQSxRQURSLFNBQ1Esa0NBREksaUJBQ0o7O0FBQUEsNEJBRXFDLGlDQUFpQixNQUFqQixFQUF5QixLQUF6QixFQUFnQyxNQUFoQyxDQUZyQzs7QUFBQSxRQUVNLFFBRk4scUJBRUQsS0FGQztBQUFBLFFBRXdCLFNBRnhCLHFCQUVnQixNQUZoQjs7O0FBSVIsUUFBSSxXQUFXLGdCQUFNLFVBQU4sQ0FBaUIsSUFBakIsRUFBdUIsRUFBRSxPQUFPLFFBQVQsRUFBbUIsUUFBUSxTQUEzQixFQUF2QixDQUFmOztBQUVBLFlBQVEsVUFBVSxXQUFWLEVBQVI7QUFDSSxhQUFLLGlCQUFMO0FBQ0EsYUFBSyxrQkFBTDtBQUNJLHNDQUFnQixJQUFoQixDQUFxQixJQUFyQixFQUEyQixRQUEzQixFQUFxQyxRQUFyQyxFQUErQyxTQUEvQztBQUNBO0FBQ0o7QUFDSSxrQkFBTSxJQUFJLEtBQUosQ0FBVSxrQ0FBa0MsU0FBNUMsQ0FBTjtBQU5SOztBQVNBLFdBQU8sUUFBUDtBQUNIOzs7Ozs7OztrQkMxQnVCLFM7QUFBVCxTQUFTLFNBQVQsQ0FBbUIsU0FBbkIsRUFBOEIsT0FBOUIsRUFBdUMsQ0FBdkMsRUFBMEMsQ0FBMUMsRUFBNkM7QUFDeEQsUUFBSSxZQUFZLFVBQVUsS0FBMUI7QUFDQSxRQUFJLGFBQWEsVUFBVSxNQUEzQjtBQUNBLFFBQUksVUFBVSxRQUFRLEtBQXRCO0FBQ0EsUUFBSSxXQUFXLFFBQVEsTUFBdkI7QUFDQSxRQUFJLFdBQVcsVUFBVSxRQUF6QjtBQUNBLFNBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxTQUFwQixFQUErQixHQUEvQixFQUFvQztBQUNoQyxhQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksVUFBcEIsRUFBZ0MsR0FBaEMsRUFBcUM7QUFDakMsaUJBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxRQUFwQixFQUE4QixHQUE5QixFQUFtQztBQUMvQixvQkFBSSxTQUFTLENBQUMsSUFBSSxTQUFKLEdBQWdCLENBQWpCLElBQXNCLFFBQXRCLEdBQWlDLENBQTlDO0FBQ0Esb0JBQUksU0FBUyxDQUFDLENBQUMsSUFBSSxDQUFMLElBQVUsT0FBVixHQUFvQixDQUFwQixHQUF3QixDQUF6QixJQUE4QixRQUE5QixHQUF5QyxDQUF0RDtBQUNBLHdCQUFRLElBQVIsQ0FBYSxNQUFiLElBQXVCLFVBQVUsSUFBVixDQUFlLE1BQWYsQ0FBdkI7QUFDSDtBQUNKO0FBQ0o7QUFDSjs7Ozs7Ozs7a0JDVHVCLEs7O0FBTnhCOzs7O0FBQ0E7Ozs7QUFDQTs7Ozs7Ozs7QUFJZSxTQUFTLEtBQVQsQ0FBZSxLQUFmLEVBQXFDO0FBQUEscUVBQUosRUFBSTs7QUFBQSxRQUFkLE1BQWMsUUFBZCxNQUFjOzs7QUFHaEQsU0FBSyxnQkFBTCxDQUFzQixZQUF0QixFQUFvQztBQUNoQyxrQkFBVSxDQUFDLENBQUQsRUFBSSxFQUFKO0FBRHNCLEtBQXBDOztBQUlBLFFBQUksS0FBSyxRQUFMLEtBQWtCLE1BQU0sUUFBNUIsRUFBc0M7QUFDbEMsY0FBTSxJQUFJLEtBQUosQ0FBVSx5Q0FBVixDQUFOO0FBQ0g7QUFDRCxRQUFJLEtBQUssUUFBTCxLQUFrQixNQUFNLFFBQTVCLEVBQXNDO0FBQ2xDLGNBQU0sSUFBSSxLQUFKLENBQVUsbURBQVYsQ0FBTjtBQUNIO0FBQ0QsUUFBSSxLQUFLLFVBQUwsS0FBb0IsTUFBTSxVQUE5QixFQUEwQztBQUN0QyxjQUFNLElBQUksS0FBSixDQUFVLDJDQUFWLENBQU47QUFDSDs7O0FBR0QsUUFBSSxtQkFBbUIscUJBQVcsTUFBTSxLQUFqQixFQUF3QixNQUFNLE1BQTlCLEVBQXNDLENBQUMsUUFBdkMsQ0FBdkI7O0FBRUEsUUFBSSxXQUFXLEtBQUssS0FBTCxDQUFXLE1BQU0sS0FBTixHQUFjLENBQXpCLENBQWY7QUFDQSxRQUFJLFdBQVcsS0FBSyxLQUFMLENBQVcsTUFBTSxNQUFOLEdBQWUsQ0FBMUIsQ0FBZjtBQUNBLFFBQUksVUFBVSxRQUFkO0FBQ0EsUUFBSSxVQUFVLFFBQWQ7QUFDQSxRQUFJLFNBQVMsS0FBYjs7QUFFQSxXQUFPLENBQUMsTUFBUixFQUFnQjtBQUNaLFlBQUksdUJBQXVCLGlCQUFpQixXQUFqQixDQUE2QixRQUE3QixFQUF1QyxRQUF2QyxFQUFpRCxDQUFDLFFBQWxELENBQTNCO0FBQ0EsYUFBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLHFCQUFxQixNQUF6QyxFQUFpRCxHQUFqRCxFQUFzRDtBQUNsRCxnQkFBSSxXQUFXLHFCQUFxQixDQUFyQixDQUFmO0FBQ0EsZ0JBQUksYUFBYSxLQUFLLGFBQUwsQ0FBbUIsS0FBbkIsRUFBMEIsRUFBQyxRQUFRLE1BQVQsRUFBaUIsT0FBTyxDQUFDLFVBQVUsU0FBUyxDQUFULENBQVgsRUFBd0IsVUFBVSxTQUFTLENBQVQsQ0FBbEMsQ0FBeEIsRUFBMUIsQ0FBakI7QUFDQSw2QkFBaUIsU0FBUyxDQUFULENBQWpCLEVBQThCLFNBQVMsQ0FBVCxDQUE5QixJQUE2QyxVQUE3QztBQUNIOztBQUVELFlBQUksTUFBTSxpQkFBaUIsUUFBakIsQ0FBMEIsUUFBMUIsRUFBb0MsUUFBcEMsQ0FBVjtBQUNBLFlBQUksSUFBSSxRQUFKLENBQWEsQ0FBYixNQUFvQixRQUFwQixJQUFnQyxJQUFJLFFBQUosQ0FBYSxDQUFiLE1BQW9CLFFBQXhELEVBQWtFO0FBQzlELHVCQUFXLElBQUksUUFBSixDQUFhLENBQWIsQ0FBWDtBQUNBLHVCQUFXLElBQUksUUFBSixDQUFhLENBQWIsQ0FBWDtBQUNILFNBSEQsTUFHTztBQUNILHFCQUFTLElBQVQ7QUFDSDtBQUNKOzs7Ozs7Ozs7Ozs7O0FBZUQsV0FBTyxDQUFDLFdBQVcsT0FBWixFQUFxQixXQUFXLE9BQWhDLENBQVA7QUFDSDs7Ozs7Ozs7a0JDNUR1QixVOztBQUh4Qjs7OztBQUNBOzs7O0FBRWUsU0FBUyxVQUFULENBQW9CLE9BQXBCLEVBQTZCOztBQUV4QyxTQUFLLGdCQUFMLENBQXNCLFlBQXRCLEVBQW9DO0FBQ2hDLGtCQUFVLENBQUMsQ0FBRCxFQUFJLEVBQUo7QUFEc0IsS0FBcEM7O0FBSUEsY0FBVSw4QkFBZ0IsSUFBaEIsRUFBcUIsT0FBckIsQ0FBVjs7QUFHQSxRQUFJLFdBQVcsZ0JBQU0sVUFBTixDQUFpQixJQUFqQixFQUF1QjtBQUNsQyxvQkFBWSxDQURzQjtBQUVsQyxlQUFPLEtBRjJCO0FBR2xDLG9CQUFZO0FBSHNCLEtBQXZCLENBQWY7QUFLQSxRQUFJLE1BQU0sQ0FBVjtBQUNBLFNBQUssSUFBSSxJQUFJLE9BQWIsRUFBc0IsSUFBSSxLQUFLLElBQUwsQ0FBVSxNQUFwQyxFQUE0QyxLQUFLLEtBQUssUUFBdEQsRUFBZ0U7QUFDNUQsaUJBQVMsSUFBVCxDQUFjLEtBQWQsSUFBdUIsS0FBSyxJQUFMLENBQVUsQ0FBVixDQUF2QjtBQUNIOztBQUVELFdBQU8sUUFBUDtBQUNIOzs7Ozs7OztrQkNwQnVCLFM7O0FBSHhCOzs7O0FBQ0E7Ozs7QUFFZSxTQUFTLFNBQVQsQ0FBbUIsTUFBbkIsRUFBd0M7QUFBQSxRQUFiLE9BQWEseURBQUgsQ0FBRzs7O0FBRW5ELFNBQUssZ0JBQUwsQ0FBc0IsV0FBdEIsRUFBbUM7QUFDL0Isa0JBQVUsQ0FBQyxDQUFELEVBQUksRUFBSjtBQURxQixLQUFuQzs7QUFJQSxTQUFLLFdBQUwsQ0FBaUIsTUFBakI7QUFDQSxTQUFLLFlBQUwsQ0FBa0IsT0FBbEI7O0FBRUEsUUFBSSxRQUFRLElBQUksS0FBSixDQUFVLEtBQUssTUFBZixDQUFaO0FBQ0EsUUFBSSxNQUFNLENBQVY7QUFDQSxRQUFJLE9BQU8sS0FBSyxLQUFMLEdBQWEsS0FBSyxRQUE3QjtBQUNBLFNBQUssSUFBSSxJQUFJLFVBQVUsU0FBUyxLQUFLLFFBQXJDLEVBQStDLElBQUksS0FBSyxJQUFMLENBQVUsTUFBN0QsRUFBcUUsS0FBSyxJQUExRSxFQUFnRjtBQUM1RSxjQUFNLEtBQU4sSUFBZSxLQUFLLElBQUwsQ0FBVSxDQUFWLENBQWY7QUFDSDtBQUNELFdBQU8sS0FBUDtBQUNIOzs7Ozs7OztrQkNuQnVCLGE7QUFBVCxTQUFTLGFBQVQsR0FJSDtBQUFBLHFFQUFKLEVBQUk7O0FBQUEsNkJBSFIsUUFHUTtBQUFBLFFBSFIsUUFHUSxpQ0FIRyxDQUFDLEVBQUQsRUFBSSxFQUFKLENBR0g7QUFBQSw0QkFGUixPQUVRO0FBQUEsUUFGUixPQUVRLGdDQUZFLEtBRUY7QUFBQSxRQURSLElBQ1EsUUFEUixJQUNROzs7QUFFUixTQUFLLGdCQUFMLENBQXNCLGVBQXRCLEVBQXVDO0FBQ25DLGtCQUFVLENBQUMsQ0FBRCxFQUFJLEVBQUosQ0FEeUI7QUFFbkMsa0JBQVU7QUFGeUIsS0FBdkM7O0FBS0EsUUFBSSxDQUFDLE1BQU0sT0FBTixDQUFjLFFBQWQsQ0FBTCxFQUE4QixXQUFXLENBQUMsUUFBRCxFQUFVLFFBQVYsQ0FBWDs7QUFFOUIsUUFBTSxZQUFZLFNBQVMsQ0FBVCxDQUFsQjtBQUNBLFFBQU0sWUFBWSxTQUFTLENBQVQsQ0FBbEI7QUFDQSxRQUFNLFlBQVksWUFBWSxTQUE5Qjs7QUFFQSxRQUFNLE1BQU0sSUFBSSxLQUFKLENBQVUsU0FBVixDQUFaO0FBQ0EsUUFBTSxLQUFLLElBQUksS0FBSixDQUFVLFNBQVYsQ0FBWDs7QUFFQSxRQUFNLFFBQVEsS0FBSyxLQUFMLEdBQWEsU0FBM0I7QUFDQSxRQUFNLFFBQVEsS0FBSyxNQUFMLEdBQWMsU0FBNUI7QUFDQSxRQUFJLFdBQVcsS0FBSyxLQUFMLENBQVcsUUFBUSxDQUFuQixDQUFmOztBQUVBLFFBQUksV0FBVyxDQUFmO0FBQ0EsU0FBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLFNBQXBCLEVBQStCLEdBQS9CLEVBQW9DO0FBQ2hDLFlBQUksV0FBVyxLQUFLLEtBQUwsQ0FBVyxRQUFRLENBQW5CLENBQWY7QUFDQSxhQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksU0FBcEIsRUFBK0IsR0FBL0IsRUFBb0M7QUFDaEMsZ0JBQUksSUFBSSxLQUFLLEtBQUwsQ0FBVyxRQUFYLENBQVI7QUFDQSxnQkFBSSxJQUFJLEtBQUssS0FBTCxDQUFXLFFBQVgsQ0FBUjtBQUNBLGdCQUFJLENBQUMsSUFBRCxJQUFTLEtBQUssUUFBTCxDQUFjLENBQWQsRUFBZ0IsQ0FBaEIsQ0FBYixFQUFpQztBQUM3QixvQkFBSSxRQUFKLElBQWdCLENBQUMsQ0FBRCxFQUFHLENBQUgsQ0FBaEI7QUFDQSxtQkFBRyxRQUFILElBQWUsS0FBSyxVQUFMLENBQWdCLENBQWhCLEVBQW1CLENBQW5CLENBQWY7QUFDQTtBQUNIO0FBQ0Qsd0JBQVksS0FBWjtBQUNIO0FBQ0Qsb0JBQVksS0FBWjtBQUNIOzs7QUFHRCxRQUFJLE1BQUosR0FBYSxRQUFiO0FBQ0EsT0FBRyxNQUFILEdBQVksUUFBWjs7QUFFQSxRQUFJLFdBQVcsRUFBQyxRQUFELEVBQU0sTUFBTixFQUFmOztBQUVBLFFBQUksT0FBSixFQUFhO0FBQ1QsaUJBQVMsT0FBVCxHQUFtQixLQUFLLEtBQUwsR0FBYSxXQUFiLENBQXlCLEdBQXpCLENBQW5CO0FBQ0g7O0FBRUQsV0FBTyxRQUFQO0FBQ0g7Ozs7Ozs7O2tCQ2hEdUIsTTs7QUFIeEI7Ozs7QUFDQTs7OztBQUVlLFNBQVMsTUFBVCxDQUFnQixHQUFoQixFQUFrQztBQUFBLFFBQWIsT0FBYSx5REFBSCxDQUFHOzs7QUFFN0MsU0FBSyxnQkFBTCxDQUFzQixRQUF0QixFQUFnQztBQUM1QixrQkFBVSxDQUFDLENBQUQsRUFBSSxFQUFKO0FBRGtCLEtBQWhDOztBQUlBLFNBQUssUUFBTCxDQUFjLEdBQWQ7QUFDQSxTQUFLLFlBQUwsQ0FBa0IsT0FBbEI7O0FBR0EsUUFBSSxRQUFRLElBQUksS0FBSixDQUFVLEtBQUssS0FBZixDQUFaO0FBQ0EsUUFBSSxNQUFNLENBQVY7QUFDQSxRQUFJLFFBQVEsTUFBTSxLQUFLLEtBQVgsR0FBbUIsS0FBSyxRQUF4QixHQUFtQyxPQUEvQztBQUNBLFFBQUksTUFBTSxRQUFRLEtBQUssS0FBTCxHQUFhLEtBQUssUUFBcEM7QUFDQSxTQUFLLElBQUksSUFBSSxLQUFiLEVBQW9CLElBQUksR0FBeEIsRUFBNkIsS0FBSyxLQUFLLFFBQXZDLEVBQWlEO0FBQzdDLGNBQU0sS0FBTixJQUFlLEtBQUssSUFBTCxDQUFVLENBQVYsQ0FBZjtBQUNIOztBQUVELFdBQU8sS0FBUDtBQUNIOzs7Ozs7OztrQkNkdUIsYTs7QUFSeEI7Ozs7QUFDQTs7QUFDQTs7Ozs7Ozs7OztBQU1lLFNBQVMsYUFBVCxDQUF1QixLQUF2QixFQUFnSDtBQUFBLHFFQUFKLEVBQUk7O0FBQUEsMEJBQWpGLEtBQWlGO0FBQUEsUUFBakYsS0FBaUYsOEJBQXpFLENBQUMsQ0FBRCxFQUFHLENBQUgsQ0FBeUU7QUFBQSxRQUFsRSxPQUFrRSxRQUFsRSxPQUFrRTtBQUFBLFFBQXpELFFBQXlELFFBQXpELFFBQXlEO0FBQUEsUUFBL0MsWUFBK0MsUUFBL0MsWUFBK0M7QUFBQSxRQUFqQyxTQUFpQyxRQUFqQyxTQUFpQztBQUFBLDJCQUF0QixNQUFzQjtBQUFBLFFBQXRCLE1BQXNCLCtCQUFiLENBQUMsQ0FBRCxFQUFHLENBQUgsQ0FBYTs7O0FBRTNILFNBQUssZ0JBQUwsQ0FBc0IsZUFBdEIsRUFBdUM7QUFDbkMsa0JBQVUsQ0FBQyxDQUFELEVBQUksRUFBSjtBQUR5QixLQUF2Qzs7QUFJQSxRQUFJLENBQUMsTUFBTSxPQUFOLENBQWMsTUFBZCxDQUFMLEVBQTRCLFNBQVMsQ0FBQyxNQUFELEVBQVMsTUFBVCxDQUFUO0FBQzVCLGVBQVcsc0NBQXdCLElBQXhCLEVBQThCLEVBQUMsVUFBUyxRQUFWLEVBQW9CLGNBQWEsWUFBakMsRUFBOUIsQ0FBWDs7QUFFQSxRQUFJLEtBQUssUUFBTCxLQUFrQixNQUFNLFFBQTVCLEVBQXNDO0FBQ2xDLGNBQU0sSUFBSSxLQUFKLENBQVUseUNBQVYsQ0FBTjtBQUNIO0FBQ0QsUUFBSSxLQUFLLFFBQUwsS0FBa0IsTUFBTSxRQUE1QixFQUFzQztBQUNsQyxjQUFNLElBQUksS0FBSixDQUFVLG1EQUFWLENBQU47QUFDSDtBQUNELFFBQUksS0FBSyxVQUFMLEtBQW9CLE1BQU0sVUFBOUIsRUFBMEM7QUFDdEMsY0FBTSxJQUFJLEtBQUosQ0FBVSwyQ0FBVixDQUFOO0FBQ0g7O0FBRUQsUUFBSSxPQUFPLE9BQVAsS0FBbUIsV0FBdkIsRUFBb0MsVUFBVSxJQUFWOzs7O0FBSXBDLFFBQUksT0FBTyxLQUFLLEdBQUwsQ0FBUyxPQUFPLENBQVAsQ0FBVCxFQUFvQixDQUFDLE1BQU0sQ0FBTixDQUFyQixDQUFYO0FBQ0EsUUFBSSxPQUFPLEtBQUssR0FBTCxDQUFTLEtBQUssS0FBTCxHQUFhLE9BQU8sQ0FBUCxDQUF0QixFQUFpQyxLQUFLLEtBQUwsR0FBYSxNQUFNLENBQU4sQ0FBOUMsQ0FBWDtBQUNBLFFBQUksT0FBTyxLQUFLLEdBQUwsQ0FBUyxPQUFPLENBQVAsQ0FBVCxFQUFvQixDQUFDLE1BQU0sQ0FBTixDQUFyQixDQUFYO0FBQ0EsUUFBSSxPQUFPLEtBQUssR0FBTCxDQUFTLEtBQUssTUFBTCxHQUFjLE9BQU8sQ0FBUCxDQUF2QixFQUFrQyxLQUFLLE1BQUwsR0FBYyxNQUFNLENBQU4sQ0FBaEQsQ0FBWDs7QUFFQSxRQUFJLFVBQVUsd0JBQVMsU0FBUyxNQUFsQixFQUF5QixDQUF6QixDQUFkO0FBQ0EsU0FBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLFNBQVMsTUFBN0IsRUFBcUMsR0FBckMsRUFBMEM7QUFDdEMsWUFBSSxJQUFJLFNBQVMsQ0FBVCxDQUFSO0FBQ0EsWUFBSSxVQUFVLFlBQVksS0FBSyxHQUFMLENBQVMsQ0FBVCxDQUFaLEdBQTBCLEtBQUssR0FBTCxDQUFTLEtBQUssR0FBTCxDQUFTLENBQVQsQ0FBVCxFQUFzQixNQUFNLEdBQU4sQ0FBVSxDQUFWLENBQXRCLENBQXhDO0FBQ0EsWUFBSSxXQUFXLFlBQVksTUFBTSxHQUFOLENBQVUsQ0FBVixDQUFaLEdBQTJCLEtBQUssR0FBTCxDQUFTLEtBQUssR0FBTCxDQUFTLENBQVQsQ0FBVCxFQUFzQixNQUFNLEdBQU4sQ0FBVSxDQUFWLENBQXRCLENBQTFDOztBQUVBLFlBQUksWUFBWSxDQUFaLElBQWlCLGFBQWEsQ0FBbEMsRUFBcUM7QUFDakMsaUJBQUssSUFBSSxJQUFJLElBQWIsRUFBbUIsSUFBSSxJQUF2QixFQUE2QixHQUE3QixFQUFrQztBQUM5QixxQkFBSyxJQUFJLElBQUksSUFBYixFQUFtQixJQUFJLElBQXZCLEVBQTZCLEdBQTdCLEVBQWtDO0FBQzlCLHdCQUFJLFlBQVksSUFBSSxLQUFLLFdBQVQsR0FBdUIsSUFBSSxLQUFLLFdBQWhDLEdBQThDLENBQTlEO0FBQ0Esd0JBQUksYUFBYSxZQUFZLE1BQU0sQ0FBTixJQUFXLEtBQUssV0FBNUIsR0FBMEMsTUFBTSxDQUFOLElBQVcsS0FBSyxXQUEzRTtBQUNBLDRCQUFRLENBQVIsS0FBYyxLQUFLLEdBQUwsQ0FBUyxLQUFLLElBQUwsQ0FBVSxTQUFWLElBQXVCLE9BQWhDLEVBQXlDLE1BQU0sSUFBTixDQUFXLFVBQVgsSUFBeUIsUUFBbEUsQ0FBZDtBQUNIO0FBQ0o7QUFDSjtBQUNKOztBQUVELFFBQUksT0FBSixFQUFhO0FBQ1QsZUFBTyxRQUFRLE1BQVIsQ0FBZSxDQUFDLEdBQUQsRUFBTSxDQUFOLEtBQVksTUFBTSxDQUFqQyxJQUFzQyxRQUFRLE1BQXJEO0FBQ0g7QUFDRCxXQUFPLE9BQVA7QUFDSDs7Ozs7Ozs7a0JDbkR1QixTOztBQU54Qjs7OztBQUNBOzs7Ozs7Ozs7QUFLZSxTQUFTLFNBQVQsR0FJSDtBQUFBLHFFQUFKLEVBQUk7O0FBQUEseUJBSFIsSUFHUTtBQUFBLFFBSFIsSUFHUSw2QkFIRCxDQUdDO0FBQUEsOEJBRlIsU0FFUTtBQUFBLFFBRlIsU0FFUSxrQ0FGSSxNQUVKO0FBQUEsUUFEUixLQUNRLFFBRFIsS0FDUTs7O0FBRVIsU0FBSyxnQkFBTCxDQUFzQixXQUF0QixFQUFtQztBQUMvQixrQkFBVSxDQUFDLENBQUQsRUFBSSxFQUFKLEVBQVEsRUFBUixFQUFZLEVBQVo7QUFEcUIsS0FBbkM7O0FBSUEsUUFBSSxjQUFjLEtBQWxCLEVBQXlCO0FBQ3JCLFlBQUksTUFBTSxNQUFOLEtBQWlCLEtBQUssUUFBMUIsRUFBb0M7QUFDaEMsa0JBQU0sSUFBSSxLQUFKLENBQVUsMkZBQTJGLEtBQUssUUFBMUcsQ0FBTjtBQUNIO0FBQ0QsYUFBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLE1BQU0sTUFBMUIsRUFBa0MsR0FBbEMsRUFBdUM7QUFDbkMsZ0JBQUksTUFBTSxDQUFOLE1BQWEsQ0FBakIsRUFBb0IsTUFBTSxDQUFOLElBQVcsS0FBWDtBQUN2QjtBQUNKLEtBUEQsTUFPTztBQUNILGdCQUFRLHdCQUFNLEtBQUssUUFBWCxFQUFxQixJQUFyQixDQUFSO0FBQ0g7O0FBRUQsUUFBSSxDQUFDLE1BQU0sT0FBTixDQUFjLElBQWQsQ0FBTCxFQUEwQjtBQUN0QixlQUFPLENBQUMsSUFBRCxFQUFNLElBQU4sQ0FBUDtBQUNIOztBQUdELFFBQUksZ0JBQWdCLEtBQUssQ0FBTCxDQUFwQjtBQUNBLFFBQUksZ0JBQWdCLEtBQUssQ0FBTCxDQUFwQjtBQUNBLFFBQUksV0FBVyxLQUFLLFFBQXBCOztBQUlBLFNBQUssSUFBSSxLQUFJLGFBQWIsRUFBNEIsS0FBSSxLQUFLLEtBQUwsR0FBYSxhQUE3QyxFQUE0RCxJQUE1RCxFQUFpRTtBQUM3RCxhQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksUUFBcEIsRUFBOEIsR0FBOUIsRUFBbUM7QUFDL0IsZ0JBQUksUUFBUSxNQUFNLENBQU4sS0FBWSxLQUFLLElBQUwsQ0FBVSxDQUFDLEtBQUksS0FBSyxLQUFMLEdBQWEsYUFBbEIsSUFBbUMsUUFBbkMsR0FBOEMsQ0FBeEQsQ0FBeEI7QUFDQSxpQkFBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLGFBQXBCLEVBQW1DLEdBQW5DLEVBQXdDO0FBQ3BDLHFCQUFLLElBQUwsQ0FBVSxDQUFDLElBQUksS0FBSyxLQUFULEdBQWlCLEVBQWxCLElBQXVCLFFBQXZCLEdBQWtDLENBQTVDLElBQWlELEtBQWpEO0FBQ0g7QUFDRCxvQkFBUSxNQUFNLENBQU4sS0FBWSxLQUFLLElBQUwsQ0FBVSxDQUFDLEtBQUksS0FBSyxLQUFMLElBQWMsS0FBSyxNQUFMLEdBQWMsYUFBZCxHQUE4QixDQUE1QyxDQUFMLElBQXVELFFBQXZELEdBQWtFLENBQTVFLENBQXBCO0FBQ0EsaUJBQUssSUFBSSxLQUFJLEtBQUssTUFBTCxHQUFjLGFBQTNCLEVBQTBDLEtBQUksS0FBSyxNQUFuRCxFQUEyRCxJQUEzRCxFQUFnRTtBQUM1RCxxQkFBSyxJQUFMLENBQVUsQ0FBQyxLQUFJLEtBQUssS0FBVCxHQUFpQixFQUFsQixJQUF1QixRQUF2QixHQUFrQyxDQUE1QyxJQUFpRCxLQUFqRDtBQUNIO0FBQ0o7QUFDSjs7QUFFRCxTQUFLLElBQUksTUFBSSxDQUFiLEVBQWdCLE1BQUksS0FBSyxNQUF6QixFQUFpQyxLQUFqQyxFQUFzQztBQUNsQyxhQUFLLElBQUksS0FBSSxDQUFiLEVBQWdCLEtBQUksUUFBcEIsRUFBOEIsSUFBOUIsRUFBbUM7QUFDL0IsZ0JBQUksU0FBUSxNQUFNLEVBQU4sS0FBWSxLQUFLLElBQUwsQ0FBVSxDQUFDLE1BQUksS0FBSyxLQUFULEdBQWlCLGFBQWxCLElBQW1DLFFBQW5DLEdBQThDLEVBQXhELENBQXhCO0FBQ0EsaUJBQUssSUFBSSxNQUFJLENBQWIsRUFBZ0IsTUFBSSxhQUFwQixFQUFtQyxLQUFuQyxFQUF3QztBQUNwQyxxQkFBSyxJQUFMLENBQVUsQ0FBQyxNQUFJLEtBQUssS0FBVCxHQUFpQixHQUFsQixJQUF1QixRQUF2QixHQUFrQyxFQUE1QyxJQUFpRCxNQUFqRDtBQUNIO0FBQ0QscUJBQVEsTUFBTSxFQUFOLEtBQVksS0FBSyxJQUFMLENBQVUsQ0FBQyxNQUFJLEtBQUssS0FBVCxHQUFpQixLQUFLLEtBQXRCLEdBQThCLGFBQTlCLEdBQThDLENBQS9DLElBQW9ELFFBQXBELEdBQStELEVBQXpFLENBQXBCO0FBQ0EsaUJBQUssSUFBSSxNQUFJLEtBQUssS0FBTCxHQUFhLGFBQTFCLEVBQXlDLE1BQUksS0FBSyxLQUFsRCxFQUF5RCxLQUF6RCxFQUE4RDtBQUMxRCxxQkFBSyxJQUFMLENBQVUsQ0FBQyxNQUFJLEtBQUssS0FBVCxHQUFpQixHQUFsQixJQUF1QixRQUF2QixHQUFrQyxFQUE1QyxJQUFpRCxNQUFqRDtBQUNIO0FBQ0o7QUFDSjtBQUNKOzs7Ozs7OztrQkM1RHVCLFU7O0FBSHhCOzs7O0FBQ0E7Ozs7QUFFZSxTQUFTLFVBQVQsQ0FBb0IsT0FBcEIsRUFBNkIsS0FBN0IsRUFBb0M7O0FBRS9DLFNBQUssZ0JBQUwsQ0FBc0IsWUFBdEIsRUFBb0M7QUFDaEMsa0JBQVUsQ0FBQyxDQUFELEVBQUksRUFBSjtBQURzQixLQUFwQzs7QUFJQSxVQUFNLGdCQUFOLENBQXVCLG9DQUF2QixFQUE2RDtBQUN6RCxrQkFBVSxDQUFDLEtBQUssUUFBTixDQUQrQztBQUV6RCxlQUFPLENBQUMsQ0FBRCxDQUZrRDtBQUd6RCxvQkFBWSxDQUFDLENBQUQ7QUFINkMsS0FBN0Q7O0FBTUEsUUFBSSxNQUFNLEtBQU4sS0FBZ0IsS0FBSyxLQUFyQixJQUE4QixNQUFNLE1BQU4sS0FBaUIsS0FBSyxNQUF4RCxFQUFnRTtBQUM1RCxjQUFNLElBQUksS0FBSixDQUFVLG9EQUFWLENBQU47QUFDSDs7QUFFRCxjQUFVLDhCQUFnQixJQUFoQixFQUFxQixPQUFyQixDQUFWOztBQUVBLFFBQUksTUFBTSxPQUFWO0FBQ0EsU0FBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLE1BQU0sSUFBTixDQUFXLE1BQS9CLEVBQXVDLEdBQXZDLEVBQTRDO0FBQ3hDLGFBQUssSUFBTCxDQUFVLEdBQVYsSUFBaUIsTUFBTSxJQUFOLENBQVcsQ0FBWCxDQUFqQjtBQUNBLGVBQU8sS0FBSyxRQUFaO0FBQ0g7QUFDSjs7Ozs7Ozs7a0JDeEJ1QixLOztBQUZ4Qjs7Ozs7O0FBRWUsU0FBUyxLQUFULEdBQTRDO0FBQUEscUVBQUosRUFBSTs7QUFBQSxrQ0FBNUIsYUFBNEI7QUFBQSxRQUE1QixhQUE0QixzQ0FBWixJQUFZOzs7QUFFdkQsU0FBSyxnQkFBTCxDQUFzQixPQUF0QixFQUErQjtBQUMzQixrQkFBVSxDQUFDLENBQUQsRUFBSSxFQUFKO0FBRGlCLEtBQS9COzs7QUFLQSxRQUFJLEtBQUssVUFBTCxLQUFvQixDQUF4QixFQUEyQjtBQUN2QixlQUFPLENBQUMsS0FBSyxLQUFMLEVBQUQsQ0FBUDtBQUNIOztBQUVELFFBQUksU0FBUyxFQUFiOztBQUVBLFFBQUksT0FBTyxLQUFLLElBQWhCO0FBQ0EsUUFBSSxLQUFLLEtBQUwsSUFBYyxhQUFsQixFQUFpQztBQUM3QixhQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksS0FBSyxVQUF6QixFQUFxQyxHQUFyQyxFQUEwQztBQUN0QyxnQkFBSSxXQUFXLGdCQUFNLFVBQU4sQ0FBaUIsSUFBakIsRUFBdUI7QUFDbEMsNEJBQVksQ0FEc0I7QUFFbEMsdUJBQU8sSUFGMkI7QUFHbEMsNEJBQVk7QUFIc0IsYUFBdkIsQ0FBZjtBQUtBLGdCQUFJLE1BQU0sQ0FBVjtBQUNBLGlCQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksS0FBSyxNQUF6QixFQUFpQyxLQUFLLEtBQUssUUFBM0MsRUFBcUQ7QUFDakQseUJBQVMsSUFBVCxDQUFjLEtBQWQsSUFBdUIsS0FBSyxJQUFJLENBQVQsQ0FBdkI7QUFDQSx5QkFBUyxJQUFULENBQWMsS0FBZCxJQUF1QixLQUFLLElBQUksS0FBSyxVQUFkLENBQXZCO0FBQ0g7QUFDRCxtQkFBTyxJQUFQLENBQVksUUFBWjtBQUNIO0FBQ0osS0FkRCxNQWNPO0FBQ0gsYUFBSyxJQUFJLEtBQUksQ0FBYixFQUFnQixLQUFJLEtBQUssUUFBekIsRUFBbUMsSUFBbkMsRUFBd0M7QUFDcEMsZ0JBQUksWUFBVyxnQkFBTSxVQUFOLENBQWlCLElBQWpCLEVBQXVCO0FBQ2xDLDRCQUFZLENBRHNCO0FBRWxDLHVCQUFPLEtBRjJCO0FBR2xDLDRCQUFZO0FBSHNCLGFBQXZCLENBQWY7QUFLQSxnQkFBSSxPQUFNLENBQVY7QUFDQSxpQkFBSyxJQUFJLEtBQUksQ0FBYixFQUFnQixLQUFJLEtBQUssTUFBekIsRUFBaUMsTUFBSyxLQUFLLFFBQTNDLEVBQXFEO0FBQ2pELDBCQUFTLElBQVQsQ0FBYyxNQUFkLElBQXVCLEtBQUssS0FBSSxFQUFULENBQXZCO0FBQ0g7QUFDRCxtQkFBTyxJQUFQLENBQVksU0FBWjtBQUNIO0FBQ0o7O0FBRUQsV0FBTyxNQUFQO0FBQ0g7Ozs7O0FDOUNEOztBQUVBLE9BQU8sT0FBUCxHQUFpQixVQUFVLFFBQVEsZUFBUixFQUF5QixPQUFwRDtBQUNBLFFBQVEsS0FBUixHQUFnQixRQUFRLGVBQVIsRUFBeUIsT0FBekM7O0FBRUEsSUFBSSxxQkFBUSxTQUFaLEVBQXVCO0FBQ25CLFlBQVEsTUFBUixHQUFpQixRQUFRLGlCQUFSLEVBQTJCLE9BQTVDO0FBQ0g7Ozs7Ozs7O2tCQ1B1QixTO0FBQVQsU0FBUyxTQUFULENBQW1CLE9BQW5CLEVBQTRCOztBQUV2QyxTQUFLLGdCQUFMLENBQXNCLEtBQXRCLEVBQTZCO0FBQ3pCLGtCQUFVLENBQUMsQ0FBRCxFQUFJLEVBQUo7QUFEZSxLQUE3Qjs7QUFJQSxRQUFJLFlBQVksS0FBSyxDQUFMLEVBQVEsWUFBUixDQUFxQixPQUFyQixDQUFoQjtBQUNBLFNBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxLQUFLLE1BQXpCLEVBQWlDLEdBQWpDLEVBQXNDO0FBQ2xDLFlBQUksa0JBQWtCLEtBQUssQ0FBTCxFQUFRLFlBQVIsQ0FBcUIsT0FBckIsQ0FBdEI7QUFDQSxhQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksVUFBVSxNQUE5QixFQUFzQyxHQUF0QyxFQUEyQztBQUN2QyxzQkFBVSxDQUFWLEtBQWdCLGdCQUFnQixDQUFoQixDQUFoQjtBQUNIO0FBQ0o7QUFDRCxXQUFPLFNBQVA7QUFDSDs7Ozs7Ozs7a0JDZHVCLFU7QUFBVCxTQUFTLFVBQVQsQ0FBb0IsT0FBcEIsRUFBNkI7O0FBRXhDLFNBQUssZ0JBQUwsQ0FBc0IsS0FBdEIsRUFBNkI7QUFDekIsa0JBQVUsQ0FBQyxDQUFELEVBQUksRUFBSjtBQURlLEtBQTdCOztBQUlBLFFBQUksYUFBYSxLQUFLLENBQUwsRUFBUSxhQUFSLENBQXNCLE9BQXRCLENBQWpCO0FBQ0EsUUFBSSxrQkFBa0IsV0FBVyxDQUFYLEVBQWMsTUFBcEM7QUFDQSxTQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksS0FBSyxNQUF6QixFQUFpQyxHQUFqQyxFQUFzQztBQUNsQyxZQUFJLG1CQUFtQixLQUFLLENBQUwsRUFBUSxhQUFSLENBQXNCLE9BQXRCLENBQXZCO0FBQ0EsYUFBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLFdBQVcsTUFBL0IsRUFBdUMsR0FBdkMsRUFBNEM7QUFDeEMsaUJBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxlQUFwQixFQUFxQyxHQUFyQyxFQUEwQztBQUN0QywyQkFBVyxDQUFYLEVBQWMsQ0FBZCxLQUFvQixpQkFBaUIsQ0FBakIsRUFBb0IsQ0FBcEIsQ0FBcEI7QUFDSDtBQUNKO0FBQ0o7QUFDRCxXQUFPLFVBQVA7QUFDSDs7Ozs7Ozs7a0JDakJ1QixHO0FBQVQsU0FBUyxHQUFULEdBQWU7O0FBRTFCLFNBQUssZ0JBQUwsQ0FBc0IsS0FBdEIsRUFBNkI7QUFDekIsa0JBQVUsQ0FBQyxDQUFELEVBQUksRUFBSjtBQURlLEtBQTdCOztBQUlBLFFBQUksTUFBTSxLQUFLLENBQUwsRUFBUSxHQUFsQjtBQUNBLFNBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxLQUFLLE1BQXpCLEVBQWlDLEdBQWpDLEVBQXNDO0FBQ2xDLGFBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxJQUFJLE1BQXhCLEVBQWdDLEdBQWhDLEVBQXFDO0FBQ2pDLGdCQUFJLENBQUosSUFBUyxLQUFLLEdBQUwsQ0FBUyxJQUFJLENBQUosQ0FBVCxFQUFpQixLQUFLLENBQUwsRUFBUSxHQUFSLENBQVksQ0FBWixDQUFqQixDQUFUO0FBQ0g7QUFDSjtBQUNELFdBQU8sR0FBUDtBQUNIOzs7Ozs7OztrQkNWdUIsTTs7QUFIeEI7Ozs7QUFDQTs7OztBQUVlLFNBQVMsTUFBVCxHQUFrQjs7QUFFN0IsU0FBSyxnQkFBTCxDQUFzQixRQUF0QixFQUFnQztBQUM1QixrQkFBVSxDQUFDLENBQUQsRUFBSSxFQUFKO0FBRGtCLEtBQWhDOztBQUtBLFFBQUksYUFBYSxLQUFLLGFBQUwsQ0FBbUIsRUFBQyxVQUFVLEtBQUssQ0FBTCxFQUFRLFFBQVIsR0FBbUIsQ0FBOUIsRUFBbkIsQ0FBakI7QUFDQSxRQUFJLFNBQVMsSUFBSSxLQUFKLENBQVUsV0FBVyxNQUFyQixDQUFiO0FBQ0EsU0FBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLFdBQVcsTUFBL0IsRUFBdUMsR0FBdkMsRUFBNEM7QUFDeEMsWUFBSSxZQUFZLFdBQVcsQ0FBWCxDQUFoQjtBQUNBLGVBQU8sQ0FBUCxJQUFZLHVCQUFvQixTQUFwQixDQUFaO0FBQ0g7QUFDRCxXQUFPLE1BQVA7QUFDSDs7Ozs7Ozs7a0JDakJ1QixHO0FBQVQsU0FBUyxHQUFULEdBQWU7QUFDMUIsU0FBSyxnQkFBTCxDQUFzQixLQUF0QixFQUE2QjtBQUN6QixrQkFBVSxDQUFDLENBQUQsRUFBSSxFQUFKO0FBRGUsS0FBN0I7O0FBSUEsUUFBSSxNQUFNLEtBQUssQ0FBTCxFQUFRLEdBQWxCO0FBQ0EsU0FBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLEtBQUssTUFBekIsRUFBaUMsR0FBakMsRUFBc0M7QUFDbEMsYUFBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLElBQUksTUFBeEIsRUFBZ0MsR0FBaEMsRUFBcUM7QUFDakMsZ0JBQUksQ0FBSixJQUFTLEtBQUssR0FBTCxDQUFTLElBQUksQ0FBSixDQUFULEVBQWlCLEtBQUssQ0FBTCxFQUFRLEdBQVIsQ0FBWSxDQUFaLENBQWpCLENBQVQ7QUFDSDtBQUNKO0FBQ0QsV0FBTyxHQUFQO0FBQ0g7Ozs7Ozs7O2tCQ0Z1QixNOztBQVZ4Qjs7OztBQUVBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFFQTs7Ozs7O0FBRWUsU0FBUyxNQUFULENBQWdCLEtBQWhCLEVBQXVCO0FBQ2xDLFFBQUksVUFBVSxFQUFDLFNBQVMsSUFBVixFQUFkO0FBQ0EsVUFBTSxZQUFOLENBQW1CLGNBQW5COztBQUVBLFVBQU0sWUFBTixDQUFtQixRQUFuQjtBQUNBLFVBQU0sWUFBTixDQUFtQixRQUFuQjtBQUNBLFVBQU0sWUFBTixDQUFtQixXQUFuQjtBQUNBLFVBQU0sWUFBTixDQUFtQixjQUFuQjtBQUNBLFVBQU0sWUFBTixDQUFtQixlQUFuQjs7QUFFQSxVQUFNLFlBQU4sQ0FBbUIsWUFBbkI7QUFDSDs7Ozs7Ozs7a0JDWnVCLEs7O0FBVHhCOzs7O0FBQ0E7Ozs7Ozs7O0FBRUEsSUFBSSw2QkFBNkI7QUFDN0Isa0JBQWMsSUFEZTtBQUU3QixnQkFBWSxLQUZpQjtBQUc3QixTQUFLO0FBSHdCLENBQWpDOztBQU1lLFNBQVMsS0FBVCxDQUFlLE1BQWYsRUFBdUI7QUFDbEMsUUFBSSxjQUFKO0FBQ0EsUUFBSSxNQUFNLE9BQU4sQ0FBYyxNQUFkLENBQUosRUFBMkI7QUFDdkIsZ0JBQVEsSUFBSSxLQUFKLENBQVUsT0FBTyxNQUFqQixDQUFSO0FBQ0EsYUFBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLE9BQU8sTUFBM0IsRUFBbUMsR0FBbkMsRUFBd0M7QUFDcEMsa0JBQU0sQ0FBTixJQUFXLE9BQU8sQ0FBUCxDQUFYO0FBQ0g7QUFDSixLQUxELE1BS08sSUFBSSxPQUFPLE1BQVAsS0FBa0IsUUFBdEIsRUFBZ0M7QUFDbkMsZ0JBQVEsSUFBSSxLQUFKLENBQVUsTUFBVixDQUFSO0FBQ0gsS0FGTSxNQUVBO0FBQ0gsZ0JBQVEsRUFBUjtBQUNIO0FBQ0QsVUFBTSxRQUFOLEdBQWlCLElBQWpCO0FBQ0EsVUFBTSxTQUFOLEdBQWtCLE1BQU0sU0FBeEI7QUFDQSxXQUFPLEtBQVA7QUFDSDs7QUFFRCxNQUFNLElBQU4sR0FBYSxVQUFVLElBQVYsRUFBZ0I7QUFDekIsV0FBTyxRQUFRLEdBQVIsQ0FBWSxLQUFLLEdBQUwsQ0FBUyxnQkFBTSxJQUFmLENBQVosRUFBa0MsSUFBbEMsQ0FBdUMsS0FBdkMsQ0FBUDtBQUNILENBRkQ7O0FBSUEsTUFBTSxZQUFOLEdBQXFCLFNBQVMsWUFBVCxDQUFzQixJQUF0QixFQUE0QixNQUE1QixFQUFpRztBQUFBLHFFQUFKLEVBQUk7O0FBQUEsNEJBQTVELE9BQTREO0FBQUEsUUFBNUQsT0FBNEQsZ0NBQWxELEtBQWtEO0FBQUEsK0JBQTNDLFVBQTJDO0FBQUEsUUFBM0MsVUFBMkMsbUNBQTlCLElBQThCO0FBQUEsZ0NBQXhCLFdBQXdCO0FBQUEsUUFBeEIsV0FBd0Isb0NBQVYsRUFBVTs7QUFDbEgsUUFBSSxPQUFKLEVBQWE7QUFDVCxjQUFNLFNBQU4sQ0FBZ0IsSUFBaEIsSUFBd0IsWUFBbUI7O0FBRXZDLGlCQUFLLFFBQUwsR0FBZ0IsSUFBaEI7O0FBRnVDLDhDQUFOLElBQU07QUFBTixvQkFBTTtBQUFBOztBQUd2QyxnQkFBSSxTQUFTLE9BQU8sS0FBUCxDQUFhLElBQWIsK0JBQXVCLFdBQXZCLEdBQXVDLElBQXZDLEVBQWI7QUFDQSxnQkFBSSxVQUFKLEVBQ0ksT0FBTyxJQUFQO0FBQ0osbUJBQU8sTUFBUDtBQUNILFNBUEQ7QUFRSCxLQVRELE1BU087QUFDSCxjQUFNLFNBQU4sQ0FBZ0IsSUFBaEIsSUFBd0IsWUFBbUI7QUFBQSwrQ0FBTixJQUFNO0FBQU4sb0JBQU07QUFBQTs7QUFDdkMsbUJBQU8sT0FBTyxLQUFQLENBQWEsSUFBYiwrQkFBdUIsV0FBdkIsR0FBdUMsSUFBdkMsRUFBUDtBQUNILFNBRkQ7QUFHSDtBQUNELFdBQU8sS0FBUDtBQUNILENBaEJEOztBQWtCQSxNQUFNLGNBQU4sR0FBdUIsU0FBUyxjQUFULENBQXdCLElBQXhCLEVBQThCLE1BQTlCLEVBQStEO0FBQUEsc0VBQUosRUFBSTs7QUFBQSxrQ0FBeEIsV0FBd0I7QUFBQSxRQUF4QixXQUF3QixxQ0FBVixFQUFVOztBQUNsRiwrQkFBMkIsR0FBM0IsR0FBaUMsWUFBWTtBQUN6QyxZQUFJLEtBQUssUUFBTCxLQUFrQixJQUF0QixFQUE0QjtBQUN4QixpQkFBSyxRQUFMLEdBQWdCLEVBQWhCO0FBQ0gsU0FGRCxNQUVPLElBQUksS0FBSyxRQUFMLENBQWMsY0FBZCxDQUE2QixJQUE3QixDQUFKLEVBQXdDO0FBQzNDLG1CQUFPLEtBQUssUUFBTCxDQUFjLElBQWQsQ0FBUDtBQUNIO0FBQ0QsWUFBSSxTQUFTLE9BQU8sS0FBUCxDQUFhLElBQWIsRUFBbUIsV0FBbkIsQ0FBYjtBQUNBLGFBQUssUUFBTCxDQUFjLElBQWQsSUFBc0IsTUFBdEI7QUFDQSxlQUFPLE1BQVA7QUFDSCxLQVREO0FBVUEsV0FBTyxjQUFQLENBQXNCLE1BQU0sU0FBNUIsRUFBdUMsSUFBdkMsRUFBNkMsMEJBQTdDO0FBQ0EsV0FBTyxLQUFQO0FBQ0gsQ0FiRDs7QUFlQSxNQUFNLFNBQU4sR0FBa0IsS0FBbEI7QUFDQSxNQUFNLFNBQU4sQ0FBZ0IsU0FBaEIsR0FBNEIsTUFBTSxTQUFsQztBQUNBLE1BQU0sU0FBTixDQUFnQixHQUFoQixHQUFzQixVQUFVLEVBQVYsRUFBYyxPQUFkLEVBQXVCO0FBQ3pDLFFBQUksT0FBTyxFQUFQLEtBQWMsVUFBbEIsRUFBOEI7QUFDMUIsY0FBTSxJQUFJLFNBQUosQ0FBYyxLQUFLLG9CQUFuQixDQUFOO0FBQ0g7QUFDRCxRQUFJLFdBQVcsSUFBSSxLQUFKLENBQVUsS0FBSyxNQUFmLENBQWY7QUFDQSxTQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksS0FBSyxNQUF6QixFQUFpQyxHQUFqQyxFQUFzQztBQUNsQyxpQkFBUyxDQUFULElBQWMsR0FBRyxJQUFILENBQVEsT0FBUixFQUFpQixLQUFLLENBQUwsQ0FBakIsRUFBMEIsQ0FBMUIsRUFBNkIsSUFBN0IsQ0FBZDtBQUNIO0FBQ0QsV0FBTyxRQUFQO0FBQ0gsQ0FURDs7O0FBWUEsTUFBTSxTQUFOLENBQWdCLGdCQUFoQixHQUFtQyxVQUFVLFdBQVYsRUFBcUM7QUFBQSxRQUFkLE9BQWMseURBQUosRUFBSTs7QUFDcEUsUUFBSSxPQUFPLFdBQVAsS0FBdUIsUUFBM0IsRUFBcUM7QUFDakMsY0FBTSxJQUFJLFNBQUosQ0FBYyx5RUFBZCxDQUFOO0FBQ0g7QUFDRCxRQUFJLEtBQUssSUFBTCxLQUFjLENBQWxCLEVBQXFCO0FBQ2pCLGNBQU0sSUFBSSxTQUFKLENBQWMsa0JBQWtCLFdBQWxCLEdBQWdDLHVDQUE5QyxDQUFOO0FBQ0g7QUFDRCxTQUFLLENBQUwsRUFBUSxnQkFBUixDQUF5QixXQUF6QixFQUFzQyxPQUF0QztBQUNBLFNBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxLQUFLLE1BQXpCLEVBQWlDLEdBQWpDLEVBQXNDO0FBQ2xDLFlBQUksQ0FBQyxRQUFRLFFBQVIsS0FBcUIsU0FBckIsSUFBa0MsUUFBUSxRQUEzQyxLQUF3RCxLQUFLLENBQUwsRUFBUSxLQUFSLEtBQWtCLEtBQUssQ0FBTCxFQUFRLEtBQXRGLEVBQTZGO0FBQ3pGLGtCQUFNLElBQUksU0FBSixDQUFjLGtCQUFrQixXQUFsQixHQUFnQyw2REFBOUMsQ0FBTjtBQUNIO0FBQ0QsWUFBSSxDQUFDLFFBQVEsUUFBUixLQUFxQixTQUFyQixJQUFrQyxRQUFRLFFBQTNDLEtBQXdELEtBQUssQ0FBTCxFQUFRLE1BQVIsS0FBbUIsS0FBSyxDQUFMLEVBQVEsTUFBdkYsRUFBK0Y7QUFDM0Ysa0JBQU0sSUFBSSxTQUFKLENBQWMsa0JBQWtCLFdBQWxCLEdBQWdDLDhEQUE5QyxDQUFOO0FBQ0g7QUFDRCxZQUFJLENBQUMsUUFBUSxTQUFSLEtBQXNCLFNBQXRCLElBQW1DLFFBQVEsU0FBNUMsS0FBMEQsS0FBSyxDQUFMLEVBQVEsS0FBUixLQUFrQixLQUFLLENBQUwsRUFBUSxLQUF4RixFQUErRjtBQUMzRixrQkFBTSxJQUFJLFNBQUosQ0FBYyxrQkFBa0IsV0FBbEIsR0FBZ0MsNkRBQTlDLENBQU47QUFDSDtBQUNELFlBQUksQ0FBQyxRQUFRLFlBQVIsS0FBeUIsU0FBekIsSUFBc0MsUUFBUSxZQUEvQyxLQUFnRSxLQUFLLENBQUwsRUFBUSxRQUFSLEtBQXFCLEtBQUssQ0FBTCxFQUFRLFFBQWpHLEVBQTJHO0FBQ3ZHLGtCQUFNLElBQUksU0FBSixDQUFjLGtCQUFrQixXQUFsQixHQUFnQyxnRUFBOUMsQ0FBTjtBQUNIO0FBQ0QsWUFBSSxDQUFDLFFBQVEsY0FBUixLQUEyQixTQUEzQixJQUF3QyxRQUFRLGNBQWpELEtBQW9FLEtBQUssQ0FBTCxFQUFRLFVBQVIsS0FBdUIsS0FBSyxDQUFMLEVBQVEsVUFBdkcsRUFBbUg7QUFDL0csa0JBQU0sSUFBSSxTQUFKLENBQWMsa0JBQWtCLFdBQWxCLEdBQWdDLGtFQUE5QyxDQUFOO0FBQ0g7QUFDRCxZQUFJLENBQUMsUUFBUSxrQkFBUixLQUErQixTQUEvQixJQUE0QyxRQUFRLGtCQUFyRCxLQUE0RSxLQUFLLENBQUwsRUFBUSxRQUFSLEtBQXFCLEtBQUssQ0FBTCxFQUFRLFFBQTdHLEVBQXVIO0FBQ25ILGtCQUFNLElBQUksU0FBSixDQUFjLGtCQUFrQixXQUFsQixHQUFnQyxnRUFBOUMsQ0FBTjtBQUNIO0FBQ0o7QUFDSixDQTVCRDs7QUE4QkEsc0JBQU8sS0FBUDs7Ozs7Ozs7a0JDMUZ3QixZOztBQWJ4Qjs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFhZSxTQUFTLFlBQVQsR0FJYjtBQUFBLHFFQURNLEVBQ047O0FBQUEsOEJBSEUsU0FHRjtBQUFBLFFBSEUsU0FHRixrQ0FIYyxpQkFHZDtBQUFBLGlDQUZFLFlBRUY7QUFBQSxRQUZFLFlBRUYscUNBRmlCLENBQUMsQ0FBRCxFQUFHLENBQUgsQ0FFakI7O0FBQ0UsU0FBSyxnQkFBTCxDQUFzQixjQUF0QixFQUFzQztBQUNsQyxrQkFBVSxDQUFDLENBQUQsRUFBSSxFQUFKO0FBRHdCLEtBQXRDOztBQUlBLFFBQUksa0JBQW1CLGNBQWMsaUJBQWYsR0FBb0MsSUFBcEMsR0FBMkMsS0FBakU7O0FBRUEsUUFBSSxTQUFTLEtBQUssQ0FBTCxDQUFiO0FBQ0EsUUFBSSxVQUFVLEVBQWQ7QUFDQSxZQUFRLENBQVIsSUFBYTtBQUNULGtCQUFTLENBQUMsQ0FBRCxFQUFHLENBQUgsQ0FEQTtBQUVULGVBQU8sS0FBSyxDQUFMO0FBRkUsS0FBYjs7QUFLQSxRQUFJLG1CQUFtQixDQUFDLENBQUQsRUFBRyxDQUFILENBQXZCOzs7QUFHQSxTQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksS0FBSyxNQUF6QixFQUFpQyxHQUFqQyxFQUFzQzs7QUFFbEMsWUFBSSxXQUFXLE9BQU8sWUFBUCxDQUFvQixLQUFLLENBQUwsQ0FBcEIsRUFBNEIsRUFBQyxRQUFPLFlBQVIsRUFBNUIsQ0FBZjs7QUFFQSxnQkFBUSxDQUFSLElBQWE7QUFDVCxzQkFBVSxDQUFDLFNBQVMsQ0FBVCxJQUFjLGlCQUFpQixDQUFqQixDQUFmLEVBQW9DLFNBQVMsQ0FBVCxJQUFjLGlCQUFpQixDQUFqQixDQUFsRCxDQUREO0FBRVQsbUJBQU8sS0FBSyxDQUFMO0FBRkUsU0FBYjtBQUlBLFlBQUksZUFBSixFQUFxQjtBQUNqQiw2QkFBaUIsQ0FBakIsS0FBdUIsU0FBUyxDQUFULENBQXZCO0FBQ0EsNkJBQWlCLENBQWpCLEtBQXVCLFNBQVMsQ0FBVCxDQUF2QjtBQUNBLHFCQUFTLEtBQUssQ0FBTCxDQUFUO0FBQ0g7QUFHSjs7O0FBR0QsUUFBSSxZQUFZLENBQWhCO0FBQ0EsUUFBSSxhQUFhLENBQWpCO0FBQ0EsUUFBSSxXQUFXLENBQWY7QUFDQSxRQUFJLGNBQWMsQ0FBbEI7O0FBRUEsU0FBSyxJQUFJLEtBQUksQ0FBYixFQUFnQixLQUFJLFFBQVEsTUFBNUIsRUFBb0MsSUFBcEMsRUFBeUM7QUFDckMsWUFBSSxTQUFTLFFBQVEsRUFBUixDQUFiO0FBQ0EsWUFBSSxPQUFPLFFBQVAsQ0FBZ0IsQ0FBaEIsSUFBcUIsU0FBekIsRUFBb0MsWUFBWSxPQUFPLFFBQVAsQ0FBZ0IsQ0FBaEIsQ0FBWjtBQUNwQyxZQUFJLE9BQU8sUUFBUCxDQUFnQixDQUFoQixJQUFxQixVQUF6QixFQUFxQyxhQUFhLE9BQU8sUUFBUCxDQUFnQixDQUFoQixDQUFiO0FBQ3JDLFlBQUksT0FBTyxRQUFQLENBQWdCLENBQWhCLElBQXFCLFFBQXpCLEVBQW1DLFdBQVcsT0FBTyxRQUFQLENBQWdCLENBQWhCLENBQVg7QUFDbkMsWUFBSSxPQUFPLFFBQVAsQ0FBZ0IsQ0FBaEIsSUFBcUIsV0FBekIsRUFBc0MsY0FBYyxPQUFPLFFBQVAsQ0FBZ0IsQ0FBaEIsQ0FBZDtBQUN6QztBQUNELGtCQUFjLENBQUMsQ0FBZjtBQUNBLG1CQUFlLENBQUMsQ0FBaEI7O0FBR0EsU0FBSyxJQUFJLE1BQUksQ0FBYixFQUFnQixNQUFJLFFBQVEsTUFBNUIsRUFBb0MsS0FBcEMsRUFBeUM7QUFDckMsWUFBSSxVQUFTLFFBQVEsR0FBUixDQUFiOzs7Ozs7Ozs7OztBQVdBLGdCQUFPLElBQVAsR0FBYyxRQUFPLEtBQVAsQ0FBYSxJQUFiLENBQWtCO0FBQzVCLGVBQUcsWUFBWSxRQUFPLFFBQVAsQ0FBZ0IsQ0FBaEIsQ0FEYTtBQUU1QixlQUFHLFdBQVcsUUFBTyxRQUFQLENBQWdCLENBQWhCLENBRmM7QUFHNUIsbUJBQU0sT0FBTyxLQUFQLEdBQWUsVUFBZixHQUE0QixTQUhOO0FBSTVCLG9CQUFPLE9BQU8sTUFBUCxHQUFnQixXQUFoQixHQUE4QjtBQUpULFNBQWxCLENBQWQ7QUFNSDs7O0FBR0QsUUFBSSxZQUFZLEVBQWhCO0FBQ0EsU0FBSyxJQUFJLE1BQUksQ0FBYixFQUFnQixNQUFJLFFBQVEsTUFBNUIsRUFBb0MsS0FBcEMsRUFBeUM7QUFDckMsa0JBQVUsR0FBVixJQUFlLFFBQVEsR0FBUixFQUFXLElBQTFCO0FBQ0g7O0FBRUQsV0FBTyxvQkFBVSxTQUFWLENBQVA7QUFDSCxDOzs7Ozs7Ozs7OztrQkNoR3VCLE87O0FBSHhCOzs7O0FBQ0E7Ozs7Ozs7O0FBRWUsU0FBUyxPQUFULEdBQTBCO0FBQUEscUVBQUosRUFBSTs7QUFBQTs7QUFDckMsU0FBSyxnQkFBTCxDQUFzQixTQUF0QixFQUFpQztBQUM3QixrQkFBVSxDQUFDLENBQUQsRUFBSSxFQUFKO0FBRG1CLEtBQWpDOztBQUlBLFFBQUksT0FBTyxJQUFJLFdBQUosQ0FBZ0IsS0FBSyxDQUFMLEVBQVEsSUFBUixDQUFhLE1BQTdCLENBQVg7QUFDQSxTQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksS0FBSyxNQUF6QixFQUFpQyxHQUFqQyxFQUFzQztBQUNsQyxZQUFJLFVBQVUsS0FBSyxDQUFMLENBQWQ7QUFDQSxhQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksS0FBSyxDQUFMLEVBQVEsSUFBUixDQUFhLE1BQWpDLEVBQXlDLEdBQXpDLEVBQThDO0FBQzFDLGlCQUFLLENBQUwsS0FBVyxRQUFRLElBQVIsQ0FBYSxDQUFiLENBQVg7QUFDSDtBQUNKOztBQUVELFFBQUksUUFBUSxnQkFBTSxVQUFOLENBQWlCLEtBQUssQ0FBTCxDQUFqQixDQUFaO0FBQ0EsUUFBSSxVQUFVLE1BQU0sSUFBcEI7O0FBRUEsU0FBSyxJQUFJLEtBQUksQ0FBYixFQUFnQixLQUFJLEtBQUssQ0FBTCxFQUFRLElBQVIsQ0FBYSxNQUFqQyxFQUF5QyxJQUF6QyxFQUE4QztBQUMxQyxnQkFBUSxFQUFSLElBQWEsS0FBSyxFQUFMLElBQVUsS0FBSyxNQUE1QjtBQUNIOztBQUVELFdBQU8sS0FBUDtBQUNIOzs7Ozs7OztRQ3JCZSx1QixHQUFBLHVCO1FBaUNBLGUsR0FBQSxlOztBQXBDaEI7O0lBQVksSzs7OztBQUdMLFNBQVMsdUJBQVQsQ0FBaUMsS0FBakMsRUFJSztBQUFBLHFFQUFKLEVBQUk7O0FBQUEsUUFIUixRQUdRLFFBSFIsUUFHUTtBQUFBLFFBRlIsVUFFUSxRQUZSLFVBRVE7QUFBQSxRQURSLFlBQ1EsUUFEUixZQUNROzs7QUFFUixRQUFJLE9BQU8sVUFBUCxLQUFzQixTQUExQixFQUFxQyxhQUFhLElBQWI7O0FBRXJDLFFBQUksT0FBTyxRQUFQLEtBQW9CLFdBQXhCLEVBQXFDO0FBQ2pDLGVBQU8sWUFBWSxLQUFaLEVBQW1CLFlBQW5CLENBQVA7QUFDSCxLQUZELE1BRU87QUFDSCxlQUFPLGlCQUFpQixLQUFqQixFQUF3QixRQUF4QixFQUFrQyxVQUFsQyxDQUFQO0FBQ0g7QUFDSjs7QUFFRCxTQUFTLFdBQVQsQ0FBcUIsS0FBckIsRUFBNEIsWUFBNUIsRUFBMEM7QUFDdEMsUUFBSSxTQUFTLGVBQWUsTUFBTSxRQUFyQixHQUFnQyxNQUFNLFVBQW5EO0FBQ0EsUUFBSSxRQUFRLElBQUksS0FBSixDQUFVLE1BQVYsQ0FBWjtBQUNBLFNBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxNQUFwQixFQUE0QixHQUE1QixFQUFpQztBQUM3QixjQUFNLENBQU4sSUFBVyxDQUFYO0FBQ0g7QUFDRCxXQUFPLEtBQVA7QUFDSDs7QUFFRCxTQUFTLGdCQUFULENBQTBCLEtBQTFCLEVBQWlDLFFBQWpDLEVBQTJDLFVBQTNDLEVBQXVEO0FBQ25ELFFBQUksQ0FBQyxNQUFNLE9BQU4sQ0FBYyxRQUFkLENBQUwsRUFBOEIsV0FBVyxDQUFDLFFBQUQsQ0FBWDtBQUM5QixTQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksU0FBUyxNQUE3QixFQUFxQyxHQUFyQyxFQUEwQztBQUN0QyxpQkFBUyxDQUFULElBQWMsZ0JBQWdCLEtBQWhCLEVBQXNCLFNBQVMsQ0FBVCxDQUF0QixFQUFtQyxVQUFuQyxDQUFkO0FBQ0g7QUFDRCxXQUFPLFFBQVA7QUFDSDs7QUFHTSxTQUFTLGVBQVQsQ0FBeUIsS0FBekIsRUFBZ0MsT0FBaEMsRUFBNEQ7QUFBQSxRQUFuQixVQUFtQix5REFBTixJQUFNOztBQUMvRCxRQUFJLFlBQVksU0FBaEIsRUFBMkI7QUFDdkIsY0FBTSxJQUFJLFVBQUosQ0FBZSxzREFBc0QsTUFBTSxRQUEzRSxDQUFOO0FBQ0g7O0FBRUQsUUFBSSxPQUFPLE9BQVAsS0FBbUIsUUFBdkIsRUFBaUM7QUFDN0IsWUFBSSxNQUFNLE9BQU4sQ0FBYyxPQUFkLElBQXlCLENBQUMsQ0FBOUIsRUFBaUM7QUFDN0IsZ0JBQUksTUFBTSxVQUFOLEtBQXFCLE1BQU0sR0FBL0IsRUFBb0MsTUFBTSxJQUFJLEtBQUosQ0FBVSw4QkFBVixDQUFOO0FBQ3BDLG9CQUFRLE9BQVI7QUFDSSxxQkFBSyxHQUFMO0FBQ0ksOEJBQVUsQ0FBVjtBQUNBO0FBQ0oscUJBQUssR0FBTDtBQUNJLDhCQUFVLENBQVY7QUFDQTtBQUNKLHFCQUFLLEdBQUw7QUFDSSw4QkFBVSxDQUFWO0FBQ0E7QUFUUjtBQVdIOztBQUVELFlBQUksWUFBWSxHQUFoQixFQUFxQjtBQUNqQixnQkFBSSxDQUFDLE1BQU0sS0FBWCxFQUFrQixNQUFNLElBQUksS0FBSixDQUFVLDREQUFWLENBQU47QUFDbEIsc0JBQVUsTUFBTSxVQUFoQjtBQUNIOztBQUVELFlBQUksT0FBTyxPQUFQLEtBQW1CLFFBQXZCLEVBQWlDO0FBQzdCLGtCQUFNLElBQUksS0FBSixDQUFVLDBDQUEwQyxPQUFwRCxDQUFOO0FBQ0g7QUFDSjs7QUFFRCxRQUFJLFdBQVcsTUFBTSxRQUFyQixFQUErQjtBQUMzQixjQUFNLElBQUksVUFBSixDQUFlLHNEQUFzRCxNQUFNLFFBQTNFLENBQU47QUFDSDs7QUFFRCxRQUFJLENBQUMsVUFBRCxJQUFlLFdBQVcsTUFBTSxVQUFwQyxFQUFnRDtBQUM1QyxjQUFNLElBQUksVUFBSixDQUFlLHFEQUFmLENBQU47QUFDSDs7QUFFRCxXQUFPLE9BQVA7QUFDSDs7Ozs7Ozs7UUN4RWUsUyxHQUFBLFM7UUFpQkEsWSxHQUFBLFk7UUFzQkEsZ0IsR0FBQSxnQjs7Ozs7QUF2Q1QsU0FBUyxTQUFULENBQW1CLEtBQW5CLEVBQTBCO0FBQzdCLFFBQUksT0FBTyxLQUFQLEtBQWlCLFFBQXJCLEVBQStCO0FBQzNCLFlBQU0sT0FBTyxNQUFNLE1BQU0sTUFBTixHQUFlLENBQXJCLENBQWI7QUFDQSxnQkFBUSxXQUFXLEtBQVgsQ0FBUjtBQUNBLFlBQUksU0FBUyxHQUFiLEVBQWtCO0FBQ2QscUJBQVMsR0FBVDtBQUNIO0FBQ0o7QUFDRCxXQUFPLEtBQVA7QUFDSDs7Ozs7Ozs7QUFRTSxTQUFTLFlBQVQsQ0FBc0IsS0FBdEIsRUFBNkIsUUFBN0IsRUFBdUM7QUFDMUMsUUFBSSxDQUFDLFFBQUwsRUFBZTtBQUNYLGNBQU0sTUFBTSxpREFBTixDQUFOO0FBQ0g7QUFDRCxRQUFJLE9BQU8sS0FBUCxLQUFpQixRQUFyQixFQUErQjtBQUMzQixZQUFJLE9BQU8sTUFBTSxNQUFNLE1BQU4sR0FBZSxDQUFyQixDQUFYO0FBQ0EsWUFBSSxTQUFTLEdBQWIsRUFBa0I7QUFDZCxrQkFBTSxNQUFNLDZEQUFOLENBQU47QUFDSDtBQUNELGVBQU8sV0FBVyxLQUFYLElBQW9CLEdBQXBCLEdBQTBCLFFBQWpDO0FBQ0gsS0FORCxNQU1PLElBQUksT0FBTyxLQUFQLEtBQWlCLFFBQXJCLEVBQStCO0FBQ2xDLFlBQUksUUFBUSxDQUFaLEVBQWU7QUFDWCxtQkFBTyxRQUFRLFFBQWY7QUFDSDtBQUNELGVBQU8sS0FBUDtBQUNILEtBTE0sTUFLQTtBQUNILGNBQU0sTUFBTSx1Q0FBTixDQUFOO0FBQ0g7QUFDSjs7QUFJTSxTQUFTLGdCQUFULENBQTBCLE1BQTFCLEVBQWtDLEtBQWxDLEVBQXlDLE1BQXpDLEVBQWlEO0FBQ3BELGFBQVMsVUFBVSxNQUFWLENBQVQ7QUFDQSxXQUFPO0FBQ0gsZUFBTyxLQUFLLEtBQUwsQ0FBVyxTQUFTLEtBQXBCLENBREo7QUFFSCxnQkFBUSxLQUFLLEtBQUwsQ0FBVyxTQUFTLE1BQXBCO0FBRkwsS0FBUDtBQUlIOzs7Ozs7OztRQ2pEZSxNLEdBQUEsTTtRQTBCQSxJLEdBQUEsSTtBQTFCVCxTQUFTLE1BQVQsQ0FBZ0IsU0FBaEIsRUFBMkI7QUFDOUIsUUFBSSxRQUFRLFVBQVUsTUFBVixDQUFpQixDQUFDLEdBQUQsRUFBTSxDQUFOLEtBQVksTUFBTSxDQUFuQyxDQUFaOztBQUVBLFFBQUksU0FBUyxDQUFiLEVBQWdCLE9BQU8sU0FBUDs7QUFFaEIsUUFBSSxXQUFXLENBQWY7QUFDQSxRQUFJLGVBQWUsQ0FBbkI7QUFDQSxRQUFJLFNBQVMsUUFBUSxDQUFyQjtBQUNBLFFBQUksaUJBQUo7O0FBRUEsV0FBTyxJQUFQLEVBQWE7QUFDVCxZQUFJLFVBQVUsUUFBVixJQUFzQixDQUExQixFQUE2QjtBQUN6QixnQkFBSSxhQUFhLFNBQWpCLEVBQTRCO0FBQ3hCLHVCQUFPLENBQUMsV0FBVyxRQUFaLElBQXdCLENBQS9CO0FBQ0g7QUFDRCw0QkFBZ0IsVUFBVSxRQUFWLENBQWhCO0FBQ0EsZ0JBQUksZUFBZSxNQUFuQixFQUEyQjtBQUN2Qix1QkFBTyxRQUFQO0FBQ0gsYUFGRCxNQUVPLElBQUksaUJBQWlCLE1BQXJCLEVBQTZCO0FBQ2hDLDJCQUFXLFFBQVg7QUFDSDtBQUNKO0FBQ0Q7QUFDSDtBQUNKOztBQUVNLFNBQVMsSUFBVCxDQUFjLFNBQWQsRUFBeUI7QUFDNUIsUUFBSSxRQUFRLENBQVo7QUFDQSxRQUFJLE1BQU0sQ0FBVjs7QUFFQSxTQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksVUFBVSxNQUE5QixFQUFzQyxHQUF0QyxFQUEyQztBQUN2QyxpQkFBUyxVQUFVLENBQVYsQ0FBVDtBQUNBLGVBQU8sVUFBVSxDQUFWLElBQWUsQ0FBdEI7QUFDSDs7QUFFRCxRQUFJLFNBQVMsQ0FBYixFQUFnQixPQUFPLFNBQVA7O0FBRWhCLFdBQU8sTUFBTSxLQUFiO0FBQ0g7Ozs7Ozs7O1FDcENlLGMsR0FBQSxjOztBQUZoQjs7Ozs7O0FBRU8sU0FBUyxjQUFULENBQXdCLE1BQXhCLEVBQWdDO0FBQ25DLFFBQUksZ0JBQUo7QUFBQSxRQUFhLGVBQWI7QUFDQSxRQUFJLE1BQU0sT0FBTixDQUFjLE1BQWQsQ0FBSixFQUEyQjtBQUN2QixZQUFJLE1BQU0sT0FBTixDQUFjLE9BQU8sQ0FBUCxDQUFkLENBQUosRUFBOEI7O0FBQzFCLGdCQUFLLENBQUMsT0FBTyxNQUFQLEdBQWdCLENBQWpCLE1BQXdCLENBQXpCLElBQWdDLENBQUMsT0FBTyxDQUFQLEVBQVUsTUFBVixHQUFtQixDQUFwQixNQUEyQixDQUEvRCxFQUNJLE1BQU0sSUFBSSxVQUFKLENBQWUsK0RBQWYsQ0FBTixDQURKLEtBRUs7QUFDRCwwQkFBVSxLQUFLLEtBQUwsQ0FBVyxPQUFPLE1BQVAsR0FBZ0IsQ0FBM0IsQ0FBVjtBQUNBLHlCQUFTLEtBQUssS0FBTCxDQUFXLE9BQU8sQ0FBUCxFQUFVLE1BQVYsR0FBbUIsQ0FBOUIsQ0FBVDtBQUNIO0FBQ0osU0FQRCxNQU9PO0FBQ0gsZ0JBQUksY0FBYyxLQUFLLElBQUwsQ0FBVSxPQUFPLE1BQWpCLENBQWxCO0FBQ0EsZ0JBQUkseUJBQVUsV0FBVixDQUFKLEVBQTRCO0FBQ3hCLHlCQUFTLFVBQVUsS0FBSyxLQUFMLENBQVcsS0FBSyxJQUFMLENBQVUsT0FBTyxNQUFqQixJQUEyQixDQUF0QyxDQUFuQjtBQUNILGFBRkQsTUFFTztBQUNILHNCQUFNLElBQUksVUFBSixDQUFlLGlEQUFmLENBQU47QUFDSDs7QUFFRCxnQkFBSSxZQUFZLElBQUksS0FBSixDQUFVLE1BQVYsQ0FBaEI7QUFDQSxpQkFBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLFdBQXBCLEVBQWlDLEdBQWpDLEVBQXNDO0FBQ2xDLDBCQUFVLENBQVYsSUFBZSxJQUFJLEtBQUosQ0FBVSxXQUFWLENBQWY7QUFDQSxxQkFBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLFdBQXBCLEVBQWlDLEdBQWpDLEVBQXNDO0FBQ2xDLDhCQUFVLENBQVYsRUFBYSxDQUFiLElBQWtCLE9BQU8sSUFBSSxXQUFKLEdBQWtCLENBQXpCLENBQWxCO0FBQ0g7QUFDSjtBQUNELHFCQUFTLFNBQVQ7QUFFSDtBQUNKLEtBMUJELE1BMEJPO0FBQ0gsY0FBTSxJQUFJLEtBQUosQ0FBVSxxQ0FBcUMsTUFBL0MsQ0FBTjtBQUNIO0FBQ0QsV0FBTyxFQUFDLGNBQUQsRUFBUyxjQUFULEVBQWlCLGdCQUFqQixFQUFQO0FBQ0g7Ozs7Ozs7O0FDbENNLElBQU0sa0RBQXFCLENBQzlCLENBQUMsQ0FBRCxFQUFLLENBQUwsRUFBUSxDQUFSLENBRDhCLEVBRTlCLENBQUMsQ0FBRCxFQUFJLENBQUMsQ0FBTCxFQUFRLENBQVIsQ0FGOEIsRUFHOUIsQ0FBQyxDQUFELEVBQUssQ0FBTCxFQUFRLENBQVIsQ0FIOEIsQ0FBM0I7O0FBTUEsSUFBTSxrREFBcUIsQ0FDOUIsQ0FBQyxDQUFELEVBQUssQ0FBTCxFQUFRLENBQVIsQ0FEOEIsRUFFOUIsQ0FBQyxDQUFELEVBQUksQ0FBQyxDQUFMLEVBQVEsQ0FBUixDQUY4QixFQUc5QixDQUFDLENBQUQsRUFBSyxDQUFMLEVBQVEsQ0FBUixDQUg4QixDQUEzQjs7QUFNQSxJQUFNLGtDQUFhLENBQ3RCLENBQUMsQ0FBQyxDQUFGLEVBQUssQ0FBTCxFQUFRLENBQUMsQ0FBVCxDQURzQixFQUV0QixDQUFDLENBQUMsQ0FBRixFQUFLLENBQUwsRUFBUSxDQUFDLENBQVQsQ0FGc0IsRUFHdEIsQ0FBQyxDQUFDLENBQUYsRUFBSyxDQUFMLEVBQVEsQ0FBQyxDQUFULENBSHNCLENBQW5COztBQU1BLElBQU0sa0NBQWEsQ0FDdEIsQ0FBQyxDQUFDLENBQUYsRUFBSyxDQUFDLENBQU4sRUFBUyxDQUFDLENBQVYsQ0FEc0IsRUFFdEIsQ0FBRSxDQUFGLEVBQU0sQ0FBTixFQUFVLENBQVYsQ0FGc0IsRUFHdEIsQ0FBQyxDQUFDLENBQUYsRUFBSyxDQUFDLENBQU4sRUFBUyxDQUFDLENBQVYsQ0FIc0IsQ0FBbkI7O0FBTUEsSUFBTSxnREFBb0IsQ0FDN0IsQ0FBQyxDQUFDLENBQUYsRUFBSyxDQUFDLENBQU4sRUFBVSxDQUFWLEVBQWMsQ0FBZCxFQUFrQixDQUFsQixDQUQ2QixFQUU3QixDQUFDLENBQUMsQ0FBRixFQUFLLENBQUMsQ0FBTixFQUFVLENBQVYsRUFBYyxDQUFkLEVBQWtCLENBQWxCLENBRjZCLEVBRzdCLENBQUUsQ0FBRixFQUFNLENBQU4sRUFBVSxDQUFWLEVBQWMsQ0FBZCxFQUFrQixDQUFsQixDQUg2QixFQUk3QixDQUFFLENBQUYsRUFBTSxDQUFOLEVBQVUsQ0FBVixFQUFhLENBQUMsQ0FBZCxFQUFpQixDQUFDLENBQWxCLENBSjZCLEVBSzdCLENBQUUsQ0FBRixFQUFNLENBQU4sRUFBVSxDQUFWLEVBQWEsQ0FBQyxDQUFkLEVBQWlCLENBQUMsQ0FBbEIsQ0FMNkIsQ0FBMUI7O0FBUUEsSUFBTSx3REFBd0IsQ0FDakMsQ0FBRSxDQUFGLEVBQU0sQ0FBTixFQUFVLENBQVYsRUFBYSxDQUFDLENBQWQsRUFBaUIsQ0FBQyxDQUFsQixDQURpQyxFQUVqQyxDQUFFLENBQUYsRUFBTSxDQUFOLEVBQVUsQ0FBVixFQUFhLENBQUMsQ0FBZCxFQUFpQixDQUFDLENBQWxCLENBRmlDLEVBR2pDLENBQUUsQ0FBRixFQUFNLENBQU4sRUFBVSxDQUFWLEVBQWMsQ0FBZCxFQUFrQixDQUFsQixDQUhpQyxFQUlqQyxDQUFDLENBQUMsQ0FBRixFQUFLLENBQUMsQ0FBTixFQUFVLENBQVYsRUFBYyxDQUFkLEVBQWtCLENBQWxCLENBSmlDLEVBS2pDLENBQUMsQ0FBQyxDQUFGLEVBQUssQ0FBQyxDQUFOLEVBQVUsQ0FBVixFQUFjLENBQWQsRUFBa0IsQ0FBbEIsQ0FMaUMsQ0FBOUI7Ozs7Ozs7O2tCQ2hDaUIsTTtBQUFULFNBQVMsTUFBVCxDQUFnQixLQUFoQixFQUF1QixNQUF2QixFQUErQixZQUEvQixFQUE2QztBQUN4RCxRQUFNLFNBQVMsSUFBSSxLQUFKLENBQVUsS0FBVixDQUFmO0FBQ0EsU0FBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLEtBQXBCLEVBQTJCLEdBQTNCLEVBQWdDO0FBQzVCLGVBQU8sQ0FBUCxJQUFZLElBQUksS0FBSixDQUFVLE1BQVYsQ0FBWjtBQUNIO0FBQ0QsUUFBSSxZQUFKLEVBQWtCO0FBQ2QsYUFBSyxJQUFJLEtBQUksQ0FBYixFQUFnQixLQUFJLEtBQXBCLEVBQTJCLElBQTNCLEVBQWdDO0FBQzVCLGlCQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksTUFBcEIsRUFBNEIsR0FBNUIsRUFBaUM7QUFDN0IsdUJBQU8sRUFBUCxFQUFVLENBQVYsSUFBZSxZQUFmO0FBQ0g7QUFDSjtBQUNKO0FBQ0QsV0FBTyxLQUFQLEdBQWUsS0FBZjtBQUNBLFdBQU8sTUFBUCxHQUFnQixNQUFoQjtBQUNBLFdBQU8sU0FBUCxHQUFtQixPQUFPLFNBQTFCO0FBQ0EsV0FBTyxNQUFQO0FBQ0g7O0FBRUQsT0FBTyxTQUFQLENBQWlCLFFBQWpCLEdBQTRCLFVBQVUsQ0FBVixFQUFhLENBQWIsRUFBZ0I7QUFDeEMsUUFBSSxNQUFNLEtBQUssQ0FBTCxFQUFRLENBQVIsQ0FBVjtBQUNBLFFBQUksV0FBVyxDQUFDLENBQUQsRUFBSSxDQUFKLENBQWY7QUFDQSxTQUFLLElBQUksSUFBSyxLQUFLLEdBQUwsQ0FBUyxDQUFULEVBQVksSUFBSSxDQUFoQixDQUFkLEVBQW1DLElBQUksS0FBSyxHQUFMLENBQVMsS0FBSyxNQUFkLEVBQXNCLElBQUksQ0FBMUIsQ0FBdkMsRUFBcUUsR0FBckUsRUFBMEU7QUFDdEUsYUFBSyxJQUFJLElBQUssS0FBSyxHQUFMLENBQVMsQ0FBVCxFQUFZLElBQUksQ0FBaEIsQ0FBZCxFQUFtQyxJQUFJLEtBQUssR0FBTCxDQUFTLEtBQUssQ0FBTCxFQUFRLE1BQWpCLEVBQXlCLElBQUksQ0FBN0IsQ0FBdkMsRUFBd0UsR0FBeEUsRUFBNkU7QUFDekUsZ0JBQUksS0FBSyxDQUFMLEVBQVEsQ0FBUixJQUFhLEdBQWpCLEVBQXNCO0FBQ2xCLHNCQUFNLEtBQUssQ0FBTCxFQUFRLENBQVIsQ0FBTjtBQUNBLDJCQUFXLENBQUMsQ0FBRCxFQUFJLENBQUosQ0FBWDtBQUNIO0FBQ0o7QUFDSjtBQUNELFdBQU87QUFDSCxrQkFBVSxRQURQO0FBRUgsZUFBTztBQUZKLEtBQVA7QUFJSCxDQWZEOztBQWlCQSxPQUFPLFNBQVAsQ0FBaUIsUUFBakIsR0FBNEIsVUFBVSxDQUFWLEVBQWEsQ0FBYixFQUFnQjtBQUN4QyxRQUFJLE1BQU0sS0FBSyxDQUFMLEVBQVEsQ0FBUixDQUFWO0FBQ0EsUUFBSSxXQUFXLENBQUMsQ0FBRCxFQUFJLENBQUosQ0FBZjtBQUNBLFNBQUssSUFBSSxJQUFLLEtBQUssR0FBTCxDQUFTLENBQVQsRUFBWSxJQUFJLENBQWhCLENBQWQsRUFBbUMsSUFBSSxLQUFLLEdBQUwsQ0FBUyxLQUFLLE1BQWQsRUFBc0IsSUFBSSxDQUExQixDQUF2QyxFQUFxRSxHQUFyRSxFQUEwRTtBQUN0RSxhQUFLLElBQUksSUFBSyxLQUFLLEdBQUwsQ0FBUyxDQUFULEVBQVksSUFBSSxDQUFoQixDQUFkLEVBQW1DLElBQUksS0FBSyxHQUFMLENBQVMsS0FBSyxDQUFMLEVBQVEsTUFBakIsRUFBeUIsSUFBSSxDQUE3QixDQUF2QyxFQUF3RSxHQUF4RSxFQUE2RTtBQUN6RSxnQkFBSSxLQUFLLENBQUwsRUFBUSxDQUFSLElBQWEsR0FBakIsRUFBc0I7QUFDbEIsc0JBQU0sS0FBSyxDQUFMLEVBQVEsQ0FBUixDQUFOO0FBQ0EsMkJBQVcsQ0FBQyxDQUFELEVBQUksQ0FBSixDQUFYO0FBQ0g7QUFDSjtBQUNKO0FBQ0QsV0FBTztBQUNILGtCQUFVLFFBRFA7QUFFSCxlQUFPO0FBRkosS0FBUDtBQUlILENBZkQ7O0FBaUJBLE9BQU8sU0FBUCxDQUFpQixXQUFqQixHQUErQixVQUFVLENBQVYsRUFBYSxDQUFiLEVBQWdCLEtBQWhCLEVBQXVCO0FBQ2xELFFBQUksVUFBVSxFQUFkO0FBQ0EsU0FBSyxJQUFJLElBQUssS0FBSyxHQUFMLENBQVMsQ0FBVCxFQUFZLElBQUksQ0FBaEIsQ0FBZCxFQUFtQyxJQUFJLEtBQUssR0FBTCxDQUFTLEtBQUssTUFBZCxFQUFzQixJQUFJLENBQTFCLENBQXZDLEVBQXFFLEdBQXJFLEVBQTBFO0FBQ3RFLGFBQUssSUFBSSxJQUFLLEtBQUssR0FBTCxDQUFTLENBQVQsRUFBWSxJQUFJLENBQWhCLENBQWQsRUFBbUMsSUFBSSxLQUFLLEdBQUwsQ0FBUyxLQUFLLENBQUwsRUFBUSxNQUFqQixFQUF5QixJQUFJLENBQTdCLENBQXZDLEVBQXdFLEdBQXhFLEVBQTZFO0FBQ3pFLGdCQUFJLEtBQUssQ0FBTCxFQUFRLENBQVIsTUFBZSxLQUFuQixFQUEwQjtBQUN0Qix3QkFBUSxJQUFSLENBQWEsQ0FBQyxDQUFELEVBQUksQ0FBSixDQUFiO0FBQ0g7QUFDSjtBQUNKO0FBQ0QsV0FBTyxPQUFQO0FBQ0gsQ0FWRDs7Ozs7Ozs7QUNwREEsSUFBSSxTQUFTLFFBQVEsV0FBUixDQUFiOztBQUdBLElBQUksUUFBUSxDQUNSLENBQUMsQ0FBRCxFQUFHLENBQUgsRUFBSyxDQUFMLEVBQU8sQ0FBUCxFQUFTLENBQVQsQ0FEUSxFQUVSLENBQUMsQ0FBRCxFQUFHLENBQUgsRUFBSyxDQUFMLEVBQU8sQ0FBUCxFQUFTLENBQVQsQ0FGUSxFQUdSLENBQUMsQ0FBRCxFQUFHLENBQUgsRUFBSyxDQUFMLEVBQU8sQ0FBUCxFQUFTLENBQVQsQ0FIUSxFQUlSLENBQUMsQ0FBRCxFQUFHLENBQUgsRUFBSyxDQUFMLEVBQU8sQ0FBUCxFQUFTLENBQVQsQ0FKUSxFQUtSLENBQUMsQ0FBRCxFQUFHLENBQUgsRUFBSyxDQUFMLEVBQU8sQ0FBUCxFQUFTLENBQVQsQ0FMUSxDQUFaOztBQVFBLElBQUksYUFBYSxDQUNiLENBQUMsQ0FBRCxFQUFHLENBQUgsRUFBSyxDQUFMLENBRGEsRUFFYixDQUFDLENBQUQsRUFBRyxDQUFILEVBQUssQ0FBTCxDQUZhLEVBR2IsQ0FBQyxDQUFELEVBQUcsQ0FBSCxFQUFLLENBQUwsQ0FIYSxDQUFqQjs7QUFTZSxNQUFNLEtBQU4sQ0FBWTtBQUN2QixrQkFBdUU7QUFBQSx5RUFBSixFQUFJOztBQUFBLDZCQUExRCxJQUEwRDtBQUFBLFlBQTFELElBQTBELDZCQUFuRCxPQUFtRDtBQUFBLFlBQTFDLEtBQTBDLFFBQTFDLEtBQTBDO0FBQUEsWUFBbkMsSUFBbUMsUUFBbkMsSUFBbUM7QUFBQSxZQUE3QixLQUE2QixRQUE3QixLQUE2QjtBQUFBLFlBQXRCLE1BQXNCLFFBQXRCLE1BQXNCO0FBQUEsWUFBZCxNQUFjLFFBQWQsTUFBYzs7QUFDbkUsWUFBSSxLQUFKLEVBQVcsT0FBTyxTQUFQO0FBQ1gsWUFBSSxJQUFKLEVBQVU7QUFDTixvQkFBUSxJQUFSO0FBQ0EscUJBQVMsSUFBVDtBQUNIO0FBQ0QsWUFBSyxTQUFTLE1BQU0sQ0FBaEIsSUFBdUIsVUFBVSxNQUFNLENBQTNDLEVBQStDO0FBQzNDLGtCQUFNLE1BQU0sb0RBQU4sQ0FBTjtBQUNIO0FBQ0QsWUFBSSxJQUFKLEVBQVU7QUFDTixvQkFBUSxJQUFSO0FBQ0kscUJBQUssT0FBTDtBQUNJLHlCQUFLLE1BQUwsR0FBYyxLQUFkO0FBQ0E7QUFDSixxQkFBSyxZQUFMO0FBQ0kseUJBQUssTUFBTCxHQUFjLFVBQWQ7QUFDQTtBQU5SO0FBUUEsaUJBQUssTUFBTCxHQUFjLEtBQUssTUFBTCxDQUFZLE1BQTFCO0FBQ0EsaUJBQUssS0FBTCxHQUFhLEtBQUssTUFBTCxDQUFZLENBQVosRUFBZSxNQUE1QjtBQUNBLGdCQUFLLEtBQUssTUFBTCxHQUFjLE1BQU0sQ0FBckIsSUFBNEIsS0FBSyxLQUFMLEdBQWEsTUFBTSxDQUFuRCxFQUF1RDtBQUNuRCxzQkFBTSxJQUFJLEtBQUosQ0FBVSwwQ0FBVixDQUFOO0FBQ0g7QUFDSixTQWRELE1BY087QUFDSCxvQkFBUSxLQUFSO0FBQ0kscUJBQUssUUFBTDtBQUNBLHFCQUFLLFdBQUw7QUFDSSx5QkFBSyxNQUFMLEdBQWMsVUFBVSxLQUFWLEVBQWlCLE1BQWpCLENBQWQ7QUFDQTtBQUNKLHFCQUFLLFFBQUw7QUFDQSxxQkFBSyxTQUFMO0FBQ0kseUJBQUssTUFBTCxHQUFjLFFBQVEsS0FBUixFQUFlLE1BQWYsQ0FBZDtBQUNBO0FBQ0oscUJBQUssVUFBTDtBQUNJLHlCQUFLLE1BQUwsR0FBYyxTQUFTLEtBQVQsRUFBZ0IsTUFBaEIsQ0FBZDtBQUNBO0FBQ0o7O0FBWko7QUFlSDs7QUFHRCxhQUFLLFVBQUwsR0FBbUIsS0FBSyxNQUFMLEdBQWMsQ0FBZixJQUFxQixDQUF2QztBQUNBLGFBQUssU0FBTCxHQUFrQixLQUFLLEtBQUwsR0FBYSxDQUFkLElBQW9CLENBQXJDO0FBQ0g7QUE3Q3NCOztrQkFBTixLO0FBZ0RyQixNQUFNLFNBQU4sQ0FBZ0IsU0FBaEIsR0FBNEIsWUFBWTtBQUNwQyxRQUFJLFNBQVMsS0FBSyxNQUFsQjtBQUNBLFFBQUksU0FBUyxJQUFJLEtBQUosQ0FBVSxPQUFPLElBQWpCLENBQWI7QUFDQSxRQUFJLFdBQVcsQ0FBZjtBQUNBLFNBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxPQUFPLE1BQTNCLEVBQW1DLEdBQW5DLEVBQXdDO0FBQ3BDLGFBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxPQUFPLENBQVAsRUFBVSxNQUE5QixFQUFzQyxHQUF0QyxFQUEyQztBQUN2QyxnQkFBSSxPQUFPLENBQVAsRUFBVSxDQUFWLENBQUosRUFBa0I7QUFDZCx1QkFBTyxVQUFQLElBQXFCLENBQUMsSUFBSSxLQUFLLFNBQVYsRUFBcUIsSUFBSSxLQUFLLFVBQTlCLENBQXJCO0FBQ0g7QUFDSjtBQUNKO0FBQ0QsV0FBTyxNQUFQO0FBQ0gsQ0FaRDs7QUFnQkEsU0FBUyxTQUFULENBQW1CLEtBQW5CLEVBQTBCLE1BQTFCLEVBQWtDO0FBQzlCLFFBQUksU0FBUyxPQUFPLEtBQVAsQ0FBYSxNQUFiLEVBQXFCLEtBQXJCLENBQWI7QUFDQSxTQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksTUFBcEIsRUFBNEIsR0FBNUIsRUFBaUM7QUFDN0IsYUFBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLEtBQXBCLEVBQTJCLEdBQTNCLEVBQWdDO0FBQzVCLG1CQUFPLENBQVAsRUFBVSxDQUFWLElBQWUsQ0FBZjtBQUNIO0FBQ0o7QUFDRCxXQUFPLE1BQVA7QUFDSDs7QUFFRCxTQUFTLE9BQVQsQ0FBaUIsS0FBakIsRUFBd0IsTUFBeEIsRUFBZ0M7QUFDNUIsUUFBSSxTQUFTLE9BQU8sS0FBUCxDQUFhLE1BQWIsRUFBcUIsS0FBckIsQ0FBYjtBQUNBLFFBQUksSUFBSSxLQUFLLEtBQUwsQ0FBVyxRQUFRLENBQW5CLENBQVI7QUFDQSxRQUFJLElBQUksS0FBSyxLQUFMLENBQVcsU0FBUyxDQUFwQixDQUFSO0FBQ0EsU0FBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLE1BQXBCLEVBQTRCLEdBQTVCLEVBQWlDO0FBQzdCLFlBQUksS0FBSyxLQUFLLEtBQUwsQ0FBVyxJQUFJLENBQWYsQ0FBVDtBQUNBLFlBQUksUUFBUSxLQUFLLEtBQUwsQ0FBVyxRQUFRLENBQVIsR0FBWSxLQUFLLElBQUwsQ0FBVSxDQUFDLElBQUksQ0FBSixHQUFRLENBQVIsR0FBWSxDQUFaLEdBQWdCLElBQUksQ0FBSixHQUFRLEVBQVIsR0FBYSxFQUE5QixJQUFvQyxDQUFwQyxHQUF3QyxDQUFsRCxDQUF2QixDQUFaO0FBQ0EsYUFBSyxJQUFJLElBQUksS0FBYixFQUFvQixJQUFLLFFBQVEsS0FBakMsRUFBeUMsR0FBekMsRUFBOEM7QUFDMUMsbUJBQU8sQ0FBUCxFQUFVLENBQVYsSUFBZSxDQUFmO0FBQ0g7QUFDSjtBQUNELFdBQU8sTUFBUDtBQUNIOztBQUVELFNBQVMsUUFBVCxDQUFrQixLQUFsQixFQUF5QixNQUF6QixFQUFpQztBQUM3QixRQUFJLFNBQVMsT0FBTyxLQUFQLENBQWEsTUFBYixFQUFxQixLQUFyQixDQUFiO0FBQ0EsU0FBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLE1BQXBCLEVBQTRCLEdBQTVCLEVBQWlDO0FBQzdCLFlBQUksUUFBUSxLQUFLLEtBQUwsQ0FBVyxDQUFDLElBQUksSUFBSSxNQUFULElBQW1CLEtBQW5CLEdBQTJCLENBQXRDLENBQVo7QUFDQSxhQUFLLElBQUksSUFBSSxLQUFiLEVBQW9CLElBQUssUUFBUSxLQUFqQyxFQUF5QyxHQUF6QyxFQUE4QztBQUMxQyxtQkFBTyxDQUFQLEVBQVUsQ0FBVixJQUFlLENBQWY7QUFDSDtBQUNKO0FBQ0QsV0FBTyxNQUFQO0FBQ0g7Ozs7Ozs7O1FDbEhlLGdCLEdBQUEsZ0I7O0FBSGhCOzs7O0FBQ0E7Ozs7OztBQUVPLFNBQVMsZ0JBQVQsQ0FBMEIsS0FBMUIsRUFBaUM7QUFDcEMsUUFBSSxDQUFDLE1BQU0sS0FBTixDQUFMLEVBQW1CO0FBQ2YsWUFBSSxTQUFTLENBQWIsRUFBZ0IsTUFBTSxJQUFJLEtBQUosQ0FBVSxvREFBVixDQUFOO0FBQ2hCLGVBQU8sS0FBUDtBQUNILEtBSEQsTUFHTztBQUNILFlBQUksZ0NBQUosRUFBNEI7QUFDeEIsbUJBQU8sTUFBTSxJQUFiO0FBQ0g7QUFDRCxZQUFJLENBQUMsMkJBQVEsS0FBUixDQUFMLEVBQXFCO0FBQ2pCLGtCQUFNLElBQUksS0FBSixDQUFVLHVFQUFWLENBQU47QUFDSDtBQUNELGVBQU8sS0FBUDtBQUNIO0FBQ0o7Ozs7Ozs7O2tCQ2R1QixNOztBQUZ4Qjs7Ozs7O0FBRWUsU0FBUyxNQUFULENBQWdCLE1BQWhCLEVBQXdCO0FBQ25DLFdBQU8sWUFBUCxDQUFvQixZQUFwQjtBQUNIOzs7Ozs7Ozs7QUNKRDs7OztBQUNBOzs7Ozs7QUFFQSxJQUFNLGlCQUFpQjtBQUNuQixnQkFBWTtBQUNSLG9CQUFZLFlBREo7QUFFUix1QkFBZSxFQUFDLFFBQVEsQ0FBVCxFQUFZLFVBQVUsQ0FBdEI7QUFGUCxLQURPO0FBS25CLGVBQVcsSUFMUTtBQU1uQixTQUFLO0FBQ0Qsb0JBQVksR0FEWDtBQUVELGtCQUFVO0FBRlQsS0FOYztBQVVuQixjQUFVLEVBVlM7QUFXbkIsYUFBUztBQVhVLENBQXZCOztBQWNBLFNBQVMsR0FBVCxDQUFhLEtBQWIsRUFBb0IsT0FBcEIsRUFBNkIsTUFBN0IsRUFBcUM7QUFDakMsY0FBVSxzQkFBTyxFQUFQLEVBQVcsY0FBWCxFQUEyQixPQUEzQixDQUFWO0FBQ0EsUUFBTSxVQUFVLEtBQUssT0FBckI7QUFDQSxRQUFJLE1BQU0sT0FBTixDQUFjLEtBQWQsQ0FBSixFQUEwQjtBQUN0QixlQUFPLFFBQVEsR0FBUixDQUFZLE1BQU0sR0FBTixDQUFVLFVBQVUsR0FBVixFQUFlO0FBQ3hDLGdCQUFNLE1BQU0sUUFBUSxPQUFSLEVBQWlCLEdBQWpCLEVBQXNCLE9BQXRCLENBQVo7QUFDQSxnQkFBSSxPQUFPLE1BQVAsS0FBa0IsVUFBdEIsRUFBa0M7QUFDOUIsb0JBQUksSUFBSixDQUFTLE1BQVQ7QUFDSDtBQUNELG1CQUFPLEdBQVA7QUFDSCxTQU5rQixDQUFaLENBQVA7QUFPSCxLQVJELE1BUU87QUFDSCxlQUFPLFFBQVEsT0FBUixFQUFpQixLQUFqQixFQUF3QixPQUF4QixDQUFQO0FBQ0g7QUFDSjs7QUFFRCxTQUFTLE9BQVQsQ0FBaUIsT0FBakIsRUFBMEIsS0FBMUIsRUFBaUMsT0FBakMsRUFBMEM7QUFDdEMsV0FBTyxRQUFRLElBQVIsQ0FBYSxNQUFiLEVBQXFCLENBQUMsS0FBRCxFQUFRLE9BQVIsQ0FBckIsRUFBdUMsSUFBdkMsQ0FBNEMsVUFBVSxRQUFWLEVBQW9CO0FBQ25FLGFBQUssSUFBSSxDQUFULElBQWMsUUFBZCxFQUF3QjtBQUNwQixxQkFBUyxDQUFULElBQWMsb0JBQVUsU0FBUyxDQUFULENBQVYsQ0FBZDtBQUNIO0FBQ0QsZUFBTyxRQUFQO0FBQ0gsS0FMTSxDQUFQO0FBTUg7O0FBRUQsU0FBUyxJQUFULEdBQWdCO0FBQ1osV0FBTyxFQUFQLENBQVUsTUFBVixFQUFrQixVQUFVLElBQVYsRUFBZ0IsS0FBaEIsRUFBdUIsT0FBdkIsRUFBZ0M7QUFDOUMsZ0JBQVEsSUFBSSxHQUFKLENBQVEsS0FBUixDQUFSO0FBQ0EsWUFBTSxTQUFTLEVBQWY7QUFDQSxZQUFNLGFBQWEsRUFBbkI7O0FBRUEsWUFBTSxPQUFPLE1BQU0sSUFBTixFQUFiOztBQUVBLFlBQU0sUUFBUSxLQUFLLFdBQUwsRUFBZDtBQUNBLHFCQUFhLE9BQWIsRUFBc0IsS0FBdEI7O0FBRUEsWUFBTSxPQUFPLE1BQU0sS0FBTixHQUFjLElBQWQsQ0FBbUIsRUFBQyxXQUFXLFFBQVEsU0FBcEIsRUFBbkIsQ0FBYjtBQUNBLHFCQUFhLE1BQWIsRUFBcUIsSUFBckI7O0FBRUEsWUFBTSxhQUFhLE1BQU0sYUFBTixFQUFuQjtBQUNBLG1CQUFXLE9BQVgsQ0FBbUIsSUFBbkI7QUFDQSxZQUFNLFdBQVcsV0FBVyxPQUFYLENBQW1CLFFBQVEsR0FBM0IsQ0FBakI7QUFDQSxxQkFBYSxVQUFiLEVBQXlCLFFBQXpCOztBQUVBLFlBQU0sU0FBUyxLQUFLLGFBQUwsQ0FBbUI7QUFDOUIsc0JBQVUsUUFBUSxRQURZO0FBRTlCLGtCQUFNO0FBRndCLFNBQW5CLENBQWY7O0FBS0EsWUFBTSxhQUFhLE1BQU0sYUFBTixDQUFvQixPQUFPLEdBQTNCLEVBQWdDLE9BQU8sRUFBdkMsRUFBMkMsUUFBUSxVQUFuRCxDQUFuQjtBQUNBLHFCQUFhLFlBQWIsRUFBMkIsVUFBM0I7O0FBRUEsWUFBTSxZQUFZLE1BQU0sUUFBTixDQUFlLFVBQWYsQ0FBbEI7O0FBRUEsZUFBTyxNQUFQLEdBQWdCLFNBQWhCO0FBQ0EsbUJBQVcsSUFBWCxDQUFnQixVQUFVLElBQVYsQ0FBZSxNQUEvQjtBQUNBLGFBQUssTUFBTCxFQUFhLFVBQWI7O0FBRUEsaUJBQVMsWUFBVCxDQUFzQixJQUF0QixFQUE0QixLQUE1QixFQUFtQztBQUMvQixnQkFBSSxRQUFRLE9BQVIsQ0FBZ0IsT0FBaEIsQ0FBd0IsSUFBeEIsTUFBa0MsQ0FBQyxDQUF2QyxFQUEwQztBQUN0Qyx1QkFBTyxJQUFQLElBQWUsS0FBZjtBQUNBLDJCQUFXLElBQVgsQ0FBZ0IsTUFBTSxJQUFOLENBQVcsTUFBM0I7QUFDSDtBQUNKO0FBQ0osS0F0Q0Q7QUF1Q0g7O2tCQUVjLEVBQUMsUUFBRCxFQUFNLFVBQU4sRTs7Ozs7Ozs7O0FDcEZmOzs7O0FBQ0E7Ozs7QUFDQTs7Ozs7O0FBRUEsTUFBTSxNQUFOLENBQWE7QUFDVCxrQkFBYztBQUNWLGFBQUssSUFBTCxHQUFZLElBQVo7QUFDQSxhQUFLLEtBQUwsR0FBYSxDQUFDLElBQUQsQ0FBYjtBQUNIO0FBQ0QsZUFBVztBQUNQLFlBQUksS0FBSyxJQUFMLEtBQWMsSUFBbEIsRUFBd0I7QUFDcEIsa0JBQU0sSUFBSSxLQUFKLENBQVUsOENBQVYsQ0FBTjtBQUNIO0FBQ0o7QUFDRCxRQUFJLEdBQUosR0FBVTtBQUNOLGVBQU8sS0FBSyxJQUFaO0FBQ0g7QUFDRCxRQUFJLEdBQUosQ0FBUSxLQUFSLEVBQWU7QUFDWCxZQUFJLE9BQU8sS0FBUCxLQUFpQixRQUFyQixFQUErQjtBQUMzQixrQkFBTSxJQUFJLFNBQUosQ0FBYyw2QkFBZCxDQUFOO0FBQ0g7QUFDRCxhQUFLLElBQUwsR0FBWSxLQUFaO0FBQ0EsYUFBSyxLQUFMLENBQVcsQ0FBWCxJQUFnQixLQUFoQjtBQUNIO0FBQ0QsV0FBTyxZQUFQLENBQW9CLElBQXBCLEVBQTBCLE1BQTFCLEVBQWtDO0FBQzlCLFlBQUksZ0JBQUo7QUFDQSxZQUFJLFlBQUo7QUFDQSxZQUFJLFNBQVMsRUFBYjtBQUNBLGlCQUFTLEdBQVQsR0FBc0I7QUFBQTs7QUFDbEIsZ0JBQUksQ0FBQyxPQUFMLEVBQWM7QUFDVixxQkFBSyxRQUFMO0FBQ0Esc0JBQU0sS0FBSyxHQUFYO0FBQ0EsMEJBQVUsK0JBQWtCLE9BQU8sSUFBekIsRUFBK0IsRUFBQyxNQUFNLEdBQVAsRUFBL0IsQ0FBVjtBQUNBLHVCQUFPLE9BQVAsR0FBaUIsT0FBakI7QUFDSDs7QUFOaUIsOENBQU4sSUFBTTtBQUFOLG9CQUFNO0FBQUE7O0FBT2xCLG1CQUFPLHNCQUFPLEdBQVAsRUFBVyxJQUFYLHFCQUFnQixNQUFoQixTQUEyQixJQUEzQixFQUFQO0FBQ0g7QUFDRCxZQUFJLEtBQUosR0FBWSxZQUFZO0FBQ3BCLGdCQUFJLE9BQUosRUFBYTtBQUNULHdCQUFRLFNBQVI7QUFDQSwwQkFBVSwrQkFBa0IsT0FBTyxJQUF6QixFQUErQixFQUFDLE1BQU0sR0FBUCxFQUEvQixDQUFWO0FBQ0EsdUJBQU8sT0FBUCxHQUFpQixPQUFqQjtBQUNIO0FBQ0osU0FORDtBQU9BLGVBQU8sU0FBUCxDQUFpQixJQUFqQixJQUF5QixHQUF6QjtBQUNIO0FBekNROztBQTRDYixzQkFBTyxNQUFQOztrQkFFZSxJQUFJLE1BQUosRTs7O0FDbERmOztBQUVBOzs7O0FBQ0E7Ozs7QUFFQSxPQUFPLE1BQVA7QUFDQSxPQUFPLE9BQVA7O0FBRUEsSUFBSSxPQUFPLFNBQVg7O0FBRUEsT0FBTyxJQUFQLEdBQWMsU0FBUyxJQUFULENBQWMsSUFBZCxFQUFvQjtBQUM5QixXQUFPLGNBQU0sSUFBTixDQUFXLE9BQU8sSUFBbEIsQ0FBUDtBQUNILENBRkQ7O0FBSUEsSUFBSSxPQUFPLFNBQVMsY0FBVCxDQUF3QixNQUF4QixDQUFYO0FBQ0EsT0FBTyxPQUFQLEdBQWlCLFNBQVMsT0FBVCxDQUFpQixHQUFqQixFQUFzQjtBQUNuQyxTQUFLLFNBQUwsR0FBaUIsRUFBakI7QUFDQSxTQUFLLFdBQUwsQ0FBaUIsSUFBSSxTQUFKLEVBQWpCO0FBQ0gsQ0FIRDs7QUFLQSxJQUFJLFFBQVEsU0FBUyxjQUFULENBQXdCLE9BQXhCLENBQVo7QUFDQSxPQUFPLFFBQVAsR0FBa0IsU0FBUyxRQUFULENBQWtCLEdBQWxCLEVBQXVCO0FBQ3JDLFVBQU0sU0FBTixHQUFrQixFQUFsQjtBQUNBLFVBQU0sV0FBTixDQUFrQixJQUFJLFNBQUosRUFBbEI7QUFDSCxDQUhEOztBQUtBLE9BQU8sT0FBUDs7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzFEQTs7QUFFQSxJQUFJLE9BQU8sUUFBUSxNQUFSLENBQVg7QUFDQSxJQUFJLFNBQVMsUUFBUSxRQUFSLEVBQWtCLE1BQS9COztBQUVBLFFBQVEsU0FBUixHQUFvQixRQUFRLGdCQUFSLENBQXBCOztBQUVBLFFBQVEsUUFBUixHQUFtQixTQUFTLFFBQVQsQ0FBa0IsSUFBbEIsRUFBd0I7QUFDdkMsV0FBTyxLQUFLLE9BQUwsQ0FBYSxTQUFiLEVBQXdCLEtBQXhCLEVBQStCLElBQS9CLENBQVA7QUFDSCxDQUZEOztBQUlBLFFBQVEsT0FBUixHQUFrQixTQUFTLE9BQVQsQ0FBaUIsR0FBakIsRUFBc0I7QUFDcEMsUUFBSSxDQUFDLElBQUksTUFBVCxFQUFpQjtBQUNiLGNBQU0sSUFBSSxJQUFWO0FBQ0g7QUFDRCxRQUFJLE1BQU0sSUFBSSxNQUFKLEVBQVY7QUFDQSxRQUFJLE1BQUosQ0FBVyxHQUFYO0FBQ0EsV0FBTyxJQUFJLE1BQUosQ0FBVyxLQUFYLENBQVA7QUFDSCxDQVBEIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gX2F0b2Ioc3RyKSB7XG4gIHJldHVybiBhdG9iKHN0cilcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKemIzVnlZMlZ6SWpwYlhTd2libUZ0WlhNaU9sdGRMQ0p0WVhCd2FXNW5jeUk2SWlJc0ltWnBiR1VpT2lKZlpXMXdkSGt1YW5NaUxDSnpiM1Z5WTJWelEyOXVkR1Z1ZENJNlcxMTkiLCIndXNlIHN0cmljdCc7XG5cbnZhciBoYXNPd24gPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIHRvU3RyID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxudmFyIGlzQXJyYXkgPSBmdW5jdGlvbiBpc0FycmF5KGFycikge1xuXHRpZiAodHlwZW9mIEFycmF5LmlzQXJyYXkgPT09ICdmdW5jdGlvbicpIHtcblx0XHRyZXR1cm4gQXJyYXkuaXNBcnJheShhcnIpO1xuXHR9XG5cblx0cmV0dXJuIHRvU3RyLmNhbGwoYXJyKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG5cbnZhciBpc1BsYWluT2JqZWN0ID0gZnVuY3Rpb24gaXNQbGFpbk9iamVjdChvYmopIHtcblx0aWYgKCFvYmogfHwgdG9TdHIuY2FsbChvYmopICE9PSAnW29iamVjdCBPYmplY3RdJykge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdHZhciBoYXNPd25Db25zdHJ1Y3RvciA9IGhhc093bi5jYWxsKG9iaiwgJ2NvbnN0cnVjdG9yJyk7XG5cdHZhciBoYXNJc1Byb3RvdHlwZU9mID0gb2JqLmNvbnN0cnVjdG9yICYmIG9iai5jb25zdHJ1Y3Rvci5wcm90b3R5cGUgJiYgaGFzT3duLmNhbGwob2JqLmNvbnN0cnVjdG9yLnByb3RvdHlwZSwgJ2lzUHJvdG90eXBlT2YnKTtcblx0Ly8gTm90IG93biBjb25zdHJ1Y3RvciBwcm9wZXJ0eSBtdXN0IGJlIE9iamVjdFxuXHRpZiAob2JqLmNvbnN0cnVjdG9yICYmICFoYXNPd25Db25zdHJ1Y3RvciAmJiAhaGFzSXNQcm90b3R5cGVPZikge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdC8vIE93biBwcm9wZXJ0aWVzIGFyZSBlbnVtZXJhdGVkIGZpcnN0bHksIHNvIHRvIHNwZWVkIHVwLFxuXHQvLyBpZiBsYXN0IG9uZSBpcyBvd24sIHRoZW4gYWxsIHByb3BlcnRpZXMgYXJlIG93bi5cblx0dmFyIGtleTtcblx0Zm9yIChrZXkgaW4gb2JqKSB7LyoqL31cblxuXHRyZXR1cm4gdHlwZW9mIGtleSA9PT0gJ3VuZGVmaW5lZCcgfHwgaGFzT3duLmNhbGwob2JqLCBrZXkpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBleHRlbmQoKSB7XG5cdHZhciBvcHRpb25zLCBuYW1lLCBzcmMsIGNvcHksIGNvcHlJc0FycmF5LCBjbG9uZSxcblx0XHR0YXJnZXQgPSBhcmd1bWVudHNbMF0sXG5cdFx0aSA9IDEsXG5cdFx0bGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCxcblx0XHRkZWVwID0gZmFsc2U7XG5cblx0Ly8gSGFuZGxlIGEgZGVlcCBjb3B5IHNpdHVhdGlvblxuXHRpZiAodHlwZW9mIHRhcmdldCA9PT0gJ2Jvb2xlYW4nKSB7XG5cdFx0ZGVlcCA9IHRhcmdldDtcblx0XHR0YXJnZXQgPSBhcmd1bWVudHNbMV0gfHwge307XG5cdFx0Ly8gc2tpcCB0aGUgYm9vbGVhbiBhbmQgdGhlIHRhcmdldFxuXHRcdGkgPSAyO1xuXHR9IGVsc2UgaWYgKCh0eXBlb2YgdGFyZ2V0ICE9PSAnb2JqZWN0JyAmJiB0eXBlb2YgdGFyZ2V0ICE9PSAnZnVuY3Rpb24nKSB8fCB0YXJnZXQgPT0gbnVsbCkge1xuXHRcdHRhcmdldCA9IHt9O1xuXHR9XG5cblx0Zm9yICg7IGkgPCBsZW5ndGg7ICsraSkge1xuXHRcdG9wdGlvbnMgPSBhcmd1bWVudHNbaV07XG5cdFx0Ly8gT25seSBkZWFsIHdpdGggbm9uLW51bGwvdW5kZWZpbmVkIHZhbHVlc1xuXHRcdGlmIChvcHRpb25zICE9IG51bGwpIHtcblx0XHRcdC8vIEV4dGVuZCB0aGUgYmFzZSBvYmplY3Rcblx0XHRcdGZvciAobmFtZSBpbiBvcHRpb25zKSB7XG5cdFx0XHRcdHNyYyA9IHRhcmdldFtuYW1lXTtcblx0XHRcdFx0Y29weSA9IG9wdGlvbnNbbmFtZV07XG5cblx0XHRcdFx0Ly8gUHJldmVudCBuZXZlci1lbmRpbmcgbG9vcFxuXHRcdFx0XHRpZiAodGFyZ2V0ICE9PSBjb3B5KSB7XG5cdFx0XHRcdFx0Ly8gUmVjdXJzZSBpZiB3ZSdyZSBtZXJnaW5nIHBsYWluIG9iamVjdHMgb3IgYXJyYXlzXG5cdFx0XHRcdFx0aWYgKGRlZXAgJiYgY29weSAmJiAoaXNQbGFpbk9iamVjdChjb3B5KSB8fCAoY29weUlzQXJyYXkgPSBpc0FycmF5KGNvcHkpKSkpIHtcblx0XHRcdFx0XHRcdGlmIChjb3B5SXNBcnJheSkge1xuXHRcdFx0XHRcdFx0XHRjb3B5SXNBcnJheSA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0XHRjbG9uZSA9IHNyYyAmJiBpc0FycmF5KHNyYykgPyBzcmMgOiBbXTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdGNsb25lID0gc3JjICYmIGlzUGxhaW5PYmplY3Qoc3JjKSA/IHNyYyA6IHt9O1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvLyBOZXZlciBtb3ZlIG9yaWdpbmFsIG9iamVjdHMsIGNsb25lIHRoZW1cblx0XHRcdFx0XHRcdHRhcmdldFtuYW1lXSA9IGV4dGVuZChkZWVwLCBjbG9uZSwgY29weSk7XG5cblx0XHRcdFx0XHQvLyBEb24ndCBicmluZyBpbiB1bmRlZmluZWQgdmFsdWVzXG5cdFx0XHRcdFx0fSBlbHNlIGlmICh0eXBlb2YgY29weSAhPT0gJ3VuZGVmaW5lZCcpIHtcblx0XHRcdFx0XHRcdHRhcmdldFtuYW1lXSA9IGNvcHk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gUmV0dXJuIHRoZSBtb2RpZmllZCBvYmplY3Rcblx0cmV0dXJuIHRhcmdldDtcbn07XG5cbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgSU9CdWZmZXIgPSByZXF1aXJlKCdpb2J1ZmZlcicpO1xuY29uc3QgSW5mbGF0b3IgPSByZXF1aXJlKCdwYWtvJykuSW5mbGF0ZTtcblxuY29uc3QgZW1wdHkgPSBuZXcgVWludDhBcnJheSgwKTtcbmNvbnN0IE5VTEwgPSAnXFwwJztcbmNvbnN0IHBuZ1NpZ25hdHVyZSA9IFsxMzcsIDgwLCA3OCwgNzEsIDEzLCAxMCwgMjYsIDEwXTtcblxuY2xhc3MgUE5HRGVjb2RlciBleHRlbmRzIElPQnVmZmVyIHtcbiAgICBjb25zdHJ1Y3RvcihkYXRhKSB7XG4gICAgICAgIHN1cGVyKGRhdGEpO1xuICAgICAgICB0aGlzLl9kZWNvZGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2luZmxhdG9yID0gbmV3IEluZmxhdG9yKCk7XG4gICAgICAgIHRoaXMuX3BuZyA9IG51bGw7XG4gICAgICAgIHRoaXMuX2VuZCA9IGZhbHNlO1xuICAgICAgICAvLyBQTkcgaXMgYWx3YXlzIGJpZyBlbmRpYW5cbiAgICAgICAgLy8gaHR0cDovL3d3dy53My5vcmcvVFIvUE5HLyM3SW50ZWdlcnMtYW5kLWJ5dGUtb3JkZXJcbiAgICAgICAgdGhpcy5zZXRCaWdFbmRpYW4oKTtcbiAgICB9XG5cbiAgICBkZWNvZGUoKSB7XG4gICAgICAgIGlmICh0aGlzLl9kZWNvZGVkKSByZXR1cm4gdGhpcy5fcG5nO1xuICAgICAgICB0aGlzLl9wbmcgPSB7XG4gICAgICAgICAgICB0RVh0OiB7fVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmRlY29kZVNpZ25hdHVyZSgpO1xuICAgICAgICB3aGlsZSAoIXRoaXMuX2VuZCkge1xuICAgICAgICAgICAgdGhpcy5kZWNvZGVDaHVuaygpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGVjb2RlSW1hZ2UoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BuZztcbiAgICB9XG5cbiAgICAvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9QTkcvIzVQTkctZmlsZS1zaWduYXR1cmVcbiAgICBkZWNvZGVTaWduYXR1cmUoKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgODsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5yZWFkVWludDgoKSAhPT0gcG5nU2lnbmF0dXJlW2ldKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBXcm9uZyBQTkcgc2lnbmF0dXJlLiBCeXRlIGF0ICR7aX0gc2hvdWxkIGJlICR7cG5nU2lnbmF0dXJlW2ldfS5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL1BORy8jNUNodW5rLWxheW91dFxuICAgIGRlY29kZUNodW5rKCkge1xuICAgICAgICB2YXIgbGVuZ3RoID0gdGhpcy5yZWFkVWludDMyKCk7XG4gICAgICAgIHZhciB0eXBlID0gdGhpcy5yZWFkQ2hhcnMoNCk7XG4gICAgICAgIHZhciBvZmZzZXQgPSB0aGlzLm9mZnNldDtcbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICBjYXNlICdJSERSJzpcbiAgICAgICAgICAgICAgICB0aGlzLmRlY29kZUlIRFIoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ1BMVEUnOlxuICAgICAgICAgICAgICAgIHRoaXMuZGVjb2RlUExURShsZW5ndGgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnSURBVCc6XG4gICAgICAgICAgICAgICAgdGhpcy5kZWNvZGVJREFUKGxlbmd0aCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICd0RVh0JzpcbiAgICAgICAgICAgICAgICB0aGlzLmRlY29kZXRFWHQobGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ0lFTkQnOlxuICAgICAgICAgICAgICAgIHRoaXMuX2VuZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRoaXMuc2tpcChsZW5ndGgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm9mZnNldCAtIG9mZnNldCAhPT0gbGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0xlbmd0aCBtaXNtYXRjaCB3aGlsZSBkZWNvZGluZyBjaHVuayAnICsgdHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVE9ETyBjb21wdXRlIGFuZCB2YWxpZGF0ZSBDUkMgP1xuICAgICAgICAvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9QTkcvIzVDUkMtYWxnb3JpdGhtXG4gICAgICAgIHZhciBjcmMgPSB0aGlzLnJlYWRVaW50MzIoKTtcbiAgICB9XG5cbiAgICAvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9QTkcvIzExSUhEUlxuICAgIGRlY29kZUlIRFIoKSB7XG4gICAgICAgIHZhciBpbWFnZSA9IHRoaXMuX3BuZztcbiAgICAgICAgaW1hZ2Uud2lkdGggPSB0aGlzLnJlYWRVaW50MzIoKTtcbiAgICAgICAgaW1hZ2UuaGVpZ2h0ID0gdGhpcy5yZWFkVWludDMyKCk7XG4gICAgICAgIGltYWdlLmJpdERlcHRoID0gdGhpcy5yZWFkVWludDgoKTtcbiAgICAgICAgaW1hZ2UuY29sb3VyVHlwZSA9IHRoaXMucmVhZFVpbnQ4KCk7XG4gICAgICAgIGltYWdlLmNvbXByZXNzaW9uTWV0aG9kID0gdGhpcy5yZWFkVWludDgoKTtcbiAgICAgICAgaW1hZ2UuZmlsdGVyTWV0aG9kID0gdGhpcy5yZWFkVWludDgoKTtcbiAgICAgICAgaW1hZ2UuaW50ZXJsYWNlTWV0aG9kID0gdGhpcy5yZWFkVWludDgoKTtcbiAgICAgICAgaWYgKHRoaXMuX3BuZy5jb21wcmVzc2lvbk1ldGhvZCAhPT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBjb21wcmVzc2lvbiBtZXRob2Q6ICcgKyBpbWFnZS5jb21wcmVzc2lvbk1ldGhvZCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgLy8gaHR0cHM6Ly93d3cudzMub3JnL1RSL1BORy8jMTFQTFRFXG4gICAgZGVjb2RlUExURShsZW5ndGgpIHtcbiAgICAgICAgaWYgKGxlbmd0aCAlIDMgIT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdQTFRFIGZpZWxkIGxlbmd0aCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMy4gR290ICcgKyBsZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBsID0gbGVuZ3RoIC8gMztcbiAgICAgICAgdGhpcy5faGFzUGFsZXR0ZSA9IHRydWU7XG4gICAgICAgIHZhciBwYWxldHRlID0gdGhpcy5fcGFsZXR0ZSA9IG5ldyBBcnJheShsKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIHBhbGV0dGVbaV0gPSBbdGhpcy5yZWFkVWludDgoKSwgdGhpcy5yZWFkVWludDgoKSwgdGhpcy5yZWFkVWludDgoKV07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9QTkcvIzExSURBVFxuICAgIGRlY29kZUlEQVQobGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuX2luZmxhdG9yLnB1c2gobmV3IFVpbnQ4QXJyYXkodGhpcy5idWZmZXIsIHRoaXMub2Zmc2V0LCBsZW5ndGgpKTtcbiAgICAgICAgdGhpcy5za2lwKGxlbmd0aCk7XG4gICAgfVxuXG4gICAgLy8gaHR0cDovL3d3dy53My5vcmcvVFIvUE5HLyMxMXRFWHRcbiAgICBkZWNvZGV0RVh0KGxlbmd0aCkge1xuICAgICAgICB2YXIga2V5d29yZCA9ICcnO1xuICAgICAgICB2YXIgY2hhcjtcbiAgICAgICAgd2hpbGUgKChjaGFyID0gdGhpcy5yZWFkQ2hhcigpKSAhPT0gTlVMTCkge1xuICAgICAgICAgICAga2V5d29yZCArPSBjaGFyO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3BuZy50RVh0W2tleXdvcmRdID0gdGhpcy5yZWFkQ2hhcnMobGVuZ3RoIC0ga2V5d29yZC5sZW5ndGggLSAxKTtcbiAgICB9XG5cbiAgICBkZWNvZGVJbWFnZSgpIHtcbiAgICAgICAgdGhpcy5faW5mbGF0b3IucHVzaChlbXB0eSwgdHJ1ZSk7XG4gICAgICAgIGlmICh0aGlzLl9pbmZsYXRvci5lcnIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXJyb3Igd2hpbGUgZGVjb21wcmVzc2luZyB0aGUgZGF0YScpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBkYXRhID0gdGhpcy5faW5mbGF0b3IucmVzdWx0O1xuICAgICAgICB0aGlzLl9pbmZsYXRvciA9IG51bGw7XG5cbiAgICAgICAgaWYgKHRoaXMuX3BuZy5maWx0ZXJNZXRob2QgIT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRmlsdGVyIG1ldGhvZCAnICsgdGhpcy5fcG5nLmZpbHRlck1ldGhvZCArICcgbm90IHN1cHBvcnRlZCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX3BuZy5pbnRlcmxhY2VNZXRob2QgPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuZGVjb2RlSW50ZXJsYWNlTnVsbChkYXRhKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW50ZXJsYWNlIG1ldGhvZCAnICsgdGhpcy5fcG5nLmludGVybGFjZU1ldGhvZCArICcgbm90IHN1cHBvcnRlZCcpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZGVjb2RlSW50ZXJsYWNlTnVsbChkYXRhKSB7XG5cbiAgICAgICAgdmFyIGNoYW5uZWxzO1xuICAgICAgICBzd2l0Y2ggKHRoaXMuX3BuZy5jb2xvdXJUeXBlKSB7XG4gICAgICAgICAgICBjYXNlIDA6IGNoYW5uZWxzID0gMTsgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDI6IGNoYW5uZWxzID0gMzsgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9oYXNQYWxldHRlKSB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgcGFsZXR0ZScpO1xuICAgICAgICAgICAgICAgIGNoYW5uZWxzID0gMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgNDogY2hhbm5lbHMgPSAyOyBicmVhaztcbiAgICAgICAgICAgIGNhc2UgNjogY2hhbm5lbHMgPSA0OyBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6IHRocm93IG5ldyBFcnJvcignVW5rbm93biBjb2xvdXIgdHlwZTogJyArIHRoaXMuX3BuZy5jb2xvdXJUeXBlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGhlaWdodCA9IHRoaXMuX3BuZy5oZWlnaHQ7XG4gICAgICAgIGNvbnN0IGJ5dGVzUGVyUGl4ZWwgPSBjaGFubmVscyAqIHRoaXMuX3BuZy5iaXREZXB0aCAvIDg7XG4gICAgICAgIGNvbnN0IGJ5dGVzUGVyTGluZSA9IHRoaXMuX3BuZy53aWR0aCAqIGJ5dGVzUGVyUGl4ZWw7XG4gICAgICAgIGNvbnN0IG5ld0RhdGEgPSBuZXcgVWludDhBcnJheSh0aGlzLl9wbmcuaGVpZ2h0ICogYnl0ZXNQZXJMaW5lKTtcblxuICAgICAgICB2YXIgcHJldkxpbmUgPSBlbXB0eTtcbiAgICAgICAgdmFyIG9mZnNldCA9IDA7XG4gICAgICAgIHZhciBjdXJyZW50TGluZSwgbmV3TGluZTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhlaWdodDsgaSsrKSB7XG4gICAgICAgICAgICBjdXJyZW50TGluZSA9IGRhdGEuc3ViYXJyYXkob2Zmc2V0ICsgMSwgb2Zmc2V0ICsgMSArIGJ5dGVzUGVyTGluZSk7XG4gICAgICAgICAgICBuZXdMaW5lID0gbmV3RGF0YS5zdWJhcnJheShpICogYnl0ZXNQZXJMaW5lLCAoaSArIDEpICogYnl0ZXNQZXJMaW5lKTtcbiAgICAgICAgICAgIHN3aXRjaCAoZGF0YVtvZmZzZXRdKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICB1bmZpbHRlck5vbmUoY3VycmVudExpbmUsIG5ld0xpbmUsIGJ5dGVzUGVyTGluZSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgdW5maWx0ZXJTdWIoY3VycmVudExpbmUsIG5ld0xpbmUsIGJ5dGVzUGVyTGluZSwgYnl0ZXNQZXJQaXhlbCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgdW5maWx0ZXJVcChjdXJyZW50TGluZSwgbmV3TGluZSwgcHJldkxpbmUsIGJ5dGVzUGVyTGluZSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgdW5maWx0ZXJBdmVyYWdlKGN1cnJlbnRMaW5lLCBuZXdMaW5lLCBwcmV2TGluZSwgYnl0ZXNQZXJMaW5lLCBieXRlc1BlclBpeGVsKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICB1bmZpbHRlclBhZXRoKGN1cnJlbnRMaW5lLCBuZXdMaW5lLCBwcmV2TGluZSwgYnl0ZXNQZXJMaW5lLCBieXRlc1BlclBpeGVsKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDogdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBmaWx0ZXI6ICcgKyBkYXRhW29mZnNldF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJldkxpbmUgPSBuZXdMaW5lO1xuICAgICAgICAgICAgb2Zmc2V0ICs9IGJ5dGVzUGVyTGluZSArIDE7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5faGFzUGFsZXR0ZSkge1xuICAgICAgICAgICAgdGhpcy5fcG5nLnBhbGV0dGUgPSB0aGlzLl9wYWxldHRlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3BuZy5kYXRhID0gbmV3RGF0YTtcbiAgICB9XG5cblxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFBOR0RlY29kZXI7XG5cbmZ1bmN0aW9uIHVuZmlsdGVyTm9uZShjdXJyZW50TGluZSwgbmV3TGluZSwgYnl0ZXNQZXJMaW5lKSB7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGJ5dGVzUGVyTGluZTsgaSsrKSB7XG4gICAgICAgIG5ld0xpbmVbaV0gPSBjdXJyZW50TGluZVtpXTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHVuZmlsdGVyU3ViKGN1cnJlbnRMaW5lLCBuZXdMaW5lLCBieXRlc1BlckxpbmUsIGJ5dGVzUGVyUGl4ZWwpIHtcbiAgICB2YXIgaSA9IDA7XG4gICAgZm9yICg7IGkgPCBieXRlc1BlclBpeGVsOyBpKyspIHtcbiAgICAgICAgLy8ganVzdCBjb3B5IGZpcnN0IGJ5dGVzXG4gICAgICAgIG5ld0xpbmVbaV0gPSBjdXJyZW50TGluZVtpXTtcbiAgICB9XG4gICAgZm9yKDsgaSA8IGJ5dGVzUGVyTGluZTsgaSsrKSB7XG4gICAgICAgIG5ld0xpbmVbaV0gPSAoY3VycmVudExpbmVbaV0gKyBuZXdMaW5lW2kgLSBieXRlc1BlclBpeGVsXSkmMHhGRjtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHVuZmlsdGVyVXAoY3VycmVudExpbmUsIG5ld0xpbmUsIHByZXZMaW5lLCBieXRlc1BlckxpbmUpIHtcbiAgICB2YXIgaSA9IDA7XG4gICAgaWYgKHByZXZMaW5lLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAvLyBqdXN0IGNvcHkgYnl0ZXMgZm9yIGZpcnN0IGxpbmVcbiAgICAgICAgZm9yICg7IGkgPCBieXRlc1BlckxpbmU7IGkrKykge1xuICAgICAgICAgICAgbmV3TGluZVtpXSA9IGN1cnJlbnRMaW5lW2ldO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZm9yICg7IGkgPCBieXRlc1BlckxpbmU7IGkrKykge1xuICAgICAgICAgICAgbmV3TGluZVtpXSA9IChjdXJyZW50TGluZVtpXSArIHByZXZMaW5lW2ldKSAmIDB4RkY7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIHVuZmlsdGVyQXZlcmFnZShjdXJyZW50TGluZSwgbmV3TGluZSwgcHJldkxpbmUsIGJ5dGVzUGVyTGluZSwgYnl0ZXNQZXJQaXhlbCkge1xuICAgIHZhciBpID0gMDtcbiAgICBpZiAocHJldkxpbmUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGZvciAoOyBpIDwgYnl0ZXNQZXJQaXhlbDsgaSsrKSB7XG4gICAgICAgICAgICBuZXdMaW5lW2ldID0gY3VycmVudExpbmVbaV07XG4gICAgICAgIH1cbiAgICAgICAgZm9yICg7IGkgPCBieXRlc1BlckxpbmU7IGkrKykge1xuICAgICAgICAgICAgbmV3TGluZVtpXSA9IChjdXJyZW50TGluZVtpXSArIChuZXdMaW5lW2kgLSBieXRlc1BlclBpeGVsXT4+MSkpJjB4RkY7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKDsgaSA8IGJ5dGVzUGVyUGl4ZWw7IGkrKykge1xuICAgICAgICAgICAgbmV3TGluZVtpXSA9IChjdXJyZW50TGluZVtpXSArIChwcmV2TGluZVtpXT4+MSkpJjB4RkY7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICg7IGkgPCBieXRlc1BlckxpbmU7IGkrKykge1xuICAgICAgICAgICAgbmV3TGluZVtpXSA9IChjdXJyZW50TGluZVtpXSArICgobmV3TGluZVtpIC0gYnl0ZXNQZXJQaXhlbF0gKyBwcmV2TGluZVtpXSk+PjEpKSYweEZGO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiB1bmZpbHRlclBhZXRoKGN1cnJlbnRMaW5lLCBuZXdMaW5lLCBwcmV2TGluZSwgYnl0ZXNQZXJMaW5lLCBieXRlc1BlclBpeGVsKSB7XG4gICAgdmFyIGkgPSAwO1xuICAgIGlmIChwcmV2TGluZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgZm9yICg7IGkgPCBieXRlc1BlclBpeGVsOyBpKyspIHtcbiAgICAgICAgICAgIG5ld0xpbmVbaV0gPSBjdXJyZW50TGluZVtpXTtcbiAgICAgICAgfVxuICAgICAgICBmb3IoOyBpIDwgYnl0ZXNQZXJMaW5lOyBpKyspIHtcbiAgICAgICAgICAgIG5ld0xpbmVbaV0gPSAoY3VycmVudExpbmVbaV0gKyBuZXdMaW5lW2kgLSBieXRlc1BlclBpeGVsXSkmMHhGRjtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAoOyBpIDwgYnl0ZXNQZXJQaXhlbDsgaSsrKSB7XG4gICAgICAgICAgICBuZXdMaW5lW2ldID0gKGN1cnJlbnRMaW5lW2ldICsgcHJldkxpbmVbaV0pJjB4RkY7XG4gICAgICAgIH1cbiAgICAgICAgZm9yKDsgaSA8IGJ5dGVzUGVyTGluZTsgaSsrKSB7XG4gICAgICAgICAgICBuZXdMaW5lW2ldID0gKGN1cnJlbnRMaW5lW2ldICsgcGFldGhQcmVkaWN0b3IobmV3TGluZVtpIC0gYnl0ZXNQZXJQaXhlbF0sIHByZXZMaW5lW2ldLCBwcmV2TGluZVtpIC0gYnl0ZXNQZXJQaXhlbF0pKSYweEZGO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiBwYWV0aFByZWRpY3RvcihhLCBiLCBjKSB7XG4gICAgdmFyIHAgPSBhICsgYiAtIGM7XG4gICAgdmFyIHBhID0gTWF0aC5hYnMocCAtIGEpO1xuICAgIHZhciBwYiA9IE1hdGguYWJzKHAgLSBiKTtcbiAgICB2YXIgcGMgPSBNYXRoLmFicyhwIC0gYyk7XG4gICAgaWYgKHBhIDw9IHBiICYmIHBhIDw9IHBjKSByZXR1cm4gYTtcbiAgICBlbHNlIGlmIChwYiA8PSBwYykgcmV0dXJuIGI7XG4gICAgZWxzZSByZXR1cm4gYztcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5QTkdEZWNvZGVyID0gcmVxdWlyZSgnLi9QTkdEZWNvZGVyJyk7XG4iLCJpZiAodHlwZW9mIE9iamVjdC5jcmVhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgLy8gaW1wbGVtZW50YXRpb24gZnJvbSBzdGFuZGFyZCBub2RlLmpzICd1dGlsJyBtb2R1bGVcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHtcbiAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvclxuICAgIGN0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckN0b3IucHJvdG90eXBlLCB7XG4gICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICB2YWx1ZTogY3RvcixcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcbn0gZWxzZSB7XG4gIC8vIG9sZCBzY2hvb2wgc2hpbSBmb3Igb2xkIGJyb3dzZXJzXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICB2YXIgVGVtcEN0b3IgPSBmdW5jdGlvbiAoKSB7fVxuICAgIFRlbXBDdG9yLnByb3RvdHlwZSA9IHN1cGVyQ3Rvci5wcm90b3R5cGVcbiAgICBjdG9yLnByb3RvdHlwZSA9IG5ldyBUZW1wQ3RvcigpXG4gICAgY3Rvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBjdG9yXG4gIH1cbn1cbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgZGVmYXVsdEJ5dGVMZW5ndGggPSAxMDI0ICogODtcbmNvbnN0IGNoYXJBcnJheSA9IFtdO1xuXG5jbGFzcyBJT0J1ZmZlciB7XG4gICAgY29uc3RydWN0b3IoZGF0YSkge1xuICAgICAgICBsZXQgbGVuZ3RoID0gMDtcbiAgICAgICAgaWYgKGRhdGEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZGF0YSA9IGRlZmF1bHRCeXRlTGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIGxlbmd0aCA9IGRhdGE7XG4gICAgICAgICAgICBkYXRhID0gbmV3IEFycmF5QnVmZmVyKGRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGxlbmd0aCA9IGRhdGEuYnl0ZUxlbmd0aDtcbiAgICAgICAgaWYgKGRhdGEuYnVmZmVyKSB7XG4gICAgICAgICAgICBsZW5ndGggPSBkYXRhLmJ5dGVMZW5ndGg7XG4gICAgICAgICAgICBpZiAoZGF0YS5ieXRlTGVuZ3RoICE9PSBkYXRhLmJ1ZmZlci5ieXRlTGVuZ3RoKSB7IC8vIE5vZGUuanMgYnVmZmVyIGZyb20gcG9vbFxuICAgICAgICAgICAgICAgIGRhdGEgPSBkYXRhLmJ1ZmZlci5zbGljZShkYXRhLmJ5dGVPZmZzZXQsIGRhdGEuYnl0ZU9mZnNldCArIGRhdGEuYnl0ZUxlbmd0aCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGRhdGEgPSBkYXRhLmJ1ZmZlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmJ1ZmZlciA9IGRhdGE7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gbGVuZ3RoO1xuICAgICAgICB0aGlzLm9mZnNldCA9IDA7XG4gICAgICAgIHRoaXMubGl0dGxlRW5kaWFuID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fZGF0YSA9IG5ldyBEYXRhVmlldyh0aGlzLmJ1ZmZlcik7XG4gICAgICAgIHRoaXMuX2luY3JlbWVudCA9IGxlbmd0aCB8fCBkZWZhdWx0Qnl0ZUxlbmd0aDtcbiAgICAgICAgdGhpcy5fbWFyayA9IDA7XG4gICAgfVxuXG4gICAgYXZhaWxhYmxlKGJ5dGVMZW5ndGgpIHtcbiAgICAgICAgaWYgKGJ5dGVMZW5ndGggPT09IHVuZGVmaW5lZCkgYnl0ZUxlbmd0aCA9IDE7XG4gICAgICAgIHJldHVybiAodGhpcy5vZmZzZXQgKyBieXRlTGVuZ3RoKSA8PSB0aGlzLmxlbmd0aDtcbiAgICB9XG5cbiAgICBpc0xpdHRsZUVuZGlhbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGl0dGxlRW5kaWFuO1xuICAgIH1cblxuICAgIHNldExpdHRsZUVuZGlhbigpIHtcbiAgICAgICAgdGhpcy5saXR0bGVFbmRpYW4gPSB0cnVlO1xuICAgIH1cblxuICAgIGlzQmlnRW5kaWFuKCkge1xuICAgICAgICByZXR1cm4gIXRoaXMubGl0dGxlRW5kaWFuO1xuICAgIH1cblxuICAgIHNldEJpZ0VuZGlhbigpIHtcbiAgICAgICAgdGhpcy5saXR0bGVFbmRpYW4gPSBmYWxzZTtcbiAgICB9XG5cbiAgICBza2lwKG4pIHtcbiAgICAgICAgaWYgKG4gPT09IHVuZGVmaW5lZCkgbiA9IDE7XG4gICAgICAgIHRoaXMub2Zmc2V0ICs9IG47XG4gICAgfVxuXG4gICAgc2VlayhvZmZzZXQpIHtcbiAgICAgICAgdGhpcy5vZmZzZXQgPSBvZmZzZXQ7XG4gICAgfVxuXG4gICAgbWFyaygpIHtcbiAgICAgICAgdGhpcy5fbWFyayA9IHRoaXMub2Zmc2V0O1xuICAgIH1cblxuICAgIHJlc2V0KCkge1xuICAgICAgICB0aGlzLm9mZnNldCA9IHRoaXMuX21hcms7XG4gICAgfVxuXG4gICAgcmV3aW5kKCkge1xuICAgICAgICB0aGlzLm9mZnNldCA9IDA7XG4gICAgfVxuXG4gICAgZW5zdXJlQXZhaWxhYmxlKGJ5dGVMZW5ndGgpIHtcbiAgICAgICAgaWYgKGJ5dGVMZW5ndGggPT09IHVuZGVmaW5lZCkgYnl0ZUxlbmd0aCA9IDE7XG4gICAgICAgIGlmICghdGhpcy5hdmFpbGFibGUoYnl0ZUxlbmd0aCkpIHtcbiAgICAgICAgICAgIGNvbnN0IG5ld0luY3JlbWVudCA9IHRoaXMuX2luY3JlbWVudCArIHRoaXMuX2luY3JlbWVudDtcbiAgICAgICAgICAgIHRoaXMuX2luY3JlbWVudCA9IG5ld0luY3JlbWVudDtcbiAgICAgICAgICAgIGNvbnN0IG5ld0xlbmd0aCA9IHRoaXMubGVuZ3RoICsgbmV3SW5jcmVtZW50O1xuICAgICAgICAgICAgY29uc3QgbmV3QXJyYXkgPSBuZXcgVWludDhBcnJheShuZXdMZW5ndGgpO1xuICAgICAgICAgICAgbmV3QXJyYXkuc2V0KG5ldyBVaW50OEFycmF5KHRoaXMuYnVmZmVyKSk7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlciA9IG5ld0FycmF5LmJ1ZmZlcjtcbiAgICAgICAgICAgIHRoaXMubGVuZ3RoID0gbmV3TGVuZ3RoO1xuICAgICAgICAgICAgdGhpcy5fZGF0YSA9IG5ldyBEYXRhVmlldyh0aGlzLmJ1ZmZlcik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZWFkQm9vbGVhbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVhZFVpbnQ4KCkgIT09IDA7XG4gICAgfVxuXG4gICAgcmVhZEludDgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kYXRhLmdldEludDgodGhpcy5vZmZzZXQrKyk7XG4gICAgfVxuXG4gICAgcmVhZFVpbnQ4KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGF0YS5nZXRVaW50OCh0aGlzLm9mZnNldCsrKTtcbiAgICB9XG5cbiAgICByZWFkQnl0ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVhZFVpbnQ4KCk7XG4gICAgfVxuXG4gICAgcmVhZEJ5dGVzKG4pIHtcbiAgICAgICAgaWYgKG4gPT09IHVuZGVmaW5lZCkgbiA9IDE7XG4gICAgICAgIHZhciBieXRlcyA9IG5ldyBVaW50OEFycmF5KG4pO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgYnl0ZXNbaV0gPSB0aGlzLnJlYWRCeXRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJ5dGVzO1xuICAgIH1cblxuICAgIHJlYWRJbnQxNigpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5fZGF0YS5nZXRJbnQxNih0aGlzLm9mZnNldCwgdGhpcy5saXR0bGVFbmRpYW4pO1xuICAgICAgICB0aGlzLm9mZnNldCArPSAyO1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgcmVhZFVpbnQxNigpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5fZGF0YS5nZXRVaW50MTYodGhpcy5vZmZzZXQsIHRoaXMubGl0dGxlRW5kaWFuKTtcbiAgICAgICAgdGhpcy5vZmZzZXQgKz0gMjtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIHJlYWRJbnQzMigpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5fZGF0YS5nZXRJbnQzMih0aGlzLm9mZnNldCwgdGhpcy5saXR0bGVFbmRpYW4pO1xuICAgICAgICB0aGlzLm9mZnNldCArPSA0O1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgcmVhZFVpbnQzMigpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5fZGF0YS5nZXRVaW50MzIodGhpcy5vZmZzZXQsIHRoaXMubGl0dGxlRW5kaWFuKTtcbiAgICAgICAgdGhpcy5vZmZzZXQgKz0gNDtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIHJlYWRGbG9hdDMyKCkge1xuICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLl9kYXRhLmdldEZsb2F0MzIodGhpcy5vZmZzZXQsIHRoaXMubGl0dGxlRW5kaWFuKTtcbiAgICAgICAgdGhpcy5vZmZzZXQgKz0gNDtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIHJlYWRGbG9hdDY0KCkge1xuICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLl9kYXRhLmdldEZsb2F0NjQodGhpcy5vZmZzZXQsIHRoaXMubGl0dGxlRW5kaWFuKTtcbiAgICAgICAgdGhpcy5vZmZzZXQgKz0gODtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIHJlYWRDaGFyKCkge1xuICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZSh0aGlzLnJlYWRJbnQ4KCkpO1xuICAgIH1cblxuICAgIHJlYWRDaGFycyhuKSB7XG4gICAgICAgIGlmIChuID09PSB1bmRlZmluZWQpIG4gPSAxO1xuICAgICAgICBjaGFyQXJyYXkubGVuZ3RoID0gbjtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIGNoYXJBcnJheVtpXSA9IHRoaXMucmVhZENoYXIoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2hhckFycmF5LmpvaW4oJycpO1xuICAgIH1cblxuICAgIHdyaXRlQm9vbGVhbihib29sKSB7XG4gICAgICAgIHRoaXMud3JpdGVVaW50OChib29sID8gMHhmZiA6IDB4MDApO1xuICAgIH1cblxuICAgIHdyaXRlSW50OCh2YWx1ZSkge1xuICAgICAgICB0aGlzLmVuc3VyZUF2YWlsYWJsZSgxKTtcbiAgICAgICAgdGhpcy5fZGF0YS5zZXRJbnQ4KHRoaXMub2Zmc2V0KyssIHZhbHVlKTtcbiAgICB9XG5cbiAgICB3cml0ZVVpbnQ4KHZhbHVlKSB7XG4gICAgICAgIHRoaXMuZW5zdXJlQXZhaWxhYmxlKDEpO1xuICAgICAgICB0aGlzLl9kYXRhLnNldFVpbnQ4KHRoaXMub2Zmc2V0KyssIHZhbHVlKTtcbiAgICB9XG5cbiAgICB3cml0ZUJ5dGUodmFsdWUpIHtcbiAgICAgICAgdGhpcy53cml0ZVVpbnQ4KHZhbHVlKTtcbiAgICB9XG5cbiAgICB3cml0ZUJ5dGVzKGJ5dGVzKSB7XG4gICAgICAgIHRoaXMuZW5zdXJlQXZhaWxhYmxlKGJ5dGVzLmxlbmd0aCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMuX2RhdGEuc2V0VWludDgodGhpcy5vZmZzZXQrKywgYnl0ZXNbaV0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgd3JpdGVJbnQxNih2YWx1ZSkge1xuICAgICAgICB0aGlzLmVuc3VyZUF2YWlsYWJsZSgyKTtcbiAgICAgICAgdGhpcy5fZGF0YS5zZXRJbnQxNih0aGlzLm9mZnNldCwgdmFsdWUsIHRoaXMubGl0dGxlRW5kaWFuKTtcbiAgICAgICAgdGhpcy5vZmZzZXQgKz0gMjtcbiAgICB9XG5cbiAgICB3cml0ZVVpbnQxNih2YWx1ZSkge1xuICAgICAgICB0aGlzLmVuc3VyZUF2YWlsYWJsZSgyKTtcbiAgICAgICAgdGhpcy5fZGF0YS5zZXRVaW50MTYodGhpcy5vZmZzZXQsIHZhbHVlLCB0aGlzLmxpdHRsZUVuZGlhbik7XG4gICAgICAgIHRoaXMub2Zmc2V0ICs9IDI7XG4gICAgfVxuXG4gICAgd3JpdGVJbnQzMih2YWx1ZSkge1xuICAgICAgICB0aGlzLmVuc3VyZUF2YWlsYWJsZSg0KTtcbiAgICAgICAgdGhpcy5fZGF0YS5zZXRJbnQzMih0aGlzLm9mZnNldCwgdmFsdWUsIHRoaXMubGl0dGxlRW5kaWFuKTtcbiAgICAgICAgdGhpcy5vZmZzZXQgKz0gNDtcbiAgICB9XG5cbiAgICB3cml0ZVVpbnQzMih2YWx1ZSkge1xuICAgICAgICB0aGlzLmVuc3VyZUF2YWlsYWJsZSg0KTtcbiAgICAgICAgdGhpcy5fZGF0YS5zZXRVaW50MzIodGhpcy5vZmZzZXQsIHZhbHVlLCB0aGlzLmxpdHRsZUVuZGlhbik7XG4gICAgICAgIHRoaXMub2Zmc2V0ICs9IDQ7XG4gICAgfVxuXG4gICAgd3JpdGVGbG9hdDMyKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuZW5zdXJlQXZhaWxhYmxlKDQpO1xuICAgICAgICB0aGlzLl9kYXRhLnNldEZsb2F0MzIodGhpcy5vZmZzZXQsIHZhbHVlLCB0aGlzLmxpdHRsZUVuZGlhbik7XG4gICAgICAgIHRoaXMub2Zmc2V0ICs9IDQ7XG4gICAgfVxuXG4gICAgd3JpdGVGbG9hdDY0KHZhbHVlKSB7XG4gICAgICAgIHRoaXMuZW5zdXJlQXZhaWxhYmxlKDgpO1xuICAgICAgICB0aGlzLl9kYXRhLnNldEZsb2F0NjQodGhpcy5vZmZzZXQsIHZhbHVlLCB0aGlzLmxpdHRsZUVuZGlhbik7XG4gICAgICAgIHRoaXMub2Zmc2V0ICs9IDg7XG4gICAgfVxuXG4gICAgd3JpdGVDaGFyKHN0cikge1xuICAgICAgICB0aGlzLndyaXRlVWludDgoc3RyLmNoYXJDb2RlQXQoMCkpO1xuICAgIH1cblxuICAgIHdyaXRlQ2hhcnMoc3RyKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLndyaXRlVWludDgoc3RyLmNoYXJDb2RlQXQoaSkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdG9BcnJheSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KHRoaXMuYnVmZmVyLCAwLCB0aGlzLm9mZnNldCk7XG4gICAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IElPQnVmZmVyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzQXJyYXlUeXBlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsdWUpLnN1YnN0cigtNiwgNSkgPT09ICdBcnJheSc7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIG51bWJlcklzTmFuID0gcmVxdWlyZSgnbnVtYmVyLWlzLW5hbicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE51bWJlci5pc0Zpbml0ZSB8fCBmdW5jdGlvbiAodmFsKSB7XG5cdHJldHVybiAhKHR5cGVvZiB2YWwgIT09ICdudW1iZXInIHx8IG51bWJlcklzTmFuKHZhbCkgfHwgdmFsID09PSBJbmZpbml0eSB8fCB2YWwgPT09IC1JbmZpbml0eSk7XG59O1xuIiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL3BhdWxtaWxsci9lczYtc2hpbVxuLy8gaHR0cDovL3Blb3BsZS5tb3ppbGxhLm9yZy9+am9yZW5kb3JmZi9lczYtZHJhZnQuaHRtbCNzZWMtbnVtYmVyLmlzaW50ZWdlclxudmFyIGlzRmluaXRlID0gcmVxdWlyZShcImlzLWZpbml0ZVwiKTtcbm1vZHVsZS5leHBvcnRzID0gTnVtYmVyLmlzSW50ZWdlciB8fCBmdW5jdGlvbih2YWwpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWwgPT09IFwibnVtYmVyXCIgJiZcbiAgICBpc0Zpbml0ZSh2YWwpICYmXG4gICAgTWF0aC5mbG9vcih2YWwpID09PSB2YWw7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBzcXVhcmVkRXVjbGlkZWFuKHAsIHEpIHtcbiAgICB2YXIgZCA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGQgKz0gKHBbaV0gLSBxW2ldKSAqIChwW2ldIC0gcVtpXSk7XG4gICAgfVxuICAgIHJldHVybiBkO1xufVxuXG5mdW5jdGlvbiBldWNsaWRlYW4ocCwgcSkge1xuICAgIHJldHVybiBNYXRoLnNxcnQoc3F1YXJlZEV1Y2xpZGVhbihwLCBxKSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXVjbGlkZWFuO1xuZXVjbGlkZWFuLnNxdWFyZWQgPSBzcXVhcmVkRXVjbGlkZWFuO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBzcXVhcmVkRXVjbGlkZWFuID0gcmVxdWlyZSgnbWwtZXVjbGlkZWFuLWRpc3RhbmNlJykuc3F1YXJlZDtcblxuY29uc3QgZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgc2lnbWE6IDFcbn07XG5cbmNsYXNzIEdhdXNzaWFuS2VybmVsIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0T3B0aW9ucywgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMuc2lnbWEgPSBvcHRpb25zLnNpZ21hO1xuICAgICAgICB0aGlzLmRpdmlzb3IgPSAyICogb3B0aW9ucy5zaWdtYSAqIG9wdGlvbnMuc2lnbWE7XG4gICAgfVxuXG4gICAgY29tcHV0ZSh4LCB5KSB7XG4gICAgICAgIGNvbnN0IGRpc3RhbmNlID0gc3F1YXJlZEV1Y2xpZGVhbih4LCB5KTtcbiAgICAgICAgcmV0dXJuIE1hdGguZXhwKC1kaXN0YW5jZSAvIHRoaXMuZGl2aXNvcik7XG4gICAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEdhdXNzaWFuS2VybmVsO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBNYXRyaXggPSByZXF1aXJlKCdtbC1tYXRyaXgnKTtcblxuY29uc3QgR2F1c3NpYW5LZXJuZWwgPSByZXF1aXJlKCdtbC1nYXVzc2lhbi1rZXJuZWwnKTtcbmNvbnN0IFBvbHlub21pYWxLZXJuZWwgPSByZXF1aXJlKCdtbC1wb2x5bm9taWFsLWtlcm5lbCcpO1xuY29uc3QgQU5PVkFLZXJuZWwgPSByZXF1aXJlKCcuL2tlcm5lbHMvYW5vdmEta2VybmVsJyk7XG5jb25zdCBDYXVjaHlLZXJuZWwgPSByZXF1aXJlKCcuL2tlcm5lbHMvY2F1Y2h5LWtlcm5lbCcpO1xuY29uc3QgRXhwb25lbnRpYWxLZXJuZWwgPSByZXF1aXJlKCcuL2tlcm5lbHMvZXhwb25lbnRpYWwta2VybmVsJyk7XG5jb25zdCBIaXN0b2dyYW1LZXJuZWwgPSByZXF1aXJlKCcuL2tlcm5lbHMvaGlzdG9ncmFtLWludGVyc2VjdGlvbi1rZXJuZWwnKTtcbmNvbnN0IExhcGxhY2lhbktlcm5lbCA9IHJlcXVpcmUoJy4va2VybmVscy9sYXBsYWNpYW4ta2VybmVsJyk7XG5jb25zdCBNdWx0aXF1YWRyYXRpY0tlcm5lbCA9IHJlcXVpcmUoJy4va2VybmVscy9tdWx0aXF1YWRyYXRpYy1rZXJuZWwnKTtcbmNvbnN0IFJhdGlvbmFsS2VybmVsID0gcmVxdWlyZSgnLi9rZXJuZWxzL3JhdGlvbmFsLXF1YWRyYXRpYy1rZXJuZWwnKTtcblxuY29uc3Qga2VybmVsVHlwZSA9IHtcbiAgICBnYXVzc2lhbjogR2F1c3NpYW5LZXJuZWwsXG4gICAgcmJmOiBHYXVzc2lhbktlcm5lbCxcbiAgICBwb2x5bm9taWFsOiBQb2x5bm9taWFsS2VybmVsLFxuICAgIHBvbHk6IFBvbHlub21pYWxLZXJuZWwsXG4gICAgYW5vdmE6IEFOT1ZBS2VybmVsLFxuICAgIGNhdWNoeTogQ2F1Y2h5S2VybmVsLFxuICAgIGV4cG9uZW50aWFsOiBFeHBvbmVudGlhbEtlcm5lbCxcbiAgICBoaXN0b2dyYW06IEhpc3RvZ3JhbUtlcm5lbCxcbiAgICBtaW46IEhpc3RvZ3JhbUtlcm5lbCxcbiAgICBsYXBsYWNpYW46IExhcGxhY2lhbktlcm5lbCxcbiAgICBtdWx0aXF1YWRyYXRpYzogTXVsdGlxdWFkcmF0aWNLZXJuZWwsXG4gICAgcmF0aW9uYWw6IFJhdGlvbmFsS2VybmVsXG59O1xuXG5jbGFzcyBLZXJuZWwge1xuICAgIGNvbnN0cnVjdG9yKHR5cGUsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdHlwZSA9IHR5cGUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdmFyIEtlcm5lbENvbnN0cnVjdG9yID0ga2VybmVsVHlwZVt0eXBlXTtcbiAgICAgICAgICAgIGlmIChLZXJuZWxDb25zdHJ1Y3Rvcikge1xuICAgICAgICAgICAgICAgIHRoaXMua2VybmVsRnVuY3Rpb24gPSBuZXcgS2VybmVsQ29uc3RydWN0b3Iob3B0aW9ucyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndW5zdXBwb3J0ZWQga2VybmVsIHR5cGU6ICcgKyB0eXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIHR5cGUuY29tcHV0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhpcy5rZXJuZWxGdW5jdGlvbiA9IHR5cGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdmaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgdmFsaWQga2VybmVsIHR5cGUgb3IgaW5zdGFuY2UnKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNvbXB1dGUoaW5wdXRzLCBsYW5kbWFya3MpIHtcbiAgICAgICAgaWYgKGxhbmRtYXJrcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBsYW5kbWFya3MgPSBpbnB1dHM7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qga2VybmVsTWF0cml4ID0gbmV3IE1hdHJpeChpbnB1dHMubGVuZ3RoLCBsYW5kbWFya3MubGVuZ3RoKTtcbiAgICAgICAgdmFyIGksIGo7XG4gICAgICAgIGlmIChpbnB1dHMgPT09IGxhbmRtYXJrcykgeyAvLyBmYXN0IHBhdGgsIG1hdHJpeCBpcyBzeW1tZXRyaWNcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBpbnB1dHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBmb3IgKGogPSBpOyBqIDwgaW5wdXRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGtlcm5lbE1hdHJpeFtpXVtqXSA9IGtlcm5lbE1hdHJpeFtqXVtpXSA9IHRoaXMua2VybmVsRnVuY3Rpb24uY29tcHV0ZShpbnB1dHNbaV0sIGlucHV0c1tqXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGlucHV0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBsYW5kbWFya3MubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAga2VybmVsTWF0cml4W2ldW2pdID0gdGhpcy5rZXJuZWxGdW5jdGlvbi5jb21wdXRlKGlucHV0c1tpXSwgbGFuZG1hcmtzW2pdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGtlcm5lbE1hdHJpeDtcbiAgICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gS2VybmVsO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgICBzaWdtYTogMSxcbiAgICBkZWdyZWU6IDFcbn07XG5cbmNsYXNzIEFOT1ZBS2VybmVsIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0T3B0aW9ucywgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMuc2lnbWEgPSBvcHRpb25zLnNpZ21hO1xuICAgICAgICB0aGlzLmRlZ3JlZSA9IG9wdGlvbnMuZGVncmVlO1xuICAgIH1cblxuICAgIGNvbXB1dGUoeCwgeSkge1xuICAgICAgICB2YXIgc3VtID0gMDtcbiAgICAgICAgdmFyIGxlbiA9IE1hdGgubWluKHgubGVuZ3RoLCB5Lmxlbmd0aCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDw9IGxlbjsgKytpKSB7XG4gICAgICAgICAgICBzdW0gKz0gTWF0aC5wb3coTWF0aC5leHAoLXRoaXMuc2lnbWEgKiBNYXRoLnBvdyhNYXRoLnBvdyh4W2kgLSAxXSwgaSkgLVxuICAgICAgICAgICAgICAgICAgICBNYXRoLnBvdyh5W2kgLSAxXSwgaSksIDIpKSwgdGhpcy5kZWdyZWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdW07XG4gICAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEFOT1ZBS2VybmVsO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBzcXVhcmVkRXVjbGlkZWFuID0gcmVxdWlyZSgnbWwtZXVjbGlkZWFuLWRpc3RhbmNlJykuc3F1YXJlZDtcblxuY29uc3QgZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgc2lnbWE6IDFcbn07XG5cbmNsYXNzIENhdWNoeUtlcm5lbCB7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdE9wdGlvbnMsIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLnNpZ21hID0gb3B0aW9ucy5zaWdtYTtcbiAgICB9XG5cbiAgICBjb21wdXRlKHgsIHkpIHtcbiAgICAgICAgcmV0dXJuIDEgLyAoMSArIHNxdWFyZWRFdWNsaWRlYW4oeCwgeSkgLyAodGhpcy5zaWdtYSAqIHRoaXMuc2lnbWEpKTtcbiAgICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gQ2F1Y2h5S2VybmVsO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBldWNsaWRlYW4gPSByZXF1aXJlKCdtbC1ldWNsaWRlYW4tZGlzdGFuY2UnKTtcblxuY29uc3QgZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgc2lnbWE6IDFcbn07XG5cbmNsYXNzIEV4cG9uZW50aWFsS2VybmVsIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0T3B0aW9ucywgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMuc2lnbWEgPSBvcHRpb25zLnNpZ21hO1xuICAgICAgICB0aGlzLmRpdmlzb3IgPSAyICogb3B0aW9ucy5zaWdtYSAqIG9wdGlvbnMuc2lnbWE7XG4gICAgfVxuXG4gICAgY29tcHV0ZSh4LCB5KSB7XG4gICAgICAgIGNvbnN0IGRpc3RhbmNlID0gZXVjbGlkZWFuKHgsIHkpO1xuICAgICAgICByZXR1cm4gTWF0aC5leHAoLWRpc3RhbmNlIC8gdGhpcy5kaXZpc29yKTtcbiAgICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gRXhwb25lbnRpYWxLZXJuZWw7XG4iLCIndXNlIHN0cmljdCc7XG5cbmNsYXNzIEhpc3RvZ3JhbUludGVyc2VjdGlvbktlcm5lbCB7XG4gICAgY29tcHV0ZSh4LCB5KSB7XG4gICAgICAgIHZhciBtaW4gPSBNYXRoLm1pbih4Lmxlbmd0aCwgeS5sZW5ndGgpO1xuICAgICAgICB2YXIgc3VtID0gMDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtaW47ICsraSlcbiAgICAgICAgICAgIHN1bSArPSBNYXRoLm1pbih4W2ldLCB5W2ldKTtcblxuICAgICAgICByZXR1cm4gc3VtO1xuICAgIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBIaXN0b2dyYW1JbnRlcnNlY3Rpb25LZXJuZWw7XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IGV1Y2xpZGVhbiA9IHJlcXVpcmUoJ21sLWV1Y2xpZGVhbi1kaXN0YW5jZScpO1xuXG5jb25zdCBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgICBzaWdtYTogMVxufTtcblxuY2xhc3MgTGFwbGFjaWFuS2VybmVsIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0T3B0aW9ucywgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMuc2lnbWEgPSBvcHRpb25zLnNpZ21hO1xuICAgIH1cblxuICAgIGNvbXB1dGUoeCwgeSkge1xuICAgICAgICBjb25zdCBkaXN0YW5jZSA9IGV1Y2xpZGVhbih4LCB5KTtcbiAgICAgICAgcmV0dXJuIE1hdGguZXhwKC1kaXN0YW5jZSAvIHRoaXMuc2lnbWEpO1xuICAgIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBMYXBsYWNpYW5LZXJuZWw7XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IHNxdWFyZWRFdWNsaWRlYW4gPSByZXF1aXJlKCdtbC1ldWNsaWRlYW4tZGlzdGFuY2UnKS5zcXVhcmVkO1xuXG5jb25zdCBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgICBjb25zdGFudDogMVxufTtcblxuY2xhc3MgTXVsdGlxdWFkcmF0aWNLZXJuZWwge1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAgICAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRPcHRpb25zLCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy5jb25zdGFudCA9IG9wdGlvbnMuY29uc3RhbnQ7XG4gICAgfVxuXG4gICAgY29tcHV0ZSh4LCB5KSB7XG4gICAgICAgIHJldHVybiBNYXRoLnNxcnQoc3F1YXJlZEV1Y2xpZGVhbih4LCB5KSArIHRoaXMuY29uc3RhbnQgKiB0aGlzLmNvbnN0YW50KTtcbiAgICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gTXVsdGlxdWFkcmF0aWNLZXJuZWw7XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IHNxdWFyZWRFdWNsaWRlYW4gPSByZXF1aXJlKCdtbC1ldWNsaWRlYW4tZGlzdGFuY2UnKS5zcXVhcmVkO1xuXG5jb25zdCBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgICBjb25zdGFudDogMVxufTtcblxuY2xhc3MgUmF0aW9uYWxRdWFkcmF0aWNLZXJuZWwge1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAgICAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRPcHRpb25zLCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy5jb25zdGFudCA9IG9wdGlvbnMuY29uc3RhbnQ7XG4gICAgfVxuXG4gICAgY29tcHV0ZSh4LCB5KSB7XG4gICAgICAgIHJldHVybiAxIC0gKHNxdWFyZWRFdWNsaWRlYW4oeCwgeSkgLyAoc3F1YXJlZEV1Y2xpZGVhbih4LCB5KSArIHRoaXMuY29uc3RhbnQpKTtcbiAgICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUmF0aW9uYWxRdWFkcmF0aWNLZXJuZWw7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBNYXRyaXggPSByZXF1aXJlKCcuLi9tYXRyaXgnKTtcblxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2x1dHpyb2VkZXIvTWFwYWNrL2Jsb2IvbWFzdGVyL1NvdXJjZS9DaG9sZXNreURlY29tcG9zaXRpb24uY3NcbmZ1bmN0aW9uIENob2xlc2t5RGVjb21wb3NpdGlvbih2YWx1ZSkge1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBDaG9sZXNreURlY29tcG9zaXRpb24pKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ2hvbGVza3lEZWNvbXBvc2l0aW9uKHZhbHVlKTtcbiAgICB9XG4gICAgdmFsdWUgPSBNYXRyaXguY2hlY2tNYXRyaXgodmFsdWUpO1xuICAgIGlmICghdmFsdWUuaXNTeW1tZXRyaWMoKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNYXRyaXggaXMgbm90IHN5bW1ldHJpYycpO1xuXG4gICAgdmFyIGEgPSB2YWx1ZSxcbiAgICAgICAgZGltZW5zaW9uID0gYS5yb3dzLFxuICAgICAgICBsID0gbmV3IE1hdHJpeChkaW1lbnNpb24sIGRpbWVuc2lvbiksXG4gICAgICAgIHBvc2l0aXZlRGVmaW5pdGUgPSB0cnVlLFxuICAgICAgICBpLCBqLCBrO1xuXG4gICAgZm9yIChqID0gMDsgaiA8IGRpbWVuc2lvbjsgaisrKSB7XG4gICAgICAgIHZhciBMcm93aiA9IGxbal07XG4gICAgICAgIHZhciBkID0gMDtcbiAgICAgICAgZm9yIChrID0gMDsgayA8IGo7IGsrKykge1xuICAgICAgICAgICAgdmFyIExyb3drID0gbFtrXTtcbiAgICAgICAgICAgIHZhciBzID0gMDtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBrOyBpKyspIHtcbiAgICAgICAgICAgICAgICBzICs9IExyb3drW2ldICogTHJvd2pbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBMcm93altrXSA9IHMgPSAoYVtqXVtrXSAtIHMpIC8gbFtrXVtrXTtcbiAgICAgICAgICAgIGQgPSBkICsgcyAqIHM7XG4gICAgICAgIH1cblxuICAgICAgICBkID0gYVtqXVtqXSAtIGQ7XG5cbiAgICAgICAgcG9zaXRpdmVEZWZpbml0ZSAmPSAoZCA+IDApO1xuICAgICAgICBsW2pdW2pdID0gTWF0aC5zcXJ0KE1hdGgubWF4KGQsIDApKTtcbiAgICAgICAgZm9yIChrID0gaiArIDE7IGsgPCBkaW1lbnNpb247IGsrKykge1xuICAgICAgICAgICAgbFtqXVtrXSA9IDA7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIXBvc2l0aXZlRGVmaW5pdGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNYXRyaXggaXMgbm90IHBvc2l0aXZlIGRlZmluaXRlJyk7XG4gICAgfVxuXG4gICAgdGhpcy5MID0gbDtcbn1cblxuQ2hvbGVza3lEZWNvbXBvc2l0aW9uLnByb3RvdHlwZSA9IHtcbiAgICBnZXQgbG93ZXJUcmlhbmd1bGFyTWF0cml4KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5MO1xuICAgIH0sXG4gICAgc29sdmU6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YWx1ZSA9IE1hdHJpeC5jaGVja01hdHJpeCh2YWx1ZSk7XG5cbiAgICAgICAgdmFyIGwgPSB0aGlzLkwsXG4gICAgICAgICAgICBkaW1lbnNpb24gPSBsLnJvd3M7XG5cbiAgICAgICAgaWYgKHZhbHVlLnJvd3MgIT09IGRpbWVuc2lvbikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNYXRyaXggZGltZW5zaW9ucyBkbyBub3QgbWF0Y2gnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjb3VudCA9IHZhbHVlLmNvbHVtbnMsXG4gICAgICAgICAgICBCID0gdmFsdWUuY2xvbmUoKSxcbiAgICAgICAgICAgIGksIGosIGs7XG5cbiAgICAgICAgZm9yIChrID0gMDsgayA8IGRpbWVuc2lvbjsgaysrKSB7XG4gICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgY291bnQ7IGorKykge1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBrOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgQltrXVtqXSAtPSBCW2ldW2pdICogbFtrXVtpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgQltrXVtqXSAvPSBsW2tdW2tdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChrID0gZGltZW5zaW9uIC0gMTsgayA+PSAwOyBrLS0pIHtcbiAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBjb3VudDsgaisrKSB7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gayArIDE7IGkgPCBkaW1lbnNpb247IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBCW2tdW2pdIC09IEJbaV1bal0gKiBsW2ldW2tdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBCW2tdW2pdIC89IGxba11ba107XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gQjtcbiAgICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENob2xlc2t5RGVjb21wb3NpdGlvbjtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgTWF0cml4ID0gcmVxdWlyZSgnLi4vbWF0cml4Jyk7XG5jb25zdCB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG5jb25zdCBoeXBvdGVudXNlID0gdXRpbC5oeXBvdGVudXNlO1xuY29uc3QgZ2V0RmlsbGVkMkRBcnJheSA9IHV0aWwuZ2V0RmlsbGVkMkRBcnJheTtcblxuY29uc3QgZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgYXNzdW1lU3ltbWV0cmljOiBmYWxzZVxufTtcblxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2x1dHpyb2VkZXIvTWFwYWNrL2Jsb2IvbWFzdGVyL1NvdXJjZS9FaWdlbnZhbHVlRGVjb21wb3NpdGlvbi5jc1xuZnVuY3Rpb24gRWlnZW52YWx1ZURlY29tcG9zaXRpb24obWF0cml4LCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRPcHRpb25zLCBvcHRpb25zKTtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgRWlnZW52YWx1ZURlY29tcG9zaXRpb24pKSB7XG4gICAgICAgIHJldHVybiBuZXcgRWlnZW52YWx1ZURlY29tcG9zaXRpb24obWF0cml4LCBvcHRpb25zKTtcbiAgICB9XG4gICAgbWF0cml4ID0gTWF0cml4LmNoZWNrTWF0cml4KG1hdHJpeCk7XG4gICAgaWYgKCFtYXRyaXguaXNTcXVhcmUoKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01hdHJpeCBpcyBub3QgYSBzcXVhcmUgbWF0cml4Jyk7XG4gICAgfVxuXG4gICAgdmFyIG4gPSBtYXRyaXguY29sdW1ucyxcbiAgICAgICAgViA9IGdldEZpbGxlZDJEQXJyYXkobiwgbiwgMCksXG4gICAgICAgIGQgPSBuZXcgQXJyYXkobiksXG4gICAgICAgIGUgPSBuZXcgQXJyYXkobiksXG4gICAgICAgIHZhbHVlID0gbWF0cml4LFxuICAgICAgICBpLCBqO1xuXG4gICAgdmFyIGlzU3ltbWV0cmljID0gZmFsc2U7XG4gICAgaWYgKG9wdGlvbnMuYXNzdW1lU3ltbWV0cmljKSB7XG4gICAgICAgIGlzU3ltbWV0cmljID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBpc1N5bW1ldHJpYyA9IG1hdHJpeC5pc1N5bW1ldHJpYygpO1xuICAgIH1cblxuICAgIGlmIChpc1N5bW1ldHJpYykge1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgbjsgaisrKSB7XG4gICAgICAgICAgICAgICAgVltpXVtqXSA9IHZhbHVlLmdldChpLCBqKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0cmVkMihuLCBlLCBkLCBWKTtcbiAgICAgICAgdHFsMihuLCBlLCBkLCBWKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHZhciBIID0gZ2V0RmlsbGVkMkRBcnJheShuLCBuLCAwKSxcbiAgICAgICAgICAgIG9ydCA9IG5ldyBBcnJheShuKTtcbiAgICAgICAgZm9yIChqID0gMDsgaiA8IG47IGorKykge1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgICAgIEhbaV1bal0gPSB2YWx1ZS5nZXQoaSwgaik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgb3J0aGVzKG4sIEgsIG9ydCwgVik7XG4gICAgICAgIGhxcjIobiwgZSwgZCwgViwgSCk7XG4gICAgfVxuXG4gICAgdGhpcy5uID0gbjtcbiAgICB0aGlzLmUgPSBlO1xuICAgIHRoaXMuZCA9IGQ7XG4gICAgdGhpcy5WID0gVjtcbn1cblxuRWlnZW52YWx1ZURlY29tcG9zaXRpb24ucHJvdG90eXBlID0ge1xuICAgIGdldCByZWFsRWlnZW52YWx1ZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmQ7XG4gICAgfSxcbiAgICBnZXQgaW1hZ2luYXJ5RWlnZW52YWx1ZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmU7XG4gICAgfSxcbiAgICBnZXQgZWlnZW52ZWN0b3JNYXRyaXgoKSB7XG4gICAgICAgIGlmICghTWF0cml4LmlzTWF0cml4KHRoaXMuVikpIHtcbiAgICAgICAgICAgIHRoaXMuViA9IG5ldyBNYXRyaXgodGhpcy5WKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5WO1xuICAgIH0sXG4gICAgZ2V0IGRpYWdvbmFsTWF0cml4KCkge1xuICAgICAgICB2YXIgbiA9IHRoaXMubixcbiAgICAgICAgICAgIGUgPSB0aGlzLmUsXG4gICAgICAgICAgICBkID0gdGhpcy5kLFxuICAgICAgICAgICAgWCA9IG5ldyBNYXRyaXgobiwgbiksXG4gICAgICAgICAgICBpLCBqO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgbjsgaisrKSB7XG4gICAgICAgICAgICAgICAgWFtpXVtqXSA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBYW2ldW2ldID0gZFtpXTtcbiAgICAgICAgICAgIGlmIChlW2ldID4gMCkge1xuICAgICAgICAgICAgICAgIFhbaV1baSArIDFdID0gZVtpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGVbaV0gPCAwKSB7XG4gICAgICAgICAgICAgICAgWFtpXVtpIC0gMV0gPSBlW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBYO1xuICAgIH1cbn07XG5cbmZ1bmN0aW9uIHRyZWQyKG4sIGUsIGQsIFYpIHtcblxuICAgIHZhciBmLCBnLCBoLCBpLCBqLCBrLFxuICAgICAgICBoaCwgc2NhbGU7XG5cbiAgICBmb3IgKGogPSAwOyBqIDwgbjsgaisrKSB7XG4gICAgICAgIGRbal0gPSBWW24gLSAxXVtqXTtcbiAgICB9XG5cbiAgICBmb3IgKGkgPSBuIC0gMTsgaSA+IDA7IGktLSkge1xuICAgICAgICBzY2FsZSA9IDA7XG4gICAgICAgIGggPSAwO1xuICAgICAgICBmb3IgKGsgPSAwOyBrIDwgaTsgaysrKSB7XG4gICAgICAgICAgICBzY2FsZSA9IHNjYWxlICsgTWF0aC5hYnMoZFtrXSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2NhbGUgPT09IDApIHtcbiAgICAgICAgICAgIGVbaV0gPSBkW2kgLSAxXTtcbiAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBpOyBqKyspIHtcbiAgICAgICAgICAgICAgICBkW2pdID0gVltpIC0gMV1bal07XG4gICAgICAgICAgICAgICAgVltpXVtqXSA9IDA7XG4gICAgICAgICAgICAgICAgVltqXVtpXSA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmb3IgKGsgPSAwOyBrIDwgaTsgaysrKSB7XG4gICAgICAgICAgICAgICAgZFtrXSAvPSBzY2FsZTtcbiAgICAgICAgICAgICAgICBoICs9IGRba10gKiBkW2tdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmID0gZFtpIC0gMV07XG4gICAgICAgICAgICBnID0gTWF0aC5zcXJ0KGgpO1xuICAgICAgICAgICAgaWYgKGYgPiAwKSB7XG4gICAgICAgICAgICAgICAgZyA9IC1nO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBlW2ldID0gc2NhbGUgKiBnO1xuICAgICAgICAgICAgaCA9IGggLSBmICogZztcbiAgICAgICAgICAgIGRbaSAtIDFdID0gZiAtIGc7XG4gICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgaTsgaisrKSB7XG4gICAgICAgICAgICAgICAgZVtqXSA9IDA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBpOyBqKyspIHtcbiAgICAgICAgICAgICAgICBmID0gZFtqXTtcbiAgICAgICAgICAgICAgICBWW2pdW2ldID0gZjtcbiAgICAgICAgICAgICAgICBnID0gZVtqXSArIFZbal1bal0gKiBmO1xuICAgICAgICAgICAgICAgIGZvciAoayA9IGogKyAxOyBrIDw9IGkgLSAxOyBrKyspIHtcbiAgICAgICAgICAgICAgICAgICAgZyArPSBWW2tdW2pdICogZFtrXTtcbiAgICAgICAgICAgICAgICAgICAgZVtrXSArPSBWW2tdW2pdICogZjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZVtqXSA9IGc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGYgPSAwO1xuICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IGk7IGorKykge1xuICAgICAgICAgICAgICAgIGVbal0gLz0gaDtcbiAgICAgICAgICAgICAgICBmICs9IGVbal0gKiBkW2pdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBoaCA9IGYgLyAoaCArIGgpO1xuICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IGk7IGorKykge1xuICAgICAgICAgICAgICAgIGVbal0gLT0gaGggKiBkW2pdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgaTsgaisrKSB7XG4gICAgICAgICAgICAgICAgZiA9IGRbal07XG4gICAgICAgICAgICAgICAgZyA9IGVbal07XG4gICAgICAgICAgICAgICAgZm9yIChrID0gajsgayA8PSBpIC0gMTsgaysrKSB7XG4gICAgICAgICAgICAgICAgICAgIFZba11bal0gLT0gKGYgKiBlW2tdICsgZyAqIGRba10pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkW2pdID0gVltpIC0gMV1bal07XG4gICAgICAgICAgICAgICAgVltpXVtqXSA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZFtpXSA9IGg7XG4gICAgfVxuXG4gICAgZm9yIChpID0gMDsgaSA8IG4gLSAxOyBpKyspIHtcbiAgICAgICAgVltuIC0gMV1baV0gPSBWW2ldW2ldO1xuICAgICAgICBWW2ldW2ldID0gMTtcbiAgICAgICAgaCA9IGRbaSArIDFdO1xuICAgICAgICBpZiAoaCAhPT0gMCkge1xuICAgICAgICAgICAgZm9yIChrID0gMDsgayA8PSBpOyBrKyspIHtcbiAgICAgICAgICAgICAgICBkW2tdID0gVltrXVtpICsgMV0gLyBoO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKGogPSAwOyBqIDw9IGk7IGorKykge1xuICAgICAgICAgICAgICAgIGcgPSAwO1xuICAgICAgICAgICAgICAgIGZvciAoayA9IDA7IGsgPD0gaTsgaysrKSB7XG4gICAgICAgICAgICAgICAgICAgIGcgKz0gVltrXVtpICsgMV0gKiBWW2tdW2pdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKGsgPSAwOyBrIDw9IGk7IGsrKykge1xuICAgICAgICAgICAgICAgICAgICBWW2tdW2pdIC09IGcgKiBkW2tdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoayA9IDA7IGsgPD0gaTsgaysrKSB7XG4gICAgICAgICAgICBWW2tdW2kgKyAxXSA9IDA7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKGogPSAwOyBqIDwgbjsgaisrKSB7XG4gICAgICAgIGRbal0gPSBWW24gLSAxXVtqXTtcbiAgICAgICAgVltuIC0gMV1bal0gPSAwO1xuICAgIH1cblxuICAgIFZbbiAtIDFdW24gLSAxXSA9IDE7XG4gICAgZVswXSA9IDA7XG59XG5cbmZ1bmN0aW9uIHRxbDIobiwgZSwgZCwgVikge1xuXG4gICAgdmFyIGcsIGgsIGksIGosIGssIGwsIG0sIHAsIHIsXG4gICAgICAgIGRsMSwgYywgYzIsIGMzLCBlbDEsIHMsIHMyLFxuICAgICAgICBpdGVyO1xuXG4gICAgZm9yIChpID0gMTsgaSA8IG47IGkrKykge1xuICAgICAgICBlW2kgLSAxXSA9IGVbaV07XG4gICAgfVxuXG4gICAgZVtuIC0gMV0gPSAwO1xuXG4gICAgdmFyIGYgPSAwLFxuICAgICAgICB0c3QxID0gMCxcbiAgICAgICAgZXBzID0gTWF0aC5wb3coMiwgLTUyKTtcblxuICAgIGZvciAobCA9IDA7IGwgPCBuOyBsKyspIHtcbiAgICAgICAgdHN0MSA9IE1hdGgubWF4KHRzdDEsIE1hdGguYWJzKGRbbF0pICsgTWF0aC5hYnMoZVtsXSkpO1xuICAgICAgICBtID0gbDtcbiAgICAgICAgd2hpbGUgKG0gPCBuKSB7XG4gICAgICAgICAgICBpZiAoTWF0aC5hYnMoZVttXSkgPD0gZXBzICogdHN0MSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbSsrO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG0gPiBsKSB7XG4gICAgICAgICAgICBpdGVyID0gMDtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICBpdGVyID0gaXRlciArIDE7XG5cbiAgICAgICAgICAgICAgICBnID0gZFtsXTtcbiAgICAgICAgICAgICAgICBwID0gKGRbbCArIDFdIC0gZykgLyAoMiAqIGVbbF0pO1xuICAgICAgICAgICAgICAgIHIgPSBoeXBvdGVudXNlKHAsIDEpO1xuICAgICAgICAgICAgICAgIGlmIChwIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICByID0gLXI7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZFtsXSA9IGVbbF0gLyAocCArIHIpO1xuICAgICAgICAgICAgICAgIGRbbCArIDFdID0gZVtsXSAqIChwICsgcik7XG4gICAgICAgICAgICAgICAgZGwxID0gZFtsICsgMV07XG4gICAgICAgICAgICAgICAgaCA9IGcgLSBkW2xdO1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IGwgKyAyOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGRbaV0gLT0gaDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmID0gZiArIGg7XG5cbiAgICAgICAgICAgICAgICBwID0gZFttXTtcbiAgICAgICAgICAgICAgICBjID0gMTtcbiAgICAgICAgICAgICAgICBjMiA9IGM7XG4gICAgICAgICAgICAgICAgYzMgPSBjO1xuICAgICAgICAgICAgICAgIGVsMSA9IGVbbCArIDFdO1xuICAgICAgICAgICAgICAgIHMgPSAwO1xuICAgICAgICAgICAgICAgIHMyID0gMDtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSBtIC0gMTsgaSA+PSBsOyBpLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgYzMgPSBjMjtcbiAgICAgICAgICAgICAgICAgICAgYzIgPSBjO1xuICAgICAgICAgICAgICAgICAgICBzMiA9IHM7XG4gICAgICAgICAgICAgICAgICAgIGcgPSBjICogZVtpXTtcbiAgICAgICAgICAgICAgICAgICAgaCA9IGMgKiBwO1xuICAgICAgICAgICAgICAgICAgICByID0gaHlwb3RlbnVzZShwLCBlW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgZVtpICsgMV0gPSBzICogcjtcbiAgICAgICAgICAgICAgICAgICAgcyA9IGVbaV0gLyByO1xuICAgICAgICAgICAgICAgICAgICBjID0gcCAvIHI7XG4gICAgICAgICAgICAgICAgICAgIHAgPSBjICogZFtpXSAtIHMgKiBnO1xuICAgICAgICAgICAgICAgICAgICBkW2kgKyAxXSA9IGggKyBzICogKGMgKiBnICsgcyAqIGRbaV0pO1xuXG4gICAgICAgICAgICAgICAgICAgIGZvciAoayA9IDA7IGsgPCBuOyBrKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGggPSBWW2tdW2kgKyAxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIFZba11baSArIDFdID0gcyAqIFZba11baV0gKyBjICogaDtcbiAgICAgICAgICAgICAgICAgICAgICAgIFZba11baV0gPSBjICogVltrXVtpXSAtIHMgKiBoO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcCA9IC1zICogczIgKiBjMyAqIGVsMSAqIGVbbF0gLyBkbDE7XG4gICAgICAgICAgICAgICAgZVtsXSA9IHMgKiBwO1xuICAgICAgICAgICAgICAgIGRbbF0gPSBjICogcDtcblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2hpbGUgKE1hdGguYWJzKGVbbF0pID4gZXBzICogdHN0MSk7XG4gICAgICAgIH1cbiAgICAgICAgZFtsXSA9IGRbbF0gKyBmO1xuICAgICAgICBlW2xdID0gMDtcbiAgICB9XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbiAtIDE7IGkrKykge1xuICAgICAgICBrID0gaTtcbiAgICAgICAgcCA9IGRbaV07XG4gICAgICAgIGZvciAoaiA9IGkgKyAxOyBqIDwgbjsgaisrKSB7XG4gICAgICAgICAgICBpZiAoZFtqXSA8IHApIHtcbiAgICAgICAgICAgICAgICBrID0gajtcbiAgICAgICAgICAgICAgICBwID0gZFtqXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChrICE9PSBpKSB7XG4gICAgICAgICAgICBkW2tdID0gZFtpXTtcbiAgICAgICAgICAgIGRbaV0gPSBwO1xuICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IG47IGorKykge1xuICAgICAgICAgICAgICAgIHAgPSBWW2pdW2ldO1xuICAgICAgICAgICAgICAgIFZbal1baV0gPSBWW2pdW2tdO1xuICAgICAgICAgICAgICAgIFZbal1ba10gPSBwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiBvcnRoZXMobiwgSCwgb3J0LCBWKSB7XG5cbiAgICB2YXIgbG93ID0gMCxcbiAgICAgICAgaGlnaCA9IG4gLSAxLFxuICAgICAgICBmLCBnLCBoLCBpLCBqLCBtLFxuICAgICAgICBzY2FsZTtcblxuICAgIGZvciAobSA9IGxvdyArIDE7IG0gPD0gaGlnaCAtIDE7IG0rKykge1xuICAgICAgICBzY2FsZSA9IDA7XG4gICAgICAgIGZvciAoaSA9IG07IGkgPD0gaGlnaDsgaSsrKSB7XG4gICAgICAgICAgICBzY2FsZSA9IHNjYWxlICsgTWF0aC5hYnMoSFtpXVttIC0gMV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNjYWxlICE9PSAwKSB7XG4gICAgICAgICAgICBoID0gMDtcbiAgICAgICAgICAgIGZvciAoaSA9IGhpZ2g7IGkgPj0gbTsgaS0tKSB7XG4gICAgICAgICAgICAgICAgb3J0W2ldID0gSFtpXVttIC0gMV0gLyBzY2FsZTtcbiAgICAgICAgICAgICAgICBoICs9IG9ydFtpXSAqIG9ydFtpXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZyA9IE1hdGguc3FydChoKTtcbiAgICAgICAgICAgIGlmIChvcnRbbV0gPiAwKSB7XG4gICAgICAgICAgICAgICAgZyA9IC1nO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBoID0gaCAtIG9ydFttXSAqIGc7XG4gICAgICAgICAgICBvcnRbbV0gPSBvcnRbbV0gLSBnO1xuXG4gICAgICAgICAgICBmb3IgKGogPSBtOyBqIDwgbjsgaisrKSB7XG4gICAgICAgICAgICAgICAgZiA9IDA7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gaGlnaDsgaSA+PSBtOyBpLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgZiArPSBvcnRbaV0gKiBIW2ldW2pdO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGYgPSBmIC8gaDtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSBtOyBpIDw9IGhpZ2g7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBIW2ldW2pdIC09IGYgKiBvcnRbaV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDw9IGhpZ2g7IGkrKykge1xuICAgICAgICAgICAgICAgIGYgPSAwO1xuICAgICAgICAgICAgICAgIGZvciAoaiA9IGhpZ2g7IGogPj0gbTsgai0tKSB7XG4gICAgICAgICAgICAgICAgICAgIGYgKz0gb3J0W2pdICogSFtpXVtqXTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmID0gZiAvIGg7XG4gICAgICAgICAgICAgICAgZm9yIChqID0gbTsgaiA8PSBoaWdoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgSFtpXVtqXSAtPSBmICogb3J0W2pdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgb3J0W21dID0gc2NhbGUgKiBvcnRbbV07XG4gICAgICAgICAgICBIW21dW20gLSAxXSA9IHNjYWxlICogZztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZvciAoaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgZm9yIChqID0gMDsgaiA8IG47IGorKykge1xuICAgICAgICAgICAgVltpXVtqXSA9IChpID09PSBqID8gMSA6IDApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZm9yIChtID0gaGlnaCAtIDE7IG0gPj0gbG93ICsgMTsgbS0tKSB7XG4gICAgICAgIGlmIChIW21dW20gLSAxXSAhPT0gMCkge1xuICAgICAgICAgICAgZm9yIChpID0gbSArIDE7IGkgPD0gaGlnaDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgb3J0W2ldID0gSFtpXVttIC0gMV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAoaiA9IG07IGogPD0gaGlnaDsgaisrKSB7XG4gICAgICAgICAgICAgICAgZyA9IDA7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gbTsgaSA8PSBoaWdoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgZyArPSBvcnRbaV0gKiBWW2ldW2pdO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGcgPSAoZyAvIG9ydFttXSkgLyBIW21dW20gLSAxXTtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSBtOyBpIDw9IGhpZ2g7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBWW2ldW2pdICs9IGcgKiBvcnRbaV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiBocXIyKG5uLCBlLCBkLCBWLCBIKSB7XG4gICAgdmFyIG4gPSBubiAtIDEsXG4gICAgICAgIGxvdyA9IDAsXG4gICAgICAgIGhpZ2ggPSBubiAtIDEsXG4gICAgICAgIGVwcyA9IE1hdGgucG93KDIsIC01MiksXG4gICAgICAgIGV4c2hpZnQgPSAwLFxuICAgICAgICBub3JtID0gMCxcbiAgICAgICAgcCA9IDAsXG4gICAgICAgIHEgPSAwLFxuICAgICAgICByID0gMCxcbiAgICAgICAgcyA9IDAsXG4gICAgICAgIHogPSAwLFxuICAgICAgICBpdGVyID0gMCxcbiAgICAgICAgaSwgaiwgaywgbCwgbSwgdCwgdywgeCwgeSxcbiAgICAgICAgcmEsIHNhLCB2ciwgdmksXG4gICAgICAgIG5vdGxhc3QsIGNkaXZyZXM7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbm47IGkrKykge1xuICAgICAgICBpZiAoaSA8IGxvdyB8fCBpID4gaGlnaCkge1xuICAgICAgICAgICAgZFtpXSA9IEhbaV1baV07XG4gICAgICAgICAgICBlW2ldID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoaiA9IE1hdGgubWF4KGkgLSAxLCAwKTsgaiA8IG5uOyBqKyspIHtcbiAgICAgICAgICAgIG5vcm0gPSBub3JtICsgTWF0aC5hYnMoSFtpXVtqXSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB3aGlsZSAobiA+PSBsb3cpIHtcbiAgICAgICAgbCA9IG47XG4gICAgICAgIHdoaWxlIChsID4gbG93KSB7XG4gICAgICAgICAgICBzID0gTWF0aC5hYnMoSFtsIC0gMV1bbCAtIDFdKSArIE1hdGguYWJzKEhbbF1bbF0pO1xuICAgICAgICAgICAgaWYgKHMgPT09IDApIHtcbiAgICAgICAgICAgICAgICBzID0gbm9ybTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChNYXRoLmFicyhIW2xdW2wgLSAxXSkgPCBlcHMgKiBzKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsLS07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobCA9PT0gbikge1xuICAgICAgICAgICAgSFtuXVtuXSA9IEhbbl1bbl0gKyBleHNoaWZ0O1xuICAgICAgICAgICAgZFtuXSA9IEhbbl1bbl07XG4gICAgICAgICAgICBlW25dID0gMDtcbiAgICAgICAgICAgIG4tLTtcbiAgICAgICAgICAgIGl0ZXIgPSAwO1xuICAgICAgICB9IGVsc2UgaWYgKGwgPT09IG4gLSAxKSB7XG4gICAgICAgICAgICB3ID0gSFtuXVtuIC0gMV0gKiBIW24gLSAxXVtuXTtcbiAgICAgICAgICAgIHAgPSAoSFtuIC0gMV1bbiAtIDFdIC0gSFtuXVtuXSkgLyAyO1xuICAgICAgICAgICAgcSA9IHAgKiBwICsgdztcbiAgICAgICAgICAgIHogPSBNYXRoLnNxcnQoTWF0aC5hYnMocSkpO1xuICAgICAgICAgICAgSFtuXVtuXSA9IEhbbl1bbl0gKyBleHNoaWZ0O1xuICAgICAgICAgICAgSFtuIC0gMV1bbiAtIDFdID0gSFtuIC0gMV1bbiAtIDFdICsgZXhzaGlmdDtcbiAgICAgICAgICAgIHggPSBIW25dW25dO1xuXG4gICAgICAgICAgICBpZiAocSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgeiA9IChwID49IDApID8gKHAgKyB6KSA6IChwIC0geik7XG4gICAgICAgICAgICAgICAgZFtuIC0gMV0gPSB4ICsgejtcbiAgICAgICAgICAgICAgICBkW25dID0gZFtuIC0gMV07XG4gICAgICAgICAgICAgICAgaWYgKHogIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZFtuXSA9IHggLSB3IC8gejtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZVtuIC0gMV0gPSAwO1xuICAgICAgICAgICAgICAgIGVbbl0gPSAwO1xuICAgICAgICAgICAgICAgIHggPSBIW25dW24gLSAxXTtcbiAgICAgICAgICAgICAgICBzID0gTWF0aC5hYnMoeCkgKyBNYXRoLmFicyh6KTtcbiAgICAgICAgICAgICAgICBwID0geCAvIHM7XG4gICAgICAgICAgICAgICAgcSA9IHogLyBzO1xuICAgICAgICAgICAgICAgIHIgPSBNYXRoLnNxcnQocCAqIHAgKyBxICogcSk7XG4gICAgICAgICAgICAgICAgcCA9IHAgLyByO1xuICAgICAgICAgICAgICAgIHEgPSBxIC8gcjtcblxuICAgICAgICAgICAgICAgIGZvciAoaiA9IG4gLSAxOyBqIDwgbm47IGorKykge1xuICAgICAgICAgICAgICAgICAgICB6ID0gSFtuIC0gMV1bal07XG4gICAgICAgICAgICAgICAgICAgIEhbbiAtIDFdW2pdID0gcSAqIHogKyBwICogSFtuXVtqXTtcbiAgICAgICAgICAgICAgICAgICAgSFtuXVtqXSA9IHEgKiBIW25dW2pdIC0gcCAqIHo7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8PSBuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgeiA9IEhbaV1bbiAtIDFdO1xuICAgICAgICAgICAgICAgICAgICBIW2ldW24gLSAxXSA9IHEgKiB6ICsgcCAqIEhbaV1bbl07XG4gICAgICAgICAgICAgICAgICAgIEhbaV1bbl0gPSBxICogSFtpXVtuXSAtIHAgKiB6O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZvciAoaSA9IGxvdzsgaSA8PSBoaWdoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgeiA9IFZbaV1bbiAtIDFdO1xuICAgICAgICAgICAgICAgICAgICBWW2ldW24gLSAxXSA9IHEgKiB6ICsgcCAqIFZbaV1bbl07XG4gICAgICAgICAgICAgICAgICAgIFZbaV1bbl0gPSBxICogVltpXVtuXSAtIHAgKiB6O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZFtuIC0gMV0gPSB4ICsgcDtcbiAgICAgICAgICAgICAgICBkW25dID0geCArIHA7XG4gICAgICAgICAgICAgICAgZVtuIC0gMV0gPSB6O1xuICAgICAgICAgICAgICAgIGVbbl0gPSAtejtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbiA9IG4gLSAyO1xuICAgICAgICAgICAgaXRlciA9IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB4ID0gSFtuXVtuXTtcbiAgICAgICAgICAgIHkgPSAwO1xuICAgICAgICAgICAgdyA9IDA7XG4gICAgICAgICAgICBpZiAobCA8IG4pIHtcbiAgICAgICAgICAgICAgICB5ID0gSFtuIC0gMV1bbiAtIDFdO1xuICAgICAgICAgICAgICAgIHcgPSBIW25dW24gLSAxXSAqIEhbbiAtIDFdW25dO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaXRlciA9PT0gMTApIHtcbiAgICAgICAgICAgICAgICBleHNoaWZ0ICs9IHg7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gbG93OyBpIDw9IG47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBIW2ldW2ldIC09IHg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHMgPSBNYXRoLmFicyhIW25dW24gLSAxXSkgKyBNYXRoLmFicyhIW24gLSAxXVtuIC0gMl0pO1xuICAgICAgICAgICAgICAgIHggPSB5ID0gMC43NSAqIHM7XG4gICAgICAgICAgICAgICAgdyA9IC0wLjQzNzUgKiBzICogcztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGl0ZXIgPT09IDMwKSB7XG4gICAgICAgICAgICAgICAgcyA9ICh5IC0geCkgLyAyO1xuICAgICAgICAgICAgICAgIHMgPSBzICogcyArIHc7XG4gICAgICAgICAgICAgICAgaWYgKHMgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHMgPSBNYXRoLnNxcnQocyk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh5IDwgeCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcyA9IC1zO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHMgPSB4IC0gdyAvICgoeSAtIHgpIC8gMiArIHMpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSBsb3c7IGkgPD0gbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBIW2ldW2ldIC09IHM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZXhzaGlmdCArPSBzO1xuICAgICAgICAgICAgICAgICAgICB4ID0geSA9IHcgPSAwLjk2NDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGl0ZXIgPSBpdGVyICsgMTtcblxuICAgICAgICAgICAgbSA9IG4gLSAyO1xuICAgICAgICAgICAgd2hpbGUgKG0gPj0gbCkge1xuICAgICAgICAgICAgICAgIHogPSBIW21dW21dO1xuICAgICAgICAgICAgICAgIHIgPSB4IC0gejtcbiAgICAgICAgICAgICAgICBzID0geSAtIHo7XG4gICAgICAgICAgICAgICAgcCA9IChyICogcyAtIHcpIC8gSFttICsgMV1bbV0gKyBIW21dW20gKyAxXTtcbiAgICAgICAgICAgICAgICBxID0gSFttICsgMV1bbSArIDFdIC0geiAtIHIgLSBzO1xuICAgICAgICAgICAgICAgIHIgPSBIW20gKyAyXVttICsgMV07XG4gICAgICAgICAgICAgICAgcyA9IE1hdGguYWJzKHApICsgTWF0aC5hYnMocSkgKyBNYXRoLmFicyhyKTtcbiAgICAgICAgICAgICAgICBwID0gcCAvIHM7XG4gICAgICAgICAgICAgICAgcSA9IHEgLyBzO1xuICAgICAgICAgICAgICAgIHIgPSByIC8gcztcbiAgICAgICAgICAgICAgICBpZiAobSA9PT0gbCkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKE1hdGguYWJzKEhbbV1bbSAtIDFdKSAqIChNYXRoLmFicyhxKSArIE1hdGguYWJzKHIpKSA8IGVwcyAqIChNYXRoLmFicyhwKSAqIChNYXRoLmFicyhIW20gLSAxXVttIC0gMV0pICsgTWF0aC5hYnMoeikgKyBNYXRoLmFicyhIW20gKyAxXVttICsgMV0pKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG0tLTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yIChpID0gbSArIDI7IGkgPD0gbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgSFtpXVtpIC0gMl0gPSAwO1xuICAgICAgICAgICAgICAgIGlmIChpID4gbSArIDIpIHtcbiAgICAgICAgICAgICAgICAgICAgSFtpXVtpIC0gM10gPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yIChrID0gbTsgayA8PSBuIC0gMTsgaysrKSB7XG4gICAgICAgICAgICAgICAgbm90bGFzdCA9IChrICE9PSBuIC0gMSk7XG4gICAgICAgICAgICAgICAgaWYgKGsgIT09IG0pIHtcbiAgICAgICAgICAgICAgICAgICAgcCA9IEhba11bayAtIDFdO1xuICAgICAgICAgICAgICAgICAgICBxID0gSFtrICsgMV1bayAtIDFdO1xuICAgICAgICAgICAgICAgICAgICByID0gKG5vdGxhc3QgPyBIW2sgKyAyXVtrIC0gMV0gOiAwKTtcbiAgICAgICAgICAgICAgICAgICAgeCA9IE1hdGguYWJzKHApICsgTWF0aC5hYnMocSkgKyBNYXRoLmFicyhyKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHggIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHAgPSBwIC8geDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHEgPSBxIC8geDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHIgPSByIC8geDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICh4ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHMgPSBNYXRoLnNxcnQocCAqIHAgKyBxICogcSArIHIgKiByKTtcbiAgICAgICAgICAgICAgICBpZiAocCA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcyA9IC1zO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChzICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChrICE9PSBtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBIW2tdW2sgLSAxXSA9IC1zICogeDtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChsICE9PSBtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBIW2tdW2sgLSAxXSA9IC1IW2tdW2sgLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHAgPSBwICsgcztcbiAgICAgICAgICAgICAgICAgICAgeCA9IHAgLyBzO1xuICAgICAgICAgICAgICAgICAgICB5ID0gcSAvIHM7XG4gICAgICAgICAgICAgICAgICAgIHogPSByIC8gcztcbiAgICAgICAgICAgICAgICAgICAgcSA9IHEgLyBwO1xuICAgICAgICAgICAgICAgICAgICByID0gciAvIHA7XG5cbiAgICAgICAgICAgICAgICAgICAgZm9yIChqID0gazsgaiA8IG5uOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHAgPSBIW2tdW2pdICsgcSAqIEhbayArIDFdW2pdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vdGxhc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwID0gcCArIHIgKiBIW2sgKyAyXVtqXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBIW2sgKyAyXVtqXSA9IEhbayArIDJdW2pdIC0gcCAqIHo7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIEhba11bal0gPSBIW2tdW2pdIC0gcCAqIHg7XG4gICAgICAgICAgICAgICAgICAgICAgICBIW2sgKyAxXVtqXSA9IEhbayArIDFdW2pdIC0gcCAqIHk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDw9IE1hdGgubWluKG4sIGsgKyAzKTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwID0geCAqIEhbaV1ba10gKyB5ICogSFtpXVtrICsgMV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobm90bGFzdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAgPSBwICsgeiAqIEhbaV1bayArIDJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEhbaV1bayArIDJdID0gSFtpXVtrICsgMl0gLSBwICogcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgSFtpXVtrXSA9IEhbaV1ba10gLSBwO1xuICAgICAgICAgICAgICAgICAgICAgICAgSFtpXVtrICsgMV0gPSBIW2ldW2sgKyAxXSAtIHAgKiBxO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gbG93OyBpIDw9IGhpZ2g7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcCA9IHggKiBWW2ldW2tdICsgeSAqIFZbaV1bayArIDFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vdGxhc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwID0gcCArIHogKiBWW2ldW2sgKyAyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBWW2ldW2sgKyAyXSA9IFZbaV1bayArIDJdIC0gcCAqIHI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIFZbaV1ba10gPSBWW2ldW2tdIC0gcDtcbiAgICAgICAgICAgICAgICAgICAgICAgIFZbaV1bayArIDFdID0gVltpXVtrICsgMV0gLSBwICogcTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChub3JtID09PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBmb3IgKG4gPSBubiAtIDE7IG4gPj0gMDsgbi0tKSB7XG4gICAgICAgIHAgPSBkW25dO1xuICAgICAgICBxID0gZVtuXTtcblxuICAgICAgICBpZiAocSA9PT0gMCkge1xuICAgICAgICAgICAgbCA9IG47XG4gICAgICAgICAgICBIW25dW25dID0gMTtcbiAgICAgICAgICAgIGZvciAoaSA9IG4gLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgICAgIHcgPSBIW2ldW2ldIC0gcDtcbiAgICAgICAgICAgICAgICByID0gMDtcbiAgICAgICAgICAgICAgICBmb3IgKGogPSBsOyBqIDw9IG47IGorKykge1xuICAgICAgICAgICAgICAgICAgICByID0gciArIEhbaV1bal0gKiBIW2pdW25dO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChlW2ldIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICB6ID0gdztcbiAgICAgICAgICAgICAgICAgICAgcyA9IHI7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbCA9IGk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlW2ldID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBIW2ldW25dID0gKHcgIT09IDApID8gKC1yIC8gdykgOiAoLXIgLyAoZXBzICogbm9ybSkpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgeCA9IEhbaV1baSArIDFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgeSA9IEhbaSArIDFdW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgcSA9IChkW2ldIC0gcCkgKiAoZFtpXSAtIHApICsgZVtpXSAqIGVbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICB0ID0gKHggKiBzIC0geiAqIHIpIC8gcTtcbiAgICAgICAgICAgICAgICAgICAgICAgIEhbaV1bbl0gPSB0O1xuICAgICAgICAgICAgICAgICAgICAgICAgSFtpICsgMV1bbl0gPSAoTWF0aC5hYnMoeCkgPiBNYXRoLmFicyh6KSkgPyAoKC1yIC0gdyAqIHQpIC8geCkgOiAoKC1zIC0geSAqIHQpIC8geik7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB0ID0gTWF0aC5hYnMoSFtpXVtuXSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICgoZXBzICogdCkgKiB0ID4gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChqID0gaTsgaiA8PSBuOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBIW2pdW25dID0gSFtqXVtuXSAvIHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAocSA8IDApIHtcbiAgICAgICAgICAgIGwgPSBuIC0gMTtcblxuICAgICAgICAgICAgaWYgKE1hdGguYWJzKEhbbl1bbiAtIDFdKSA+IE1hdGguYWJzKEhbbiAtIDFdW25dKSkge1xuICAgICAgICAgICAgICAgIEhbbiAtIDFdW24gLSAxXSA9IHEgLyBIW25dW24gLSAxXTtcbiAgICAgICAgICAgICAgICBIW24gLSAxXVtuXSA9IC0oSFtuXVtuXSAtIHApIC8gSFtuXVtuIC0gMV07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNkaXZyZXMgPSBjZGl2KDAsIC1IW24gLSAxXVtuXSwgSFtuIC0gMV1bbiAtIDFdIC0gcCwgcSk7XG4gICAgICAgICAgICAgICAgSFtuIC0gMV1bbiAtIDFdID0gY2RpdnJlc1swXTtcbiAgICAgICAgICAgICAgICBIW24gLSAxXVtuXSA9IGNkaXZyZXNbMV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIEhbbl1bbiAtIDFdID0gMDtcbiAgICAgICAgICAgIEhbbl1bbl0gPSAxO1xuICAgICAgICAgICAgZm9yIChpID0gbiAtIDI7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgcmEgPSAwO1xuICAgICAgICAgICAgICAgIHNhID0gMDtcbiAgICAgICAgICAgICAgICBmb3IgKGogPSBsOyBqIDw9IG47IGorKykge1xuICAgICAgICAgICAgICAgICAgICByYSA9IHJhICsgSFtpXVtqXSAqIEhbal1bbiAtIDFdO1xuICAgICAgICAgICAgICAgICAgICBzYSA9IHNhICsgSFtpXVtqXSAqIEhbal1bbl07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdyA9IEhbaV1baV0gLSBwO1xuXG4gICAgICAgICAgICAgICAgaWYgKGVbaV0gPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHogPSB3O1xuICAgICAgICAgICAgICAgICAgICByID0gcmE7XG4gICAgICAgICAgICAgICAgICAgIHMgPSBzYTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsID0gaTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVbaV0gPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNkaXZyZXMgPSBjZGl2KC1yYSwgLXNhLCB3LCBxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIEhbaV1bbiAtIDFdID0gY2RpdnJlc1swXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIEhbaV1bbl0gPSBjZGl2cmVzWzFdO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgeCA9IEhbaV1baSArIDFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgeSA9IEhbaSArIDFdW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgdnIgPSAoZFtpXSAtIHApICogKGRbaV0gLSBwKSArIGVbaV0gKiBlW2ldIC0gcSAqIHE7XG4gICAgICAgICAgICAgICAgICAgICAgICB2aSA9IChkW2ldIC0gcCkgKiAyICogcTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2ciA9PT0gMCAmJiB2aSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZyID0gZXBzICogbm9ybSAqIChNYXRoLmFicyh3KSArIE1hdGguYWJzKHEpICsgTWF0aC5hYnMoeCkgKyBNYXRoLmFicyh5KSArIE1hdGguYWJzKHopKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNkaXZyZXMgPSBjZGl2KHggKiByIC0geiAqIHJhICsgcSAqIHNhLCB4ICogcyAtIHogKiBzYSAtIHEgKiByYSwgdnIsIHZpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIEhbaV1bbiAtIDFdID0gY2RpdnJlc1swXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIEhbaV1bbl0gPSBjZGl2cmVzWzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKE1hdGguYWJzKHgpID4gKE1hdGguYWJzKHopICsgTWF0aC5hYnMocSkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgSFtpICsgMV1bbiAtIDFdID0gKC1yYSAtIHcgKiBIW2ldW24gLSAxXSArIHEgKiBIW2ldW25dKSAvIHg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgSFtpICsgMV1bbl0gPSAoLXNhIC0gdyAqIEhbaV1bbl0gLSBxICogSFtpXVtuIC0gMV0pIC8geDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2RpdnJlcyA9IGNkaXYoLXIgLSB5ICogSFtpXVtuIC0gMV0sIC1zIC0geSAqIEhbaV1bbl0sIHosIHEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEhbaSArIDFdW24gLSAxXSA9IGNkaXZyZXNbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgSFtpICsgMV1bbl0gPSBjZGl2cmVzWzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdCA9IE1hdGgubWF4KE1hdGguYWJzKEhbaV1bbiAtIDFdKSwgTWF0aC5hYnMoSFtpXVtuXSkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoKGVwcyAqIHQpICogdCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaiA9IGk7IGogPD0gbjsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgSFtqXVtuIC0gMV0gPSBIW2pdW24gLSAxXSAvIHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgSFtqXVtuXSA9IEhbal1bbl0gLyB0O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZm9yIChpID0gMDsgaSA8IG5uOyBpKyspIHtcbiAgICAgICAgaWYgKGkgPCBsb3cgfHwgaSA+IGhpZ2gpIHtcbiAgICAgICAgICAgIGZvciAoaiA9IGk7IGogPCBubjsgaisrKSB7XG4gICAgICAgICAgICAgICAgVltpXVtqXSA9IEhbaV1bal07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKGogPSBubiAtIDE7IGogPj0gbG93OyBqLS0pIHtcbiAgICAgICAgZm9yIChpID0gbG93OyBpIDw9IGhpZ2g7IGkrKykge1xuICAgICAgICAgICAgeiA9IDA7XG4gICAgICAgICAgICBmb3IgKGsgPSBsb3c7IGsgPD0gTWF0aC5taW4oaiwgaGlnaCk7IGsrKykge1xuICAgICAgICAgICAgICAgIHogPSB6ICsgVltpXVtrXSAqIEhba11bal07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBWW2ldW2pdID0gejtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZnVuY3Rpb24gY2Rpdih4ciwgeGksIHlyLCB5aSkge1xuICAgIHZhciByLCBkO1xuICAgIGlmIChNYXRoLmFicyh5cikgPiBNYXRoLmFicyh5aSkpIHtcbiAgICAgICAgciA9IHlpIC8geXI7XG4gICAgICAgIGQgPSB5ciArIHIgKiB5aTtcbiAgICAgICAgcmV0dXJuIFsoeHIgKyByICogeGkpIC8gZCwgKHhpIC0gciAqIHhyKSAvIGRdO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgciA9IHlyIC8geWk7XG4gICAgICAgIGQgPSB5aSArIHIgKiB5cjtcbiAgICAgICAgcmV0dXJuIFsociAqIHhyICsgeGkpIC8gZCwgKHIgKiB4aSAtIHhyKSAvIGRdO1xuICAgIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBFaWdlbnZhbHVlRGVjb21wb3NpdGlvbjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIE1hdHJpeCA9IHJlcXVpcmUoJy4uL21hdHJpeCcpO1xuXG4vLyBodHRwczovL2dpdGh1Yi5jb20vbHV0enJvZWRlci9NYXBhY2svYmxvYi9tYXN0ZXIvU291cmNlL0x1RGVjb21wb3NpdGlvbi5jc1xuZnVuY3Rpb24gTHVEZWNvbXBvc2l0aW9uKG1hdHJpeCkge1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBMdURlY29tcG9zaXRpb24pKSB7XG4gICAgICAgIHJldHVybiBuZXcgTHVEZWNvbXBvc2l0aW9uKG1hdHJpeCk7XG4gICAgfVxuICAgIG1hdHJpeCA9IE1hdHJpeC5jaGVja01hdHJpeChtYXRyaXgpO1xuXG4gICAgdmFyIGx1ID0gbWF0cml4LmNsb25lKCksXG4gICAgICAgIHJvd3MgPSBsdS5yb3dzLFxuICAgICAgICBjb2x1bW5zID0gbHUuY29sdW1ucyxcbiAgICAgICAgcGl2b3RWZWN0b3IgPSBuZXcgQXJyYXkocm93cyksXG4gICAgICAgIHBpdm90U2lnbiA9IDEsXG4gICAgICAgIGksIGosIGssIHAsIHMsIHQsIHYsXG4gICAgICAgIExVcm93aSwgTFVjb2xqLCBrbWF4O1xuXG4gICAgZm9yIChpID0gMDsgaSA8IHJvd3M7IGkrKykge1xuICAgICAgICBwaXZvdFZlY3RvcltpXSA9IGk7XG4gICAgfVxuXG4gICAgTFVjb2xqID0gbmV3IEFycmF5KHJvd3MpO1xuXG4gICAgZm9yIChqID0gMDsgaiA8IGNvbHVtbnM7IGorKykge1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCByb3dzOyBpKyspIHtcbiAgICAgICAgICAgIExVY29saltpXSA9IGx1W2ldW2pdO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHJvd3M7IGkrKykge1xuICAgICAgICAgICAgTFVyb3dpID0gbHVbaV07XG4gICAgICAgICAgICBrbWF4ID0gTWF0aC5taW4oaSwgaik7XG4gICAgICAgICAgICBzID0gMDtcbiAgICAgICAgICAgIGZvciAoayA9IDA7IGsgPCBrbWF4OyBrKyspIHtcbiAgICAgICAgICAgICAgICBzICs9IExVcm93aVtrXSAqIExVY29saltrXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIExVcm93aVtqXSA9IExVY29saltpXSAtPSBzO1xuICAgICAgICB9XG5cbiAgICAgICAgcCA9IGo7XG4gICAgICAgIGZvciAoaSA9IGogKyAxOyBpIDwgcm93czsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoTWF0aC5hYnMoTFVjb2xqW2ldKSA+IE1hdGguYWJzKExVY29saltwXSkpIHtcbiAgICAgICAgICAgICAgICBwID0gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwICE9PSBqKSB7XG4gICAgICAgICAgICBmb3IgKGsgPSAwOyBrIDwgY29sdW1uczsgaysrKSB7XG4gICAgICAgICAgICAgICAgdCA9IGx1W3BdW2tdO1xuICAgICAgICAgICAgICAgIGx1W3BdW2tdID0gbHVbal1ba107XG4gICAgICAgICAgICAgICAgbHVbal1ba10gPSB0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2ID0gcGl2b3RWZWN0b3JbcF07XG4gICAgICAgICAgICBwaXZvdFZlY3RvcltwXSA9IHBpdm90VmVjdG9yW2pdO1xuICAgICAgICAgICAgcGl2b3RWZWN0b3Jbal0gPSB2O1xuXG4gICAgICAgICAgICBwaXZvdFNpZ24gPSAtcGl2b3RTaWduO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGogPCByb3dzICYmIGx1W2pdW2pdICE9PSAwKSB7XG4gICAgICAgICAgICBmb3IgKGkgPSBqICsgMTsgaSA8IHJvd3M7IGkrKykge1xuICAgICAgICAgICAgICAgIGx1W2ldW2pdIC89IGx1W2pdW2pdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5MVSA9IGx1O1xuICAgIHRoaXMucGl2b3RWZWN0b3IgPSBwaXZvdFZlY3RvcjtcbiAgICB0aGlzLnBpdm90U2lnbiA9IHBpdm90U2lnbjtcbn1cblxuTHVEZWNvbXBvc2l0aW9uLnByb3RvdHlwZSA9IHtcbiAgICBpc1Npbmd1bGFyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBkYXRhID0gdGhpcy5MVSxcbiAgICAgICAgICAgIGNvbCA9IGRhdGEuY29sdW1ucztcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBjb2w7IGorKykge1xuICAgICAgICAgICAgaWYgKGRhdGFbal1bal0gPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcbiAgICBnZXQgZGV0ZXJtaW5hbnQoKSB7XG4gICAgICAgIHZhciBkYXRhID0gdGhpcy5MVTtcbiAgICAgICAgaWYgKCFkYXRhLmlzU3F1YXJlKCkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01hdHJpeCBtdXN0IGJlIHNxdWFyZScpO1xuICAgICAgICB2YXIgZGV0ZXJtaW5hbnQgPSB0aGlzLnBpdm90U2lnbiwgY29sID0gZGF0YS5jb2x1bW5zO1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGNvbDsgaisrKVxuICAgICAgICAgICAgZGV0ZXJtaW5hbnQgKj0gZGF0YVtqXVtqXTtcbiAgICAgICAgcmV0dXJuIGRldGVybWluYW50O1xuICAgIH0sXG4gICAgZ2V0IGxvd2VyVHJpYW5ndWxhck1hdHJpeCgpIHtcbiAgICAgICAgdmFyIGRhdGEgPSB0aGlzLkxVLFxuICAgICAgICAgICAgcm93cyA9IGRhdGEucm93cyxcbiAgICAgICAgICAgIGNvbHVtbnMgPSBkYXRhLmNvbHVtbnMsXG4gICAgICAgICAgICBYID0gbmV3IE1hdHJpeChyb3dzLCBjb2x1bW5zKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByb3dzOyBpKyspIHtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgY29sdW1uczsgaisrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGkgPiBqKSB7XG4gICAgICAgICAgICAgICAgICAgIFhbaV1bal0gPSBkYXRhW2ldW2pdO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaSA9PT0gaikge1xuICAgICAgICAgICAgICAgICAgICBYW2ldW2pdID0gMTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBYW2ldW2pdID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFg7XG4gICAgfSxcbiAgICBnZXQgdXBwZXJUcmlhbmd1bGFyTWF0cml4KCkge1xuICAgICAgICB2YXIgZGF0YSA9IHRoaXMuTFUsXG4gICAgICAgICAgICByb3dzID0gZGF0YS5yb3dzLFxuICAgICAgICAgICAgY29sdW1ucyA9IGRhdGEuY29sdW1ucyxcbiAgICAgICAgICAgIFggPSBuZXcgTWF0cml4KHJvd3MsIGNvbHVtbnMpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJvd3M7IGkrKykge1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBjb2x1bW5zOyBqKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoaSA8PSBqKSB7XG4gICAgICAgICAgICAgICAgICAgIFhbaV1bal0gPSBkYXRhW2ldW2pdO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIFhbaV1bal0gPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gWDtcbiAgICB9LFxuICAgIGdldCBwaXZvdFBlcm11dGF0aW9uVmVjdG9yKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5waXZvdFZlY3Rvci5zbGljZSgpO1xuICAgIH0sXG4gICAgc29sdmU6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YWx1ZSA9IE1hdHJpeC5jaGVja01hdHJpeCh2YWx1ZSk7XG5cbiAgICAgICAgdmFyIGx1ID0gdGhpcy5MVSxcbiAgICAgICAgICAgIHJvd3MgPSBsdS5yb3dzO1xuXG4gICAgICAgIGlmIChyb3dzICE9PSB2YWx1ZS5yb3dzKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG1hdHJpeCBkaW1lbnNpb25zJyk7XG4gICAgICAgIGlmICh0aGlzLmlzU2luZ3VsYXIoKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTFUgbWF0cml4IGlzIHNpbmd1bGFyJyk7XG5cbiAgICAgICAgdmFyIGNvdW50ID0gdmFsdWUuY29sdW1ucyxcbiAgICAgICAgICAgIFggPSB2YWx1ZS5zdWJNYXRyaXhSb3codGhpcy5waXZvdFZlY3RvciwgMCwgY291bnQgLSAxKSxcbiAgICAgICAgICAgIGNvbHVtbnMgPSBsdS5jb2x1bW5zLFxuICAgICAgICAgICAgaSwgaiwgaztcblxuICAgICAgICBmb3IgKGsgPSAwOyBrIDwgY29sdW1uczsgaysrKSB7XG4gICAgICAgICAgICBmb3IgKGkgPSBrICsgMTsgaSA8IGNvbHVtbnM7IGkrKykge1xuICAgICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBjb3VudDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIFhbaV1bal0gLT0gWFtrXVtqXSAqIGx1W2ldW2tdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGsgPSBjb2x1bW5zIC0gMTsgayA+PSAwOyBrLS0pIHtcbiAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBjb3VudDsgaisrKSB7XG4gICAgICAgICAgICAgICAgWFtrXVtqXSAvPSBsdVtrXVtrXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBrOyBpKyspIHtcbiAgICAgICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgY291bnQ7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBYW2ldW2pdIC09IFhba11bal0gKiBsdVtpXVtrXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFg7XG4gICAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBMdURlY29tcG9zaXRpb247XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBNYXRyaXggPSByZXF1aXJlKCcuLi9tYXRyaXgnKTtcbnZhciBoeXBvdGVudXNlID0gcmVxdWlyZSgnLi91dGlsJykuaHlwb3RlbnVzZTtcblxuLy9odHRwczovL2dpdGh1Yi5jb20vbHV0enJvZWRlci9NYXBhY2svYmxvYi9tYXN0ZXIvU291cmNlL1FyRGVjb21wb3NpdGlvbi5jc1xuZnVuY3Rpb24gUXJEZWNvbXBvc2l0aW9uKHZhbHVlKSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFFyRGVjb21wb3NpdGlvbikpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBRckRlY29tcG9zaXRpb24odmFsdWUpO1xuICAgIH1cbiAgICB2YWx1ZSA9IE1hdHJpeC5jaGVja01hdHJpeCh2YWx1ZSk7XG5cbiAgICB2YXIgcXIgPSB2YWx1ZS5jbG9uZSgpLFxuICAgICAgICBtID0gdmFsdWUucm93cyxcbiAgICAgICAgbiA9IHZhbHVlLmNvbHVtbnMsXG4gICAgICAgIHJkaWFnID0gbmV3IEFycmF5KG4pLFxuICAgICAgICBpLCBqLCBrLCBzO1xuXG4gICAgZm9yIChrID0gMDsgayA8IG47IGsrKykge1xuICAgICAgICB2YXIgbnJtID0gMDtcbiAgICAgICAgZm9yIChpID0gazsgaSA8IG07IGkrKykge1xuICAgICAgICAgICAgbnJtID0gaHlwb3RlbnVzZShucm0sIHFyW2ldW2tdKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobnJtICE9PSAwKSB7XG4gICAgICAgICAgICBpZiAocXJba11ba10gPCAwKSB7XG4gICAgICAgICAgICAgICAgbnJtID0gLW5ybTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoaSA9IGs7IGkgPCBtOyBpKyspIHtcbiAgICAgICAgICAgICAgICBxcltpXVtrXSAvPSBucm07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBxcltrXVtrXSArPSAxO1xuICAgICAgICAgICAgZm9yIChqID0gayArIDE7IGogPCBuOyBqKyspIHtcbiAgICAgICAgICAgICAgICBzID0gMDtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSBrOyBpIDwgbTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHMgKz0gcXJbaV1ba10gKiBxcltpXVtqXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcyA9IC1zIC8gcXJba11ba107XG4gICAgICAgICAgICAgICAgZm9yIChpID0gazsgaSA8IG07IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBxcltpXVtqXSArPSBzICogcXJbaV1ba107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJkaWFnW2tdID0gLW5ybTtcbiAgICB9XG5cbiAgICB0aGlzLlFSID0gcXI7XG4gICAgdGhpcy5SZGlhZyA9IHJkaWFnO1xufVxuXG5RckRlY29tcG9zaXRpb24ucHJvdG90eXBlID0ge1xuICAgIHNvbHZlOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFsdWUgPSBNYXRyaXguY2hlY2tNYXRyaXgodmFsdWUpO1xuXG4gICAgICAgIHZhciBxciA9IHRoaXMuUVIsXG4gICAgICAgICAgICBtID0gcXIucm93cztcblxuICAgICAgICBpZiAodmFsdWUucm93cyAhPT0gbSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTWF0cml4IHJvdyBkaW1lbnNpb25zIG11c3QgYWdyZWUnKTtcbiAgICAgICAgaWYgKCF0aGlzLmlzRnVsbFJhbmsoKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTWF0cml4IGlzIHJhbmsgZGVmaWNpZW50Jyk7XG5cbiAgICAgICAgdmFyIGNvdW50ID0gdmFsdWUuY29sdW1ucyxcbiAgICAgICAgICAgIFggPSB2YWx1ZS5jbG9uZSgpLFxuICAgICAgICAgICAgbiA9IHFyLmNvbHVtbnMsXG4gICAgICAgICAgICBpLCBqLCBrLCBzO1xuXG4gICAgICAgIGZvciAoayA9IDA7IGsgPCBuOyBrKyspIHtcbiAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBjb3VudDsgaisrKSB7XG4gICAgICAgICAgICAgICAgcyA9IDA7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gazsgaSA8IG07IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBzICs9IHFyW2ldW2tdICogWFtpXVtqXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcyA9IC1zIC8gcXJba11ba107XG4gICAgICAgICAgICAgICAgZm9yIChpID0gazsgaSA8IG07IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBYW2ldW2pdICs9IHMgKiBxcltpXVtrXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChrID0gbiAtIDE7IGsgPj0gMDsgay0tKSB7XG4gICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgY291bnQ7IGorKykge1xuICAgICAgICAgICAgICAgIFhba11bal0gLz0gdGhpcy5SZGlhZ1trXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBrOyBpKyspIHtcbiAgICAgICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgY291bnQ7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBYW2ldW2pdIC09IFhba11bal0gKiBxcltpXVtrXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gWC5zdWJNYXRyaXgoMCwgbiAtIDEsIDAsIGNvdW50IC0gMSk7XG4gICAgfSxcbiAgICBpc0Z1bGxSYW5rOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjb2x1bW5zID0gdGhpcy5RUi5jb2x1bW5zO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbHVtbnM7IGkrKykge1xuICAgICAgICAgICAgaWYgKHRoaXMuUmRpYWdbaV0gPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcbiAgICBnZXQgdXBwZXJUcmlhbmd1bGFyTWF0cml4KCkge1xuICAgICAgICB2YXIgcXIgPSB0aGlzLlFSLFxuICAgICAgICAgICAgbiA9IHFyLmNvbHVtbnMsXG4gICAgICAgICAgICBYID0gbmV3IE1hdHJpeChuLCBuKSxcbiAgICAgICAgICAgIGksIGo7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBuOyBqKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoaSA8IGopIHtcbiAgICAgICAgICAgICAgICAgICAgWFtpXVtqXSA9IHFyW2ldW2pdO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaSA9PT0gaikge1xuICAgICAgICAgICAgICAgICAgICBYW2ldW2pdID0gdGhpcy5SZGlhZ1tpXTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBYW2ldW2pdID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFg7XG4gICAgfSxcbiAgICBnZXQgb3J0aG9nb25hbE1hdHJpeCgpIHtcbiAgICAgICAgdmFyIHFyID0gdGhpcy5RUixcbiAgICAgICAgICAgIHJvd3MgPSBxci5yb3dzLFxuICAgICAgICAgICAgY29sdW1ucyA9IHFyLmNvbHVtbnMsXG4gICAgICAgICAgICBYID0gbmV3IE1hdHJpeChyb3dzLCBjb2x1bW5zKSxcbiAgICAgICAgICAgIGksIGosIGssIHM7XG5cbiAgICAgICAgZm9yIChrID0gY29sdW1ucyAtIDE7IGsgPj0gMDsgay0tKSB7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcm93czsgaSsrKSB7XG4gICAgICAgICAgICAgICAgWFtpXVtrXSA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBYW2tdW2tdID0gMTtcbiAgICAgICAgICAgIGZvciAoaiA9IGs7IGogPCBjb2x1bW5zOyBqKyspIHtcbiAgICAgICAgICAgICAgICBpZiAocXJba11ba10gIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcyA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IGs7IGkgPCByb3dzOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHMgKz0gcXJbaV1ba10gKiBYW2ldW2pdO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgcyA9IC1zIC8gcXJba11ba107XG5cbiAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gazsgaSA8IHJvd3M7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgWFtpXVtqXSArPSBzICogcXJbaV1ba107XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFg7XG4gICAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBRckRlY29tcG9zaXRpb247XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBNYXRyaXggPSByZXF1aXJlKCcuLi9tYXRyaXgnKTtcbnZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG52YXIgaHlwb3RlbnVzZSA9IHV0aWwuaHlwb3RlbnVzZTtcbnZhciBnZXRGaWxsZWQyREFycmF5ID0gdXRpbC5nZXRGaWxsZWQyREFycmF5O1xuXG4vLyBodHRwczovL2dpdGh1Yi5jb20vbHV0enJvZWRlci9NYXBhY2svYmxvYi9tYXN0ZXIvU291cmNlL1Npbmd1bGFyVmFsdWVEZWNvbXBvc2l0aW9uLmNzXG5mdW5jdGlvbiBTaW5ndWxhclZhbHVlRGVjb21wb3NpdGlvbih2YWx1ZSwgb3B0aW9ucykge1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBTaW5ndWxhclZhbHVlRGVjb21wb3NpdGlvbikpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTaW5ndWxhclZhbHVlRGVjb21wb3NpdGlvbih2YWx1ZSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIHZhbHVlID0gTWF0cml4LmNoZWNrTWF0cml4KHZhbHVlKTtcblxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgdmFyIG0gPSB2YWx1ZS5yb3dzLFxuICAgICAgICBuID0gdmFsdWUuY29sdW1ucyxcbiAgICAgICAgbnUgPSBNYXRoLm1pbihtLCBuKTtcblxuICAgIHZhciB3YW50dSA9IHRydWUsIHdhbnR2ID0gdHJ1ZTtcbiAgICBpZiAob3B0aW9ucy5jb21wdXRlTGVmdFNpbmd1bGFyVmVjdG9ycyA9PT0gZmFsc2UpXG4gICAgICAgIHdhbnR1ID0gZmFsc2U7XG4gICAgaWYgKG9wdGlvbnMuY29tcHV0ZVJpZ2h0U2luZ3VsYXJWZWN0b3JzID09PSBmYWxzZSlcbiAgICAgICAgd2FudHYgPSBmYWxzZTtcbiAgICB2YXIgYXV0b1RyYW5zcG9zZSA9IG9wdGlvbnMuYXV0b1RyYW5zcG9zZSA9PT0gdHJ1ZTtcblxuICAgIHZhciBzd2FwcGVkID0gZmFsc2U7XG4gICAgdmFyIGE7XG4gICAgaWYgKG0gPCBuKSB7XG4gICAgICAgIGlmICghYXV0b1RyYW5zcG9zZSkge1xuICAgICAgICAgICAgYSA9IHZhbHVlLmNsb25lKCk7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ0NvbXB1dGluZyBTVkQgb24gYSBtYXRyaXggd2l0aCBtb3JlIGNvbHVtbnMgdGhhbiByb3dzLiBDb25zaWRlciBlbmFibGluZyBhdXRvVHJhbnNwb3NlJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhID0gdmFsdWUudHJhbnNwb3NlKCk7XG4gICAgICAgICAgICBtID0gYS5yb3dzO1xuICAgICAgICAgICAgbiA9IGEuY29sdW1ucztcbiAgICAgICAgICAgIHN3YXBwZWQgPSB0cnVlO1xuICAgICAgICAgICAgdmFyIGF1eCA9IHdhbnR1O1xuICAgICAgICAgICAgd2FudHUgPSB3YW50djtcbiAgICAgICAgICAgIHdhbnR2ID0gYXV4O1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgYSA9IHZhbHVlLmNsb25lKCk7XG4gICAgfVxuXG4gICAgdmFyIHMgPSBuZXcgQXJyYXkoTWF0aC5taW4obSArIDEsIG4pKSxcbiAgICAgICAgVSA9IGdldEZpbGxlZDJEQXJyYXkobSwgbnUsIDApLFxuICAgICAgICBWID0gZ2V0RmlsbGVkMkRBcnJheShuLCBuLCAwKSxcbiAgICAgICAgZSA9IG5ldyBBcnJheShuKSxcbiAgICAgICAgd29yayA9IG5ldyBBcnJheShtKTtcblxuICAgIHZhciBuY3QgPSBNYXRoLm1pbihtIC0gMSwgbik7XG4gICAgdmFyIG5ydCA9IE1hdGgubWF4KDAsIE1hdGgubWluKG4gLSAyLCBtKSk7XG5cbiAgICB2YXIgaSwgaiwgaywgcCwgdCwga3MsIGYsIGNzLCBzbiwgbWF4LCBrYXNlLFxuICAgICAgICBzY2FsZSwgc3AsIHNwbTEsIGVwbTEsIHNrLCBlaywgYiwgYywgc2hpZnQsIGc7XG5cbiAgICBmb3IgKGsgPSAwLCBtYXggPSBNYXRoLm1heChuY3QsIG5ydCk7IGsgPCBtYXg7IGsrKykge1xuICAgICAgICBpZiAoayA8IG5jdCkge1xuICAgICAgICAgICAgc1trXSA9IDA7XG4gICAgICAgICAgICBmb3IgKGkgPSBrOyBpIDwgbTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgc1trXSA9IGh5cG90ZW51c2Uoc1trXSwgYVtpXVtrXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc1trXSAhPT0gMCkge1xuICAgICAgICAgICAgICAgIGlmIChhW2tdW2tdIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICBzW2tdID0gLXNba107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAoaSA9IGs7IGkgPCBtOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgYVtpXVtrXSAvPSBzW2tdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhW2tdW2tdICs9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzW2tdID0gLXNba107XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGogPSBrICsgMTsgaiA8IG47IGorKykge1xuICAgICAgICAgICAgaWYgKChrIDwgbmN0KSAmJiAoc1trXSAhPT0gMCkpIHtcbiAgICAgICAgICAgICAgICB0ID0gMDtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSBrOyBpIDwgbTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHQgKz0gYVtpXVtrXSAqIGFbaV1bal07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHQgPSAtdCAvIGFba11ba107XG4gICAgICAgICAgICAgICAgZm9yIChpID0gazsgaSA8IG07IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBhW2ldW2pdICs9IHQgKiBhW2ldW2tdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVbal0gPSBhW2tdW2pdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHdhbnR1ICYmIChrIDwgbmN0KSkge1xuICAgICAgICAgICAgZm9yIChpID0gazsgaSA8IG07IGkrKykge1xuICAgICAgICAgICAgICAgIFVbaV1ba10gPSBhW2ldW2tdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGsgPCBucnQpIHtcbiAgICAgICAgICAgIGVba10gPSAwO1xuICAgICAgICAgICAgZm9yIChpID0gayArIDE7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBlW2tdID0gaHlwb3RlbnVzZShlW2tdLCBlW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlW2tdICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVbayArIDFdIDwgMClcbiAgICAgICAgICAgICAgICAgICAgZVtrXSA9IC1lW2tdO1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IGsgKyAxOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGVbaV0gLz0gZVtrXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZVtrICsgMV0gKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVba10gPSAtZVtrXTtcbiAgICAgICAgICAgIGlmICgoayArIDEgPCBtKSAmJiAoZVtrXSAhPT0gMCkpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSBrICsgMTsgaSA8IG07IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB3b3JrW2ldID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yIChqID0gayArIDE7IGogPCBuOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gayArIDE7IGkgPCBtOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdvcmtbaV0gKz0gZVtqXSAqIGFbaV1bal07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yIChqID0gayArIDE7IGogPCBuOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdCA9IC1lW2pdIC8gZVtrICsgMV07XG4gICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IGsgKyAxOyBpIDwgbTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhW2ldW2pdICs9IHQgKiB3b3JrW2ldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHdhbnR2KSB7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gayArIDE7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgVltpXVtrXSA9IGVbaV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcCA9IE1hdGgubWluKG4sIG0gKyAxKTtcbiAgICBpZiAobmN0IDwgbikge1xuICAgICAgICBzW25jdF0gPSBhW25jdF1bbmN0XTtcbiAgICB9XG4gICAgaWYgKG0gPCBwKSB7XG4gICAgICAgIHNbcCAtIDFdID0gMDtcbiAgICB9XG4gICAgaWYgKG5ydCArIDEgPCBwKSB7XG4gICAgICAgIGVbbnJ0XSA9IGFbbnJ0XVtwIC0gMV07XG4gICAgfVxuICAgIGVbcCAtIDFdID0gMDtcblxuICAgIGlmICh3YW50dSkge1xuICAgICAgICBmb3IgKGogPSBuY3Q7IGogPCBudTsgaisrKSB7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgVVtpXVtqXSA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBVW2pdW2pdID0gMTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGsgPSBuY3QgLSAxOyBrID49IDA7IGstLSkge1xuICAgICAgICAgICAgaWYgKHNba10gIT09IDApIHtcbiAgICAgICAgICAgICAgICBmb3IgKGogPSBrICsgMTsgaiA8IG51OyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IGs7IGkgPCBtOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHQgKz0gVVtpXVtrXSAqIFVbaV1bal07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdCA9IC10IC8gVVtrXVtrXTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gazsgaSA8IG07IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgVVtpXVtqXSArPSB0ICogVVtpXVtrXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKGkgPSBrOyBpIDwgbTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIFVbaV1ba10gPSAtVVtpXVtrXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgVVtrXVtrXSA9IDEgKyBVW2tdW2tdO1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBrIC0gMTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIFVbaV1ba10gPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IG07IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBVW2ldW2tdID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgVVtrXVtrXSA9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAod2FudHYpIHtcbiAgICAgICAgZm9yIChrID0gbiAtIDE7IGsgPj0gMDsgay0tKSB7XG4gICAgICAgICAgICBpZiAoKGsgPCBucnQpICYmIChlW2tdICE9PSAwKSkge1xuICAgICAgICAgICAgICAgIGZvciAoaiA9IGsgKyAxOyBqIDwgbjsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIHQgPSAwO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSBrICsgMTsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdCArPSBWW2ldW2tdICogVltpXVtqXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0ID0gLXQgLyBWW2sgKyAxXVtrXTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gayArIDE7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFZbaV1bal0gKz0gdCAqIFZbaV1ba107XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgVltpXVtrXSA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBWW2tdW2tdID0gMTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBwcCA9IHAgLSAxLFxuICAgICAgICBpdGVyID0gMCxcbiAgICAgICAgZXBzID0gTWF0aC5wb3coMiwgLTUyKTtcbiAgICB3aGlsZSAocCA+IDApIHtcbiAgICAgICAgZm9yIChrID0gcCAtIDI7IGsgPj0gLTE7IGstLSkge1xuICAgICAgICAgICAgaWYgKGsgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoTWF0aC5hYnMoZVtrXSkgPD0gZXBzICogKE1hdGguYWJzKHNba10pICsgTWF0aC5hYnMoc1trICsgMV0pKSkge1xuICAgICAgICAgICAgICAgIGVba10gPSAwO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChrID09PSBwIC0gMikge1xuICAgICAgICAgICAga2FzZSA9IDQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmb3IgKGtzID0gcCAtIDE7IGtzID49IGs7IGtzLS0pIHtcbiAgICAgICAgICAgICAgICBpZiAoa3MgPT09IGspIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHQgPSAoa3MgIT09IHAgPyBNYXRoLmFicyhlW2tzXSkgOiAwKSArIChrcyAhPT0gayArIDEgPyBNYXRoLmFicyhlW2tzIC0gMV0pIDogMCk7XG4gICAgICAgICAgICAgICAgaWYgKE1hdGguYWJzKHNba3NdKSA8PSBlcHMgKiB0KSB7XG4gICAgICAgICAgICAgICAgICAgIHNba3NdID0gMDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGtzID09PSBrKSB7XG4gICAgICAgICAgICAgICAga2FzZSA9IDM7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGtzID09PSBwIC0gMSkge1xuICAgICAgICAgICAgICAgIGthc2UgPSAxO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBrYXNlID0gMjtcbiAgICAgICAgICAgICAgICBrID0ga3M7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBrKys7XG5cbiAgICAgICAgc3dpdGNoIChrYXNlKSB7XG4gICAgICAgICAgICBjYXNlIDE6IHtcbiAgICAgICAgICAgICAgICBmID0gZVtwIC0gMl07XG4gICAgICAgICAgICAgICAgZVtwIC0gMl0gPSAwO1xuICAgICAgICAgICAgICAgIGZvciAoaiA9IHAgLSAyOyBqID49IGs7IGotLSkge1xuICAgICAgICAgICAgICAgICAgICB0ID0gaHlwb3RlbnVzZShzW2pdLCBmKTtcbiAgICAgICAgICAgICAgICAgICAgY3MgPSBzW2pdIC8gdDtcbiAgICAgICAgICAgICAgICAgICAgc24gPSBmIC8gdDtcbiAgICAgICAgICAgICAgICAgICAgc1tqXSA9IHQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChqICE9PSBrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmID0gLXNuICogZVtqIC0gMV07XG4gICAgICAgICAgICAgICAgICAgICAgICBlW2ogLSAxXSA9IGNzICogZVtqIC0gMV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHdhbnR2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdCA9IGNzICogVltpXVtqXSArIHNuICogVltpXVtwIC0gMV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgVltpXVtwIC0gMV0gPSAtc24gKiBWW2ldW2pdICsgY3MgKiBWW2ldW3AgLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBWW2ldW2pdID0gdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgMiA6IHtcbiAgICAgICAgICAgICAgICBmID0gZVtrIC0gMV07XG4gICAgICAgICAgICAgICAgZVtrIC0gMV0gPSAwO1xuICAgICAgICAgICAgICAgIGZvciAoaiA9IGs7IGogPCBwOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdCA9IGh5cG90ZW51c2Uoc1tqXSwgZik7XG4gICAgICAgICAgICAgICAgICAgIGNzID0gc1tqXSAvIHQ7XG4gICAgICAgICAgICAgICAgICAgIHNuID0gZiAvIHQ7XG4gICAgICAgICAgICAgICAgICAgIHNbal0gPSB0O1xuICAgICAgICAgICAgICAgICAgICBmID0gLXNuICogZVtqXTtcbiAgICAgICAgICAgICAgICAgICAgZVtqXSA9IGNzICogZVtqXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHdhbnR1KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdCA9IGNzICogVVtpXVtqXSArIHNuICogVVtpXVtrIC0gMV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgVVtpXVtrIC0gMV0gPSAtc24gKiBVW2ldW2pdICsgY3MgKiBVW2ldW2sgLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBVW2ldW2pdID0gdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgMyA6IHtcbiAgICAgICAgICAgICAgICBzY2FsZSA9IE1hdGgubWF4KE1hdGgubWF4KE1hdGgubWF4KE1hdGgubWF4KE1hdGguYWJzKHNbcCAtIDFdKSwgTWF0aC5hYnMoc1twIC0gMl0pKSwgTWF0aC5hYnMoZVtwIC0gMl0pKSwgTWF0aC5hYnMoc1trXSkpLCBNYXRoLmFicyhlW2tdKSk7XG4gICAgICAgICAgICAgICAgc3AgPSBzW3AgLSAxXSAvIHNjYWxlO1xuICAgICAgICAgICAgICAgIHNwbTEgPSBzW3AgLSAyXSAvIHNjYWxlO1xuICAgICAgICAgICAgICAgIGVwbTEgPSBlW3AgLSAyXSAvIHNjYWxlO1xuICAgICAgICAgICAgICAgIHNrID0gc1trXSAvIHNjYWxlO1xuICAgICAgICAgICAgICAgIGVrID0gZVtrXSAvIHNjYWxlO1xuICAgICAgICAgICAgICAgIGIgPSAoKHNwbTEgKyBzcCkgKiAoc3BtMSAtIHNwKSArIGVwbTEgKiBlcG0xKSAvIDI7XG4gICAgICAgICAgICAgICAgYyA9IChzcCAqIGVwbTEpICogKHNwICogZXBtMSk7XG4gICAgICAgICAgICAgICAgc2hpZnQgPSAwO1xuICAgICAgICAgICAgICAgIGlmICgoYiAhPT0gMCkgfHwgKGMgIT09IDApKSB7XG4gICAgICAgICAgICAgICAgICAgIHNoaWZ0ID0gTWF0aC5zcXJ0KGIgKiBiICsgYyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChiIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2hpZnQgPSAtc2hpZnQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc2hpZnQgPSBjIC8gKGIgKyBzaGlmdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGYgPSAoc2sgKyBzcCkgKiAoc2sgLSBzcCkgKyBzaGlmdDtcbiAgICAgICAgICAgICAgICBnID0gc2sgKiBlaztcbiAgICAgICAgICAgICAgICBmb3IgKGogPSBrOyBqIDwgcCAtIDE7IGorKykge1xuICAgICAgICAgICAgICAgICAgICB0ID0gaHlwb3RlbnVzZShmLCBnKTtcbiAgICAgICAgICAgICAgICAgICAgY3MgPSBmIC8gdDtcbiAgICAgICAgICAgICAgICAgICAgc24gPSBnIC8gdDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGogIT09IGspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVbaiAtIDFdID0gdDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmID0gY3MgKiBzW2pdICsgc24gKiBlW2pdO1xuICAgICAgICAgICAgICAgICAgICBlW2pdID0gY3MgKiBlW2pdIC0gc24gKiBzW2pdO1xuICAgICAgICAgICAgICAgICAgICBnID0gc24gKiBzW2ogKyAxXTtcbiAgICAgICAgICAgICAgICAgICAgc1tqICsgMV0gPSBjcyAqIHNbaiArIDFdO1xuICAgICAgICAgICAgICAgICAgICBpZiAod2FudHYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ID0gY3MgKiBWW2ldW2pdICsgc24gKiBWW2ldW2ogKyAxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBWW2ldW2ogKyAxXSA9IC1zbiAqIFZbaV1bal0gKyBjcyAqIFZbaV1baiArIDFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFZbaV1bal0gPSB0O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHQgPSBoeXBvdGVudXNlKGYsIGcpO1xuICAgICAgICAgICAgICAgICAgICBjcyA9IGYgLyB0O1xuICAgICAgICAgICAgICAgICAgICBzbiA9IGcgLyB0O1xuICAgICAgICAgICAgICAgICAgICBzW2pdID0gdDtcbiAgICAgICAgICAgICAgICAgICAgZiA9IGNzICogZVtqXSArIHNuICogc1tqICsgMV07XG4gICAgICAgICAgICAgICAgICAgIHNbaiArIDFdID0gLXNuICogZVtqXSArIGNzICogc1tqICsgMV07XG4gICAgICAgICAgICAgICAgICAgIGcgPSBzbiAqIGVbaiArIDFdO1xuICAgICAgICAgICAgICAgICAgICBlW2ogKyAxXSA9IGNzICogZVtqICsgMV07XG4gICAgICAgICAgICAgICAgICAgIGlmICh3YW50dSAmJiAoaiA8IG0gLSAxKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IG07IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHQgPSBjcyAqIFVbaV1bal0gKyBzbiAqIFVbaV1baiArIDFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFVbaV1baiArIDFdID0gLXNuICogVVtpXVtqXSArIGNzICogVVtpXVtqICsgMV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgVVtpXVtqXSA9IHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZVtwIC0gMl0gPSBmO1xuICAgICAgICAgICAgICAgIGl0ZXIgPSBpdGVyICsgMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgNDoge1xuICAgICAgICAgICAgICAgIGlmIChzW2tdIDw9IDApIHtcbiAgICAgICAgICAgICAgICAgICAgc1trXSA9IChzW2tdIDwgMCA/IC1zW2tdIDogMCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh3YW50dikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8PSBwcDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgVltpXVtrXSA9IC1WW2ldW2tdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHdoaWxlIChrIDwgcHApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNba10gPj0gc1trICsgMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHQgPSBzW2tdO1xuICAgICAgICAgICAgICAgICAgICBzW2tdID0gc1trICsgMV07XG4gICAgICAgICAgICAgICAgICAgIHNbayArIDFdID0gdDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHdhbnR2ICYmIChrIDwgbiAtIDEpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdCA9IFZbaV1bayArIDFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFZbaV1bayArIDFdID0gVltpXVtrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBWW2ldW2tdID0gdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAod2FudHUgJiYgKGsgPCBtIC0gMSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBtOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ID0gVVtpXVtrICsgMV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgVVtpXVtrICsgMV0gPSBVW2ldW2tdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFVbaV1ba10gPSB0O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGsrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaXRlciA9IDA7XG4gICAgICAgICAgICAgICAgcC0tO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHN3YXBwZWQpIHtcbiAgICAgICAgdmFyIHRtcCA9IFY7XG4gICAgICAgIFYgPSBVO1xuICAgICAgICBVID0gdG1wO1xuICAgIH1cblxuICAgIHRoaXMubSA9IG07XG4gICAgdGhpcy5uID0gbjtcbiAgICB0aGlzLnMgPSBzO1xuICAgIHRoaXMuVSA9IFU7XG4gICAgdGhpcy5WID0gVjtcbn1cblxuU2luZ3VsYXJWYWx1ZURlY29tcG9zaXRpb24ucHJvdG90eXBlID0ge1xuICAgIGdldCBjb25kaXRpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNbMF0gLyB0aGlzLnNbTWF0aC5taW4odGhpcy5tLCB0aGlzLm4pIC0gMV07XG4gICAgfSxcbiAgICBnZXQgbm9ybTIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNbMF07XG4gICAgfSxcbiAgICBnZXQgcmFuaygpIHtcbiAgICAgICAgdmFyIGVwcyA9IE1hdGgucG93KDIsIC01MiksXG4gICAgICAgICAgICB0b2wgPSBNYXRoLm1heCh0aGlzLm0sIHRoaXMubikgKiB0aGlzLnNbMF0gKiBlcHMsXG4gICAgICAgICAgICByID0gMCxcbiAgICAgICAgICAgIHMgPSB0aGlzLnM7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IHMubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgICAgICAgaWYgKHNbaV0gPiB0b2wpIHtcbiAgICAgICAgICAgICAgICByKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHI7XG4gICAgfSxcbiAgICBnZXQgZGlhZ29uYWwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnM7XG4gICAgfSxcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vYWNjb3JkLW5ldC9mcmFtZXdvcmsvYmxvYi9kZXZlbG9wbWVudC9Tb3VyY2VzL0FjY29yZC5NYXRoL0RlY29tcG9zaXRpb25zL1Npbmd1bGFyVmFsdWVEZWNvbXBvc2l0aW9uLmNzXG4gICAgZ2V0IHRocmVzaG9sZCgpIHtcbiAgICAgICAgcmV0dXJuIChNYXRoLnBvdygyLCAtNTIpIC8gMikgKiBNYXRoLm1heCh0aGlzLm0sIHRoaXMubikgKiB0aGlzLnNbMF07XG4gICAgfSxcbiAgICBnZXQgbGVmdFNpbmd1bGFyVmVjdG9ycygpIHtcbiAgICAgICAgaWYgKCFNYXRyaXguaXNNYXRyaXgodGhpcy5VKSkge1xuICAgICAgICAgICAgdGhpcy5VID0gbmV3IE1hdHJpeCh0aGlzLlUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLlU7XG4gICAgfSxcbiAgICBnZXQgcmlnaHRTaW5ndWxhclZlY3RvcnMoKSB7XG4gICAgICAgIGlmICghTWF0cml4LmlzTWF0cml4KHRoaXMuVikpIHtcbiAgICAgICAgICAgIHRoaXMuViA9IG5ldyBNYXRyaXgodGhpcy5WKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5WO1xuICAgIH0sXG4gICAgZ2V0IGRpYWdvbmFsTWF0cml4KCkge1xuICAgICAgICByZXR1cm4gTWF0cml4LmRpYWcodGhpcy5zKTtcbiAgICB9LFxuICAgIHNvbHZlOiBmdW5jdGlvbiAodmFsdWUpIHtcblxuICAgICAgICB2YXIgWSA9IHZhbHVlLFxuICAgICAgICAgICAgZSA9IHRoaXMudGhyZXNob2xkLFxuICAgICAgICAgICAgc2NvbHMgPSB0aGlzLnMubGVuZ3RoLFxuICAgICAgICAgICAgTHMgPSBNYXRyaXguemVyb3Moc2NvbHMsIHNjb2xzKSxcbiAgICAgICAgICAgIGk7XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHNjb2xzOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChNYXRoLmFicyh0aGlzLnNbaV0pIDw9IGUpIHtcbiAgICAgICAgICAgICAgICBMc1tpXVtpXSA9IDA7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIExzW2ldW2ldID0gMSAvIHRoaXMuc1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBVID0gdGhpcy5VO1xuICAgICAgICB2YXIgViA9IHRoaXMucmlnaHRTaW5ndWxhclZlY3RvcnM7XG5cbiAgICAgICAgdmFyIFZMID0gVi5tbXVsKExzKSxcbiAgICAgICAgICAgIHZyb3dzID0gVi5yb3dzLFxuICAgICAgICAgICAgdXJvd3MgPSBVLmxlbmd0aCxcbiAgICAgICAgICAgIFZMVSA9IE1hdHJpeC56ZXJvcyh2cm93cywgdXJvd3MpLFxuICAgICAgICAgICAgaiwgaywgc3VtO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB2cm93czsgaSsrKSB7XG4gICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgdXJvd3M7IGorKykge1xuICAgICAgICAgICAgICAgIHN1bSA9IDA7XG4gICAgICAgICAgICAgICAgZm9yIChrID0gMDsgayA8IHNjb2xzOyBrKyspIHtcbiAgICAgICAgICAgICAgICAgICAgc3VtICs9IFZMW2ldW2tdICogVVtqXVtrXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgVkxVW2ldW2pdID0gc3VtO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFZMVS5tbXVsKFkpO1xuICAgIH0sXG4gICAgc29sdmVGb3JEaWFnb25hbDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNvbHZlKE1hdHJpeC5kaWFnKHZhbHVlKSk7XG4gICAgfSxcbiAgICBpbnZlcnNlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBWID0gdGhpcy5WO1xuICAgICAgICB2YXIgZSA9IHRoaXMudGhyZXNob2xkLFxuICAgICAgICAgICAgdnJvd3MgPSBWLmxlbmd0aCxcbiAgICAgICAgICAgIHZjb2xzID0gVlswXS5sZW5ndGgsXG4gICAgICAgICAgICBYID0gbmV3IE1hdHJpeCh2cm93cywgdGhpcy5zLmxlbmd0aCksXG4gICAgICAgICAgICBpLCBqO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB2cm93czsgaSsrKSB7XG4gICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgdmNvbHM7IGorKykge1xuICAgICAgICAgICAgICAgIGlmIChNYXRoLmFicyh0aGlzLnNbal0pID4gZSkge1xuICAgICAgICAgICAgICAgICAgICBYW2ldW2pdID0gVltpXVtqXSAvIHRoaXMuc1tqXTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBYW2ldW2pdID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgVSA9IHRoaXMuVTtcblxuICAgICAgICB2YXIgdXJvd3MgPSBVLmxlbmd0aCxcbiAgICAgICAgICAgIHVjb2xzID0gVVswXS5sZW5ndGgsXG4gICAgICAgICAgICBZID0gbmV3IE1hdHJpeCh2cm93cywgdXJvd3MpLFxuICAgICAgICAgICAgaywgc3VtO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB2cm93czsgaSsrKSB7XG4gICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgdXJvd3M7IGorKykge1xuICAgICAgICAgICAgICAgIHN1bSA9IDA7XG4gICAgICAgICAgICAgICAgZm9yIChrID0gMDsgayA8IHVjb2xzOyBrKyspIHtcbiAgICAgICAgICAgICAgICAgICAgc3VtICs9IFhbaV1ba10gKiBVW2pdW2tdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBZW2ldW2pdID0gc3VtO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFk7XG4gICAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBTaW5ndWxhclZhbHVlRGVjb21wb3NpdGlvbjtcbiIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5oeXBvdGVudXNlID0gZnVuY3Rpb24gaHlwb3RlbnVzZShhLCBiKSB7XG4gICAgaWYgKE1hdGguYWJzKGEpID4gTWF0aC5hYnMoYikpIHtcbiAgICAgICAgdmFyIHIgPSBiIC8gYTtcbiAgICAgICAgcmV0dXJuIE1hdGguYWJzKGEpICogTWF0aC5zcXJ0KDEgKyByICogcik7XG4gICAgfVxuICAgIGlmIChiICE9PSAwKSB7XG4gICAgICAgIHZhciByID0gYSAvIGI7XG4gICAgICAgIHJldHVybiBNYXRoLmFicyhiKSAqIE1hdGguc3FydCgxICsgciAqIHIpO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbn07XG5cbi8vIEZvciB1c2UgaW4gdGhlIGRlY29tcG9zaXRpb24gYWxnb3JpdGhtcy4gV2l0aCBiaWcgbWF0cmljZXMsIGFjY2VzcyB0aW1lIGlzXG4vLyB0b28gbG9uZyBvbiBlbGVtZW50cyBmcm9tIGFycmF5IHN1YmNsYXNzXG4vLyB0b2RvIGNoZWNrIHdoZW4gaXQgaXMgZml4ZWQgaW4gdjhcbi8vIGh0dHA6Ly9qc3BlcmYuY29tL2FjY2Vzcy1hbmQtd3JpdGUtYXJyYXktc3ViY2xhc3NcbmV4cG9ydHMuZ2V0RW1wdHkyREFycmF5ID0gZnVuY3Rpb24gKHJvd3MsIGNvbHVtbnMpIHtcbiAgICB2YXIgYXJyYXkgPSBuZXcgQXJyYXkocm93cyk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCByb3dzOyBpKyspIHtcbiAgICAgICAgYXJyYXlbaV0gPSBuZXcgQXJyYXkoY29sdW1ucyk7XG4gICAgfVxuICAgIHJldHVybiBhcnJheTtcbn07XG5cbmV4cG9ydHMuZ2V0RmlsbGVkMkRBcnJheSA9IGZ1bmN0aW9uIChyb3dzLCBjb2x1bW5zLCB2YWx1ZSkge1xuICAgIHZhciBhcnJheSA9IG5ldyBBcnJheShyb3dzKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJvd3M7IGkrKykge1xuICAgICAgICBhcnJheVtpXSA9IG5ldyBBcnJheShjb2x1bW5zKTtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBjb2x1bW5zOyBqKyspIHtcbiAgICAgICAgICAgIGFycmF5W2ldW2pdID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFycmF5O1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIE1hdHJpeCA9IHJlcXVpcmUoJy4vbWF0cml4Jyk7XG5cbnZhciBTaW5ndWxhclZhbHVlRGVjb21wb3NpdGlvbiA9IHJlcXVpcmUoJy4vZGMvc3ZkJyk7XG52YXIgRWlnZW52YWx1ZURlY29tcG9zaXRpb24gPSByZXF1aXJlKCcuL2RjL2V2ZCcpO1xudmFyIEx1RGVjb21wb3NpdGlvbiA9IHJlcXVpcmUoJy4vZGMvbHUnKTtcbnZhciBRckRlY29tcG9zaXRpb24gPSByZXF1aXJlKCcuL2RjL3FyJyk7XG52YXIgQ2hvbGVza3lEZWNvbXBvc2l0aW9uID0gcmVxdWlyZSgnLi9kYy9jaG9sZXNreScpO1xuXG5mdW5jdGlvbiBpbnZlcnNlKG1hdHJpeCkge1xuICAgIG1hdHJpeCA9IE1hdHJpeC5jaGVja01hdHJpeChtYXRyaXgpO1xuICAgIHJldHVybiBzb2x2ZShtYXRyaXgsIE1hdHJpeC5leWUobWF0cml4LnJvd3MpKTtcbn1cblxuTWF0cml4LmludmVyc2UgPSBNYXRyaXguaW52ID0gaW52ZXJzZTtcbk1hdHJpeC5wcm90b3R5cGUuaW52ZXJzZSA9IE1hdHJpeC5wcm90b3R5cGUuaW52ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBpbnZlcnNlKHRoaXMpO1xufTtcblxuZnVuY3Rpb24gc29sdmUobGVmdEhhbmRTaWRlLCByaWdodEhhbmRTaWRlKSB7XG4gICAgbGVmdEhhbmRTaWRlID0gTWF0cml4LmNoZWNrTWF0cml4KGxlZnRIYW5kU2lkZSk7XG4gICAgcmlnaHRIYW5kU2lkZSA9IE1hdHJpeC5jaGVja01hdHJpeChyaWdodEhhbmRTaWRlKTtcbiAgICByZXR1cm4gbGVmdEhhbmRTaWRlLmlzU3F1YXJlKCkgPyBuZXcgTHVEZWNvbXBvc2l0aW9uKGxlZnRIYW5kU2lkZSkuc29sdmUocmlnaHRIYW5kU2lkZSkgOiBuZXcgUXJEZWNvbXBvc2l0aW9uKGxlZnRIYW5kU2lkZSkuc29sdmUocmlnaHRIYW5kU2lkZSk7XG59XG5cbk1hdHJpeC5zb2x2ZSA9IHNvbHZlO1xuTWF0cml4LnByb3RvdHlwZS5zb2x2ZSA9IGZ1bmN0aW9uIChvdGhlcikge1xuICAgIHJldHVybiBzb2x2ZSh0aGlzLCBvdGhlcik7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBTaW5ndWxhclZhbHVlRGVjb21wb3NpdGlvbjogU2luZ3VsYXJWYWx1ZURlY29tcG9zaXRpb24sXG4gICAgU1ZEOiBTaW5ndWxhclZhbHVlRGVjb21wb3NpdGlvbixcbiAgICBFaWdlbnZhbHVlRGVjb21wb3NpdGlvbjogRWlnZW52YWx1ZURlY29tcG9zaXRpb24sXG4gICAgRVZEOiBFaWdlbnZhbHVlRGVjb21wb3NpdGlvbixcbiAgICBMdURlY29tcG9zaXRpb246IEx1RGVjb21wb3NpdGlvbixcbiAgICBMVTogTHVEZWNvbXBvc2l0aW9uLFxuICAgIFFyRGVjb21wb3NpdGlvbjogUXJEZWNvbXBvc2l0aW9uLFxuICAgIFFSOiBRckRlY29tcG9zaXRpb24sXG4gICAgQ2hvbGVza3lEZWNvbXBvc2l0aW9uOiBDaG9sZXNreURlY29tcG9zaXRpb24sXG4gICAgQ0hPOiBDaG9sZXNreURlY29tcG9zaXRpb24sXG4gICAgaW52ZXJzZTogaW52ZXJzZSxcbiAgICBzb2x2ZTogc29sdmVcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9tYXRyaXgnKTtcbm1vZHVsZS5leHBvcnRzLkRlY29tcG9zaXRpb25zID0gbW9kdWxlLmV4cG9ydHMuREMgPSByZXF1aXJlKCcuL2RlY29tcG9zaXRpb25zJyk7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogUmVhbCBtYXRyaXhcbiAqL1xuY2xhc3MgTWF0cml4IGV4dGVuZHMgQXJyYXkge1xuICAgIC8qKlxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfEFycmF5fE1hdHJpeH0gblJvd3MgLSBOdW1iZXIgb2Ygcm93cyBvZiB0aGUgbmV3IG1hdHJpeCxcbiAgICAgKiAyRCBhcnJheSBjb250YWluaW5nIHRoZSBkYXRhIG9yIE1hdHJpeCBpbnN0YW5jZSB0byBjbG9uZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbkNvbHVtbnNdIC0gTnVtYmVyIG9mIGNvbHVtbnMgb2YgdGhlIG5ldyBtYXRyaXhcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihuUm93cywgbkNvbHVtbnMpIHtcbiAgICAgICAgaWYgKE1hdHJpeC5pc01hdHJpeChuUm93cykpIHtcbiAgICAgICAgICAgIHJldHVybiBuUm93cy5jbG9uZSgpO1xuICAgICAgICB9IGVsc2UgaWYgKE51bWJlci5pc0ludGVnZXIoblJvd3MpICYmIG5Sb3dzID4gMCkgeyAvLyBDcmVhdGUgYW4gZW1wdHkgbWF0cml4XG4gICAgICAgICAgICBzdXBlcihuUm93cyk7XG4gICAgICAgICAgICBpZiAoTnVtYmVyLmlzSW50ZWdlcihuQ29sdW1ucykgJiYgbkNvbHVtbnMgPiAwKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuUm93czsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXNbaV0gPSBuZXcgQXJyYXkobkNvbHVtbnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbkNvbHVtbnMgbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXInKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KG5Sb3dzKSkgeyAvLyBDb3B5IHRoZSB2YWx1ZXMgZnJvbSB0aGUgMkQgYXJyYXlcbiAgICAgICAgICAgIHZhciBtYXRyaXggPSBuUm93cztcbiAgICAgICAgICAgIG5Sb3dzID0gbWF0cml4Lmxlbmd0aDtcbiAgICAgICAgICAgIG5Db2x1bW5zID0gbWF0cml4WzBdLmxlbmd0aDtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbkNvbHVtbnMgIT09ICdudW1iZXInIHx8IG5Db2x1bW5zID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRGF0YSBtdXN0IGJlIGEgMkQgYXJyYXkgd2l0aCBhdCBsZWFzdCBvbmUgZWxlbWVudCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3VwZXIoblJvd3MpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuUm93czsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1hdHJpeFtpXS5sZW5ndGggIT09IG5Db2x1bW5zKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmNvbnNpc3RlbnQgYXJyYXkgZGltZW5zaW9ucycpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzW2ldID0gW10uY29uY2F0KG1hdHJpeFtpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdGaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyIG9yIGFuIGFycmF5Jyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yb3dzID0gblJvd3M7XG4gICAgICAgIHRoaXMuY29sdW1ucyA9IG5Db2x1bW5zO1xuICAgIH1cblxuICAgIC8vIE5hdGl2ZSBhcnJheSBtZXRob2RzIHNob3VsZCByZXR1cm4gaW5zdGFuY2VzIG9mIEFycmF5LCBub3QgTWF0cml4XG4gICAgc3RhdGljIGdldCBbU3ltYm9sLnNwZWNpZXNdKCkge1xuICAgICAgICByZXR1cm4gQXJyYXk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0cyBhIE1hdHJpeCB3aXRoIHRoZSBjaG9zZW4gZGltZW5zaW9ucyBmcm9tIGEgMUQgYXJyYXlcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbmV3Um93cyAtIE51bWJlciBvZiByb3dzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG5ld0NvbHVtbnMgLSBOdW1iZXIgb2YgY29sdW1uc1xuICAgICAqIEBwYXJhbSB7QXJyYXl9IG5ld0RhdGEgLSBBIDFEIGFycmF5IGNvbnRhaW5pbmcgZGF0YSBmb3IgdGhlIG1hdHJpeFxuICAgICAqIEByZXR1cm5zIHtNYXRyaXh9IC0gVGhlIG5ldyBtYXRyaXhcbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbTFEQXJyYXkobmV3Um93cywgbmV3Q29sdW1ucywgbmV3RGF0YSkge1xuICAgICAgICB2YXIgbGVuZ3RoID0gbmV3Um93cyAqIG5ld0NvbHVtbnM7XG4gICAgICAgIGlmIChsZW5ndGggIT09IG5ld0RhdGEubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignRGF0YSBsZW5ndGggZG9lcyBub3QgbWF0Y2ggZ2l2ZW4gZGltZW5zaW9ucycpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBuZXdNYXRyaXggPSBuZXcgTWF0cml4KG5ld1Jvd3MsIG5ld0NvbHVtbnMpO1xuICAgICAgICBmb3IgKHZhciByb3cgPSAwOyByb3cgPCBuZXdSb3dzOyByb3crKykge1xuICAgICAgICAgICAgZm9yICh2YXIgY29sdW1uID0gMDsgY29sdW1uIDwgbmV3Q29sdW1uczsgY29sdW1uKyspIHtcbiAgICAgICAgICAgICAgICBuZXdNYXRyaXhbcm93XVtjb2x1bW5dID0gbmV3RGF0YVtyb3cgKiBuZXdDb2x1bW5zICsgY29sdW1uXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3TWF0cml4O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSByb3cgdmVjdG9yLCBhIG1hdHJpeCB3aXRoIG9ubHkgb25lIHJvdy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBuZXdEYXRhIC0gQSAxRCBhcnJheSBjb250YWluaW5nIGRhdGEgZm9yIHRoZSB2ZWN0b3JcbiAgICAgKiBAcmV0dXJucyB7TWF0cml4fSAtIFRoZSBuZXcgbWF0cml4XG4gICAgICovXG4gICAgc3RhdGljIHJvd1ZlY3RvcihuZXdEYXRhKSB7XG4gICAgICAgIHZhciB2ZWN0b3IgPSBuZXcgTWF0cml4KDEsIG5ld0RhdGEubGVuZ3RoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuZXdEYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2ZWN0b3JbMF1baV0gPSBuZXdEYXRhW2ldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2ZWN0b3I7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGNvbHVtbiB2ZWN0b3IsIGEgbWF0cml4IHdpdGggb25seSBvbmUgY29sdW1uLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IG5ld0RhdGEgLSBBIDFEIGFycmF5IGNvbnRhaW5pbmcgZGF0YSBmb3IgdGhlIHZlY3RvclxuICAgICAqIEByZXR1cm5zIHtNYXRyaXh9IC0gVGhlIG5ldyBtYXRyaXhcbiAgICAgKi9cbiAgICBzdGF0aWMgY29sdW1uVmVjdG9yKG5ld0RhdGEpIHtcbiAgICAgICAgdmFyIHZlY3RvciA9IG5ldyBNYXRyaXgobmV3RGF0YS5sZW5ndGgsIDEpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5ld0RhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZlY3RvcltpXVswXSA9IG5ld0RhdGFbaV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZlY3RvcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGVtcHR5IG1hdHJpeCB3aXRoIHRoZSBnaXZlbiBkaW1lbnNpb25zLiBWYWx1ZXMgd2lsbCBiZSB1bmRlZmluZWQuIFNhbWUgYXMgdXNpbmcgbmV3IE1hdHJpeChyb3dzLCBjb2x1bW5zKS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcm93cyAtIE51bWJlciBvZiByb3dzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNvbHVtbnMgLSBOdW1iZXIgb2YgY29sdW1uc1xuICAgICAqIEByZXR1cm5zIHtNYXRyaXh9IC0gVGhlIG5ldyBtYXRyaXhcbiAgICAgKi9cbiAgICBzdGF0aWMgZW1wdHkocm93cywgY29sdW1ucykge1xuICAgICAgICByZXR1cm4gbmV3IE1hdHJpeChyb3dzLCBjb2x1bW5zKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbWF0cml4IHdpdGggdGhlIGdpdmVuIGRpbWVuc2lvbnMuIFZhbHVlcyB3aWxsIGJlIHNldCB0byB6ZXJvLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSByb3dzIC0gTnVtYmVyIG9mIHJvd3NcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY29sdW1ucyAtIE51bWJlciBvZiBjb2x1bW5zXG4gICAgICogQHJldHVybnMge01hdHJpeH0gLSBUaGUgbmV3IG1hdHJpeFxuICAgICAqL1xuICAgIHN0YXRpYyB6ZXJvcyhyb3dzLCBjb2x1bW5zKSB7XG4gICAgICAgIHJldHVybiBNYXRyaXguZW1wdHkocm93cywgY29sdW1ucykuZmlsbCgwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbWF0cml4IHdpdGggdGhlIGdpdmVuIGRpbWVuc2lvbnMuIFZhbHVlcyB3aWxsIGJlIHNldCB0byBvbmUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHJvd3MgLSBOdW1iZXIgb2Ygcm93c1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjb2x1bW5zIC0gTnVtYmVyIG9mIGNvbHVtbnNcbiAgICAgKiBAcmV0dXJucyB7TWF0cml4fSAtIFRoZSBuZXcgbWF0cml4XG4gICAgICovXG4gICAgc3RhdGljIG9uZXMocm93cywgY29sdW1ucykge1xuICAgICAgICByZXR1cm4gTWF0cml4LmVtcHR5KHJvd3MsIGNvbHVtbnMpLmZpbGwoMSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG1hdHJpeCB3aXRoIHRoZSBnaXZlbiBkaW1lbnNpb25zLiBWYWx1ZXMgd2lsbCBiZSByYW5kb21seSBzZXQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHJvd3MgLSBOdW1iZXIgb2Ygcm93c1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjb2x1bW5zIC0gTnVtYmVyIG9mIGNvbHVtbnNcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBbcm5nXSAtIFJhbmRvbSBudW1iZXIgZ2VuZXJhdG9yIChkZWZhdWx0OiBNYXRoLnJhbmRvbSlcbiAgICAgKiBAcmV0dXJucyB7TWF0cml4fSBUaGUgbmV3IG1hdHJpeFxuICAgICAqL1xuICAgIHN0YXRpYyByYW5kKHJvd3MsIGNvbHVtbnMsIHJuZykge1xuICAgICAgICBpZiAocm5nID09PSB1bmRlZmluZWQpIHJuZyA9IE1hdGgucmFuZG9tO1xuICAgICAgICB2YXIgbWF0cml4ID0gTWF0cml4LmVtcHR5KHJvd3MsIGNvbHVtbnMpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJvd3M7IGkrKykge1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBjb2x1bW5zOyBqKyspIHtcbiAgICAgICAgICAgICAgICBtYXRyaXhbaV1bal0gPSBybmcoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWF0cml4O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gaWRlbnRpdHkgbWF0cml4IHdpdGggdGhlIGdpdmVuIGRpbWVuc2lvbi4gVmFsdWVzIG9mIHRoZSBkaWFnb25hbCB3aWxsIGJlIDEgYW5kIG90aGVycyB3aWxsIGJlIDAuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHJvd3MgLSBOdW1iZXIgb2Ygcm93c1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbY29sdW1uc10gLSBOdW1iZXIgb2YgY29sdW1ucyAoRGVmYXVsdDogcm93cylcbiAgICAgKiBAcmV0dXJucyB7TWF0cml4fSAtIFRoZSBuZXcgaWRlbnRpdHkgbWF0cml4XG4gICAgICovXG4gICAgc3RhdGljIGV5ZShyb3dzLCBjb2x1bW5zKSB7XG4gICAgICAgIGlmIChjb2x1bW5zID09PSB1bmRlZmluZWQpIGNvbHVtbnMgPSByb3dzO1xuICAgICAgICB2YXIgbWluID0gTWF0aC5taW4ocm93cywgY29sdW1ucyk7XG4gICAgICAgIHZhciBtYXRyaXggPSBNYXRyaXguemVyb3Mocm93cywgY29sdW1ucyk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWluOyBpKyspIHtcbiAgICAgICAgICAgIG1hdHJpeFtpXVtpXSA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1hdHJpeDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZGlhZ29uYWwgbWF0cml4IGJhc2VkIG9uIHRoZSBnaXZlbiBhcnJheS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBkYXRhIC0gQXJyYXkgY29udGFpbmluZyB0aGUgZGF0YSBmb3IgdGhlIGRpYWdvbmFsXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtyb3dzXSAtIE51bWJlciBvZiByb3dzIChEZWZhdWx0OiBkYXRhLmxlbmd0aClcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2NvbHVtbnNdIC0gTnVtYmVyIG9mIGNvbHVtbnMgKERlZmF1bHQ6IHJvd3MpXG4gICAgICogQHJldHVybnMge01hdHJpeH0gLSBUaGUgbmV3IGRpYWdvbmFsIG1hdHJpeFxuICAgICAqL1xuICAgIHN0YXRpYyBkaWFnKGRhdGEsIHJvd3MsIGNvbHVtbnMpIHtcbiAgICAgICAgdmFyIGwgPSBkYXRhLmxlbmd0aDtcbiAgICAgICAgaWYgKHJvd3MgPT09IHVuZGVmaW5lZCkgcm93cyA9IGw7XG4gICAgICAgIGlmIChjb2x1bW5zID09PSB1bmRlZmluZWQpIGNvbHVtbnMgPSByb3dzO1xuICAgICAgICB2YXIgbWluID0gTWF0aC5taW4obCwgcm93cywgY29sdW1ucyk7XG4gICAgICAgIHZhciBtYXRyaXggPSBNYXRyaXguemVyb3Mocm93cywgY29sdW1ucyk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWluOyBpKyspIHtcbiAgICAgICAgICAgIG1hdHJpeFtpXVtpXSA9IGRhdGFbaV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1hdHJpeDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbWF0cml4IHdob3NlIGVsZW1lbnRzIGFyZSB0aGUgbWluaW11bSBiZXR3ZWVuIG1hdHJpeDEgYW5kIG1hdHJpeDJcbiAgICAgKiBAcGFyYW0gbWF0cml4MVxuICAgICAqIEBwYXJhbSBtYXRyaXgyXG4gICAgICogQHJldHVybnMge01hdHJpeH1cbiAgICAgKi9cbiAgICBzdGF0aWMgbWluKG1hdHJpeDEsIG1hdHJpeDIpIHtcbiAgICAgICAgdmFyIHJvd3MgPSBtYXRyaXgxLmxlbmd0aDtcbiAgICAgICAgdmFyIGNvbHVtbnMgPSBtYXRyaXgxWzBdLmxlbmd0aDtcbiAgICAgICAgdmFyIHJlc3VsdCA9IG5ldyBNYXRyaXgocm93cywgY29sdW1ucyk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcm93czsgaSsrKSB7XG4gICAgICAgICAgICBmb3IodmFyIGogPSAwOyBqIDwgY29sdW1uczsgaisrKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0W2ldW2pdID0gTWF0aC5taW4obWF0cml4MVtpXVtqXSwgbWF0cml4MltpXVtqXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbWF0cml4IHdob3NlIGVsZW1lbnRzIGFyZSB0aGUgbWF4aW11bSBiZXR3ZWVuIG1hdHJpeDEgYW5kIG1hdHJpeDJcbiAgICAgKiBAcGFyYW0gbWF0cml4MVxuICAgICAqIEBwYXJhbSBtYXRyaXgyXG4gICAgICogQHJldHVybnMge01hdHJpeH1cbiAgICAgKi9cbiAgICBzdGF0aWMgbWF4KG1hdHJpeDEsIG1hdHJpeDIpIHtcbiAgICAgICAgdmFyIHJvd3MgPSBtYXRyaXgxLmxlbmd0aDtcbiAgICAgICAgdmFyIGNvbHVtbnMgPSBtYXRyaXgxWzBdLmxlbmd0aDtcbiAgICAgICAgdmFyIHJlc3VsdCA9IG5ldyBNYXRyaXgocm93cywgY29sdW1ucyk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcm93czsgaSsrKSB7XG4gICAgICAgICAgICBmb3IodmFyIGogPSAwOyBqIDwgY29sdW1uczsgaisrKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0W2ldW2pdID0gTWF0aC5tYXgobWF0cml4MVtpXVtqXSwgbWF0cml4MltpXVtqXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVjayB0aGF0IHRoZSBwcm92aWRlZCB2YWx1ZSBpcyBhIE1hdHJpeCBhbmQgdHJpZXMgdG8gaW5zdGFudGlhdGUgb25lIGlmIG5vdFxuICAgICAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjaGVja1xuICAgICAqIEByZXR1cm5zIHtNYXRyaXh9XG4gICAgICovXG4gICAgc3RhdGljIGNoZWNrTWF0cml4KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBNYXRyaXguaXNNYXRyaXgodmFsdWUpID8gdmFsdWUgOiBuZXcgTWF0cml4KHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGFyZ3VtZW50IGlzIGEgTWF0cml4LCBmYWxzZSBvdGhlcndpc2VcbiAgICAgKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gY2hlY2tcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAqL1xuICAgIHN0YXRpYyBpc01hdHJpeCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gKHZhbHVlICE9IG51bGwpICYmICh2YWx1ZS5rbGFzcyA9PT0gJ01hdHJpeCcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSAtIFRoZSBudW1iZXIgb2YgZWxlbWVudHMgaW4gdGhlIG1hdHJpeC5cbiAgICAgKi9cbiAgICBnZXQgc2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucm93cyAqIHRoaXMuY29sdW1ucztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBcHBsaWVzIGEgY2FsbGJhY2sgZm9yIGVhY2ggZWxlbWVudCBvZiB0aGUgbWF0cml4LiBUaGUgZnVuY3Rpb24gaXMgY2FsbGVkIGluIHRoZSBtYXRyaXggKHRoaXMpIGNvbnRleHQuXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgLSBGdW5jdGlvbiB0aGF0IHdpbGwgYmUgY2FsbGVkIHdpdGggdHdvIHBhcmFtZXRlcnMgOiBpIChyb3cpIGFuZCBqIChjb2x1bW4pXG4gICAgICogQHJldHVybnMge01hdHJpeH0gdGhpc1xuICAgICAqL1xuICAgIGFwcGx5KGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2NhbGxiYWNrIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBpaSA9IHRoaXMucm93cztcbiAgICAgICAgdmFyIGpqID0gdGhpcy5jb2x1bW5zO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgamo7IGorKykge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrLmNhbGwodGhpcywgaSwgaik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBleGFjdCBhbmQgaW5kZXBlbmRlbnQgY29weSBvZiB0aGUgbWF0cml4XG4gICAgICogQHJldHVybnMge01hdHJpeH1cbiAgICAgKi9cbiAgICBjbG9uZSgpIHtcbiAgICAgICAgdmFyIG5ld01hdHJpeCA9IG5ldyBNYXRyaXgodGhpcy5yb3dzLCB0aGlzLmNvbHVtbnMpO1xuICAgICAgICBmb3IgKHZhciByb3cgPSAwOyByb3cgPCB0aGlzLnJvd3M7IHJvdysrKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBjb2x1bW4gPSAwOyBjb2x1bW4gPCB0aGlzLmNvbHVtbnM7IGNvbHVtbisrKSB7XG4gICAgICAgICAgICAgICAgbmV3TWF0cml4W3Jvd11bY29sdW1uXSA9IHRoaXNbcm93XVtjb2x1bW5dO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXdNYXRyaXg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIG5ldyAxRCBhcnJheSBmaWxsZWQgcm93IGJ5IHJvdyB3aXRoIHRoZSBtYXRyaXggdmFsdWVzXG4gICAgICogQHJldHVybnMge0FycmF5fVxuICAgICAqL1xuICAgIHRvMURBcnJheSgpIHtcbiAgICAgICAgdmFyIGFycmF5ID0gbmV3IEFycmF5KHRoaXMuc2l6ZSk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5yb3dzOyBpKyspIHtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdGhpcy5jb2x1bW5zOyBqKyspIHtcbiAgICAgICAgICAgICAgICBhcnJheVtpICogdGhpcy5jb2x1bW5zICsgal0gPSB0aGlzW2ldW2pdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhcnJheTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgMkQgYXJyYXkgY29udGFpbmluZyBhIGNvcHkgb2YgdGhlIGRhdGFcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9XG4gICAgICovXG4gICAgdG8yREFycmF5KCkge1xuICAgICAgICB2YXIgY29weSA9IG5ldyBBcnJheSh0aGlzLnJvd3MpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucm93czsgaSsrKSB7XG4gICAgICAgICAgICBjb3B5W2ldID0gW10uY29uY2F0KHRoaXNbaV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb3B5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmIHRoZSBtYXRyaXggaGFzIG9uZSByb3dcbiAgICAgKi9cbiAgICBpc1Jvd1ZlY3RvcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucm93cyA9PT0gMTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGUgbWF0cml4IGhhcyBvbmUgY29sdW1uXG4gICAgICovXG4gICAgaXNDb2x1bW5WZWN0b3IoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbHVtbnMgPT09IDE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgdGhlIG1hdHJpeCBoYXMgb25lIHJvdyBvciBvbmUgY29sdW1uXG4gICAgICovXG4gICAgaXNWZWN0b3IoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5yb3dzID09PSAxKSB8fCAodGhpcy5jb2x1bW5zID09PSAxKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGUgbWF0cml4IGhhcyB0aGUgc2FtZSBudW1iZXIgb2Ygcm93cyBhbmQgY29sdW1uc1xuICAgICAqL1xuICAgIGlzU3F1YXJlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yb3dzID09PSB0aGlzLmNvbHVtbnM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgdGhlIG1hdHJpeCBpcyBzcXVhcmUgYW5kIGhhcyB0aGUgc2FtZSB2YWx1ZXMgb24gYm90aCBzaWRlcyBvZiB0aGUgZGlhZ29uYWxcbiAgICAgKi9cbiAgICBpc1N5bW1ldHJpYygpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNTcXVhcmUoKSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnJvd3M7IGkrKykge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDw9IGk7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpc1tpXVtqXSAhPT0gdGhpc1tqXVtpXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgYSBnaXZlbiBlbGVtZW50IG9mIHRoZSBtYXRyaXguIG1hdC5zZXQoMyw0LDEpIGlzIGVxdWl2YWxlbnQgdG8gbWF0WzNdWzRdPTFcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcm93SW5kZXggLSBJbmRleCBvZiB0aGUgcm93XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNvbHVtbkluZGV4IC0gSW5kZXggb2YgdGhlIGNvbHVtblxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSAtIFRoZSBuZXcgdmFsdWUgZm9yIHRoZSBlbGVtZW50XG4gICAgICogQHJldHVybnMge01hdHJpeH0gdGhpc1xuICAgICAqL1xuICAgIHNldChyb3dJbmRleCwgY29sdW1uSW5kZXgsIHZhbHVlKSB7XG4gICAgICAgIHRoaXNbcm93SW5kZXhdW2NvbHVtbkluZGV4XSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBnaXZlbiBlbGVtZW50IG9mIHRoZSBtYXRyaXguIG1hdC5nZXQoMyw0KSBpcyBlcXVpdmFsZW50IHRvIG1hdHJpeFszXVs0XVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSByb3dJbmRleCAtIEluZGV4IG9mIHRoZSByb3dcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY29sdW1uSW5kZXggLSBJbmRleCBvZiB0aGUgY29sdW1uXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKi9cbiAgICBnZXQocm93SW5kZXgsIGNvbHVtbkluZGV4KSB7XG4gICAgICAgIHJldHVybiB0aGlzW3Jvd0luZGV4XVtjb2x1bW5JbmRleF07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRmlsbHMgdGhlIG1hdHJpeCB3aXRoIGEgZ2l2ZW4gdmFsdWUuIEFsbCBlbGVtZW50cyB3aWxsIGJlIHNldCB0byB0aGlzIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSAtIE5ldyB2YWx1ZVxuICAgICAqIEByZXR1cm5zIHtNYXRyaXh9IHRoaXNcbiAgICAgKi9cbiAgICBmaWxsKHZhbHVlKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5yb3dzOyBpKyspIHtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdGhpcy5jb2x1bW5zOyBqKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzW2ldW2pdID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTmVnYXRlcyB0aGUgbWF0cml4LiBBbGwgZWxlbWVudHMgd2lsbCBiZSBtdWx0aXBsaWVkIGJ5ICgtMSlcbiAgICAgKiBAcmV0dXJucyB7TWF0cml4fSB0aGlzXG4gICAgICovXG4gICAgbmVnKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tdWxTKC0xKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbmV3IGFycmF5IGZyb20gdGhlIGdpdmVuIHJvdyBpbmRleFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCAtIFJvdyBpbmRleFxuICAgICAqIEByZXR1cm5zIHtBcnJheX1cbiAgICAgKi9cbiAgICBnZXRSb3coaW5kZXgpIHtcbiAgICAgICAgY2hlY2tSb3dJbmRleCh0aGlzLCBpbmRleCk7XG4gICAgICAgIHJldHVybiBbXS5jb25jYXQodGhpc1tpbmRleF0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBuZXcgcm93IHZlY3RvciBmcm9tIHRoZSBnaXZlbiByb3cgaW5kZXhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggLSBSb3cgaW5kZXhcbiAgICAgKiBAcmV0dXJucyB7TWF0cml4fVxuICAgICAqL1xuICAgIGdldFJvd1ZlY3RvcihpbmRleCkge1xuICAgICAgICByZXR1cm4gTWF0cml4LnJvd1ZlY3Rvcih0aGlzLmdldFJvdyhpbmRleCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgYSByb3cgYXQgdGhlIGdpdmVuIGluZGV4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IC0gUm93IGluZGV4XG4gICAgICogQHBhcmFtIHtBcnJheXxNYXRyaXh9IGFycmF5IC0gQXJyYXkgb3IgdmVjdG9yXG4gICAgICogQHJldHVybnMge01hdHJpeH0gdGhpc1xuICAgICAqL1xuICAgIHNldFJvdyhpbmRleCwgYXJyYXkpIHtcbiAgICAgICAgY2hlY2tSb3dJbmRleCh0aGlzLCBpbmRleCk7XG4gICAgICAgIGFycmF5ID0gY2hlY2tSb3dWZWN0b3IodGhpcywgYXJyYXksIHRydWUpO1xuICAgICAgICB0aGlzW2luZGV4XSA9IGFycmF5O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGEgcm93IGZyb20gdGhlIGdpdmVuIGluZGV4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IC0gUm93IGluZGV4XG4gICAgICogQHJldHVybnMge01hdHJpeH0gdGhpc1xuICAgICAqL1xuICAgIHJlbW92ZVJvdyhpbmRleCkge1xuICAgICAgICBjaGVja1Jvd0luZGV4KHRoaXMsIGluZGV4KTtcbiAgICAgICAgaWYgKHRoaXMucm93cyA9PT0gMSlcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBIG1hdHJpeCBjYW5ub3QgaGF2ZSBsZXNzIHRoYW4gb25lIHJvdycpO1xuICAgICAgICB0aGlzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIHRoaXMucm93cyAtPSAxO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgcm93IGF0IHRoZSBnaXZlbiBpbmRleFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbaW5kZXggPSB0aGlzLnJvd3NdIC0gUm93IGluZGV4XG4gICAgICogQHBhcmFtIHtBcnJheXxNYXRyaXh9IGFycmF5IC0gQXJyYXkgb3IgdmVjdG9yXG4gICAgICogQHJldHVybnMge01hdHJpeH0gdGhpc1xuICAgICAqL1xuICAgIGFkZFJvdyhpbmRleCwgYXJyYXkpIHtcbiAgICAgICAgaWYgKGFycmF5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGFycmF5ID0gaW5kZXg7XG4gICAgICAgICAgICBpbmRleCA9IHRoaXMucm93cztcbiAgICAgICAgfVxuICAgICAgICBjaGVja1Jvd0luZGV4KHRoaXMsIGluZGV4LCB0cnVlKTtcbiAgICAgICAgYXJyYXkgPSBjaGVja1Jvd1ZlY3Rvcih0aGlzLCBhcnJheSwgdHJ1ZSk7XG4gICAgICAgIHRoaXMuc3BsaWNlKGluZGV4LCAwLCBhcnJheSk7XG4gICAgICAgIHRoaXMucm93cyArPSAxO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTd2FwcyB0d28gcm93c1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSByb3cxIC0gRmlyc3Qgcm93IGluZGV4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHJvdzIgLSBTZWNvbmQgcm93IGluZGV4XG4gICAgICogQHJldHVybnMge01hdHJpeH0gdGhpc1xuICAgICAqL1xuICAgIHN3YXBSb3dzKHJvdzEsIHJvdzIpIHtcbiAgICAgICAgY2hlY2tSb3dJbmRleCh0aGlzLCByb3cxKTtcbiAgICAgICAgY2hlY2tSb3dJbmRleCh0aGlzLCByb3cyKTtcbiAgICAgICAgdmFyIHRlbXAgPSB0aGlzW3JvdzFdO1xuICAgICAgICB0aGlzW3JvdzFdID0gdGhpc1tyb3cyXTtcbiAgICAgICAgdGhpc1tyb3cyXSA9IHRlbXA7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBuZXcgYXJyYXkgZnJvbSB0aGUgZ2l2ZW4gY29sdW1uIGluZGV4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IC0gQ29sdW1uIGluZGV4XG4gICAgICogQHJldHVybnMge0FycmF5fVxuICAgICAqL1xuICAgIGdldENvbHVtbihpbmRleCkge1xuICAgICAgICBjaGVja0NvbHVtbkluZGV4KHRoaXMsIGluZGV4KTtcbiAgICAgICAgdmFyIGNvbHVtbiA9IG5ldyBBcnJheSh0aGlzLnJvd3MpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucm93czsgaSsrKSB7XG4gICAgICAgICAgICBjb2x1bW5baV0gPSB0aGlzW2ldW2luZGV4XTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29sdW1uO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBuZXcgY29sdW1uIHZlY3RvciBmcm9tIHRoZSBnaXZlbiBjb2x1bW4gaW5kZXhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggLSBDb2x1bW4gaW5kZXhcbiAgICAgKiBAcmV0dXJucyB7TWF0cml4fVxuICAgICAqL1xuICAgIGdldENvbHVtblZlY3RvcihpbmRleCkge1xuICAgICAgICByZXR1cm4gTWF0cml4LmNvbHVtblZlY3Rvcih0aGlzLmdldENvbHVtbihpbmRleCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgYSBjb2x1bW4gYXQgdGhlIGdpdmVuIGluZGV4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IC0gQ29sdW1uIGluZGV4XG4gICAgICogQHBhcmFtIHtBcnJheXxNYXRyaXh9IGFycmF5IC0gQXJyYXkgb3IgdmVjdG9yXG4gICAgICogQHJldHVybnMge01hdHJpeH0gdGhpc1xuICAgICAqL1xuICAgIHNldENvbHVtbihpbmRleCwgYXJyYXkpIHtcbiAgICAgICAgY2hlY2tDb2x1bW5JbmRleCh0aGlzLCBpbmRleCk7XG4gICAgICAgIGFycmF5ID0gY2hlY2tDb2x1bW5WZWN0b3IodGhpcywgYXJyYXkpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucm93czsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzW2ldW2luZGV4XSA9IGFycmF5W2ldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYSBjb2x1bW4gZnJvbSB0aGUgZ2l2ZW4gaW5kZXhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggLSBDb2x1bW4gaW5kZXhcbiAgICAgKiBAcmV0dXJucyB7TWF0cml4fSB0aGlzXG4gICAgICovXG4gICAgcmVtb3ZlQ29sdW1uKGluZGV4KSB7XG4gICAgICAgIGNoZWNrQ29sdW1uSW5kZXgodGhpcywgaW5kZXgpO1xuICAgICAgICBpZiAodGhpcy5jb2x1bW5zID09PSAxKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0EgbWF0cml4IGNhbm5vdCBoYXZlIGxlc3MgdGhhbiBvbmUgY29sdW1uJyk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5yb3dzOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXNbaV0uc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNvbHVtbnMgLT0gMTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkcyBhIGNvbHVtbiBhdCB0aGUgZ2l2ZW4gaW5kZXhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2luZGV4ID0gdGhpcy5jb2x1bW5zXSAtIENvbHVtbiBpbmRleFxuICAgICAqIEBwYXJhbSB7QXJyYXl8TWF0cml4fSBhcnJheSAtIEFycmF5IG9yIHZlY3RvclxuICAgICAqIEByZXR1cm5zIHtNYXRyaXh9IHRoaXNcbiAgICAgKi9cbiAgICBhZGRDb2x1bW4oaW5kZXgsIGFycmF5KSB7XG4gICAgICAgIGlmICh0eXBlb2YgYXJyYXkgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBhcnJheSA9IGluZGV4O1xuICAgICAgICAgICAgaW5kZXggPSB0aGlzLmNvbHVtbnM7XG4gICAgICAgIH1cbiAgICAgICAgY2hlY2tDb2x1bW5JbmRleCh0aGlzLCBpbmRleCwgdHJ1ZSk7XG4gICAgICAgIGFycmF5ID0gY2hlY2tDb2x1bW5WZWN0b3IodGhpcywgYXJyYXkpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucm93czsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzW2ldLnNwbGljZShpbmRleCwgMCwgYXJyYXlbaV0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY29sdW1ucyArPSAxO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTd2FwcyB0d28gY29sdW1uc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjb2x1bW4xIC0gRmlyc3QgY29sdW1uIGluZGV4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNvbHVtbjIgLSBTZWNvbmQgY29sdW1uIGluZGV4XG4gICAgICogQHJldHVybnMge01hdHJpeH0gdGhpc1xuICAgICAqL1xuICAgIHN3YXBDb2x1bW5zKGNvbHVtbjEsIGNvbHVtbjIpIHtcbiAgICAgICAgY2hlY2tDb2x1bW5JbmRleCh0aGlzLCBjb2x1bW4xKTtcbiAgICAgICAgY2hlY2tDb2x1bW5JbmRleCh0aGlzLCBjb2x1bW4yKTtcbiAgICAgICAgdmFyIHRlbXAsIHJvdztcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnJvd3M7IGkrKykge1xuICAgICAgICAgICAgcm93ID0gdGhpc1tpXTtcbiAgICAgICAgICAgIHRlbXAgPSByb3dbY29sdW1uMV07XG4gICAgICAgICAgICByb3dbY29sdW1uMV0gPSByb3dbY29sdW1uMl07XG4gICAgICAgICAgICByb3dbY29sdW1uMl0gPSB0ZW1wO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZHMgdGhlIHZhbHVlcyBvZiBhIHZlY3RvciB0byBlYWNoIHJvd1xuICAgICAqIEBwYXJhbSB7QXJyYXl8TWF0cml4fSB2ZWN0b3IgLSBBcnJheSBvciB2ZWN0b3JcbiAgICAgKiBAcmV0dXJucyB7TWF0cml4fSB0aGlzXG4gICAgICovXG4gICAgYWRkUm93VmVjdG9yKHZlY3Rvcikge1xuICAgICAgICB2ZWN0b3IgPSBjaGVja1Jvd1ZlY3Rvcih0aGlzLCB2ZWN0b3IpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucm93czsgaSsrKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHRoaXMuY29sdW1uczsgaisrKSB7XG4gICAgICAgICAgICAgICAgdGhpc1tpXVtqXSArPSB2ZWN0b3Jbal07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU3VidHJhY3RzIHRoZSB2YWx1ZXMgb2YgYSB2ZWN0b3IgZnJvbSBlYWNoIHJvd1xuICAgICAqIEBwYXJhbSB7QXJyYXl8TWF0cml4fSB2ZWN0b3IgLSBBcnJheSBvciB2ZWN0b3JcbiAgICAgKiBAcmV0dXJucyB7TWF0cml4fSB0aGlzXG4gICAgICovXG4gICAgc3ViUm93VmVjdG9yKHZlY3Rvcikge1xuICAgICAgICB2ZWN0b3IgPSBjaGVja1Jvd1ZlY3Rvcih0aGlzLCB2ZWN0b3IpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucm93czsgaSsrKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHRoaXMuY29sdW1uczsgaisrKSB7XG4gICAgICAgICAgICAgICAgdGhpc1tpXVtqXSAtPSB2ZWN0b3Jbal07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTXVsdGlwbGllcyB0aGUgdmFsdWVzIG9mIGEgdmVjdG9yIHdpdGggZWFjaCByb3dcbiAgICAgKiBAcGFyYW0ge0FycmF5fE1hdHJpeH0gdmVjdG9yIC0gQXJyYXkgb3IgdmVjdG9yXG4gICAgICogQHJldHVybnMge01hdHJpeH0gdGhpc1xuICAgICAqL1xuICAgIG11bFJvd1ZlY3Rvcih2ZWN0b3IpIHtcbiAgICAgICAgdmVjdG9yID0gY2hlY2tSb3dWZWN0b3IodGhpcywgdmVjdG9yKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnJvd3M7IGkrKykge1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB0aGlzLmNvbHVtbnM7IGorKykge1xuICAgICAgICAgICAgICAgIHRoaXNbaV1bal0gKj0gdmVjdG9yW2pdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERpdmlkZXMgdGhlIHZhbHVlcyBvZiBlYWNoIHJvdyBieSB0aG9zZSBvZiBhIHZlY3RvclxuICAgICAqIEBwYXJhbSB7QXJyYXl8TWF0cml4fSB2ZWN0b3IgLSBBcnJheSBvciB2ZWN0b3JcbiAgICAgKiBAcmV0dXJucyB7TWF0cml4fSB0aGlzXG4gICAgICovXG4gICAgZGl2Um93VmVjdG9yKHZlY3Rvcikge1xuICAgICAgICB2ZWN0b3IgPSBjaGVja1Jvd1ZlY3Rvcih0aGlzLCB2ZWN0b3IpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucm93czsgaSsrKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHRoaXMuY29sdW1uczsgaisrKSB7XG4gICAgICAgICAgICAgICAgdGhpc1tpXVtqXSAvPSB2ZWN0b3Jbal07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkcyB0aGUgdmFsdWVzIG9mIGEgdmVjdG9yIHRvIGVhY2ggY29sdW1uXG4gICAgICogQHBhcmFtIHtBcnJheXxNYXRyaXh9IHZlY3RvciAtIEFycmF5IG9yIHZlY3RvclxuICAgICAqIEByZXR1cm5zIHtNYXRyaXh9IHRoaXNcbiAgICAgKi9cbiAgICBhZGRDb2x1bW5WZWN0b3IodmVjdG9yKSB7XG4gICAgICAgIHZlY3RvciA9IGNoZWNrQ29sdW1uVmVjdG9yKHRoaXMsIHZlY3Rvcik7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5yb3dzOyBpKyspIHtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdGhpcy5jb2x1bW5zOyBqKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzW2ldW2pdICs9IHZlY3RvcltpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTdWJ0cmFjdHMgdGhlIHZhbHVlcyBvZiBhIHZlY3RvciBmcm9tIGVhY2ggY29sdW1uXG4gICAgICogQHBhcmFtIHtBcnJheXxNYXRyaXh9IHZlY3RvciAtIEFycmF5IG9yIHZlY3RvclxuICAgICAqIEByZXR1cm5zIHtNYXRyaXh9IHRoaXNcbiAgICAgKi9cbiAgICBzdWJDb2x1bW5WZWN0b3IodmVjdG9yKSB7XG4gICAgICAgIHZlY3RvciA9IGNoZWNrQ29sdW1uVmVjdG9yKHRoaXMsIHZlY3Rvcik7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5yb3dzOyBpKyspIHtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdGhpcy5jb2x1bW5zOyBqKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzW2ldW2pdIC09IHZlY3RvcltpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNdWx0aXBsaWVzIHRoZSB2YWx1ZXMgb2YgYSB2ZWN0b3Igd2l0aCBlYWNoIGNvbHVtblxuICAgICAqIEBwYXJhbSB7QXJyYXl8TWF0cml4fSB2ZWN0b3IgLSBBcnJheSBvciB2ZWN0b3JcbiAgICAgKiBAcmV0dXJucyB7TWF0cml4fSB0aGlzXG4gICAgICovXG4gICAgbXVsQ29sdW1uVmVjdG9yKHZlY3Rvcikge1xuICAgICAgICB2ZWN0b3IgPSBjaGVja0NvbHVtblZlY3Rvcih0aGlzLCB2ZWN0b3IpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucm93czsgaSsrKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHRoaXMuY29sdW1uczsgaisrKSB7XG4gICAgICAgICAgICAgICAgdGhpc1tpXVtqXSAqPSB2ZWN0b3JbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGl2aWRlcyB0aGUgdmFsdWVzIG9mIGVhY2ggY29sdW1uIGJ5IHRob3NlIG9mIGEgdmVjdG9yXG4gICAgICogQHBhcmFtIHtBcnJheXxNYXRyaXh9IHZlY3RvciAtIEFycmF5IG9yIHZlY3RvclxuICAgICAqIEByZXR1cm5zIHtNYXRyaXh9IHRoaXNcbiAgICAgKi9cbiAgICBkaXZDb2x1bW5WZWN0b3IodmVjdG9yKSB7XG4gICAgICAgIHZlY3RvciA9IGNoZWNrQ29sdW1uVmVjdG9yKHRoaXMsIHZlY3Rvcik7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5yb3dzOyBpKyspIHtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdGhpcy5jb2x1bW5zOyBqKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzW2ldW2pdIC89IHZlY3RvcltpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNdWx0aXBsaWVzIHRoZSB2YWx1ZXMgb2YgYSByb3cgd2l0aCBhIHNjYWxhclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCAtIFJvdyBpbmRleFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxuICAgICAqIEByZXR1cm5zIHtNYXRyaXh9IHRoaXNcbiAgICAgKi9cbiAgICBtdWxSb3coaW5kZXgsIHZhbHVlKSB7XG4gICAgICAgIGNoZWNrUm93SW5kZXgodGhpcywgaW5kZXgpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuY29sdW1uczsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzW2luZGV4XVtpXSAqPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNdWx0aXBsaWVzIHRoZSB2YWx1ZXMgb2YgYSBjb2x1bW4gd2l0aCBhIHNjYWxhclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCAtIENvbHVtbiBpbmRleFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxuICAgICAqIEByZXR1cm5zIHtNYXRyaXh9IHRoaXNcbiAgICAgKi9cbiAgICBtdWxDb2x1bW4oaW5kZXgsIHZhbHVlKSB7XG4gICAgICAgIGNoZWNrQ29sdW1uSW5kZXgodGhpcywgaW5kZXgpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucm93czsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzW2ldW2luZGV4XSAqPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG1heGltdW0gdmFsdWUgb2YgdGhlIG1hdHJpeFxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG4gICAgbWF4KCkge1xuICAgICAgICB2YXIgdiA9IHRoaXNbMF1bMF07XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5yb3dzOyBpKyspIHtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdGhpcy5jb2x1bW5zOyBqKyspIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpc1tpXVtqXSA+IHYpIHtcbiAgICAgICAgICAgICAgICAgICAgdiA9IHRoaXNbaV1bal07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXhpbXVtIHZhbHVlXG4gICAgICogQHJldHVybnMge0FycmF5fVxuICAgICAqL1xuICAgIG1heEluZGV4KCkge1xuICAgICAgICB2YXIgdiA9IHRoaXNbMF1bMF07XG4gICAgICAgIHZhciBpZHggPSBbMCwgMF07XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5yb3dzOyBpKyspIHtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdGhpcy5jb2x1bW5zOyBqKyspIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpc1tpXVtqXSA+IHYpIHtcbiAgICAgICAgICAgICAgICAgICAgdiA9IHRoaXNbaV1bal07XG4gICAgICAgICAgICAgICAgICAgIGlkeFswXSA9IGk7XG4gICAgICAgICAgICAgICAgICAgIGlkeFsxXSA9IGo7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpZHg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbWluaW11bSB2YWx1ZSBvZiB0aGUgbWF0cml4XG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKi9cbiAgICBtaW4oKSB7XG4gICAgICAgIHZhciB2ID0gdGhpc1swXVswXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnJvd3M7IGkrKykge1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB0aGlzLmNvbHVtbnM7IGorKykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzW2ldW2pdIDwgdikge1xuICAgICAgICAgICAgICAgICAgICB2ID0gdGhpc1tpXVtqXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHY7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1pbmltdW0gdmFsdWVcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9XG4gICAgICovXG4gICAgbWluSW5kZXgoKSB7XG4gICAgICAgIHZhciB2ID0gdGhpc1swXVswXTtcbiAgICAgICAgdmFyIGlkeCA9IFswLCAwXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnJvd3M7IGkrKykge1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB0aGlzLmNvbHVtbnM7IGorKykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzW2ldW2pdIDwgdikge1xuICAgICAgICAgICAgICAgICAgICB2ID0gdGhpc1tpXVtqXTtcbiAgICAgICAgICAgICAgICAgICAgaWR4WzBdID0gaTtcbiAgICAgICAgICAgICAgICAgICAgaWR4WzFdID0gajtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlkeDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBtYXhpbXVtIHZhbHVlIG9mIG9uZSByb3dcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcm93IC0gUm93IGluZGV4XG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKi9cbiAgICBtYXhSb3cocm93KSB7XG4gICAgICAgIGNoZWNrUm93SW5kZXgodGhpcywgcm93KTtcbiAgICAgICAgdmFyIHYgPSB0aGlzW3Jvd11bMF07XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgdGhpcy5jb2x1bW5zOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh0aGlzW3Jvd11baV0gPiB2KSB7XG4gICAgICAgICAgICAgICAgdiA9IHRoaXNbcm93XVtpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF4aW11bSB2YWx1ZSBvZiBvbmUgcm93XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHJvdyAtIFJvdyBpbmRleFxuICAgICAqIEByZXR1cm5zIHtBcnJheX1cbiAgICAgKi9cbiAgICBtYXhSb3dJbmRleChyb3cpIHtcbiAgICAgICAgY2hlY2tSb3dJbmRleCh0aGlzLCByb3cpO1xuICAgICAgICB2YXIgdiA9IHRoaXNbcm93XVswXTtcbiAgICAgICAgdmFyIGlkeCA9IFtyb3csIDBdO1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IHRoaXMuY29sdW1uczsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodGhpc1tyb3ddW2ldID4gdikge1xuICAgICAgICAgICAgICAgIHYgPSB0aGlzW3Jvd11baV07XG4gICAgICAgICAgICAgICAgaWR4WzFdID0gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaWR4O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG1pbmltdW0gdmFsdWUgb2Ygb25lIHJvd1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSByb3cgLSBSb3cgaW5kZXhcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuICAgIG1pblJvdyhyb3cpIHtcbiAgICAgICAgY2hlY2tSb3dJbmRleCh0aGlzLCByb3cpO1xuICAgICAgICB2YXIgdiA9IHRoaXNbcm93XVswXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCB0aGlzLmNvbHVtbnM7IGkrKykge1xuICAgICAgICAgICAgaWYgKHRoaXNbcm93XVtpXSA8IHYpIHtcbiAgICAgICAgICAgICAgICB2ID0gdGhpc1tyb3ddW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXhpbXVtIHZhbHVlIG9mIG9uZSByb3dcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcm93IC0gUm93IGluZGV4XG4gICAgICogQHJldHVybnMge0FycmF5fVxuICAgICAqL1xuICAgIG1pblJvd0luZGV4KHJvdykge1xuICAgICAgICBjaGVja1Jvd0luZGV4KHRoaXMsIHJvdyk7XG4gICAgICAgIHZhciB2ID0gdGhpc1tyb3ddWzBdO1xuICAgICAgICB2YXIgaWR4ID0gW3JvdywgMF07XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgdGhpcy5jb2x1bW5zOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh0aGlzW3Jvd11baV0gPCB2KSB7XG4gICAgICAgICAgICAgICAgdiA9IHRoaXNbcm93XVtpXTtcbiAgICAgICAgICAgICAgICBpZHhbMV0gPSBpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpZHg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbWF4aW11bSB2YWx1ZSBvZiBvbmUgY29sdW1uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNvbHVtbiAtIENvbHVtbiBpbmRleFxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG4gICAgbWF4Q29sdW1uKGNvbHVtbikge1xuICAgICAgICBjaGVja0NvbHVtbkluZGV4KHRoaXMsIGNvbHVtbik7XG4gICAgICAgIHZhciB2ID0gdGhpc1swXVtjb2x1bW5dO1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IHRoaXMucm93czsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodGhpc1tpXVtjb2x1bW5dID4gdikge1xuICAgICAgICAgICAgICAgIHYgPSB0aGlzW2ldW2NvbHVtbl07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHY7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1heGltdW0gdmFsdWUgb2Ygb25lIGNvbHVtblxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjb2x1bW4gLSBDb2x1bW4gaW5kZXhcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9XG4gICAgICovXG4gICAgbWF4Q29sdW1uSW5kZXgoY29sdW1uKSB7XG4gICAgICAgIGNoZWNrQ29sdW1uSW5kZXgodGhpcywgY29sdW1uKTtcbiAgICAgICAgdmFyIHYgPSB0aGlzWzBdW2NvbHVtbl07XG4gICAgICAgIHZhciBpZHggPSBbMCwgY29sdW1uXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCB0aGlzLnJvd3M7IGkrKykge1xuICAgICAgICAgICAgaWYgKHRoaXNbaV1bY29sdW1uXSA+IHYpIHtcbiAgICAgICAgICAgICAgICB2ID0gdGhpc1tpXVtjb2x1bW5dO1xuICAgICAgICAgICAgICAgIGlkeFswXSA9IGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlkeDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBtaW5pbXVtIHZhbHVlIG9mIG9uZSBjb2x1bW5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY29sdW1uIC0gQ29sdW1uIGluZGV4XG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKi9cbiAgICBtaW5Db2x1bW4oY29sdW1uKSB7XG4gICAgICAgIGNoZWNrQ29sdW1uSW5kZXgodGhpcywgY29sdW1uKTtcbiAgICAgICAgdmFyIHYgPSB0aGlzWzBdW2NvbHVtbl07XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgdGhpcy5yb3dzOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh0aGlzW2ldW2NvbHVtbl0gPCB2KSB7XG4gICAgICAgICAgICAgICAgdiA9IHRoaXNbaV1bY29sdW1uXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWluaW11bSB2YWx1ZSBvZiBvbmUgY29sdW1uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNvbHVtbiAtIENvbHVtbiBpbmRleFxuICAgICAqIEByZXR1cm5zIHtBcnJheX1cbiAgICAgKi9cbiAgICBtaW5Db2x1bW5JbmRleChjb2x1bW4pIHtcbiAgICAgICAgY2hlY2tDb2x1bW5JbmRleCh0aGlzLCBjb2x1bW4pO1xuICAgICAgICB2YXIgdiA9IHRoaXNbMF1bY29sdW1uXTtcbiAgICAgICAgdmFyIGlkeCA9IFswLCBjb2x1bW5dO1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IHRoaXMucm93czsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodGhpc1tpXVtjb2x1bW5dIDwgdikge1xuICAgICAgICAgICAgICAgIHYgPSB0aGlzW2ldW2NvbHVtbl07XG4gICAgICAgICAgICAgICAgaWR4WzBdID0gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaWR4O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYW4gYXJyYXkgY29udGFpbmluZyB0aGUgZGlhZ29uYWwgdmFsdWVzIG9mIHRoZSBtYXRyaXhcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9XG4gICAgICovXG4gICAgZGlhZygpIHtcbiAgICAgICAgdmFyIG1pbiA9IE1hdGgubWluKHRoaXMucm93cywgdGhpcy5jb2x1bW5zKTtcbiAgICAgICAgdmFyIGRpYWcgPSBuZXcgQXJyYXkobWluKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtaW47IGkrKykge1xuICAgICAgICAgICAgZGlhZ1tpXSA9IHRoaXNbaV1baV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRpYWc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgc3VtIG9mIGFsbCBlbGVtZW50cyBvZiB0aGUgbWF0cml4XG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKi9cbiAgICBzdW0oKSB7XG4gICAgICAgIHZhciB2ID0gMDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnJvd3M7IGkrKykge1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB0aGlzLmNvbHVtbnM7IGorKykge1xuICAgICAgICAgICAgICAgIHYgKz0gdGhpc1tpXVtqXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBtZWFuIG9mIGFsbCBlbGVtZW50cyBvZiB0aGUgbWF0cml4XG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKi9cbiAgICBtZWFuKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdW0oKSAvIHRoaXMuc2l6ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBwcm9kdWN0IG9mIGFsbCBlbGVtZW50cyBvZiB0aGUgbWF0cml4XG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKi9cbiAgICBwcm9kKCkge1xuICAgICAgICB2YXIgcHJvZCA9IDE7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5yb3dzOyBpKyspIHtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdGhpcy5jb2x1bW5zOyBqKyspIHtcbiAgICAgICAgICAgICAgICBwcm9kICo9IHRoaXNbaV1bal07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHByb2Q7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29tcHV0ZXMgdGhlIGN1bXVsYXRpdmUgc3VtIG9mIHRoZSBtYXRyaXggZWxlbWVudHMgKGluIHBsYWNlLCByb3cgYnkgcm93KVxuICAgICAqIEByZXR1cm5zIHtNYXRyaXh9IHRoaXNcbiAgICAgKi9cbiAgICBjdW11bGF0aXZlU3VtKCkge1xuICAgICAgICB2YXIgc3VtID0gMDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnJvd3M7IGkrKykge1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB0aGlzLmNvbHVtbnM7IGorKykge1xuICAgICAgICAgICAgICAgIHN1bSArPSB0aGlzW2ldW2pdO1xuICAgICAgICAgICAgICAgIHRoaXNbaV1bal0gPSBzdW07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29tcHV0ZXMgdGhlIGRvdCAoc2NhbGFyKSBwcm9kdWN0IGJldHdlZW4gdGhlIG1hdHJpeCBhbmQgYW5vdGhlclxuICAgICAqIEBwYXJhbSB7TWF0cml4fSB2ZWN0b3IyIHZlY3RvclxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG4gICAgZG90KHZlY3RvcjIpIHtcbiAgICAgICAgaWYgKE1hdHJpeC5pc01hdHJpeCh2ZWN0b3IyKSkgdmVjdG9yMiA9IHZlY3RvcjIudG8xREFycmF5KCk7XG4gICAgICAgIHZhciB2ZWN0b3IxID0gdGhpcy50bzFEQXJyYXkoKTtcbiAgICAgICAgaWYgKHZlY3RvcjEubGVuZ3RoICE9PSB2ZWN0b3IyLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3ZlY3RvcnMgZG8gbm90IGhhdmUgdGhlIHNhbWUgc2l6ZScpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBkb3QgPSAwO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZlY3RvcjEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGRvdCArPSB2ZWN0b3IxW2ldICogdmVjdG9yMltpXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZG90O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG1hdHJpeCBwcm9kdWN0IGJldHdlZW4gdGhpcyBhbmQgb3RoZXJcbiAgICAgKiBAcGFyYW0ge01hdHJpeH0gb3RoZXJcbiAgICAgKiBAcmV0dXJucyB7TWF0cml4fVxuICAgICAqL1xuICAgIG1tdWwob3RoZXIpIHtcbiAgICAgICAgb3RoZXIgPSBNYXRyaXguY2hlY2tNYXRyaXgob3RoZXIpO1xuICAgICAgICBpZiAodGhpcy5jb2x1bW5zICE9PSBvdGhlci5yb3dzKVxuICAgICAgICAgICAgY29uc29sZS53YXJuKCdOdW1iZXIgb2YgY29sdW1ucyBvZiBsZWZ0IG1hdHJpeCBhcmUgbm90IGVxdWFsIHRvIG51bWJlciBvZiByb3dzIG9mIHJpZ2h0IG1hdHJpeC4nKTtcblxuICAgICAgICB2YXIgbSA9IHRoaXMucm93cztcbiAgICAgICAgdmFyIG4gPSB0aGlzLmNvbHVtbnM7XG4gICAgICAgIHZhciBwID0gb3RoZXIuY29sdW1ucztcblxuICAgICAgICB2YXIgcmVzdWx0ID0gbmV3IE1hdHJpeChtLCBwKTtcblxuICAgICAgICB2YXIgQmNvbGogPSBuZXcgQXJyYXkobik7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgcDsgaisrKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IG47IGsrKylcbiAgICAgICAgICAgICAgICBCY29saltrXSA9IG90aGVyW2tdW2pdO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG07IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBBcm93aSA9IHRoaXNbaV07XG5cbiAgICAgICAgICAgICAgICB2YXIgcyA9IDA7XG4gICAgICAgICAgICAgICAgZm9yIChrID0gMDsgayA8IG47IGsrKylcbiAgICAgICAgICAgICAgICAgICAgcyArPSBBcm93aVtrXSAqIEJjb2xqW2tdO1xuXG4gICAgICAgICAgICAgICAgcmVzdWx0W2ldW2pdID0gcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIEtyb25lY2tlciBwcm9kdWN0IChhbHNvIGtub3duIGFzIHRlbnNvciBwcm9kdWN0KSBiZXR3ZWVuIHRoaXMgYW5kIG90aGVyXG4gICAgICogU2VlIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0tyb25lY2tlcl9wcm9kdWN0XG4gICAgICogQHBhcmFtIHtNYXRyaXh9IG90aGVyXG4gICAgICogQHJldHVybiB7TWF0cml4fVxuICAgICAqL1xuICAgIGtyb25lY2tlclByb2R1Y3Qob3RoZXIpIHtcbiAgICAgICAgb3RoZXIgPSBNYXRyaXguY2hlY2tNYXRyaXgob3RoZXIpO1xuXG4gICAgICAgIHZhciBtID0gdGhpcy5yb3dzO1xuICAgICAgICB2YXIgbiA9IHRoaXMuY29sdW1ucztcbiAgICAgICAgdmFyIHAgPSBvdGhlci5yb3dzO1xuICAgICAgICB2YXIgcSA9IG90aGVyLmNvbHVtbnM7XG5cbiAgICAgICAgdmFyIHJlc3VsdCA9IG5ldyBNYXRyaXgobSAqIHAsIG4gKiBxKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtOyBpKyspIHtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbjsgaisrKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBwOyBrKyspIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgbCA9IDA7IGwgPCBxOyBsKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFtwICogaSArIGtdW3EgKiBqICsgbF0gPSB0aGlzW2ldW2pdICogb3RoZXJba11bbF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmFuc3Bvc2VzIHRoZSBtYXRyaXggYW5kIHJldHVybnMgYSBuZXcgb25lIGNvbnRhaW5pbmcgdGhlIHJlc3VsdFxuICAgICAqIEByZXR1cm5zIHtNYXRyaXh9XG4gICAgICovXG4gICAgdHJhbnNwb3NlKCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gbmV3IE1hdHJpeCh0aGlzLmNvbHVtbnMsIHRoaXMucm93cyk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5yb3dzOyBpKyspIHtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdGhpcy5jb2x1bW5zOyBqKyspIHtcbiAgICAgICAgICAgICAgICByZXN1bHRbal1baV0gPSB0aGlzW2ldW2pdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU29ydHMgdGhlIHJvd3MgKGluIHBsYWNlKVxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNvbXBhcmVGdW5jdGlvbiAtIHVzdWFsIEFycmF5LnByb3RvdHlwZS5zb3J0IGNvbXBhcmlzb24gZnVuY3Rpb25cbiAgICAgKiBAcmV0dXJucyB7TWF0cml4fSB0aGlzXG4gICAgICovXG4gICAgc29ydFJvd3MoY29tcGFyZUZ1bmN0aW9uKSB7XG4gICAgICAgIGlmIChjb21wYXJlRnVuY3Rpb24gPT09IHVuZGVmaW5lZCkgY29tcGFyZUZ1bmN0aW9uID0gY29tcGFyZU51bWJlcnM7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5yb3dzOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXNbaV0uc29ydChjb21wYXJlRnVuY3Rpb24pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNvcnRzIHRoZSBjb2x1bW5zIChpbiBwbGFjZSlcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjb21wYXJlRnVuY3Rpb24gLSB1c3VhbCBBcnJheS5wcm90b3R5cGUuc29ydCBjb21wYXJpc29uIGZ1bmN0aW9uXG4gICAgICogQHJldHVybnMge01hdHJpeH0gdGhpc1xuICAgICAqL1xuICAgIHNvcnRDb2x1bW5zKGNvbXBhcmVGdW5jdGlvbikge1xuICAgICAgICBpZiAoY29tcGFyZUZ1bmN0aW9uID09PSB1bmRlZmluZWQpIGNvbXBhcmVGdW5jdGlvbiA9IGNvbXBhcmVOdW1iZXJzO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuY29sdW1uczsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLnNldENvbHVtbihpLCB0aGlzLmdldENvbHVtbihpKS5zb3J0KGNvbXBhcmVGdW5jdGlvbikpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBzdWJzZXQgb2YgdGhlIG1hdHJpeFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydFJvdyAtIEZpcnN0IHJvdyBpbmRleFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBlbmRSb3cgLSBMYXN0IHJvdyBpbmRleFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydENvbHVtbiAtIEZpcnN0IGNvbHVtbiBpbmRleFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBlbmRDb2x1bW4gLSBMYXN0IGNvbHVtbiBpbmRleFxuICAgICAqIEByZXR1cm5zIHtNYXRyaXh9XG4gICAgICovXG4gICAgc3ViTWF0cml4KHN0YXJ0Um93LCBlbmRSb3csIHN0YXJ0Q29sdW1uLCBlbmRDb2x1bW4pIHtcbiAgICAgICAgaWYgKChzdGFydFJvdyA+IGVuZFJvdykgfHwgKHN0YXJ0Q29sdW1uID4gZW5kQ29sdW1uKSB8fCAoc3RhcnRSb3cgPCAwKSB8fCAoc3RhcnRSb3cgPj0gdGhpcy5yb3dzKSB8fCAoZW5kUm93IDwgMCkgfHwgKGVuZFJvdyA+PSB0aGlzLnJvd3MpIHx8IChzdGFydENvbHVtbiA8IDApIHx8IChzdGFydENvbHVtbiA+PSB0aGlzLmNvbHVtbnMpIHx8IChlbmRDb2x1bW4gPCAwKSB8fCAoZW5kQ29sdW1uID49IHRoaXMuY29sdW1ucykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBcmd1bWVudCBvdXQgb2YgcmFuZ2UnKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbmV3TWF0cml4ID0gbmV3IE1hdHJpeChlbmRSb3cgLSBzdGFydFJvdyArIDEsIGVuZENvbHVtbiAtIHN0YXJ0Q29sdW1uICsgMSk7XG4gICAgICAgIGZvciAodmFyIGkgPSBzdGFydFJvdzsgaSA8PSBlbmRSb3c7IGkrKykge1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IHN0YXJ0Q29sdW1uOyBqIDw9IGVuZENvbHVtbjsgaisrKSB7XG4gICAgICAgICAgICAgICAgbmV3TWF0cml4W2kgLSBzdGFydFJvd11baiAtIHN0YXJ0Q29sdW1uXSA9IHRoaXNbaV1bal07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ld01hdHJpeDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgc3Vic2V0IG9mIHRoZSBtYXRyaXggYmFzZWQgb24gYW4gYXJyYXkgb2Ygcm93IGluZGljZXNcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBpbmRpY2VzIC0gQXJyYXkgY29udGFpbmluZyB0aGUgcm93IGluZGljZXNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0Q29sdW1uID0gMF0gLSBGaXJzdCBjb2x1bW4gaW5kZXhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2VuZENvbHVtbiA9IHRoaXMuY29sdW1ucy0xXSAtIExhc3QgY29sdW1uIGluZGV4XG4gICAgICogQHJldHVybnMge01hdHJpeH1cbiAgICAgKi9cbiAgICBzdWJNYXRyaXhSb3coaW5kaWNlcywgc3RhcnRDb2x1bW4sIGVuZENvbHVtbikge1xuICAgICAgICBpZiAoc3RhcnRDb2x1bW4gPT09IHVuZGVmaW5lZCkgc3RhcnRDb2x1bW4gPSAwO1xuICAgICAgICBpZiAoZW5kQ29sdW1uID09PSB1bmRlZmluZWQpIGVuZENvbHVtbiA9IHRoaXMuY29sdW1ucyAtIDE7XG4gICAgICAgIGlmICgoc3RhcnRDb2x1bW4gPiBlbmRDb2x1bW4pIHx8IChzdGFydENvbHVtbiA8IDApIHx8IChzdGFydENvbHVtbiA+PSB0aGlzLmNvbHVtbnMpIHx8IChlbmRDb2x1bW4gPCAwKSB8fCAoZW5kQ29sdW1uID49IHRoaXMuY29sdW1ucykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBcmd1bWVudCBvdXQgb2YgcmFuZ2UnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBuZXdNYXRyaXggPSBuZXcgTWF0cml4KGluZGljZXMubGVuZ3RoLCBlbmRDb2x1bW4gLSBzdGFydENvbHVtbiArIDEpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGluZGljZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSBzdGFydENvbHVtbjsgaiA8PSBlbmRDb2x1bW47IGorKykge1xuICAgICAgICAgICAgICAgIGlmIChpbmRpY2VzW2ldIDwgMCB8fCBpbmRpY2VzW2ldID49IHRoaXMucm93cykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignUm93IGluZGV4IG91dCBvZiByYW5nZTogJyArIGluZGljZXNbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBuZXdNYXRyaXhbaV1baiAtIHN0YXJ0Q29sdW1uXSA9IHRoaXNbaW5kaWNlc1tpXV1bal07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ld01hdHJpeDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgc3Vic2V0IG9mIHRoZSBtYXRyaXggYmFzZWQgb24gYW4gYXJyYXkgb2YgY29sdW1uIGluZGljZXNcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBpbmRpY2VzIC0gQXJyYXkgY29udGFpbmluZyB0aGUgY29sdW1uIGluZGljZXNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0Um93ID0gMF0gLSBGaXJzdCByb3cgaW5kZXhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2VuZFJvdyA9IHRoaXMucm93cy0xXSAtIExhc3Qgcm93IGluZGV4XG4gICAgICogQHJldHVybnMge01hdHJpeH1cbiAgICAgKi9cbiAgICBzdWJNYXRyaXhDb2x1bW4oaW5kaWNlcywgc3RhcnRSb3csIGVuZFJvdykge1xuICAgICAgICBpZiAoc3RhcnRSb3cgPT09IHVuZGVmaW5lZCkgc3RhcnRSb3cgPSAwO1xuICAgICAgICBpZiAoZW5kUm93ID09PSB1bmRlZmluZWQpIGVuZFJvdyA9IHRoaXMucm93cyAtIDE7XG4gICAgICAgIGlmICgoc3RhcnRSb3cgPiBlbmRSb3cpIHx8IChzdGFydFJvdyA8IDApIHx8IChzdGFydFJvdyA+PSB0aGlzLnJvd3MpIHx8IChlbmRSb3cgPCAwKSB8fCAoZW5kUm93ID49IHRoaXMucm93cykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBcmd1bWVudCBvdXQgb2YgcmFuZ2UnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBuZXdNYXRyaXggPSBuZXcgTWF0cml4KGVuZFJvdyAtIHN0YXJ0Um93ICsgMSwgaW5kaWNlcy5sZW5ndGgpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGluZGljZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSBzdGFydFJvdzsgaiA8PSBlbmRSb3c7IGorKykge1xuICAgICAgICAgICAgICAgIGlmIChpbmRpY2VzW2ldIDwgMCB8fCBpbmRpY2VzW2ldID49IHRoaXMuY29sdW1ucykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQ29sdW1uIGluZGV4IG91dCBvZiByYW5nZTogJyArIGluZGljZXNbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBuZXdNYXRyaXhbaiAtIHN0YXJ0Um93XVtpXSA9IHRoaXNbal1baW5kaWNlc1tpXV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ld01hdHJpeDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB0cmFjZSBvZiB0aGUgbWF0cml4IChzdW0gb2YgdGhlIGRpYWdvbmFsIGVsZW1lbnRzKVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG4gICAgdHJhY2UoKSB7XG4gICAgICAgIHZhciBtaW4gPSBNYXRoLm1pbih0aGlzLnJvd3MsIHRoaXMuY29sdW1ucyk7XG4gICAgICAgIHZhciB0cmFjZSA9IDA7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWluOyBpKyspIHtcbiAgICAgICAgICAgIHRyYWNlICs9IHRoaXNbaV1baV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRyYWNlO1xuICAgIH1cbn1cblxuTWF0cml4LnByb3RvdHlwZS5rbGFzcyA9ICdNYXRyaXgnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE1hdHJpeDtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogQ2hlY2sgdGhhdCBhIHJvdyBpbmRleCBpcyBub3Qgb3V0IG9mIGJvdW5kc1xuICogQHBhcmFtIHtNYXRyaXh9IG1hdHJpeFxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvdXRlcl1cbiAqL1xuZnVuY3Rpb24gY2hlY2tSb3dJbmRleChtYXRyaXgsIGluZGV4LCBvdXRlcikge1xuICAgIHZhciBtYXggPSBvdXRlciA/IG1hdHJpeC5yb3dzIDogbWF0cml4LnJvd3MgLSAxO1xuICAgIGlmIChpbmRleCA8IDAgfHwgaW5kZXggPiBtYXgpXG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdSb3cgaW5kZXggb3V0IG9mIHJhbmdlJyk7XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIENoZWNrIHRoYXQgdGhlIHByb3ZpZGVkIHZlY3RvciBpcyBhbiBhcnJheSB3aXRoIHRoZSByaWdodCBsZW5ndGhcbiAqIEBwYXJhbSB7TWF0cml4fSBtYXRyaXhcbiAqIEBwYXJhbSB7QXJyYXl8TWF0cml4fSB2ZWN0b3JcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gY29weVxuICogQHJldHVybnMge0FycmF5fVxuICogQHRocm93cyB7UmFuZ2VFcnJvcn1cbiAqL1xuZnVuY3Rpb24gY2hlY2tSb3dWZWN0b3IobWF0cml4LCB2ZWN0b3IsIGNvcHkpIHtcbiAgICBpZiAoTWF0cml4LmlzTWF0cml4KHZlY3RvcikpIHtcbiAgICAgICAgdmVjdG9yID0gdmVjdG9yLnRvMURBcnJheSgpO1xuICAgIH0gZWxzZSBpZiAoY29weSkge1xuICAgICAgICB2ZWN0b3IgPSBbXS5jb25jYXQodmVjdG9yKTtcbiAgICB9XG4gICAgaWYgKHZlY3Rvci5sZW5ndGggIT09IG1hdHJpeC5jb2x1bW5zKVxuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigndmVjdG9yIHNpemUgbXVzdCBiZSB0aGUgc2FtZSBhcyB0aGUgbnVtYmVyIG9mIGNvbHVtbnMnKTtcbiAgICByZXR1cm4gdmVjdG9yO1xufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBDaGVjayB0aGF0IHRoZSBwcm92aWRlZCB2ZWN0b3IgaXMgYW4gYXJyYXkgd2l0aCB0aGUgcmlnaHQgbGVuZ3RoXG4gKiBAcGFyYW0ge01hdHJpeH0gbWF0cml4XG4gKiBAcGFyYW0ge0FycmF5fE1hdHJpeH0gdmVjdG9yXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGNvcHlcbiAqIEByZXR1cm5zIHtBcnJheX1cbiAqIEB0aHJvd3Mge1JhbmdlRXJyb3J9XG4gKi9cbmZ1bmN0aW9uIGNoZWNrQ29sdW1uVmVjdG9yKG1hdHJpeCwgdmVjdG9yLCBjb3B5KSB7XG4gICAgaWYgKE1hdHJpeC5pc01hdHJpeCh2ZWN0b3IpKSB7XG4gICAgICAgIHZlY3RvciA9IHZlY3Rvci50bzFEQXJyYXkoKTtcbiAgICB9IGVsc2UgaWYgKGNvcHkpIHtcbiAgICAgICAgdmVjdG9yID0gW10uY29uY2F0KHZlY3Rvcik7XG4gICAgfVxuICAgIGlmICh2ZWN0b3IubGVuZ3RoICE9PSBtYXRyaXgucm93cylcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3ZlY3RvciBzaXplIG11c3QgYmUgdGhlIHNhbWUgYXMgdGhlIG51bWJlciBvZiByb3dzJyk7XG4gICAgcmV0dXJuIHZlY3Rvcjtcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogQ2hlY2sgdGhhdCBhIGNvbHVtbiBpbmRleCBpcyBub3Qgb3V0IG9mIGJvdW5kc1xuICogQHBhcmFtIHtNYXRyaXh9IG1hdHJpeFxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvdXRlcl1cbiAqL1xuZnVuY3Rpb24gY2hlY2tDb2x1bW5JbmRleChtYXRyaXgsIGluZGV4LCBvdXRlcikge1xuICAgIHZhciBtYXggPSBvdXRlciA/IG1hdHJpeC5jb2x1bW5zIDogbWF0cml4LmNvbHVtbnMgLSAxO1xuICAgIGlmIChpbmRleCA8IDAgfHwgaW5kZXggPiBtYXgpXG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdDb2x1bW4gaW5kZXggb3V0IG9mIHJhbmdlJyk7XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIENoZWNrIHRoYXQgdHdvIG1hdHJpY2VzIGhhdmUgdGhlIHNhbWUgZGltZW5zaW9uc1xuICogQHBhcmFtIHtNYXRyaXh9IG1hdHJpeFxuICogQHBhcmFtIHtNYXRyaXh9IG90aGVyTWF0cml4XG4gKi9cbmZ1bmN0aW9uIGNoZWNrRGltZW5zaW9ucyhtYXRyaXgsIG90aGVyTWF0cml4KSB7XG4gICAgaWYgKG1hdHJpeC5yb3dzICE9PSBvdGhlck1hdHJpeC5sZW5ndGggfHxcbiAgICAgICAgbWF0cml4LmNvbHVtbnMgIT09IG90aGVyTWF0cml4WzBdLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignTWF0cmljZXMgZGltZW5zaW9ucyBtdXN0IGJlIGVxdWFsJyk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBjb21wYXJlTnVtYmVycyhhLCBiKSB7XG4gICAgcmV0dXJuIGEgLSBiO1xufVxuXG4vKlxuU3lub255bXNcbiAqL1xuXG5NYXRyaXgucmFuZG9tID0gTWF0cml4LnJhbmQ7XG5NYXRyaXguZGlhZ29uYWwgPSBNYXRyaXguZGlhZztcbk1hdHJpeC5wcm90b3R5cGUuZGlhZ29uYWwgPSBNYXRyaXgucHJvdG90eXBlLmRpYWc7XG5NYXRyaXguaWRlbnRpdHkgPSBNYXRyaXguZXllO1xuTWF0cml4LnByb3RvdHlwZS5uZWdhdGUgPSBNYXRyaXgucHJvdG90eXBlLm5lZztcbk1hdHJpeC5wcm90b3R5cGUudGVuc29yUHJvZHVjdCA9IE1hdHJpeC5wcm90b3R5cGUua3JvbmVja2VyUHJvZHVjdDtcblxuLypcbkFkZCBkeW5hbWljYWxseSBpbnN0YW5jZSBhbmQgc3RhdGljIG1ldGhvZHMgZm9yIG1hdGhlbWF0aWNhbCBvcGVyYXRpb25zXG4gKi9cblxudmFyIGlucGxhY2VPcGVyYXRvciA9IGBcbihmdW5jdGlvbiAlbmFtZSUodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykgcmV0dXJuIHRoaXMuJW5hbWUlUyh2YWx1ZSk7XG4gICAgcmV0dXJuIHRoaXMuJW5hbWUlTSh2YWx1ZSk7XG59KVxuYDtcblxudmFyIGlucGxhY2VPcGVyYXRvclNjYWxhciA9IGBcbihmdW5jdGlvbiAlbmFtZSVTKHZhbHVlKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnJvd3M7IGkrKykge1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHRoaXMuY29sdW1uczsgaisrKSB7XG4gICAgICAgICAgICB0aGlzW2ldW2pdID0gdGhpc1tpXVtqXSAlb3AlIHZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xufSlcbmA7XG5cbnZhciBpbnBsYWNlT3BlcmF0b3JNYXRyaXggPSBgXG4oZnVuY3Rpb24gJW5hbWUlTShtYXRyaXgpIHtcbiAgICBjaGVja0RpbWVuc2lvbnModGhpcywgbWF0cml4KTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucm93czsgaSsrKSB7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdGhpcy5jb2x1bW5zOyBqKyspIHtcbiAgICAgICAgICAgIHRoaXNbaV1bal0gPSB0aGlzW2ldW2pdICVvcCUgbWF0cml4W2ldW2pdO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xufSlcbmA7XG5cbnZhciBzdGF0aWNPcGVyYXRvciA9IGBcbihmdW5jdGlvbiAlbmFtZSUobWF0cml4LCB2YWx1ZSkge1xuICAgIHZhciBuZXdNYXRyaXggPSBuZXcgTWF0cml4KG1hdHJpeCk7XG4gICAgcmV0dXJuIG5ld01hdHJpeC4lbmFtZSUodmFsdWUpO1xufSlcbmA7XG5cbnZhciBpbnBsYWNlTWV0aG9kID0gYFxuKGZ1bmN0aW9uICVuYW1lJSgpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucm93czsgaSsrKSB7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdGhpcy5jb2x1bW5zOyBqKyspIHtcbiAgICAgICAgICAgIHRoaXNbaV1bal0gPSAlbWV0aG9kJSh0aGlzW2ldW2pdKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbn0pXG5gO1xuXG52YXIgc3RhdGljTWV0aG9kID0gYFxuKGZ1bmN0aW9uICVuYW1lJShtYXRyaXgpIHtcbiAgICB2YXIgbmV3TWF0cml4ID0gbmV3IE1hdHJpeChtYXRyaXgpO1xuICAgIHJldHVybiBuZXdNYXRyaXguJW5hbWUlKCk7XG59KVxuYDtcblxudmFyIG9wZXJhdG9ycyA9IFtcbiAgICAvLyBBcml0aG1ldGljIG9wZXJhdG9yc1xuICAgIFsnKycsICdhZGQnXSxcbiAgICBbJy0nLCAnc3ViJywgJ3N1YnRyYWN0J10sXG4gICAgWycqJywgJ211bCcsICdtdWx0aXBseSddLFxuICAgIFsnLycsICdkaXYnLCAnZGl2aWRlJ10sXG4gICAgWyclJywgJ21vZCcsICdtb2R1bHVzJ10sXG4gICAgLy8gQml0d2lzZSBvcGVyYXRvcnNcbiAgICBbJyYnLCAnYW5kJ10sXG4gICAgWyd8JywgJ29yJ10sXG4gICAgWydeJywgJ3hvciddLFxuICAgIFsnPDwnLCAnbGVmdFNoaWZ0J10sXG4gICAgWyc+PicsICdzaWduUHJvcGFnYXRpbmdSaWdodFNoaWZ0J10sXG4gICAgWyc+Pj4nLCAncmlnaHRTaGlmdCcsICd6ZXJvRmlsbFJpZ2h0U2hpZnQnXVxuXTtcblxuZm9yICh2YXIgb3BlcmF0b3Igb2Ygb3BlcmF0b3JzKSB7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBvcGVyYXRvci5sZW5ndGg7IGkrKykge1xuICAgICAgICBNYXRyaXgucHJvdG90eXBlW29wZXJhdG9yW2ldXSA9IGV2YWwoZmlsbFRlbXBsYXRlRnVuY3Rpb24oaW5wbGFjZU9wZXJhdG9yLCB7bmFtZTogb3BlcmF0b3JbaV0sIG9wOiBvcGVyYXRvclswXX0pKTtcbiAgICAgICAgTWF0cml4LnByb3RvdHlwZVtvcGVyYXRvcltpXSArICdTJ10gPSBldmFsKGZpbGxUZW1wbGF0ZUZ1bmN0aW9uKGlucGxhY2VPcGVyYXRvclNjYWxhciwge25hbWU6IG9wZXJhdG9yW2ldICsgJ1MnLCBvcDogb3BlcmF0b3JbMF19KSk7XG4gICAgICAgIE1hdHJpeC5wcm90b3R5cGVbb3BlcmF0b3JbaV0gKyAnTSddID0gZXZhbChmaWxsVGVtcGxhdGVGdW5jdGlvbihpbnBsYWNlT3BlcmF0b3JNYXRyaXgsIHtuYW1lOiBvcGVyYXRvcltpXSArICdNJywgb3A6IG9wZXJhdG9yWzBdfSkpO1xuXG4gICAgICAgIE1hdHJpeFtvcGVyYXRvcltpXV0gPSBldmFsKGZpbGxUZW1wbGF0ZUZ1bmN0aW9uKHN0YXRpY09wZXJhdG9yLCB7bmFtZTogb3BlcmF0b3JbaV19KSk7XG4gICAgfVxufVxuXG52YXIgbWV0aG9kcyA9IFtcbiAgICBbJ34nLCAnbm90J11cbl07XG5cbltcbiAgICAnYWJzJywgJ2Fjb3MnLCAnYWNvc2gnLCAnYXNpbicsICdhc2luaCcsICdhdGFuJywgJ2F0YW5oJywgJ2NicnQnLCAnY2VpbCcsXG4gICAgJ2NsejMyJywgJ2NvcycsICdjb3NoJywgJ2V4cCcsICdleHBtMScsICdmbG9vcicsICdmcm91bmQnLCAnbG9nJywgJ2xvZzFwJyxcbiAgICAnbG9nMTAnLCAnbG9nMicsICdyb3VuZCcsICdzaWduJywgJ3NpbicsICdzaW5oJywgJ3NxcnQnLCAndGFuJywgJ3RhbmgnLCAndHJ1bmMnXG5dLmZvckVhY2goZnVuY3Rpb24gKG1hdGhNZXRob2QpIHtcbiAgICBtZXRob2RzLnB1c2goWydNYXRoLicgKyBtYXRoTWV0aG9kLCBtYXRoTWV0aG9kXSk7XG59KTtcblxuZm9yICh2YXIgbWV0aG9kIG9mIG1ldGhvZHMpIHtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IG1ldGhvZC5sZW5ndGg7IGkrKykge1xuICAgICAgICBNYXRyaXgucHJvdG90eXBlW21ldGhvZFtpXV0gPSBldmFsKGZpbGxUZW1wbGF0ZUZ1bmN0aW9uKGlucGxhY2VNZXRob2QsIHtuYW1lOiBtZXRob2RbaV0sIG1ldGhvZDogbWV0aG9kWzBdfSkpO1xuICAgICAgICBNYXRyaXhbbWV0aG9kW2ldXSA9IGV2YWwoZmlsbFRlbXBsYXRlRnVuY3Rpb24oc3RhdGljTWV0aG9kLCB7bmFtZTogbWV0aG9kW2ldfSkpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZmlsbFRlbXBsYXRlRnVuY3Rpb24odGVtcGxhdGUsIHZhbHVlcykge1xuICAgIGZvciAodmFyIGkgaW4gdmFsdWVzKSB7XG4gICAgICAgIHRlbXBsYXRlID0gdGVtcGxhdGUucmVwbGFjZShuZXcgUmVnRXhwKCclJyArIGkgKyAnJScsICdnJyksIHZhbHVlc1tpXSk7XG4gICAgfVxuICAgIHJldHVybiB0ZW1wbGF0ZTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgZGVncmVlOiAxLFxuICAgIGNvbnN0YW50OiAxLFxuICAgIHNjYWxlOiAxXG59O1xuXG5jbGFzcyBQb2x5bm9taWFsS2VybmVsIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0T3B0aW9ucywgb3B0aW9ucyk7XG5cbiAgICAgICAgdGhpcy5kZWdyZWUgPSBvcHRpb25zLmRlZ3JlZTtcbiAgICAgICAgdGhpcy5jb25zdGFudCA9IG9wdGlvbnMuY29uc3RhbnQ7XG4gICAgICAgIHRoaXMuc2NhbGUgPSBvcHRpb25zLnNjYWxlO1xuICAgIH1cblxuICAgIGNvbXB1dGUoeCwgeSkge1xuICAgICAgICB2YXIgc3VtID0gMDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB4Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBzdW0gKz0geFtpXSAqIHlbaV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE1hdGgucG93KHRoaXMuc2NhbGUgKiBzdW0gKyB0aGlzLmNvbnN0YW50LCB0aGlzLmRlZ3JlZSk7XG4gICAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFBvbHlub21pYWxLZXJuZWw7XG4iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuU2ltcGxlTGluZWFyUmVncmVzc2lvbiA9IGV4cG9ydHMuU0xSID0gcmVxdWlyZSgnLi9yZWdyZXNzaW9uL3NpbXBsZS1saW5lYXItcmVncmVzc2lvbicpO1xuZXhwb3J0cy5LZXJuZWxSaWRnZVJlZ3Jlc3Npb24gPSBleHBvcnRzLktSUiA9IHJlcXVpcmUoJy4vcmVncmVzc2lvbi9rZXJuZWwtcmlkZ2UtcmVncmVzc2lvbicpO1xuLy9leHBvcnRzLk11bHRpcGxlTGluZWFyUmVncmVzc2lvbiA9IGV4cG9ydHMuTUxSID0gcmVxdWlyZSgnLi9yZWdyZXNzaW9uL211bHRpcGxlLWxpbmVhci1yZWdyZXNzaW9uJyk7XG4vL2V4cG9ydHMuTXVsdGl2YXJpYXRlTGluZWFyUmVncmVzc2lvbiA9IGV4cG9ydHMuTVZMUiA9IHJlcXVpcmUoJy4vcmVncmVzc2lvbi9tdWx0aXZhcmlhdGUtbGluZWFyLXJlZ3Jlc3Npb24nKTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgTWF0cml4ID0gcmVxdWlyZSgnbWwtbWF0cml4Jyk7XG5jb25zdCBLZXJuZWwgPSByZXF1aXJlKCdtbC1rZXJuZWwnKTtcblxuY29uc3QgZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgbGFtYmRhOiAwLjEsXG4gICAga2VybmVsVHlwZTogJ2dhdXNzaWFuJyxcbiAgICBrZXJuZWxPcHRpb25zOiB7fVxufTtcblxuLy8gSW1wbGVtZW50cyB0aGUgS2VybmVsIHJpZGdlIHJlZ3Jlc3Npb24gYWxnb3JpdGhtLlxuLy8gaHR0cDovL3d3dy5pY3MudWNpLmVkdS9+d2VsbGluZy9jbGFzc25vdGVzL3BhcGVyc19jbGFzcy9LZXJuZWwtUmlkZ2UucGRmXG5jbGFzcyBLZXJuZWxSaWRnZVJlZ3Jlc3Npb24ge1xuICAgIGNvbnN0cnVjdG9yKGlucHV0cywgb3V0cHV0cywgb3B0aW9ucykge1xuICAgICAgICBpZiAoaW5wdXRzID09PSB0cnVlKSB7IC8vIHJlbG9hZGluZyBtb2RlbFxuICAgICAgICAgICAgdGhpcy5hbHBoYSA9IG91dHB1dHMuYWxwaGE7XG4gICAgICAgICAgICB0aGlzLmlucHV0cyA9IG91dHB1dHMuaW5wdXRzO1xuICAgICAgICAgICAgdGhpcy5rZXJuZWxUeXBlID0gb3V0cHV0cy5rZXJuZWxUeXBlO1xuICAgICAgICAgICAgdGhpcy5rZXJuZWxPcHRpb25zID0gb3V0cHV0cy5rZXJuZWxPcHRpb25zO1xuICAgICAgICAgICAgdGhpcy5rZXJuZWwgPSBuZXcgS2VybmVsKG91dHB1dHMua2VybmVsVHlwZSwgb3V0cHV0cy5rZXJuZWxPcHRpb25zKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0T3B0aW9ucywgb3B0aW9ucyk7XG5cbiAgICAgICAgICAgIGNvbnN0IGtlcm5lbEZ1bmN0aW9uID0gbmV3IEtlcm5lbChvcHRpb25zLmtlcm5lbFR5cGUsIG9wdGlvbnMua2VybmVsT3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBLID0ga2VybmVsRnVuY3Rpb24uY29tcHV0ZShpbnB1dHMpO1xuICAgICAgICAgICAgY29uc3QgbiA9IGlucHV0cy5sZW5ndGg7XG4gICAgICAgICAgICBLLmFkZChNYXRyaXguZXllKG4sIG4pLm11bChvcHRpb25zLmxhbWJkYSkpO1xuXG4gICAgICAgICAgICB0aGlzLmFscGhhID0gSy5zb2x2ZShvdXRwdXRzKTtcbiAgICAgICAgICAgIHRoaXMuaW5wdXRzID0gaW5wdXRzO1xuICAgICAgICAgICAgdGhpcy5rZXJuZWxUeXBlID0gb3B0aW9ucy5rZXJuZWxUeXBlO1xuICAgICAgICAgICAgdGhpcy5rZXJuZWxPcHRpb25zID0gb3B0aW9ucy5rZXJuZWxPcHRpb25zO1xuICAgICAgICAgICAgdGhpcy5rZXJuZWwgPSBrZXJuZWxGdW5jdGlvbjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByZWRpY3QobmV3SW5wdXRzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmtlcm5lbC5jb21wdXRlKG5ld0lucHV0cywgdGhpcy5pbnB1dHMpLm1tdWwodGhpcy5hbHBoYSk7XG4gICAgfVxuXG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmFtZTogJ2tlcm5lbFJpZGdlUmVncmVzc2lvbicsXG4gICAgICAgICAgICBhbHBoYTogdGhpcy5hbHBoYSxcbiAgICAgICAgICAgIGlucHV0czogdGhpcy5pbnB1dHMsXG4gICAgICAgICAgICBrZXJuZWxUeXBlOiB0aGlzLmtlcm5lbFR5cGUsXG4gICAgICAgICAgICBrZXJuZWxPcHRpb25zOiB0aGlzLmtlcm5lbE9wdGlvbnNcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBzdGF0aWMgbG9hZChqc29uKSB7XG4gICAgICAgIGlmIChqc29uLm5hbWUgIT09ICdrZXJuZWxSaWRnZVJlZ3Jlc3Npb24nKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdub3QgYSBLUlIgbW9kZWwnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEtlcm5lbFJpZGdlUmVncmVzc2lvbih0cnVlLCBqc29uKTtcbiAgICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gS2VybmVsUmlkZ2VSZWdyZXNzaW9uO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgbWF5YmVUb1ByZWNpc2lvbiA9IHJlcXVpcmUoJy4vdXRpbCcpLm1heWJlVG9QcmVjaXNpb247XG5cbmZ1bmN0aW9uIFNpbXBsZUxpbmVhclJlZ3Jlc3Npb24oeCwgeSkge1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBTaW1wbGVMaW5lYXJSZWdyZXNzaW9uKSkge1xuICAgICAgICByZXR1cm4gbmV3IFNpbXBsZUxpbmVhclJlZ3Jlc3Npb24oeCwgeSk7XG4gICAgfVxuXG4gICAgdmFyIG4gPSB4Lmxlbmd0aDtcbiAgICBpZiAobiAhPT0geS5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ2lucHV0IGFuZCBvdXRwdXQgYXJyYXkgaGF2ZSBhIGRpZmZlcmVudCBsZW5ndGgnKTtcbiAgICB9XG5cbiAgICB2YXIgeFN1bSA9IDA7XG4gICAgdmFyIHlTdW0gPSAwO1xuXG4gICAgdmFyIHhTcXVhcmVkID0gMDtcbiAgICB2YXIgeVNxdWFyZWQgPSAwO1xuICAgIHZhciB4WSA9IDA7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgICB4U3VtICs9IHhbaV07XG4gICAgICAgIHlTdW0gKz0geVtpXTtcbiAgICAgICAgeFNxdWFyZWQgKz0geFtpXSAqIHhbaV07XG4gICAgICAgIHlTcXVhcmVkICs9IHlbaV0gKiB5W2ldO1xuICAgICAgICB4WSArPSB4W2ldICogeVtpXTtcbiAgICB9XG5cbiAgICB2YXIgbnVtZXJhdG9yID0gKG4gKiB4WSAtIHhTdW0gKiB5U3VtKTtcblxuICAgIHRoaXMuc2xvcGUgPSBudW1lcmF0b3IgLyAobiAqIHhTcXVhcmVkIC0geFN1bSAqIHhTdW0pO1xuICAgIHRoaXMuaW50ZXJjZXB0ID0gKDEgLyBuKSAqIHlTdW0gLSB0aGlzLnNsb3BlICogKDEgLyBuKSAqIHhTdW07XG4gICAgdGhpcy5jb2VmZmljaWVudHMgPSBbdGhpcy5pbnRlcmNlcHQsIHRoaXMuc2xvcGVdO1xuXG4gICAgdGhpcy5yID0gbnVtZXJhdG9yIC8gTWF0aC5zcXJ0KChuICogeFNxdWFyZWQgLSB4U3VtICogeFN1bSkgKiAobiAqIHlTcXVhcmVkIC0geVN1bSAqIHlTdW0pKTtcbiAgICB0aGlzLmNvZWZmaWNpZW50T2ZEZXRlcm1pbmF0aW9uID0gdGhpcy5yMiA9IHRoaXMuciAqIHRoaXMucjtcbn1cblxuU2ltcGxlTGluZWFyUmVncmVzc2lvbi5wcm90b3R5cGUuY29tcHV0ZSA9IGZ1bmN0aW9uIGNvbXB1dGUoaW5wdXQpIHtcbiAgICByZXR1cm4gdGhpcy5zbG9wZSAqIGlucHV0ICsgdGhpcy5pbnRlcmNlcHQ7XG59O1xuXG5TaW1wbGVMaW5lYXJSZWdyZXNzaW9uLnByb3RvdHlwZS5jb21wdXRlWCA9IGZ1bmN0aW9uIGNvbXB1dGVYKGlucHV0KSB7XG4gICAgcmV0dXJuIChpbnB1dCAtIHRoaXMuaW50ZXJjZXB0KSAvIHRoaXMuc2xvcGU7XG59O1xuXG5TaW1wbGVMaW5lYXJSZWdyZXNzaW9uLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKHByZWNpc2lvbikge1xuICAgIHZhciByZXN1bHQgPSAneSA9ICc7XG4gICAgaWYgKHRoaXMuc2xvcGUpIHtcbiAgICAgICAgdmFyIHhGYWN0b3IgPSBtYXliZVRvUHJlY2lzaW9uKHRoaXMuc2xvcGUsIHByZWNpc2lvbik7XG4gICAgICAgIHJlc3VsdCArPSAoeEZhY3RvciA9PSAxID8gJycgOiB4RmFjdG9yKSArICd4JztcbiAgICAgICAgaWYgKHRoaXMuaW50ZXJjZXB0KSB7XG4gICAgICAgICAgICB2YXIgYWJzSW50ZXJjZXB0ID0gTWF0aC5hYnModGhpcy5pbnRlcmNlcHQpO1xuICAgICAgICAgICAgdmFyIG9wZXJhdG9yID0gYWJzSW50ZXJjZXB0ID09PSB0aGlzLmludGVyY2VwdCA/ICcrJyA6ICctJztcbiAgICAgICAgICAgIHJlc3VsdCArPSAnICcgKyBvcGVyYXRvciArICcgJyArIG1heWJlVG9QcmVjaXNpb24oYWJzSW50ZXJjZXB0LCBwcmVjaXNpb24pO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0ICs9IG1heWJlVG9QcmVjaXNpb24odGhpcy5pbnRlcmNlcHQsIHByZWNpc2lvbik7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNpbXBsZUxpbmVhclJlZ3Jlc3Npb247XG4iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMubWF5YmVUb1ByZWNpc2lvbiA9IGZ1bmN0aW9uIG1heWJlVG9QcmVjaXNpb24odmFsdWUsIGRpZ2l0cykge1xuICAgIGlmIChkaWdpdHMpIHJldHVybiB2YWx1ZS50b1ByZWNpc2lvbihkaWdpdHMpO1xuICAgIGVsc2UgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKCk7XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBuZXdBcnJheVxuXG5mdW5jdGlvbiBuZXdBcnJheSAobiwgdmFsdWUpIHtcbiAgbiA9IG4gfHwgMFxuICB2YXIgYXJyYXkgPSBuZXcgQXJyYXkobilcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICBhcnJheVtpXSA9IHZhbHVlXG4gIH1cbiAgcmV0dXJuIGFycmF5XG59XG4iLCIndXNlIHN0cmljdCc7XG5tb2R1bGUuZXhwb3J0cyA9IE51bWJlci5pc05hTiB8fCBmdW5jdGlvbiAoeCkge1xuXHRyZXR1cm4geCAhPT0geDtcbn07XG4iLCIvLyBUb3AgbGV2ZWwgZmlsZSBpcyBqdXN0IGEgbWl4aW4gb2Ygc3VibW9kdWxlcyAmIGNvbnN0YW50c1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgYXNzaWduICAgID0gcmVxdWlyZSgnLi9saWIvdXRpbHMvY29tbW9uJykuYXNzaWduO1xuXG52YXIgZGVmbGF0ZSAgID0gcmVxdWlyZSgnLi9saWIvZGVmbGF0ZScpO1xudmFyIGluZmxhdGUgICA9IHJlcXVpcmUoJy4vbGliL2luZmxhdGUnKTtcbnZhciBjb25zdGFudHMgPSByZXF1aXJlKCcuL2xpYi96bGliL2NvbnN0YW50cycpO1xuXG52YXIgcGFrbyA9IHt9O1xuXG5hc3NpZ24ocGFrbywgZGVmbGF0ZSwgaW5mbGF0ZSwgY29uc3RhbnRzKTtcblxubW9kdWxlLmV4cG9ydHMgPSBwYWtvO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciB6bGliX2RlZmxhdGUgPSByZXF1aXJlKCcuL3psaWIvZGVmbGF0ZScpO1xudmFyIHV0aWxzICAgICAgICA9IHJlcXVpcmUoJy4vdXRpbHMvY29tbW9uJyk7XG52YXIgc3RyaW5ncyAgICAgID0gcmVxdWlyZSgnLi91dGlscy9zdHJpbmdzJyk7XG52YXIgbXNnICAgICAgICAgID0gcmVxdWlyZSgnLi96bGliL21lc3NhZ2VzJyk7XG52YXIgWlN0cmVhbSAgICAgID0gcmVxdWlyZSgnLi96bGliL3pzdHJlYW0nKTtcblxudmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxuLyogUHVibGljIGNvbnN0YW50cyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cbnZhciBaX05PX0ZMVVNIICAgICAgPSAwO1xudmFyIFpfRklOSVNIICAgICAgICA9IDQ7XG5cbnZhciBaX09LICAgICAgICAgICAgPSAwO1xudmFyIFpfU1RSRUFNX0VORCAgICA9IDE7XG52YXIgWl9TWU5DX0ZMVVNIICAgID0gMjtcblxudmFyIFpfREVGQVVMVF9DT01QUkVTU0lPTiA9IC0xO1xuXG52YXIgWl9ERUZBVUxUX1NUUkFURUdZICAgID0gMDtcblxudmFyIFpfREVGTEFURUQgID0gODtcblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuXG4vKipcbiAqIGNsYXNzIERlZmxhdGVcbiAqXG4gKiBHZW5lcmljIEpTLXN0eWxlIHdyYXBwZXIgZm9yIHpsaWIgY2FsbHMuIElmIHlvdSBkb24ndCBuZWVkXG4gKiBzdHJlYW1pbmcgYmVoYXZpb3VyIC0gdXNlIG1vcmUgc2ltcGxlIGZ1bmN0aW9uczogW1tkZWZsYXRlXV0sXG4gKiBbW2RlZmxhdGVSYXddXSBhbmQgW1tnemlwXV0uXG4gKiovXG5cbi8qIGludGVybmFsXG4gKiBEZWZsYXRlLmNodW5rcyAtPiBBcnJheVxuICpcbiAqIENodW5rcyBvZiBvdXRwdXQgZGF0YSwgaWYgW1tEZWZsYXRlI29uRGF0YV1dIG5vdCBvdmVycmlkZW4uXG4gKiovXG5cbi8qKlxuICogRGVmbGF0ZS5yZXN1bHQgLT4gVWludDhBcnJheXxBcnJheVxuICpcbiAqIENvbXByZXNzZWQgcmVzdWx0LCBnZW5lcmF0ZWQgYnkgZGVmYXVsdCBbW0RlZmxhdGUjb25EYXRhXV1cbiAqIGFuZCBbW0RlZmxhdGUjb25FbmRdXSBoYW5kbGVycy4gRmlsbGVkIGFmdGVyIHlvdSBwdXNoIGxhc3QgY2h1bmtcbiAqIChjYWxsIFtbRGVmbGF0ZSNwdXNoXV0gd2l0aCBgWl9GSU5JU0hgIC8gYHRydWVgIHBhcmFtKSAgb3IgaWYgeW91XG4gKiBwdXNoIGEgY2h1bmsgd2l0aCBleHBsaWNpdCBmbHVzaCAoY2FsbCBbW0RlZmxhdGUjcHVzaF1dIHdpdGhcbiAqIGBaX1NZTkNfRkxVU0hgIHBhcmFtKS5cbiAqKi9cblxuLyoqXG4gKiBEZWZsYXRlLmVyciAtPiBOdW1iZXJcbiAqXG4gKiBFcnJvciBjb2RlIGFmdGVyIGRlZmxhdGUgZmluaXNoZWQuIDAgKFpfT0spIG9uIHN1Y2Nlc3MuXG4gKiBZb3Ugd2lsbCBub3QgbmVlZCBpdCBpbiByZWFsIGxpZmUsIGJlY2F1c2UgZGVmbGF0ZSBlcnJvcnNcbiAqIGFyZSBwb3NzaWJsZSBvbmx5IG9uIHdyb25nIG9wdGlvbnMgb3IgYmFkIGBvbkRhdGFgIC8gYG9uRW5kYFxuICogY3VzdG9tIGhhbmRsZXJzLlxuICoqL1xuXG4vKipcbiAqIERlZmxhdGUubXNnIC0+IFN0cmluZ1xuICpcbiAqIEVycm9yIG1lc3NhZ2UsIGlmIFtbRGVmbGF0ZS5lcnJdXSAhPSAwXG4gKiovXG5cblxuLyoqXG4gKiBuZXcgRGVmbGF0ZShvcHRpb25zKVxuICogLSBvcHRpb25zIChPYmplY3QpOiB6bGliIGRlZmxhdGUgb3B0aW9ucy5cbiAqXG4gKiBDcmVhdGVzIG5ldyBkZWZsYXRvciBpbnN0YW5jZSB3aXRoIHNwZWNpZmllZCBwYXJhbXMuIFRocm93cyBleGNlcHRpb25cbiAqIG9uIGJhZCBwYXJhbXMuIFN1cHBvcnRlZCBvcHRpb25zOlxuICpcbiAqIC0gYGxldmVsYFxuICogLSBgd2luZG93Qml0c2BcbiAqIC0gYG1lbUxldmVsYFxuICogLSBgc3RyYXRlZ3lgXG4gKiAtIGBkaWN0aW9uYXJ5YFxuICpcbiAqIFtodHRwOi8vemxpYi5uZXQvbWFudWFsLmh0bWwjQWR2YW5jZWRdKGh0dHA6Ly96bGliLm5ldC9tYW51YWwuaHRtbCNBZHZhbmNlZClcbiAqIGZvciBtb3JlIGluZm9ybWF0aW9uIG9uIHRoZXNlLlxuICpcbiAqIEFkZGl0aW9uYWwgb3B0aW9ucywgZm9yIGludGVybmFsIG5lZWRzOlxuICpcbiAqIC0gYGNodW5rU2l6ZWAgLSBzaXplIG9mIGdlbmVyYXRlZCBkYXRhIGNodW5rcyAoMTZLIGJ5IGRlZmF1bHQpXG4gKiAtIGByYXdgIChCb29sZWFuKSAtIGRvIHJhdyBkZWZsYXRlXG4gKiAtIGBnemlwYCAoQm9vbGVhbikgLSBjcmVhdGUgZ3ppcCB3cmFwcGVyXG4gKiAtIGB0b2AgKFN0cmluZykgLSBpZiBlcXVhbCB0byAnc3RyaW5nJywgdGhlbiByZXN1bHQgd2lsbCBiZSBcImJpbmFyeSBzdHJpbmdcIlxuICogICAgKGVhY2ggY2hhciBjb2RlIFswLi4yNTVdKVxuICogLSBgaGVhZGVyYCAoT2JqZWN0KSAtIGN1c3RvbSBoZWFkZXIgZm9yIGd6aXBcbiAqICAgLSBgdGV4dGAgKEJvb2xlYW4pIC0gdHJ1ZSBpZiBjb21wcmVzc2VkIGRhdGEgYmVsaWV2ZWQgdG8gYmUgdGV4dFxuICogICAtIGB0aW1lYCAoTnVtYmVyKSAtIG1vZGlmaWNhdGlvbiB0aW1lLCB1bml4IHRpbWVzdGFtcFxuICogICAtIGBvc2AgKE51bWJlcikgLSBvcGVyYXRpb24gc3lzdGVtIGNvZGVcbiAqICAgLSBgZXh0cmFgIChBcnJheSkgLSBhcnJheSBvZiBieXRlcyB3aXRoIGV4dHJhIGRhdGEgKG1heCA2NTUzNilcbiAqICAgLSBgbmFtZWAgKFN0cmluZykgLSBmaWxlIG5hbWUgKGJpbmFyeSBzdHJpbmcpXG4gKiAgIC0gYGNvbW1lbnRgIChTdHJpbmcpIC0gY29tbWVudCAoYmluYXJ5IHN0cmluZylcbiAqICAgLSBgaGNyY2AgKEJvb2xlYW4pIC0gdHJ1ZSBpZiBoZWFkZXIgY3JjIHNob3VsZCBiZSBhZGRlZFxuICpcbiAqICMjIyMjIEV4YW1wbGU6XG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogdmFyIHBha28gPSByZXF1aXJlKCdwYWtvJylcbiAqICAgLCBjaHVuazEgPSBVaW50OEFycmF5KFsxLDIsMyw0LDUsNiw3LDgsOV0pXG4gKiAgICwgY2h1bmsyID0gVWludDhBcnJheShbMTAsMTEsMTIsMTMsMTQsMTUsMTYsMTcsMTgsMTldKTtcbiAqXG4gKiB2YXIgZGVmbGF0ZSA9IG5ldyBwYWtvLkRlZmxhdGUoeyBsZXZlbDogM30pO1xuICpcbiAqIGRlZmxhdGUucHVzaChjaHVuazEsIGZhbHNlKTtcbiAqIGRlZmxhdGUucHVzaChjaHVuazIsIHRydWUpOyAgLy8gdHJ1ZSAtPiBsYXN0IGNodW5rXG4gKlxuICogaWYgKGRlZmxhdGUuZXJyKSB7IHRocm93IG5ldyBFcnJvcihkZWZsYXRlLmVycik7IH1cbiAqXG4gKiBjb25zb2xlLmxvZyhkZWZsYXRlLnJlc3VsdCk7XG4gKiBgYGBcbiAqKi9cbmZ1bmN0aW9uIERlZmxhdGUob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgRGVmbGF0ZSkpIHJldHVybiBuZXcgRGVmbGF0ZShvcHRpb25zKTtcblxuICB0aGlzLm9wdGlvbnMgPSB1dGlscy5hc3NpZ24oe1xuICAgIGxldmVsOiBaX0RFRkFVTFRfQ09NUFJFU1NJT04sXG4gICAgbWV0aG9kOiBaX0RFRkxBVEVELFxuICAgIGNodW5rU2l6ZTogMTYzODQsXG4gICAgd2luZG93Qml0czogMTUsXG4gICAgbWVtTGV2ZWw6IDgsXG4gICAgc3RyYXRlZ3k6IFpfREVGQVVMVF9TVFJBVEVHWSxcbiAgICB0bzogJydcbiAgfSwgb3B0aW9ucyB8fCB7fSk7XG5cbiAgdmFyIG9wdCA9IHRoaXMub3B0aW9ucztcblxuICBpZiAob3B0LnJhdyAmJiAob3B0LndpbmRvd0JpdHMgPiAwKSkge1xuICAgIG9wdC53aW5kb3dCaXRzID0gLW9wdC53aW5kb3dCaXRzO1xuICB9XG5cbiAgZWxzZSBpZiAob3B0Lmd6aXAgJiYgKG9wdC53aW5kb3dCaXRzID4gMCkgJiYgKG9wdC53aW5kb3dCaXRzIDwgMTYpKSB7XG4gICAgb3B0LndpbmRvd0JpdHMgKz0gMTY7XG4gIH1cblxuICB0aGlzLmVyciAgICA9IDA7ICAgICAgLy8gZXJyb3IgY29kZSwgaWYgaGFwcGVucyAoMCA9IFpfT0spXG4gIHRoaXMubXNnICAgID0gJyc7ICAgICAvLyBlcnJvciBtZXNzYWdlXG4gIHRoaXMuZW5kZWQgID0gZmFsc2U7ICAvLyB1c2VkIHRvIGF2b2lkIG11bHRpcGxlIG9uRW5kKCkgY2FsbHNcbiAgdGhpcy5jaHVua3MgPSBbXTsgICAgIC8vIGNodW5rcyBvZiBjb21wcmVzc2VkIGRhdGFcblxuICB0aGlzLnN0cm0gPSBuZXcgWlN0cmVhbSgpO1xuICB0aGlzLnN0cm0uYXZhaWxfb3V0ID0gMDtcblxuICB2YXIgc3RhdHVzID0gemxpYl9kZWZsYXRlLmRlZmxhdGVJbml0MihcbiAgICB0aGlzLnN0cm0sXG4gICAgb3B0LmxldmVsLFxuICAgIG9wdC5tZXRob2QsXG4gICAgb3B0LndpbmRvd0JpdHMsXG4gICAgb3B0Lm1lbUxldmVsLFxuICAgIG9wdC5zdHJhdGVneVxuICApO1xuXG4gIGlmIChzdGF0dXMgIT09IFpfT0spIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IobXNnW3N0YXR1c10pO1xuICB9XG5cbiAgaWYgKG9wdC5oZWFkZXIpIHtcbiAgICB6bGliX2RlZmxhdGUuZGVmbGF0ZVNldEhlYWRlcih0aGlzLnN0cm0sIG9wdC5oZWFkZXIpO1xuICB9XG5cbiAgaWYgKG9wdC5kaWN0aW9uYXJ5KSB7XG4gICAgdmFyIGRpY3Q7XG4gICAgLy8gQ29udmVydCBkYXRhIGlmIG5lZWRlZFxuICAgIGlmICh0eXBlb2Ygb3B0LmRpY3Rpb25hcnkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyBJZiB3ZSBuZWVkIHRvIGNvbXByZXNzIHRleHQsIGNoYW5nZSBlbmNvZGluZyB0byB1dGY4LlxuICAgICAgZGljdCA9IHN0cmluZ3Muc3RyaW5nMmJ1ZihvcHQuZGljdGlvbmFyeSk7XG4gICAgfSBlbHNlIGlmICh0b1N0cmluZy5jYWxsKG9wdC5kaWN0aW9uYXJ5KSA9PT0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJykge1xuICAgICAgZGljdCA9IG5ldyBVaW50OEFycmF5KG9wdC5kaWN0aW9uYXJ5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGljdCA9IG9wdC5kaWN0aW9uYXJ5O1xuICAgIH1cblxuICAgIHN0YXR1cyA9IHpsaWJfZGVmbGF0ZS5kZWZsYXRlU2V0RGljdGlvbmFyeSh0aGlzLnN0cm0sIGRpY3QpO1xuXG4gICAgaWYgKHN0YXR1cyAhPT0gWl9PSykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZ1tzdGF0dXNdKTtcbiAgICB9XG5cbiAgICB0aGlzLl9kaWN0X3NldCA9IHRydWU7XG4gIH1cbn1cblxuLyoqXG4gKiBEZWZsYXRlI3B1c2goZGF0YVssIG1vZGVdKSAtPiBCb29sZWFuXG4gKiAtIGRhdGEgKFVpbnQ4QXJyYXl8QXJyYXl8QXJyYXlCdWZmZXJ8U3RyaW5nKTogaW5wdXQgZGF0YS4gU3RyaW5ncyB3aWxsIGJlXG4gKiAgIGNvbnZlcnRlZCB0byB1dGY4IGJ5dGUgc2VxdWVuY2UuXG4gKiAtIG1vZGUgKE51bWJlcnxCb29sZWFuKTogMC4uNiBmb3IgY29ycmVzcG9uZGluZyBaX05PX0ZMVVNILi5aX1RSRUUgbW9kZXMuXG4gKiAgIFNlZSBjb25zdGFudHMuIFNraXBwZWQgb3IgYGZhbHNlYCBtZWFucyBaX05PX0ZMVVNILCBgdHJ1ZWAgbWVhbnNoIFpfRklOSVNILlxuICpcbiAqIFNlbmRzIGlucHV0IGRhdGEgdG8gZGVmbGF0ZSBwaXBlLCBnZW5lcmF0aW5nIFtbRGVmbGF0ZSNvbkRhdGFdXSBjYWxscyB3aXRoXG4gKiBuZXcgY29tcHJlc3NlZCBjaHVua3MuIFJldHVybnMgYHRydWVgIG9uIHN1Y2Nlc3MuIFRoZSBsYXN0IGRhdGEgYmxvY2sgbXVzdCBoYXZlXG4gKiBtb2RlIFpfRklOSVNIIChvciBgdHJ1ZWApLiBUaGF0IHdpbGwgZmx1c2ggaW50ZXJuYWwgcGVuZGluZyBidWZmZXJzIGFuZCBjYWxsXG4gKiBbW0RlZmxhdGUjb25FbmRdXS4gRm9yIGludGVyaW0gZXhwbGljaXQgZmx1c2hlcyAod2l0aG91dCBlbmRpbmcgdGhlIHN0cmVhbSkgeW91XG4gKiBjYW4gdXNlIG1vZGUgWl9TWU5DX0ZMVVNILCBrZWVwaW5nIHRoZSBjb21wcmVzc2lvbiBjb250ZXh0LlxuICpcbiAqIE9uIGZhaWwgY2FsbCBbW0RlZmxhdGUjb25FbmRdXSB3aXRoIGVycm9yIGNvZGUgYW5kIHJldHVybiBmYWxzZS5cbiAqXG4gKiBXZSBzdHJvbmdseSByZWNvbW1lbmQgdG8gdXNlIGBVaW50OEFycmF5YCBvbiBpbnB1dCBmb3IgYmVzdCBzcGVlZCAob3V0cHV0XG4gKiBhcnJheSBmb3JtYXQgaXMgZGV0ZWN0ZWQgYXV0b21hdGljYWxseSkuIEFsc28sIGRvbid0IHNraXAgbGFzdCBwYXJhbSBhbmQgYWx3YXlzXG4gKiB1c2UgdGhlIHNhbWUgdHlwZSBpbiB5b3VyIGNvZGUgKGJvb2xlYW4gb3IgbnVtYmVyKS4gVGhhdCB3aWxsIGltcHJvdmUgSlMgc3BlZWQuXG4gKlxuICogRm9yIHJlZ3VsYXIgYEFycmF5YC1zIG1ha2Ugc3VyZSBhbGwgZWxlbWVudHMgYXJlIFswLi4yNTVdLlxuICpcbiAqICMjIyMjIEV4YW1wbGVcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiBwdXNoKGNodW5rLCBmYWxzZSk7IC8vIHB1c2ggb25lIG9mIGRhdGEgY2h1bmtzXG4gKiAuLi5cbiAqIHB1c2goY2h1bmssIHRydWUpOyAgLy8gcHVzaCBsYXN0IGNodW5rXG4gKiBgYGBcbiAqKi9cbkRlZmxhdGUucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoZGF0YSwgbW9kZSkge1xuICB2YXIgc3RybSA9IHRoaXMuc3RybTtcbiAgdmFyIGNodW5rU2l6ZSA9IHRoaXMub3B0aW9ucy5jaHVua1NpemU7XG4gIHZhciBzdGF0dXMsIF9tb2RlO1xuXG4gIGlmICh0aGlzLmVuZGVkKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIF9tb2RlID0gKG1vZGUgPT09IH5+bW9kZSkgPyBtb2RlIDogKChtb2RlID09PSB0cnVlKSA/IFpfRklOSVNIIDogWl9OT19GTFVTSCk7XG5cbiAgLy8gQ29udmVydCBkYXRhIGlmIG5lZWRlZFxuICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgLy8gSWYgd2UgbmVlZCB0byBjb21wcmVzcyB0ZXh0LCBjaGFuZ2UgZW5jb2RpbmcgdG8gdXRmOC5cbiAgICBzdHJtLmlucHV0ID0gc3RyaW5ncy5zdHJpbmcyYnVmKGRhdGEpO1xuICB9IGVsc2UgaWYgKHRvU3RyaW5nLmNhbGwoZGF0YSkgPT09ICdbb2JqZWN0IEFycmF5QnVmZmVyXScpIHtcbiAgICBzdHJtLmlucHV0ID0gbmV3IFVpbnQ4QXJyYXkoZGF0YSk7XG4gIH0gZWxzZSB7XG4gICAgc3RybS5pbnB1dCA9IGRhdGE7XG4gIH1cblxuICBzdHJtLm5leHRfaW4gPSAwO1xuICBzdHJtLmF2YWlsX2luID0gc3RybS5pbnB1dC5sZW5ndGg7XG5cbiAgZG8ge1xuICAgIGlmIChzdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgc3RybS5vdXRwdXQgPSBuZXcgdXRpbHMuQnVmOChjaHVua1NpemUpO1xuICAgICAgc3RybS5uZXh0X291dCA9IDA7XG4gICAgICBzdHJtLmF2YWlsX291dCA9IGNodW5rU2l6ZTtcbiAgICB9XG4gICAgc3RhdHVzID0gemxpYl9kZWZsYXRlLmRlZmxhdGUoc3RybSwgX21vZGUpOyAgICAvKiBubyBiYWQgcmV0dXJuIHZhbHVlICovXG5cbiAgICBpZiAoc3RhdHVzICE9PSBaX1NUUkVBTV9FTkQgJiYgc3RhdHVzICE9PSBaX09LKSB7XG4gICAgICB0aGlzLm9uRW5kKHN0YXR1cyk7XG4gICAgICB0aGlzLmVuZGVkID0gdHJ1ZTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHN0cm0uYXZhaWxfb3V0ID09PSAwIHx8IChzdHJtLmF2YWlsX2luID09PSAwICYmIChfbW9kZSA9PT0gWl9GSU5JU0ggfHwgX21vZGUgPT09IFpfU1lOQ19GTFVTSCkpKSB7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLnRvID09PSAnc3RyaW5nJykge1xuICAgICAgICB0aGlzLm9uRGF0YShzdHJpbmdzLmJ1ZjJiaW5zdHJpbmcodXRpbHMuc2hyaW5rQnVmKHN0cm0ub3V0cHV0LCBzdHJtLm5leHRfb3V0KSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5vbkRhdGEodXRpbHMuc2hyaW5rQnVmKHN0cm0ub3V0cHV0LCBzdHJtLm5leHRfb3V0KSk7XG4gICAgICB9XG4gICAgfVxuICB9IHdoaWxlICgoc3RybS5hdmFpbF9pbiA+IDAgfHwgc3RybS5hdmFpbF9vdXQgPT09IDApICYmIHN0YXR1cyAhPT0gWl9TVFJFQU1fRU5EKTtcblxuICAvLyBGaW5hbGl6ZSBvbiB0aGUgbGFzdCBjaHVuay5cbiAgaWYgKF9tb2RlID09PSBaX0ZJTklTSCkge1xuICAgIHN0YXR1cyA9IHpsaWJfZGVmbGF0ZS5kZWZsYXRlRW5kKHRoaXMuc3RybSk7XG4gICAgdGhpcy5vbkVuZChzdGF0dXMpO1xuICAgIHRoaXMuZW5kZWQgPSB0cnVlO1xuICAgIHJldHVybiBzdGF0dXMgPT09IFpfT0s7XG4gIH1cblxuICAvLyBjYWxsYmFjayBpbnRlcmltIHJlc3VsdHMgaWYgWl9TWU5DX0ZMVVNILlxuICBpZiAoX21vZGUgPT09IFpfU1lOQ19GTFVTSCkge1xuICAgIHRoaXMub25FbmQoWl9PSyk7XG4gICAgc3RybS5hdmFpbF9vdXQgPSAwO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5cbi8qKlxuICogRGVmbGF0ZSNvbkRhdGEoY2h1bmspIC0+IFZvaWRcbiAqIC0gY2h1bmsgKFVpbnQ4QXJyYXl8QXJyYXl8U3RyaW5nKTogb3VwdXQgZGF0YS4gVHlwZSBvZiBhcnJheSBkZXBlbmRzXG4gKiAgIG9uIGpzIGVuZ2luZSBzdXBwb3J0LiBXaGVuIHN0cmluZyBvdXRwdXQgcmVxdWVzdGVkLCBlYWNoIGNodW5rXG4gKiAgIHdpbGwgYmUgc3RyaW5nLlxuICpcbiAqIEJ5IGRlZmF1bHQsIHN0b3JlcyBkYXRhIGJsb2NrcyBpbiBgY2h1bmtzW11gIHByb3BlcnR5IGFuZCBnbHVlXG4gKiB0aG9zZSBpbiBgb25FbmRgLiBPdmVycmlkZSB0aGlzIGhhbmRsZXIsIGlmIHlvdSBuZWVkIGFub3RoZXIgYmVoYXZpb3VyLlxuICoqL1xuRGVmbGF0ZS5wcm90b3R5cGUub25EYXRhID0gZnVuY3Rpb24gKGNodW5rKSB7XG4gIHRoaXMuY2h1bmtzLnB1c2goY2h1bmspO1xufTtcblxuXG4vKipcbiAqIERlZmxhdGUjb25FbmQoc3RhdHVzKSAtPiBWb2lkXG4gKiAtIHN0YXR1cyAoTnVtYmVyKTogZGVmbGF0ZSBzdGF0dXMuIDAgKFpfT0spIG9uIHN1Y2Nlc3MsXG4gKiAgIG90aGVyIGlmIG5vdC5cbiAqXG4gKiBDYWxsZWQgb25jZSBhZnRlciB5b3UgdGVsbCBkZWZsYXRlIHRoYXQgdGhlIGlucHV0IHN0cmVhbSBpc1xuICogY29tcGxldGUgKFpfRklOSVNIKSBvciBzaG91bGQgYmUgZmx1c2hlZCAoWl9TWU5DX0ZMVVNIKVxuICogb3IgaWYgYW4gZXJyb3IgaGFwcGVuZWQuIEJ5IGRlZmF1bHQgLSBqb2luIGNvbGxlY3RlZCBjaHVua3MsXG4gKiBmcmVlIG1lbW9yeSBhbmQgZmlsbCBgcmVzdWx0c2AgLyBgZXJyYCBwcm9wZXJ0aWVzLlxuICoqL1xuRGVmbGF0ZS5wcm90b3R5cGUub25FbmQgPSBmdW5jdGlvbiAoc3RhdHVzKSB7XG4gIC8vIE9uIHN1Y2Nlc3MgLSBqb2luXG4gIGlmIChzdGF0dXMgPT09IFpfT0spIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLnRvID09PSAnc3RyaW5nJykge1xuICAgICAgdGhpcy5yZXN1bHQgPSB0aGlzLmNodW5rcy5qb2luKCcnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5yZXN1bHQgPSB1dGlscy5mbGF0dGVuQ2h1bmtzKHRoaXMuY2h1bmtzKTtcbiAgICB9XG4gIH1cbiAgdGhpcy5jaHVua3MgPSBbXTtcbiAgdGhpcy5lcnIgPSBzdGF0dXM7XG4gIHRoaXMubXNnID0gdGhpcy5zdHJtLm1zZztcbn07XG5cblxuLyoqXG4gKiBkZWZsYXRlKGRhdGFbLCBvcHRpb25zXSkgLT4gVWludDhBcnJheXxBcnJheXxTdHJpbmdcbiAqIC0gZGF0YSAoVWludDhBcnJheXxBcnJheXxTdHJpbmcpOiBpbnB1dCBkYXRhIHRvIGNvbXByZXNzLlxuICogLSBvcHRpb25zIChPYmplY3QpOiB6bGliIGRlZmxhdGUgb3B0aW9ucy5cbiAqXG4gKiBDb21wcmVzcyBgZGF0YWAgd2l0aCBkZWZsYXRlIGFsZ29yaXRobSBhbmQgYG9wdGlvbnNgLlxuICpcbiAqIFN1cHBvcnRlZCBvcHRpb25zIGFyZTpcbiAqXG4gKiAtIGxldmVsXG4gKiAtIHdpbmRvd0JpdHNcbiAqIC0gbWVtTGV2ZWxcbiAqIC0gc3RyYXRlZ3lcbiAqIC0gZGljdGlvbmFyeVxuICpcbiAqIFtodHRwOi8vemxpYi5uZXQvbWFudWFsLmh0bWwjQWR2YW5jZWRdKGh0dHA6Ly96bGliLm5ldC9tYW51YWwuaHRtbCNBZHZhbmNlZClcbiAqIGZvciBtb3JlIGluZm9ybWF0aW9uIG9uIHRoZXNlLlxuICpcbiAqIFN1Z2FyIChvcHRpb25zKTpcbiAqXG4gKiAtIGByYXdgIChCb29sZWFuKSAtIHNheSB0aGF0IHdlIHdvcmsgd2l0aCByYXcgc3RyZWFtLCBpZiB5b3UgZG9uJ3Qgd2lzaCB0byBzcGVjaWZ5XG4gKiAgIG5lZ2F0aXZlIHdpbmRvd0JpdHMgaW1wbGljaXRseS5cbiAqIC0gYHRvYCAoU3RyaW5nKSAtIGlmIGVxdWFsIHRvICdzdHJpbmcnLCB0aGVuIHJlc3VsdCB3aWxsIGJlIFwiYmluYXJ5IHN0cmluZ1wiXG4gKiAgICAoZWFjaCBjaGFyIGNvZGUgWzAuLjI1NV0pXG4gKlxuICogIyMjIyMgRXhhbXBsZTpcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiB2YXIgcGFrbyA9IHJlcXVpcmUoJ3Bha28nKVxuICogICAsIGRhdGEgPSBVaW50OEFycmF5KFsxLDIsMyw0LDUsNiw3LDgsOV0pO1xuICpcbiAqIGNvbnNvbGUubG9nKHBha28uZGVmbGF0ZShkYXRhKSk7XG4gKiBgYGBcbiAqKi9cbmZ1bmN0aW9uIGRlZmxhdGUoaW5wdXQsIG9wdGlvbnMpIHtcbiAgdmFyIGRlZmxhdG9yID0gbmV3IERlZmxhdGUob3B0aW9ucyk7XG5cbiAgZGVmbGF0b3IucHVzaChpbnB1dCwgdHJ1ZSk7XG5cbiAgLy8gVGhhdCB3aWxsIG5ldmVyIGhhcHBlbnMsIGlmIHlvdSBkb24ndCBjaGVhdCB3aXRoIG9wdGlvbnMgOilcbiAgaWYgKGRlZmxhdG9yLmVycikgeyB0aHJvdyBkZWZsYXRvci5tc2c7IH1cblxuICByZXR1cm4gZGVmbGF0b3IucmVzdWx0O1xufVxuXG5cbi8qKlxuICogZGVmbGF0ZVJhdyhkYXRhWywgb3B0aW9uc10pIC0+IFVpbnQ4QXJyYXl8QXJyYXl8U3RyaW5nXG4gKiAtIGRhdGEgKFVpbnQ4QXJyYXl8QXJyYXl8U3RyaW5nKTogaW5wdXQgZGF0YSB0byBjb21wcmVzcy5cbiAqIC0gb3B0aW9ucyAoT2JqZWN0KTogemxpYiBkZWZsYXRlIG9wdGlvbnMuXG4gKlxuICogVGhlIHNhbWUgYXMgW1tkZWZsYXRlXV0sIGJ1dCBjcmVhdGVzIHJhdyBkYXRhLCB3aXRob3V0IHdyYXBwZXJcbiAqIChoZWFkZXIgYW5kIGFkbGVyMzIgY3JjKS5cbiAqKi9cbmZ1bmN0aW9uIGRlZmxhdGVSYXcoaW5wdXQsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIG9wdGlvbnMucmF3ID0gdHJ1ZTtcbiAgcmV0dXJuIGRlZmxhdGUoaW5wdXQsIG9wdGlvbnMpO1xufVxuXG5cbi8qKlxuICogZ3ppcChkYXRhWywgb3B0aW9uc10pIC0+IFVpbnQ4QXJyYXl8QXJyYXl8U3RyaW5nXG4gKiAtIGRhdGEgKFVpbnQ4QXJyYXl8QXJyYXl8U3RyaW5nKTogaW5wdXQgZGF0YSB0byBjb21wcmVzcy5cbiAqIC0gb3B0aW9ucyAoT2JqZWN0KTogemxpYiBkZWZsYXRlIG9wdGlvbnMuXG4gKlxuICogVGhlIHNhbWUgYXMgW1tkZWZsYXRlXV0sIGJ1dCBjcmVhdGUgZ3ppcCB3cmFwcGVyIGluc3RlYWQgb2ZcbiAqIGRlZmxhdGUgb25lLlxuICoqL1xuZnVuY3Rpb24gZ3ppcChpbnB1dCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgb3B0aW9ucy5nemlwID0gdHJ1ZTtcbiAgcmV0dXJuIGRlZmxhdGUoaW5wdXQsIG9wdGlvbnMpO1xufVxuXG5cbmV4cG9ydHMuRGVmbGF0ZSA9IERlZmxhdGU7XG5leHBvcnRzLmRlZmxhdGUgPSBkZWZsYXRlO1xuZXhwb3J0cy5kZWZsYXRlUmF3ID0gZGVmbGF0ZVJhdztcbmV4cG9ydHMuZ3ppcCA9IGd6aXA7XG4iLCIndXNlIHN0cmljdCc7XG5cblxudmFyIHpsaWJfaW5mbGF0ZSA9IHJlcXVpcmUoJy4vemxpYi9pbmZsYXRlJyk7XG52YXIgdXRpbHMgICAgICAgID0gcmVxdWlyZSgnLi91dGlscy9jb21tb24nKTtcbnZhciBzdHJpbmdzICAgICAgPSByZXF1aXJlKCcuL3V0aWxzL3N0cmluZ3MnKTtcbnZhciBjICAgICAgICAgICAgPSByZXF1aXJlKCcuL3psaWIvY29uc3RhbnRzJyk7XG52YXIgbXNnICAgICAgICAgID0gcmVxdWlyZSgnLi96bGliL21lc3NhZ2VzJyk7XG52YXIgWlN0cmVhbSAgICAgID0gcmVxdWlyZSgnLi96bGliL3pzdHJlYW0nKTtcbnZhciBHWmhlYWRlciAgICAgPSByZXF1aXJlKCcuL3psaWIvZ3poZWFkZXInKTtcblxudmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxuLyoqXG4gKiBjbGFzcyBJbmZsYXRlXG4gKlxuICogR2VuZXJpYyBKUy1zdHlsZSB3cmFwcGVyIGZvciB6bGliIGNhbGxzLiBJZiB5b3UgZG9uJ3QgbmVlZFxuICogc3RyZWFtaW5nIGJlaGF2aW91ciAtIHVzZSBtb3JlIHNpbXBsZSBmdW5jdGlvbnM6IFtbaW5mbGF0ZV1dXG4gKiBhbmQgW1tpbmZsYXRlUmF3XV0uXG4gKiovXG5cbi8qIGludGVybmFsXG4gKiBpbmZsYXRlLmNodW5rcyAtPiBBcnJheVxuICpcbiAqIENodW5rcyBvZiBvdXRwdXQgZGF0YSwgaWYgW1tJbmZsYXRlI29uRGF0YV1dIG5vdCBvdmVycmlkZW4uXG4gKiovXG5cbi8qKlxuICogSW5mbGF0ZS5yZXN1bHQgLT4gVWludDhBcnJheXxBcnJheXxTdHJpbmdcbiAqXG4gKiBVbmNvbXByZXNzZWQgcmVzdWx0LCBnZW5lcmF0ZWQgYnkgZGVmYXVsdCBbW0luZmxhdGUjb25EYXRhXV1cbiAqIGFuZCBbW0luZmxhdGUjb25FbmRdXSBoYW5kbGVycy4gRmlsbGVkIGFmdGVyIHlvdSBwdXNoIGxhc3QgY2h1bmtcbiAqIChjYWxsIFtbSW5mbGF0ZSNwdXNoXV0gd2l0aCBgWl9GSU5JU0hgIC8gYHRydWVgIHBhcmFtKSBvciBpZiB5b3VcbiAqIHB1c2ggYSBjaHVuayB3aXRoIGV4cGxpY2l0IGZsdXNoIChjYWxsIFtbSW5mbGF0ZSNwdXNoXV0gd2l0aFxuICogYFpfU1lOQ19GTFVTSGAgcGFyYW0pLlxuICoqL1xuXG4vKipcbiAqIEluZmxhdGUuZXJyIC0+IE51bWJlclxuICpcbiAqIEVycm9yIGNvZGUgYWZ0ZXIgaW5mbGF0ZSBmaW5pc2hlZC4gMCAoWl9PSykgb24gc3VjY2Vzcy5cbiAqIFNob3VsZCBiZSBjaGVja2VkIGlmIGJyb2tlbiBkYXRhIHBvc3NpYmxlLlxuICoqL1xuXG4vKipcbiAqIEluZmxhdGUubXNnIC0+IFN0cmluZ1xuICpcbiAqIEVycm9yIG1lc3NhZ2UsIGlmIFtbSW5mbGF0ZS5lcnJdXSAhPSAwXG4gKiovXG5cblxuLyoqXG4gKiBuZXcgSW5mbGF0ZShvcHRpb25zKVxuICogLSBvcHRpb25zIChPYmplY3QpOiB6bGliIGluZmxhdGUgb3B0aW9ucy5cbiAqXG4gKiBDcmVhdGVzIG5ldyBpbmZsYXRvciBpbnN0YW5jZSB3aXRoIHNwZWNpZmllZCBwYXJhbXMuIFRocm93cyBleGNlcHRpb25cbiAqIG9uIGJhZCBwYXJhbXMuIFN1cHBvcnRlZCBvcHRpb25zOlxuICpcbiAqIC0gYHdpbmRvd0JpdHNgXG4gKiAtIGBkaWN0aW9uYXJ5YFxuICpcbiAqIFtodHRwOi8vemxpYi5uZXQvbWFudWFsLmh0bWwjQWR2YW5jZWRdKGh0dHA6Ly96bGliLm5ldC9tYW51YWwuaHRtbCNBZHZhbmNlZClcbiAqIGZvciBtb3JlIGluZm9ybWF0aW9uIG9uIHRoZXNlLlxuICpcbiAqIEFkZGl0aW9uYWwgb3B0aW9ucywgZm9yIGludGVybmFsIG5lZWRzOlxuICpcbiAqIC0gYGNodW5rU2l6ZWAgLSBzaXplIG9mIGdlbmVyYXRlZCBkYXRhIGNodW5rcyAoMTZLIGJ5IGRlZmF1bHQpXG4gKiAtIGByYXdgIChCb29sZWFuKSAtIGRvIHJhdyBpbmZsYXRlXG4gKiAtIGB0b2AgKFN0cmluZykgLSBpZiBlcXVhbCB0byAnc3RyaW5nJywgdGhlbiByZXN1bHQgd2lsbCBiZSBjb252ZXJ0ZWRcbiAqICAgZnJvbSB1dGY4IHRvIHV0ZjE2IChqYXZhc2NyaXB0KSBzdHJpbmcuIFdoZW4gc3RyaW5nIG91dHB1dCByZXF1ZXN0ZWQsXG4gKiAgIGNodW5rIGxlbmd0aCBjYW4gZGlmZmVyIGZyb20gYGNodW5rU2l6ZWAsIGRlcGVuZGluZyBvbiBjb250ZW50LlxuICpcbiAqIEJ5IGRlZmF1bHQsIHdoZW4gbm8gb3B0aW9ucyBzZXQsIGF1dG9kZXRlY3QgZGVmbGF0ZS9nemlwIGRhdGEgZm9ybWF0IHZpYVxuICogd3JhcHBlciBoZWFkZXIuXG4gKlxuICogIyMjIyMgRXhhbXBsZTpcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiB2YXIgcGFrbyA9IHJlcXVpcmUoJ3Bha28nKVxuICogICAsIGNodW5rMSA9IFVpbnQ4QXJyYXkoWzEsMiwzLDQsNSw2LDcsOCw5XSlcbiAqICAgLCBjaHVuazIgPSBVaW50OEFycmF5KFsxMCwxMSwxMiwxMywxNCwxNSwxNiwxNywxOCwxOV0pO1xuICpcbiAqIHZhciBpbmZsYXRlID0gbmV3IHBha28uSW5mbGF0ZSh7IGxldmVsOiAzfSk7XG4gKlxuICogaW5mbGF0ZS5wdXNoKGNodW5rMSwgZmFsc2UpO1xuICogaW5mbGF0ZS5wdXNoKGNodW5rMiwgdHJ1ZSk7ICAvLyB0cnVlIC0+IGxhc3QgY2h1bmtcbiAqXG4gKiBpZiAoaW5mbGF0ZS5lcnIpIHsgdGhyb3cgbmV3IEVycm9yKGluZmxhdGUuZXJyKTsgfVxuICpcbiAqIGNvbnNvbGUubG9nKGluZmxhdGUucmVzdWx0KTtcbiAqIGBgYFxuICoqL1xuZnVuY3Rpb24gSW5mbGF0ZShvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBJbmZsYXRlKSkgcmV0dXJuIG5ldyBJbmZsYXRlKG9wdGlvbnMpO1xuXG4gIHRoaXMub3B0aW9ucyA9IHV0aWxzLmFzc2lnbih7XG4gICAgY2h1bmtTaXplOiAxNjM4NCxcbiAgICB3aW5kb3dCaXRzOiAwLFxuICAgIHRvOiAnJ1xuICB9LCBvcHRpb25zIHx8IHt9KTtcblxuICB2YXIgb3B0ID0gdGhpcy5vcHRpb25zO1xuXG4gIC8vIEZvcmNlIHdpbmRvdyBzaXplIGZvciBgcmF3YCBkYXRhLCBpZiBub3Qgc2V0IGRpcmVjdGx5LFxuICAvLyBiZWNhdXNlIHdlIGhhdmUgbm8gaGVhZGVyIGZvciBhdXRvZGV0ZWN0LlxuICBpZiAob3B0LnJhdyAmJiAob3B0LndpbmRvd0JpdHMgPj0gMCkgJiYgKG9wdC53aW5kb3dCaXRzIDwgMTYpKSB7XG4gICAgb3B0LndpbmRvd0JpdHMgPSAtb3B0LndpbmRvd0JpdHM7XG4gICAgaWYgKG9wdC53aW5kb3dCaXRzID09PSAwKSB7IG9wdC53aW5kb3dCaXRzID0gLTE1OyB9XG4gIH1cblxuICAvLyBJZiBgd2luZG93Qml0c2Agbm90IGRlZmluZWQgKGFuZCBtb2RlIG5vdCByYXcpIC0gc2V0IGF1dG9kZXRlY3QgZmxhZyBmb3IgZ3ppcC9kZWZsYXRlXG4gIGlmICgob3B0LndpbmRvd0JpdHMgPj0gMCkgJiYgKG9wdC53aW5kb3dCaXRzIDwgMTYpICYmXG4gICAgICAhKG9wdGlvbnMgJiYgb3B0aW9ucy53aW5kb3dCaXRzKSkge1xuICAgIG9wdC53aW5kb3dCaXRzICs9IDMyO1xuICB9XG5cbiAgLy8gR3ppcCBoZWFkZXIgaGFzIG5vIGluZm8gYWJvdXQgd2luZG93cyBzaXplLCB3ZSBjYW4gZG8gYXV0b2RldGVjdCBvbmx5XG4gIC8vIGZvciBkZWZsYXRlLiBTbywgaWYgd2luZG93IHNpemUgbm90IHNldCwgZm9yY2UgaXQgdG8gbWF4IHdoZW4gZ3ppcCBwb3NzaWJsZVxuICBpZiAoKG9wdC53aW5kb3dCaXRzID4gMTUpICYmIChvcHQud2luZG93Qml0cyA8IDQ4KSkge1xuICAgIC8vIGJpdCAzICgxNikgLT4gZ3ppcHBlZCBkYXRhXG4gICAgLy8gYml0IDQgKDMyKSAtPiBhdXRvZGV0ZWN0IGd6aXAvZGVmbGF0ZVxuICAgIGlmICgob3B0LndpbmRvd0JpdHMgJiAxNSkgPT09IDApIHtcbiAgICAgIG9wdC53aW5kb3dCaXRzIHw9IDE1O1xuICAgIH1cbiAgfVxuXG4gIHRoaXMuZXJyICAgID0gMDsgICAgICAvLyBlcnJvciBjb2RlLCBpZiBoYXBwZW5zICgwID0gWl9PSylcbiAgdGhpcy5tc2cgICAgPSAnJzsgICAgIC8vIGVycm9yIG1lc3NhZ2VcbiAgdGhpcy5lbmRlZCAgPSBmYWxzZTsgIC8vIHVzZWQgdG8gYXZvaWQgbXVsdGlwbGUgb25FbmQoKSBjYWxsc1xuICB0aGlzLmNodW5rcyA9IFtdOyAgICAgLy8gY2h1bmtzIG9mIGNvbXByZXNzZWQgZGF0YVxuXG4gIHRoaXMuc3RybSAgID0gbmV3IFpTdHJlYW0oKTtcbiAgdGhpcy5zdHJtLmF2YWlsX291dCA9IDA7XG5cbiAgdmFyIHN0YXR1cyAgPSB6bGliX2luZmxhdGUuaW5mbGF0ZUluaXQyKFxuICAgIHRoaXMuc3RybSxcbiAgICBvcHQud2luZG93Qml0c1xuICApO1xuXG4gIGlmIChzdGF0dXMgIT09IGMuWl9PSykge1xuICAgIHRocm93IG5ldyBFcnJvcihtc2dbc3RhdHVzXSk7XG4gIH1cblxuICB0aGlzLmhlYWRlciA9IG5ldyBHWmhlYWRlcigpO1xuXG4gIHpsaWJfaW5mbGF0ZS5pbmZsYXRlR2V0SGVhZGVyKHRoaXMuc3RybSwgdGhpcy5oZWFkZXIpO1xufVxuXG4vKipcbiAqIEluZmxhdGUjcHVzaChkYXRhWywgbW9kZV0pIC0+IEJvb2xlYW5cbiAqIC0gZGF0YSAoVWludDhBcnJheXxBcnJheXxBcnJheUJ1ZmZlcnxTdHJpbmcpOiBpbnB1dCBkYXRhXG4gKiAtIG1vZGUgKE51bWJlcnxCb29sZWFuKTogMC4uNiBmb3IgY29ycmVzcG9uZGluZyBaX05PX0ZMVVNILi5aX1RSRUUgbW9kZXMuXG4gKiAgIFNlZSBjb25zdGFudHMuIFNraXBwZWQgb3IgYGZhbHNlYCBtZWFucyBaX05PX0ZMVVNILCBgdHJ1ZWAgbWVhbnNoIFpfRklOSVNILlxuICpcbiAqIFNlbmRzIGlucHV0IGRhdGEgdG8gaW5mbGF0ZSBwaXBlLCBnZW5lcmF0aW5nIFtbSW5mbGF0ZSNvbkRhdGFdXSBjYWxscyB3aXRoXG4gKiBuZXcgb3V0cHV0IGNodW5rcy4gUmV0dXJucyBgdHJ1ZWAgb24gc3VjY2Vzcy4gVGhlIGxhc3QgZGF0YSBibG9jayBtdXN0IGhhdmVcbiAqIG1vZGUgWl9GSU5JU0ggKG9yIGB0cnVlYCkuIFRoYXQgd2lsbCBmbHVzaCBpbnRlcm5hbCBwZW5kaW5nIGJ1ZmZlcnMgYW5kIGNhbGxcbiAqIFtbSW5mbGF0ZSNvbkVuZF1dLiBGb3IgaW50ZXJpbSBleHBsaWNpdCBmbHVzaGVzICh3aXRob3V0IGVuZGluZyB0aGUgc3RyZWFtKSB5b3VcbiAqIGNhbiB1c2UgbW9kZSBaX1NZTkNfRkxVU0gsIGtlZXBpbmcgdGhlIGRlY29tcHJlc3Npb24gY29udGV4dC5cbiAqXG4gKiBPbiBmYWlsIGNhbGwgW1tJbmZsYXRlI29uRW5kXV0gd2l0aCBlcnJvciBjb2RlIGFuZCByZXR1cm4gZmFsc2UuXG4gKlxuICogV2Ugc3Ryb25nbHkgcmVjb21tZW5kIHRvIHVzZSBgVWludDhBcnJheWAgb24gaW5wdXQgZm9yIGJlc3Qgc3BlZWQgKG91dHB1dFxuICogZm9ybWF0IGlzIGRldGVjdGVkIGF1dG9tYXRpY2FsbHkpLiBBbHNvLCBkb24ndCBza2lwIGxhc3QgcGFyYW0gYW5kIGFsd2F5c1xuICogdXNlIHRoZSBzYW1lIHR5cGUgaW4geW91ciBjb2RlIChib29sZWFuIG9yIG51bWJlcikuIFRoYXQgd2lsbCBpbXByb3ZlIEpTIHNwZWVkLlxuICpcbiAqIEZvciByZWd1bGFyIGBBcnJheWAtcyBtYWtlIHN1cmUgYWxsIGVsZW1lbnRzIGFyZSBbMC4uMjU1XS5cbiAqXG4gKiAjIyMjIyBFeGFtcGxlXG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogcHVzaChjaHVuaywgZmFsc2UpOyAvLyBwdXNoIG9uZSBvZiBkYXRhIGNodW5rc1xuICogLi4uXG4gKiBwdXNoKGNodW5rLCB0cnVlKTsgIC8vIHB1c2ggbGFzdCBjaHVua1xuICogYGBgXG4gKiovXG5JbmZsYXRlLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGRhdGEsIG1vZGUpIHtcbiAgdmFyIHN0cm0gPSB0aGlzLnN0cm07XG4gIHZhciBjaHVua1NpemUgPSB0aGlzLm9wdGlvbnMuY2h1bmtTaXplO1xuICB2YXIgZGljdGlvbmFyeSA9IHRoaXMub3B0aW9ucy5kaWN0aW9uYXJ5O1xuICB2YXIgc3RhdHVzLCBfbW9kZTtcbiAgdmFyIG5leHRfb3V0X3V0ZjgsIHRhaWwsIHV0ZjhzdHI7XG4gIHZhciBkaWN0O1xuXG4gIC8vIEZsYWcgdG8gcHJvcGVybHkgcHJvY2VzcyBaX0JVRl9FUlJPUiBvbiB0ZXN0aW5nIGluZmxhdGUgY2FsbFxuICAvLyB3aGVuIHdlIGNoZWNrIHRoYXQgYWxsIG91dHB1dCBkYXRhIHdhcyBmbHVzaGVkLlxuICB2YXIgYWxsb3dCdWZFcnJvciA9IGZhbHNlO1xuXG4gIGlmICh0aGlzLmVuZGVkKSB7IHJldHVybiBmYWxzZTsgfVxuICBfbW9kZSA9IChtb2RlID09PSB+fm1vZGUpID8gbW9kZSA6ICgobW9kZSA9PT0gdHJ1ZSkgPyBjLlpfRklOSVNIIDogYy5aX05PX0ZMVVNIKTtcblxuICAvLyBDb252ZXJ0IGRhdGEgaWYgbmVlZGVkXG4gIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAvLyBPbmx5IGJpbmFyeSBzdHJpbmdzIGNhbiBiZSBkZWNvbXByZXNzZWQgb24gcHJhY3RpY2VcbiAgICBzdHJtLmlucHV0ID0gc3RyaW5ncy5iaW5zdHJpbmcyYnVmKGRhdGEpO1xuICB9IGVsc2UgaWYgKHRvU3RyaW5nLmNhbGwoZGF0YSkgPT09ICdbb2JqZWN0IEFycmF5QnVmZmVyXScpIHtcbiAgICBzdHJtLmlucHV0ID0gbmV3IFVpbnQ4QXJyYXkoZGF0YSk7XG4gIH0gZWxzZSB7XG4gICAgc3RybS5pbnB1dCA9IGRhdGE7XG4gIH1cblxuICBzdHJtLm5leHRfaW4gPSAwO1xuICBzdHJtLmF2YWlsX2luID0gc3RybS5pbnB1dC5sZW5ndGg7XG5cbiAgZG8ge1xuICAgIGlmIChzdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgc3RybS5vdXRwdXQgPSBuZXcgdXRpbHMuQnVmOChjaHVua1NpemUpO1xuICAgICAgc3RybS5uZXh0X291dCA9IDA7XG4gICAgICBzdHJtLmF2YWlsX291dCA9IGNodW5rU2l6ZTtcbiAgICB9XG5cbiAgICBzdGF0dXMgPSB6bGliX2luZmxhdGUuaW5mbGF0ZShzdHJtLCBjLlpfTk9fRkxVU0gpOyAgICAvKiBubyBiYWQgcmV0dXJuIHZhbHVlICovXG5cbiAgICBpZiAoc3RhdHVzID09PSBjLlpfTkVFRF9ESUNUICYmIGRpY3Rpb25hcnkpIHtcbiAgICAgIC8vIENvbnZlcnQgZGF0YSBpZiBuZWVkZWRcbiAgICAgIGlmICh0eXBlb2YgZGljdGlvbmFyeSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgZGljdCA9IHN0cmluZ3Muc3RyaW5nMmJ1ZihkaWN0aW9uYXJ5KTtcbiAgICAgIH0gZWxzZSBpZiAodG9TdHJpbmcuY2FsbChkaWN0aW9uYXJ5KSA9PT0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJykge1xuICAgICAgICBkaWN0ID0gbmV3IFVpbnQ4QXJyYXkoZGljdGlvbmFyeSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkaWN0ID0gZGljdGlvbmFyeTtcbiAgICAgIH1cblxuICAgICAgc3RhdHVzID0gemxpYl9pbmZsYXRlLmluZmxhdGVTZXREaWN0aW9uYXJ5KHRoaXMuc3RybSwgZGljdCk7XG5cbiAgICB9XG5cbiAgICBpZiAoc3RhdHVzID09PSBjLlpfQlVGX0VSUk9SICYmIGFsbG93QnVmRXJyb3IgPT09IHRydWUpIHtcbiAgICAgIHN0YXR1cyA9IGMuWl9PSztcbiAgICAgIGFsbG93QnVmRXJyb3IgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoc3RhdHVzICE9PSBjLlpfU1RSRUFNX0VORCAmJiBzdGF0dXMgIT09IGMuWl9PSykge1xuICAgICAgdGhpcy5vbkVuZChzdGF0dXMpO1xuICAgICAgdGhpcy5lbmRlZCA9IHRydWU7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKHN0cm0ubmV4dF9vdXQpIHtcbiAgICAgIGlmIChzdHJtLmF2YWlsX291dCA9PT0gMCB8fCBzdGF0dXMgPT09IGMuWl9TVFJFQU1fRU5EIHx8IChzdHJtLmF2YWlsX2luID09PSAwICYmIChfbW9kZSA9PT0gYy5aX0ZJTklTSCB8fCBfbW9kZSA9PT0gYy5aX1NZTkNfRkxVU0gpKSkge1xuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMudG8gPT09ICdzdHJpbmcnKSB7XG5cbiAgICAgICAgICBuZXh0X291dF91dGY4ID0gc3RyaW5ncy51dGY4Ym9yZGVyKHN0cm0ub3V0cHV0LCBzdHJtLm5leHRfb3V0KTtcblxuICAgICAgICAgIHRhaWwgPSBzdHJtLm5leHRfb3V0IC0gbmV4dF9vdXRfdXRmODtcbiAgICAgICAgICB1dGY4c3RyID0gc3RyaW5ncy5idWYyc3RyaW5nKHN0cm0ub3V0cHV0LCBuZXh0X291dF91dGY4KTtcblxuICAgICAgICAgIC8vIG1vdmUgdGFpbFxuICAgICAgICAgIHN0cm0ubmV4dF9vdXQgPSB0YWlsO1xuICAgICAgICAgIHN0cm0uYXZhaWxfb3V0ID0gY2h1bmtTaXplIC0gdGFpbDtcbiAgICAgICAgICBpZiAodGFpbCkgeyB1dGlscy5hcnJheVNldChzdHJtLm91dHB1dCwgc3RybS5vdXRwdXQsIG5leHRfb3V0X3V0ZjgsIHRhaWwsIDApOyB9XG5cbiAgICAgICAgICB0aGlzLm9uRGF0YSh1dGY4c3RyKTtcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMub25EYXRhKHV0aWxzLnNocmlua0J1ZihzdHJtLm91dHB1dCwgc3RybS5uZXh0X291dCkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gV2hlbiBubyBtb3JlIGlucHV0IGRhdGEsIHdlIHNob3VsZCBjaGVjayB0aGF0IGludGVybmFsIGluZmxhdGUgYnVmZmVyc1xuICAgIC8vIGFyZSBmbHVzaGVkLiBUaGUgb25seSB3YXkgdG8gZG8gaXQgd2hlbiBhdmFpbF9vdXQgPSAwIC0gcnVuIG9uZSBtb3JlXG4gICAgLy8gaW5mbGF0ZSBwYXNzLiBCdXQgaWYgb3V0cHV0IGRhdGEgbm90IGV4aXN0cywgaW5mbGF0ZSByZXR1cm4gWl9CVUZfRVJST1IuXG4gICAgLy8gSGVyZSB3ZSBzZXQgZmxhZyB0byBwcm9jZXNzIHRoaXMgZXJyb3IgcHJvcGVybHkuXG4gICAgLy9cbiAgICAvLyBOT1RFLiBEZWZsYXRlIGRvZXMgbm90IHJldHVybiBlcnJvciBpbiB0aGlzIGNhc2UgYW5kIGRvZXMgbm90IG5lZWRzIHN1Y2hcbiAgICAvLyBsb2dpYy5cbiAgICBpZiAoc3RybS5hdmFpbF9pbiA9PT0gMCAmJiBzdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgYWxsb3dCdWZFcnJvciA9IHRydWU7XG4gICAgfVxuXG4gIH0gd2hpbGUgKChzdHJtLmF2YWlsX2luID4gMCB8fCBzdHJtLmF2YWlsX291dCA9PT0gMCkgJiYgc3RhdHVzICE9PSBjLlpfU1RSRUFNX0VORCk7XG5cbiAgaWYgKHN0YXR1cyA9PT0gYy5aX1NUUkVBTV9FTkQpIHtcbiAgICBfbW9kZSA9IGMuWl9GSU5JU0g7XG4gIH1cblxuICAvLyBGaW5hbGl6ZSBvbiB0aGUgbGFzdCBjaHVuay5cbiAgaWYgKF9tb2RlID09PSBjLlpfRklOSVNIKSB7XG4gICAgc3RhdHVzID0gemxpYl9pbmZsYXRlLmluZmxhdGVFbmQodGhpcy5zdHJtKTtcbiAgICB0aGlzLm9uRW5kKHN0YXR1cyk7XG4gICAgdGhpcy5lbmRlZCA9IHRydWU7XG4gICAgcmV0dXJuIHN0YXR1cyA9PT0gYy5aX09LO1xuICB9XG5cbiAgLy8gY2FsbGJhY2sgaW50ZXJpbSByZXN1bHRzIGlmIFpfU1lOQ19GTFVTSC5cbiAgaWYgKF9tb2RlID09PSBjLlpfU1lOQ19GTFVTSCkge1xuICAgIHRoaXMub25FbmQoYy5aX09LKTtcbiAgICBzdHJtLmF2YWlsX291dCA9IDA7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cblxuLyoqXG4gKiBJbmZsYXRlI29uRGF0YShjaHVuaykgLT4gVm9pZFxuICogLSBjaHVuayAoVWludDhBcnJheXxBcnJheXxTdHJpbmcpOiBvdXB1dCBkYXRhLiBUeXBlIG9mIGFycmF5IGRlcGVuZHNcbiAqICAgb24ganMgZW5naW5lIHN1cHBvcnQuIFdoZW4gc3RyaW5nIG91dHB1dCByZXF1ZXN0ZWQsIGVhY2ggY2h1bmtcbiAqICAgd2lsbCBiZSBzdHJpbmcuXG4gKlxuICogQnkgZGVmYXVsdCwgc3RvcmVzIGRhdGEgYmxvY2tzIGluIGBjaHVua3NbXWAgcHJvcGVydHkgYW5kIGdsdWVcbiAqIHRob3NlIGluIGBvbkVuZGAuIE92ZXJyaWRlIHRoaXMgaGFuZGxlciwgaWYgeW91IG5lZWQgYW5vdGhlciBiZWhhdmlvdXIuXG4gKiovXG5JbmZsYXRlLnByb3RvdHlwZS5vbkRhdGEgPSBmdW5jdGlvbiAoY2h1bmspIHtcbiAgdGhpcy5jaHVua3MucHVzaChjaHVuayk7XG59O1xuXG5cbi8qKlxuICogSW5mbGF0ZSNvbkVuZChzdGF0dXMpIC0+IFZvaWRcbiAqIC0gc3RhdHVzIChOdW1iZXIpOiBpbmZsYXRlIHN0YXR1cy4gMCAoWl9PSykgb24gc3VjY2VzcyxcbiAqICAgb3RoZXIgaWYgbm90LlxuICpcbiAqIENhbGxlZCBlaXRoZXIgYWZ0ZXIgeW91IHRlbGwgaW5mbGF0ZSB0aGF0IHRoZSBpbnB1dCBzdHJlYW0gaXNcbiAqIGNvbXBsZXRlIChaX0ZJTklTSCkgb3Igc2hvdWxkIGJlIGZsdXNoZWQgKFpfU1lOQ19GTFVTSClcbiAqIG9yIGlmIGFuIGVycm9yIGhhcHBlbmVkLiBCeSBkZWZhdWx0IC0gam9pbiBjb2xsZWN0ZWQgY2h1bmtzLFxuICogZnJlZSBtZW1vcnkgYW5kIGZpbGwgYHJlc3VsdHNgIC8gYGVycmAgcHJvcGVydGllcy5cbiAqKi9cbkluZmxhdGUucHJvdG90eXBlLm9uRW5kID0gZnVuY3Rpb24gKHN0YXR1cykge1xuICAvLyBPbiBzdWNjZXNzIC0gam9pblxuICBpZiAoc3RhdHVzID09PSBjLlpfT0spIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLnRvID09PSAnc3RyaW5nJykge1xuICAgICAgLy8gR2x1ZSAmIGNvbnZlcnQgaGVyZSwgdW50aWwgd2UgdGVhY2ggcGFrbyB0byBzZW5kXG4gICAgICAvLyB1dGY4IGFsbGlnbmVkIHN0cmluZ3MgdG8gb25EYXRhXG4gICAgICB0aGlzLnJlc3VsdCA9IHRoaXMuY2h1bmtzLmpvaW4oJycpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnJlc3VsdCA9IHV0aWxzLmZsYXR0ZW5DaHVua3ModGhpcy5jaHVua3MpO1xuICAgIH1cbiAgfVxuICB0aGlzLmNodW5rcyA9IFtdO1xuICB0aGlzLmVyciA9IHN0YXR1cztcbiAgdGhpcy5tc2cgPSB0aGlzLnN0cm0ubXNnO1xufTtcblxuXG4vKipcbiAqIGluZmxhdGUoZGF0YVssIG9wdGlvbnNdKSAtPiBVaW50OEFycmF5fEFycmF5fFN0cmluZ1xuICogLSBkYXRhIChVaW50OEFycmF5fEFycmF5fFN0cmluZyk6IGlucHV0IGRhdGEgdG8gZGVjb21wcmVzcy5cbiAqIC0gb3B0aW9ucyAoT2JqZWN0KTogemxpYiBpbmZsYXRlIG9wdGlvbnMuXG4gKlxuICogRGVjb21wcmVzcyBgZGF0YWAgd2l0aCBpbmZsYXRlL3VuZ3ppcCBhbmQgYG9wdGlvbnNgLiBBdXRvZGV0ZWN0XG4gKiBmb3JtYXQgdmlhIHdyYXBwZXIgaGVhZGVyIGJ5IGRlZmF1bHQuIFRoYXQncyB3aHkgd2UgZG9uJ3QgcHJvdmlkZVxuICogc2VwYXJhdGUgYHVuZ3ppcGAgbWV0aG9kLlxuICpcbiAqIFN1cHBvcnRlZCBvcHRpb25zIGFyZTpcbiAqXG4gKiAtIHdpbmRvd0JpdHNcbiAqXG4gKiBbaHR0cDovL3psaWIubmV0L21hbnVhbC5odG1sI0FkdmFuY2VkXShodHRwOi8vemxpYi5uZXQvbWFudWFsLmh0bWwjQWR2YW5jZWQpXG4gKiBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAqXG4gKiBTdWdhciAob3B0aW9ucyk6XG4gKlxuICogLSBgcmF3YCAoQm9vbGVhbikgLSBzYXkgdGhhdCB3ZSB3b3JrIHdpdGggcmF3IHN0cmVhbSwgaWYgeW91IGRvbid0IHdpc2ggdG8gc3BlY2lmeVxuICogICBuZWdhdGl2ZSB3aW5kb3dCaXRzIGltcGxpY2l0bHkuXG4gKiAtIGB0b2AgKFN0cmluZykgLSBpZiBlcXVhbCB0byAnc3RyaW5nJywgdGhlbiByZXN1bHQgd2lsbCBiZSBjb252ZXJ0ZWRcbiAqICAgZnJvbSB1dGY4IHRvIHV0ZjE2IChqYXZhc2NyaXB0KSBzdHJpbmcuIFdoZW4gc3RyaW5nIG91dHB1dCByZXF1ZXN0ZWQsXG4gKiAgIGNodW5rIGxlbmd0aCBjYW4gZGlmZmVyIGZyb20gYGNodW5rU2l6ZWAsIGRlcGVuZGluZyBvbiBjb250ZW50LlxuICpcbiAqXG4gKiAjIyMjIyBFeGFtcGxlOlxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIHZhciBwYWtvID0gcmVxdWlyZSgncGFrbycpXG4gKiAgICwgaW5wdXQgPSBwYWtvLmRlZmxhdGUoWzEsMiwzLDQsNSw2LDcsOCw5XSlcbiAqICAgLCBvdXRwdXQ7XG4gKlxuICogdHJ5IHtcbiAqICAgb3V0cHV0ID0gcGFrby5pbmZsYXRlKGlucHV0KTtcbiAqIH0gY2F0Y2ggKGVycilcbiAqICAgY29uc29sZS5sb2coZXJyKTtcbiAqIH1cbiAqIGBgYFxuICoqL1xuZnVuY3Rpb24gaW5mbGF0ZShpbnB1dCwgb3B0aW9ucykge1xuICB2YXIgaW5mbGF0b3IgPSBuZXcgSW5mbGF0ZShvcHRpb25zKTtcblxuICBpbmZsYXRvci5wdXNoKGlucHV0LCB0cnVlKTtcblxuICAvLyBUaGF0IHdpbGwgbmV2ZXIgaGFwcGVucywgaWYgeW91IGRvbid0IGNoZWF0IHdpdGggb3B0aW9ucyA6KVxuICBpZiAoaW5mbGF0b3IuZXJyKSB7IHRocm93IGluZmxhdG9yLm1zZzsgfVxuXG4gIHJldHVybiBpbmZsYXRvci5yZXN1bHQ7XG59XG5cblxuLyoqXG4gKiBpbmZsYXRlUmF3KGRhdGFbLCBvcHRpb25zXSkgLT4gVWludDhBcnJheXxBcnJheXxTdHJpbmdcbiAqIC0gZGF0YSAoVWludDhBcnJheXxBcnJheXxTdHJpbmcpOiBpbnB1dCBkYXRhIHRvIGRlY29tcHJlc3MuXG4gKiAtIG9wdGlvbnMgKE9iamVjdCk6IHpsaWIgaW5mbGF0ZSBvcHRpb25zLlxuICpcbiAqIFRoZSBzYW1lIGFzIFtbaW5mbGF0ZV1dLCBidXQgY3JlYXRlcyByYXcgZGF0YSwgd2l0aG91dCB3cmFwcGVyXG4gKiAoaGVhZGVyIGFuZCBhZGxlcjMyIGNyYykuXG4gKiovXG5mdW5jdGlvbiBpbmZsYXRlUmF3KGlucHV0LCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBvcHRpb25zLnJhdyA9IHRydWU7XG4gIHJldHVybiBpbmZsYXRlKGlucHV0LCBvcHRpb25zKTtcbn1cblxuXG4vKipcbiAqIHVuZ3ppcChkYXRhWywgb3B0aW9uc10pIC0+IFVpbnQ4QXJyYXl8QXJyYXl8U3RyaW5nXG4gKiAtIGRhdGEgKFVpbnQ4QXJyYXl8QXJyYXl8U3RyaW5nKTogaW5wdXQgZGF0YSB0byBkZWNvbXByZXNzLlxuICogLSBvcHRpb25zIChPYmplY3QpOiB6bGliIGluZmxhdGUgb3B0aW9ucy5cbiAqXG4gKiBKdXN0IHNob3J0Y3V0IHRvIFtbaW5mbGF0ZV1dLCBiZWNhdXNlIGl0IGF1dG9kZXRlY3RzIGZvcm1hdFxuICogYnkgaGVhZGVyLmNvbnRlbnQuIERvbmUgZm9yIGNvbnZlbmllbmNlLlxuICoqL1xuXG5cbmV4cG9ydHMuSW5mbGF0ZSA9IEluZmxhdGU7XG5leHBvcnRzLmluZmxhdGUgPSBpbmZsYXRlO1xuZXhwb3J0cy5pbmZsYXRlUmF3ID0gaW5mbGF0ZVJhdztcbmV4cG9ydHMudW5nemlwICA9IGluZmxhdGU7XG4iLCIndXNlIHN0cmljdCc7XG5cblxudmFyIFRZUEVEX09LID0gICh0eXBlb2YgVWludDhBcnJheSAhPT0gJ3VuZGVmaW5lZCcpICYmXG4gICAgICAgICAgICAgICAgKHR5cGVvZiBVaW50MTZBcnJheSAhPT0gJ3VuZGVmaW5lZCcpICYmXG4gICAgICAgICAgICAgICAgKHR5cGVvZiBJbnQzMkFycmF5ICE9PSAndW5kZWZpbmVkJyk7XG5cblxuZXhwb3J0cy5hc3NpZ24gPSBmdW5jdGlvbiAob2JqIC8qZnJvbTEsIGZyb20yLCBmcm9tMywgLi4uKi8pIHtcbiAgdmFyIHNvdXJjZXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICB3aGlsZSAoc291cmNlcy5sZW5ndGgpIHtcbiAgICB2YXIgc291cmNlID0gc291cmNlcy5zaGlmdCgpO1xuICAgIGlmICghc291cmNlKSB7IGNvbnRpbnVlOyB9XG5cbiAgICBpZiAodHlwZW9mIHNvdXJjZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3Ioc291cmNlICsgJ211c3QgYmUgbm9uLW9iamVjdCcpO1xuICAgIH1cblxuICAgIGZvciAodmFyIHAgaW4gc291cmNlKSB7XG4gICAgICBpZiAoc291cmNlLmhhc093blByb3BlcnR5KHApKSB7XG4gICAgICAgIG9ialtwXSA9IHNvdXJjZVtwXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gb2JqO1xufTtcblxuXG4vLyByZWR1Y2UgYnVmZmVyIHNpemUsIGF2b2lkaW5nIG1lbSBjb3B5XG5leHBvcnRzLnNocmlua0J1ZiA9IGZ1bmN0aW9uIChidWYsIHNpemUpIHtcbiAgaWYgKGJ1Zi5sZW5ndGggPT09IHNpemUpIHsgcmV0dXJuIGJ1ZjsgfVxuICBpZiAoYnVmLnN1YmFycmF5KSB7IHJldHVybiBidWYuc3ViYXJyYXkoMCwgc2l6ZSk7IH1cbiAgYnVmLmxlbmd0aCA9IHNpemU7XG4gIHJldHVybiBidWY7XG59O1xuXG5cbnZhciBmblR5cGVkID0ge1xuICBhcnJheVNldDogZnVuY3Rpb24gKGRlc3QsIHNyYywgc3JjX29mZnMsIGxlbiwgZGVzdF9vZmZzKSB7XG4gICAgaWYgKHNyYy5zdWJhcnJheSAmJiBkZXN0LnN1YmFycmF5KSB7XG4gICAgICBkZXN0LnNldChzcmMuc3ViYXJyYXkoc3JjX29mZnMsIHNyY19vZmZzICsgbGVuKSwgZGVzdF9vZmZzKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gRmFsbGJhY2sgdG8gb3JkaW5hcnkgYXJyYXlcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBkZXN0W2Rlc3Rfb2ZmcyArIGldID0gc3JjW3NyY19vZmZzICsgaV07XG4gICAgfVxuICB9LFxuICAvLyBKb2luIGFycmF5IG9mIGNodW5rcyB0byBzaW5nbGUgYXJyYXkuXG4gIGZsYXR0ZW5DaHVua3M6IGZ1bmN0aW9uIChjaHVua3MpIHtcbiAgICB2YXIgaSwgbCwgbGVuLCBwb3MsIGNodW5rLCByZXN1bHQ7XG5cbiAgICAvLyBjYWxjdWxhdGUgZGF0YSBsZW5ndGhcbiAgICBsZW4gPSAwO1xuICAgIGZvciAoaSA9IDAsIGwgPSBjaHVua3MubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBsZW4gKz0gY2h1bmtzW2ldLmxlbmd0aDtcbiAgICB9XG5cbiAgICAvLyBqb2luIGNodW5rc1xuICAgIHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KGxlbik7XG4gICAgcG9zID0gMDtcbiAgICBmb3IgKGkgPSAwLCBsID0gY2h1bmtzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgY2h1bmsgPSBjaHVua3NbaV07XG4gICAgICByZXN1bHQuc2V0KGNodW5rLCBwb3MpO1xuICAgICAgcG9zICs9IGNodW5rLmxlbmd0aDtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59O1xuXG52YXIgZm5VbnR5cGVkID0ge1xuICBhcnJheVNldDogZnVuY3Rpb24gKGRlc3QsIHNyYywgc3JjX29mZnMsIGxlbiwgZGVzdF9vZmZzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgZGVzdFtkZXN0X29mZnMgKyBpXSA9IHNyY1tzcmNfb2ZmcyArIGldO1xuICAgIH1cbiAgfSxcbiAgLy8gSm9pbiBhcnJheSBvZiBjaHVua3MgdG8gc2luZ2xlIGFycmF5LlxuICBmbGF0dGVuQ2h1bmtzOiBmdW5jdGlvbiAoY2h1bmtzKSB7XG4gICAgcmV0dXJuIFtdLmNvbmNhdC5hcHBseShbXSwgY2h1bmtzKTtcbiAgfVxufTtcblxuXG4vLyBFbmFibGUvRGlzYWJsZSB0eXBlZCBhcnJheXMgdXNlLCBmb3IgdGVzdGluZ1xuLy9cbmV4cG9ydHMuc2V0VHlwZWQgPSBmdW5jdGlvbiAob24pIHtcbiAgaWYgKG9uKSB7XG4gICAgZXhwb3J0cy5CdWY4ICA9IFVpbnQ4QXJyYXk7XG4gICAgZXhwb3J0cy5CdWYxNiA9IFVpbnQxNkFycmF5O1xuICAgIGV4cG9ydHMuQnVmMzIgPSBJbnQzMkFycmF5O1xuICAgIGV4cG9ydHMuYXNzaWduKGV4cG9ydHMsIGZuVHlwZWQpO1xuICB9IGVsc2Uge1xuICAgIGV4cG9ydHMuQnVmOCAgPSBBcnJheTtcbiAgICBleHBvcnRzLkJ1ZjE2ID0gQXJyYXk7XG4gICAgZXhwb3J0cy5CdWYzMiA9IEFycmF5O1xuICAgIGV4cG9ydHMuYXNzaWduKGV4cG9ydHMsIGZuVW50eXBlZCk7XG4gIH1cbn07XG5cbmV4cG9ydHMuc2V0VHlwZWQoVFlQRURfT0spO1xuIiwiLy8gU3RyaW5nIGVuY29kZS9kZWNvZGUgaGVscGVyc1xuJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vY29tbW9uJyk7XG5cblxuLy8gUXVpY2sgY2hlY2sgaWYgd2UgY2FuIHVzZSBmYXN0IGFycmF5IHRvIGJpbiBzdHJpbmcgY29udmVyc2lvblxuLy9cbi8vIC0gYXBwbHkoQXJyYXkpIGNhbiBmYWlsIG9uIEFuZHJvaWQgMi4yXG4vLyAtIGFwcGx5KFVpbnQ4QXJyYXkpIGNhbiBmYWlsIG9uIGlPUyA1LjEgU2FmYXJ5XG4vL1xudmFyIFNUUl9BUFBMWV9PSyA9IHRydWU7XG52YXIgU1RSX0FQUExZX1VJQV9PSyA9IHRydWU7XG5cbnRyeSB7IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgWyAwIF0pOyB9IGNhdGNoIChfXykgeyBTVFJfQVBQTFlfT0sgPSBmYWxzZTsgfVxudHJ5IHsgU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBuZXcgVWludDhBcnJheSgxKSk7IH0gY2F0Y2ggKF9fKSB7IFNUUl9BUFBMWV9VSUFfT0sgPSBmYWxzZTsgfVxuXG5cbi8vIFRhYmxlIHdpdGggdXRmOCBsZW5ndGhzIChjYWxjdWxhdGVkIGJ5IGZpcnN0IGJ5dGUgb2Ygc2VxdWVuY2UpXG4vLyBOb3RlLCB0aGF0IDUgJiA2LWJ5dGUgdmFsdWVzIGFuZCBzb21lIDQtYnl0ZSB2YWx1ZXMgY2FuIG5vdCBiZSByZXByZXNlbnRlZCBpbiBKUyxcbi8vIGJlY2F1c2UgbWF4IHBvc3NpYmxlIGNvZGVwb2ludCBpcyAweDEwZmZmZlxudmFyIF91dGY4bGVuID0gbmV3IHV0aWxzLkJ1ZjgoMjU2KTtcbmZvciAodmFyIHEgPSAwOyBxIDwgMjU2OyBxKyspIHtcbiAgX3V0ZjhsZW5bcV0gPSAocSA+PSAyNTIgPyA2IDogcSA+PSAyNDggPyA1IDogcSA+PSAyNDAgPyA0IDogcSA+PSAyMjQgPyAzIDogcSA+PSAxOTIgPyAyIDogMSk7XG59XG5fdXRmOGxlblsyNTRdID0gX3V0ZjhsZW5bMjU0XSA9IDE7IC8vIEludmFsaWQgc2VxdWVuY2Ugc3RhcnRcblxuXG4vLyBjb252ZXJ0IHN0cmluZyB0byBhcnJheSAodHlwZWQsIHdoZW4gcG9zc2libGUpXG5leHBvcnRzLnN0cmluZzJidWYgPSBmdW5jdGlvbiAoc3RyKSB7XG4gIHZhciBidWYsIGMsIGMyLCBtX3BvcywgaSwgc3RyX2xlbiA9IHN0ci5sZW5ndGgsIGJ1Zl9sZW4gPSAwO1xuXG4gIC8vIGNvdW50IGJpbmFyeSBzaXplXG4gIGZvciAobV9wb3MgPSAwOyBtX3BvcyA8IHN0cl9sZW47IG1fcG9zKyspIHtcbiAgICBjID0gc3RyLmNoYXJDb2RlQXQobV9wb3MpO1xuICAgIGlmICgoYyAmIDB4ZmMwMCkgPT09IDB4ZDgwMCAmJiAobV9wb3MgKyAxIDwgc3RyX2xlbikpIHtcbiAgICAgIGMyID0gc3RyLmNoYXJDb2RlQXQobV9wb3MgKyAxKTtcbiAgICAgIGlmICgoYzIgJiAweGZjMDApID09PSAweGRjMDApIHtcbiAgICAgICAgYyA9IDB4MTAwMDAgKyAoKGMgLSAweGQ4MDApIDw8IDEwKSArIChjMiAtIDB4ZGMwMCk7XG4gICAgICAgIG1fcG9zKys7XG4gICAgICB9XG4gICAgfVxuICAgIGJ1Zl9sZW4gKz0gYyA8IDB4ODAgPyAxIDogYyA8IDB4ODAwID8gMiA6IGMgPCAweDEwMDAwID8gMyA6IDQ7XG4gIH1cblxuICAvLyBhbGxvY2F0ZSBidWZmZXJcbiAgYnVmID0gbmV3IHV0aWxzLkJ1ZjgoYnVmX2xlbik7XG5cbiAgLy8gY29udmVydFxuICBmb3IgKGkgPSAwLCBtX3BvcyA9IDA7IGkgPCBidWZfbGVuOyBtX3BvcysrKSB7XG4gICAgYyA9IHN0ci5jaGFyQ29kZUF0KG1fcG9zKTtcbiAgICBpZiAoKGMgJiAweGZjMDApID09PSAweGQ4MDAgJiYgKG1fcG9zICsgMSA8IHN0cl9sZW4pKSB7XG4gICAgICBjMiA9IHN0ci5jaGFyQ29kZUF0KG1fcG9zICsgMSk7XG4gICAgICBpZiAoKGMyICYgMHhmYzAwKSA9PT0gMHhkYzAwKSB7XG4gICAgICAgIGMgPSAweDEwMDAwICsgKChjIC0gMHhkODAwKSA8PCAxMCkgKyAoYzIgLSAweGRjMDApO1xuICAgICAgICBtX3BvcysrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoYyA8IDB4ODApIHtcbiAgICAgIC8qIG9uZSBieXRlICovXG4gICAgICBidWZbaSsrXSA9IGM7XG4gICAgfSBlbHNlIGlmIChjIDwgMHg4MDApIHtcbiAgICAgIC8qIHR3byBieXRlcyAqL1xuICAgICAgYnVmW2krK10gPSAweEMwIHwgKGMgPj4+IDYpO1xuICAgICAgYnVmW2krK10gPSAweDgwIHwgKGMgJiAweDNmKTtcbiAgICB9IGVsc2UgaWYgKGMgPCAweDEwMDAwKSB7XG4gICAgICAvKiB0aHJlZSBieXRlcyAqL1xuICAgICAgYnVmW2krK10gPSAweEUwIHwgKGMgPj4+IDEyKTtcbiAgICAgIGJ1ZltpKytdID0gMHg4MCB8IChjID4+PiA2ICYgMHgzZik7XG4gICAgICBidWZbaSsrXSA9IDB4ODAgfCAoYyAmIDB4M2YpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvKiBmb3VyIGJ5dGVzICovXG4gICAgICBidWZbaSsrXSA9IDB4ZjAgfCAoYyA+Pj4gMTgpO1xuICAgICAgYnVmW2krK10gPSAweDgwIHwgKGMgPj4+IDEyICYgMHgzZik7XG4gICAgICBidWZbaSsrXSA9IDB4ODAgfCAoYyA+Pj4gNiAmIDB4M2YpO1xuICAgICAgYnVmW2krK10gPSAweDgwIHwgKGMgJiAweDNmKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYnVmO1xufTtcblxuLy8gSGVscGVyICh1c2VkIGluIDIgcGxhY2VzKVxuZnVuY3Rpb24gYnVmMmJpbnN0cmluZyhidWYsIGxlbikge1xuICAvLyB1c2UgZmFsbGJhY2sgZm9yIGJpZyBhcnJheXMgdG8gYXZvaWQgc3RhY2sgb3ZlcmZsb3dcbiAgaWYgKGxlbiA8IDY1NTM3KSB7XG4gICAgaWYgKChidWYuc3ViYXJyYXkgJiYgU1RSX0FQUExZX1VJQV9PSykgfHwgKCFidWYuc3ViYXJyYXkgJiYgU1RSX0FQUExZX09LKSkge1xuICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgdXRpbHMuc2hyaW5rQnVmKGJ1ZiwgbGVuKSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIHJlc3VsdCA9ICcnO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgcmVzdWx0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5cbi8vIENvbnZlcnQgYnl0ZSBhcnJheSB0byBiaW5hcnkgc3RyaW5nXG5leHBvcnRzLmJ1ZjJiaW5zdHJpbmcgPSBmdW5jdGlvbiAoYnVmKSB7XG4gIHJldHVybiBidWYyYmluc3RyaW5nKGJ1ZiwgYnVmLmxlbmd0aCk7XG59O1xuXG5cbi8vIENvbnZlcnQgYmluYXJ5IHN0cmluZyAodHlwZWQsIHdoZW4gcG9zc2libGUpXG5leHBvcnRzLmJpbnN0cmluZzJidWYgPSBmdW5jdGlvbiAoc3RyKSB7XG4gIHZhciBidWYgPSBuZXcgdXRpbHMuQnVmOChzdHIubGVuZ3RoKTtcbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGJ1Zi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGJ1ZltpXSA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICB9XG4gIHJldHVybiBidWY7XG59O1xuXG5cbi8vIGNvbnZlcnQgYXJyYXkgdG8gc3RyaW5nXG5leHBvcnRzLmJ1ZjJzdHJpbmcgPSBmdW5jdGlvbiAoYnVmLCBtYXgpIHtcbiAgdmFyIGksIG91dCwgYywgY19sZW47XG4gIHZhciBsZW4gPSBtYXggfHwgYnVmLmxlbmd0aDtcblxuICAvLyBSZXNlcnZlIG1heCBwb3NzaWJsZSBsZW5ndGggKDIgd29yZHMgcGVyIGNoYXIpXG4gIC8vIE5COiBieSB1bmtub3duIHJlYXNvbnMsIEFycmF5IGlzIHNpZ25pZmljYW50bHkgZmFzdGVyIGZvclxuICAvLyAgICAgU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseSB0aGFuIFVpbnQxNkFycmF5LlxuICB2YXIgdXRmMTZidWYgPSBuZXcgQXJyYXkobGVuICogMik7XG5cbiAgZm9yIChvdXQgPSAwLCBpID0gMDsgaSA8IGxlbjspIHtcbiAgICBjID0gYnVmW2krK107XG4gICAgLy8gcXVpY2sgcHJvY2VzcyBhc2NpaVxuICAgIGlmIChjIDwgMHg4MCkgeyB1dGYxNmJ1ZltvdXQrK10gPSBjOyBjb250aW51ZTsgfVxuXG4gICAgY19sZW4gPSBfdXRmOGxlbltjXTtcbiAgICAvLyBza2lwIDUgJiA2IGJ5dGUgY29kZXNcbiAgICBpZiAoY19sZW4gPiA0KSB7IHV0ZjE2YnVmW291dCsrXSA9IDB4ZmZmZDsgaSArPSBjX2xlbiAtIDE7IGNvbnRpbnVlOyB9XG5cbiAgICAvLyBhcHBseSBtYXNrIG9uIGZpcnN0IGJ5dGVcbiAgICBjICY9IGNfbGVuID09PSAyID8gMHgxZiA6IGNfbGVuID09PSAzID8gMHgwZiA6IDB4MDc7XG4gICAgLy8gam9pbiB0aGUgcmVzdFxuICAgIHdoaWxlIChjX2xlbiA+IDEgJiYgaSA8IGxlbikge1xuICAgICAgYyA9IChjIDw8IDYpIHwgKGJ1ZltpKytdICYgMHgzZik7XG4gICAgICBjX2xlbi0tO1xuICAgIH1cblxuICAgIC8vIHRlcm1pbmF0ZWQgYnkgZW5kIG9mIHN0cmluZz9cbiAgICBpZiAoY19sZW4gPiAxKSB7IHV0ZjE2YnVmW291dCsrXSA9IDB4ZmZmZDsgY29udGludWU7IH1cblxuICAgIGlmIChjIDwgMHgxMDAwMCkge1xuICAgICAgdXRmMTZidWZbb3V0KytdID0gYztcbiAgICB9IGVsc2Uge1xuICAgICAgYyAtPSAweDEwMDAwO1xuICAgICAgdXRmMTZidWZbb3V0KytdID0gMHhkODAwIHwgKChjID4+IDEwKSAmIDB4M2ZmKTtcbiAgICAgIHV0ZjE2YnVmW291dCsrXSA9IDB4ZGMwMCB8IChjICYgMHgzZmYpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBidWYyYmluc3RyaW5nKHV0ZjE2YnVmLCBvdXQpO1xufTtcblxuXG4vLyBDYWxjdWxhdGUgbWF4IHBvc3NpYmxlIHBvc2l0aW9uIGluIHV0ZjggYnVmZmVyLFxuLy8gdGhhdCB3aWxsIG5vdCBicmVhayBzZXF1ZW5jZS4gSWYgdGhhdCdzIG5vdCBwb3NzaWJsZVxuLy8gLSAodmVyeSBzbWFsbCBsaW1pdHMpIHJldHVybiBtYXggc2l6ZSBhcyBpcy5cbi8vXG4vLyBidWZbXSAtIHV0ZjggYnl0ZXMgYXJyYXlcbi8vIG1heCAgIC0gbGVuZ3RoIGxpbWl0IChtYW5kYXRvcnkpO1xuZXhwb3J0cy51dGY4Ym9yZGVyID0gZnVuY3Rpb24gKGJ1ZiwgbWF4KSB7XG4gIHZhciBwb3M7XG5cbiAgbWF4ID0gbWF4IHx8IGJ1Zi5sZW5ndGg7XG4gIGlmIChtYXggPiBidWYubGVuZ3RoKSB7IG1heCA9IGJ1Zi5sZW5ndGg7IH1cblxuICAvLyBnbyBiYWNrIGZyb20gbGFzdCBwb3NpdGlvbiwgdW50aWwgc3RhcnQgb2Ygc2VxdWVuY2UgZm91bmRcbiAgcG9zID0gbWF4IC0gMTtcbiAgd2hpbGUgKHBvcyA+PSAwICYmIChidWZbcG9zXSAmIDB4QzApID09PSAweDgwKSB7IHBvcy0tOyB9XG5cbiAgLy8gRnVja3VwIC0gdmVyeSBzbWFsbCBhbmQgYnJva2VuIHNlcXVlbmNlLFxuICAvLyByZXR1cm4gbWF4LCBiZWNhdXNlIHdlIHNob3VsZCByZXR1cm4gc29tZXRoaW5nIGFueXdheS5cbiAgaWYgKHBvcyA8IDApIHsgcmV0dXJuIG1heDsgfVxuXG4gIC8vIElmIHdlIGNhbWUgdG8gc3RhcnQgb2YgYnVmZmVyIC0gdGhhdCBtZWFucyB2dWZmZXIgaXMgdG9vIHNtYWxsLFxuICAvLyByZXR1cm4gbWF4IHRvby5cbiAgaWYgKHBvcyA9PT0gMCkgeyByZXR1cm4gbWF4OyB9XG5cbiAgcmV0dXJuIChwb3MgKyBfdXRmOGxlbltidWZbcG9zXV0gPiBtYXgpID8gcG9zIDogbWF4O1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gTm90ZTogYWRsZXIzMiB0YWtlcyAxMiUgZm9yIGxldmVsIDAgYW5kIDIlIGZvciBsZXZlbCA2LlxuLy8gSXQgZG9lc24ndCB3b3J0aCB0byBtYWtlIGFkZGl0aW9uYWwgb3B0aW1pemF0aW9uYSBhcyBpbiBvcmlnaW5hbC5cbi8vIFNtYWxsIHNpemUgaXMgcHJlZmVyYWJsZS5cblxuZnVuY3Rpb24gYWRsZXIzMihhZGxlciwgYnVmLCBsZW4sIHBvcykge1xuICB2YXIgczEgPSAoYWRsZXIgJiAweGZmZmYpIHwwLFxuICAgICAgczIgPSAoKGFkbGVyID4+PiAxNikgJiAweGZmZmYpIHwwLFxuICAgICAgbiA9IDA7XG5cbiAgd2hpbGUgKGxlbiAhPT0gMCkge1xuICAgIC8vIFNldCBsaW1pdCB+IHR3aWNlIGxlc3MgdGhhbiA1NTUyLCB0byBrZWVwXG4gICAgLy8gczIgaW4gMzEtYml0cywgYmVjYXVzZSB3ZSBmb3JjZSBzaWduZWQgaW50cy5cbiAgICAvLyBpbiBvdGhlciBjYXNlICU9IHdpbGwgZmFpbC5cbiAgICBuID0gbGVuID4gMjAwMCA/IDIwMDAgOiBsZW47XG4gICAgbGVuIC09IG47XG5cbiAgICBkbyB7XG4gICAgICBzMSA9IChzMSArIGJ1Zltwb3MrK10pIHwwO1xuICAgICAgczIgPSAoczIgKyBzMSkgfDA7XG4gICAgfSB3aGlsZSAoLS1uKTtcblxuICAgIHMxICU9IDY1NTIxO1xuICAgIHMyICU9IDY1NTIxO1xuICB9XG5cbiAgcmV0dXJuIChzMSB8IChzMiA8PCAxNikpIHwwO1xufVxuXG5cbm1vZHVsZS5leHBvcnRzID0gYWRsZXIzMjtcbiIsIid1c2Ugc3RyaWN0JztcblxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblxuICAvKiBBbGxvd2VkIGZsdXNoIHZhbHVlczsgc2VlIGRlZmxhdGUoKSBhbmQgaW5mbGF0ZSgpIGJlbG93IGZvciBkZXRhaWxzICovXG4gIFpfTk9fRkxVU0g6ICAgICAgICAgMCxcbiAgWl9QQVJUSUFMX0ZMVVNIOiAgICAxLFxuICBaX1NZTkNfRkxVU0g6ICAgICAgIDIsXG4gIFpfRlVMTF9GTFVTSDogICAgICAgMyxcbiAgWl9GSU5JU0g6ICAgICAgICAgICA0LFxuICBaX0JMT0NLOiAgICAgICAgICAgIDUsXG4gIFpfVFJFRVM6ICAgICAgICAgICAgNixcblxuICAvKiBSZXR1cm4gY29kZXMgZm9yIHRoZSBjb21wcmVzc2lvbi9kZWNvbXByZXNzaW9uIGZ1bmN0aW9ucy4gTmVnYXRpdmUgdmFsdWVzXG4gICogYXJlIGVycm9ycywgcG9zaXRpdmUgdmFsdWVzIGFyZSB1c2VkIGZvciBzcGVjaWFsIGJ1dCBub3JtYWwgZXZlbnRzLlxuICAqL1xuICBaX09LOiAgICAgICAgICAgICAgIDAsXG4gIFpfU1RSRUFNX0VORDogICAgICAgMSxcbiAgWl9ORUVEX0RJQ1Q6ICAgICAgICAyLFxuICBaX0VSUk5POiAgICAgICAgICAgLTEsXG4gIFpfU1RSRUFNX0VSUk9SOiAgICAtMixcbiAgWl9EQVRBX0VSUk9SOiAgICAgIC0zLFxuICAvL1pfTUVNX0VSUk9SOiAgICAgLTQsXG4gIFpfQlVGX0VSUk9SOiAgICAgICAtNSxcbiAgLy9aX1ZFUlNJT05fRVJST1I6IC02LFxuXG4gIC8qIGNvbXByZXNzaW9uIGxldmVscyAqL1xuICBaX05PX0NPTVBSRVNTSU9OOiAgICAgICAgIDAsXG4gIFpfQkVTVF9TUEVFRDogICAgICAgICAgICAgMSxcbiAgWl9CRVNUX0NPTVBSRVNTSU9OOiAgICAgICA5LFxuICBaX0RFRkFVTFRfQ09NUFJFU1NJT046ICAgLTEsXG5cblxuICBaX0ZJTFRFUkVEOiAgICAgICAgICAgICAgIDEsXG4gIFpfSFVGRk1BTl9PTkxZOiAgICAgICAgICAgMixcbiAgWl9STEU6ICAgICAgICAgICAgICAgICAgICAzLFxuICBaX0ZJWEVEOiAgICAgICAgICAgICAgICAgIDQsXG4gIFpfREVGQVVMVF9TVFJBVEVHWTogICAgICAgMCxcblxuICAvKiBQb3NzaWJsZSB2YWx1ZXMgb2YgdGhlIGRhdGFfdHlwZSBmaWVsZCAodGhvdWdoIHNlZSBpbmZsYXRlKCkpICovXG4gIFpfQklOQVJZOiAgICAgICAgICAgICAgICAgMCxcbiAgWl9URVhUOiAgICAgICAgICAgICAgICAgICAxLFxuICAvL1pfQVNDSUk6ICAgICAgICAgICAgICAgIDEsIC8vID0gWl9URVhUIChkZXByZWNhdGVkKVxuICBaX1VOS05PV046ICAgICAgICAgICAgICAgIDIsXG5cbiAgLyogVGhlIGRlZmxhdGUgY29tcHJlc3Npb24gbWV0aG9kICovXG4gIFpfREVGTEFURUQ6ICAgICAgICAgICAgICAgOFxuICAvL1pfTlVMTDogICAgICAgICAgICAgICAgIG51bGwgLy8gVXNlIC0xIG9yIG51bGwgaW5saW5lLCBkZXBlbmRpbmcgb24gdmFyIHR5cGVcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIE5vdGU6IHdlIGNhbid0IGdldCBzaWduaWZpY2FudCBzcGVlZCBib29zdCBoZXJlLlxuLy8gU28gd3JpdGUgY29kZSB0byBtaW5pbWl6ZSBzaXplIC0gbm8gcHJlZ2VuZXJhdGVkIHRhYmxlc1xuLy8gYW5kIGFycmF5IHRvb2xzIGRlcGVuZGVuY2llcy5cblxuXG4vLyBVc2Ugb3JkaW5hcnkgYXJyYXksIHNpbmNlIHVudHlwZWQgbWFrZXMgbm8gYm9vc3QgaGVyZVxuZnVuY3Rpb24gbWFrZVRhYmxlKCkge1xuICB2YXIgYywgdGFibGUgPSBbXTtcblxuICBmb3IgKHZhciBuID0gMDsgbiA8IDI1NjsgbisrKSB7XG4gICAgYyA9IG47XG4gICAgZm9yICh2YXIgayA9IDA7IGsgPCA4OyBrKyspIHtcbiAgICAgIGMgPSAoKGMgJiAxKSA/ICgweEVEQjg4MzIwIF4gKGMgPj4+IDEpKSA6IChjID4+PiAxKSk7XG4gICAgfVxuICAgIHRhYmxlW25dID0gYztcbiAgfVxuXG4gIHJldHVybiB0YWJsZTtcbn1cblxuLy8gQ3JlYXRlIHRhYmxlIG9uIGxvYWQuIEp1c3QgMjU1IHNpZ25lZCBsb25ncy4gTm90IGEgcHJvYmxlbS5cbnZhciBjcmNUYWJsZSA9IG1ha2VUYWJsZSgpO1xuXG5cbmZ1bmN0aW9uIGNyYzMyKGNyYywgYnVmLCBsZW4sIHBvcykge1xuICB2YXIgdCA9IGNyY1RhYmxlLFxuICAgICAgZW5kID0gcG9zICsgbGVuO1xuXG4gIGNyYyBePSAtMTtcblxuICBmb3IgKHZhciBpID0gcG9zOyBpIDwgZW5kOyBpKyspIHtcbiAgICBjcmMgPSAoY3JjID4+PiA4KSBeIHRbKGNyYyBeIGJ1ZltpXSkgJiAweEZGXTtcbiAgfVxuXG4gIHJldHVybiAoY3JjIF4gKC0xKSk7IC8vID4+PiAwO1xufVxuXG5cbm1vZHVsZS5leHBvcnRzID0gY3JjMzI7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyAgID0gcmVxdWlyZSgnLi4vdXRpbHMvY29tbW9uJyk7XG52YXIgdHJlZXMgICA9IHJlcXVpcmUoJy4vdHJlZXMnKTtcbnZhciBhZGxlcjMyID0gcmVxdWlyZSgnLi9hZGxlcjMyJyk7XG52YXIgY3JjMzIgICA9IHJlcXVpcmUoJy4vY3JjMzInKTtcbnZhciBtc2cgICAgID0gcmVxdWlyZSgnLi9tZXNzYWdlcycpO1xuXG4vKiBQdWJsaWMgY29uc3RhbnRzID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuXG4vKiBBbGxvd2VkIGZsdXNoIHZhbHVlczsgc2VlIGRlZmxhdGUoKSBhbmQgaW5mbGF0ZSgpIGJlbG93IGZvciBkZXRhaWxzICovXG52YXIgWl9OT19GTFVTSCAgICAgID0gMDtcbnZhciBaX1BBUlRJQUxfRkxVU0ggPSAxO1xuLy92YXIgWl9TWU5DX0ZMVVNIICAgID0gMjtcbnZhciBaX0ZVTExfRkxVU0ggICAgPSAzO1xudmFyIFpfRklOSVNIICAgICAgICA9IDQ7XG52YXIgWl9CTE9DSyAgICAgICAgID0gNTtcbi8vdmFyIFpfVFJFRVMgICAgICAgICA9IDY7XG5cblxuLyogUmV0dXJuIGNvZGVzIGZvciB0aGUgY29tcHJlc3Npb24vZGVjb21wcmVzc2lvbiBmdW5jdGlvbnMuIE5lZ2F0aXZlIHZhbHVlc1xuICogYXJlIGVycm9ycywgcG9zaXRpdmUgdmFsdWVzIGFyZSB1c2VkIGZvciBzcGVjaWFsIGJ1dCBub3JtYWwgZXZlbnRzLlxuICovXG52YXIgWl9PSyAgICAgICAgICAgID0gMDtcbnZhciBaX1NUUkVBTV9FTkQgICAgPSAxO1xuLy92YXIgWl9ORUVEX0RJQ1QgICAgID0gMjtcbi8vdmFyIFpfRVJSTk8gICAgICAgICA9IC0xO1xudmFyIFpfU1RSRUFNX0VSUk9SICA9IC0yO1xudmFyIFpfREFUQV9FUlJPUiAgICA9IC0zO1xuLy92YXIgWl9NRU1fRVJST1IgICAgID0gLTQ7XG52YXIgWl9CVUZfRVJST1IgICAgID0gLTU7XG4vL3ZhciBaX1ZFUlNJT05fRVJST1IgPSAtNjtcblxuXG4vKiBjb21wcmVzc2lvbiBsZXZlbHMgKi9cbi8vdmFyIFpfTk9fQ09NUFJFU1NJT04gICAgICA9IDA7XG4vL3ZhciBaX0JFU1RfU1BFRUQgICAgICAgICAgPSAxO1xuLy92YXIgWl9CRVNUX0NPTVBSRVNTSU9OICAgID0gOTtcbnZhciBaX0RFRkFVTFRfQ09NUFJFU1NJT04gPSAtMTtcblxuXG52YXIgWl9GSUxURVJFRCAgICAgICAgICAgID0gMTtcbnZhciBaX0hVRkZNQU5fT05MWSAgICAgICAgPSAyO1xudmFyIFpfUkxFICAgICAgICAgICAgICAgICA9IDM7XG52YXIgWl9GSVhFRCAgICAgICAgICAgICAgID0gNDtcbnZhciBaX0RFRkFVTFRfU1RSQVRFR1kgICAgPSAwO1xuXG4vKiBQb3NzaWJsZSB2YWx1ZXMgb2YgdGhlIGRhdGFfdHlwZSBmaWVsZCAodGhvdWdoIHNlZSBpbmZsYXRlKCkpICovXG4vL3ZhciBaX0JJTkFSWSAgICAgICAgICAgICAgPSAwO1xuLy92YXIgWl9URVhUICAgICAgICAgICAgICAgID0gMTtcbi8vdmFyIFpfQVNDSUkgICAgICAgICAgICAgICA9IDE7IC8vID0gWl9URVhUXG52YXIgWl9VTktOT1dOICAgICAgICAgICAgID0gMjtcblxuXG4vKiBUaGUgZGVmbGF0ZSBjb21wcmVzc2lvbiBtZXRob2QgKi9cbnZhciBaX0RFRkxBVEVEICA9IDg7XG5cbi8qPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cblxudmFyIE1BWF9NRU1fTEVWRUwgPSA5O1xuLyogTWF4aW11bSB2YWx1ZSBmb3IgbWVtTGV2ZWwgaW4gZGVmbGF0ZUluaXQyICovXG52YXIgTUFYX1dCSVRTID0gMTU7XG4vKiAzMksgTFo3NyB3aW5kb3cgKi9cbnZhciBERUZfTUVNX0xFVkVMID0gODtcblxuXG52YXIgTEVOR1RIX0NPREVTICA9IDI5O1xuLyogbnVtYmVyIG9mIGxlbmd0aCBjb2Rlcywgbm90IGNvdW50aW5nIHRoZSBzcGVjaWFsIEVORF9CTE9DSyBjb2RlICovXG52YXIgTElURVJBTFMgICAgICA9IDI1Njtcbi8qIG51bWJlciBvZiBsaXRlcmFsIGJ5dGVzIDAuLjI1NSAqL1xudmFyIExfQ09ERVMgICAgICAgPSBMSVRFUkFMUyArIDEgKyBMRU5HVEhfQ09ERVM7XG4vKiBudW1iZXIgb2YgTGl0ZXJhbCBvciBMZW5ndGggY29kZXMsIGluY2x1ZGluZyB0aGUgRU5EX0JMT0NLIGNvZGUgKi9cbnZhciBEX0NPREVTICAgICAgID0gMzA7XG4vKiBudW1iZXIgb2YgZGlzdGFuY2UgY29kZXMgKi9cbnZhciBCTF9DT0RFUyAgICAgID0gMTk7XG4vKiBudW1iZXIgb2YgY29kZXMgdXNlZCB0byB0cmFuc2ZlciB0aGUgYml0IGxlbmd0aHMgKi9cbnZhciBIRUFQX1NJWkUgICAgID0gMiAqIExfQ09ERVMgKyAxO1xuLyogbWF4aW11bSBoZWFwIHNpemUgKi9cbnZhciBNQVhfQklUUyAgPSAxNTtcbi8qIEFsbCBjb2RlcyBtdXN0IG5vdCBleGNlZWQgTUFYX0JJVFMgYml0cyAqL1xuXG52YXIgTUlOX01BVENIID0gMztcbnZhciBNQVhfTUFUQ0ggPSAyNTg7XG52YXIgTUlOX0xPT0tBSEVBRCA9IChNQVhfTUFUQ0ggKyBNSU5fTUFUQ0ggKyAxKTtcblxudmFyIFBSRVNFVF9ESUNUID0gMHgyMDtcblxudmFyIElOSVRfU1RBVEUgPSA0MjtcbnZhciBFWFRSQV9TVEFURSA9IDY5O1xudmFyIE5BTUVfU1RBVEUgPSA3MztcbnZhciBDT01NRU5UX1NUQVRFID0gOTE7XG52YXIgSENSQ19TVEFURSA9IDEwMztcbnZhciBCVVNZX1NUQVRFID0gMTEzO1xudmFyIEZJTklTSF9TVEFURSA9IDY2NjtcblxudmFyIEJTX05FRURfTU9SRSAgICAgID0gMTsgLyogYmxvY2sgbm90IGNvbXBsZXRlZCwgbmVlZCBtb3JlIGlucHV0IG9yIG1vcmUgb3V0cHV0ICovXG52YXIgQlNfQkxPQ0tfRE9ORSAgICAgPSAyOyAvKiBibG9jayBmbHVzaCBwZXJmb3JtZWQgKi9cbnZhciBCU19GSU5JU0hfU1RBUlRFRCA9IDM7IC8qIGZpbmlzaCBzdGFydGVkLCBuZWVkIG9ubHkgbW9yZSBvdXRwdXQgYXQgbmV4dCBkZWZsYXRlICovXG52YXIgQlNfRklOSVNIX0RPTkUgICAgPSA0OyAvKiBmaW5pc2ggZG9uZSwgYWNjZXB0IG5vIG1vcmUgaW5wdXQgb3Igb3V0cHV0ICovXG5cbnZhciBPU19DT0RFID0gMHgwMzsgLy8gVW5peCA6KSAuIERvbid0IGRldGVjdCwgdXNlIHRoaXMgZGVmYXVsdC5cblxuZnVuY3Rpb24gZXJyKHN0cm0sIGVycm9yQ29kZSkge1xuICBzdHJtLm1zZyA9IG1zZ1tlcnJvckNvZGVdO1xuICByZXR1cm4gZXJyb3JDb2RlO1xufVxuXG5mdW5jdGlvbiByYW5rKGYpIHtcbiAgcmV0dXJuICgoZikgPDwgMSkgLSAoKGYpID4gNCA/IDkgOiAwKTtcbn1cblxuZnVuY3Rpb24gemVybyhidWYpIHsgdmFyIGxlbiA9IGJ1Zi5sZW5ndGg7IHdoaWxlICgtLWxlbiA+PSAwKSB7IGJ1ZltsZW5dID0gMDsgfSB9XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogRmx1c2ggYXMgbXVjaCBwZW5kaW5nIG91dHB1dCBhcyBwb3NzaWJsZS4gQWxsIGRlZmxhdGUoKSBvdXRwdXQgZ29lc1xuICogdGhyb3VnaCB0aGlzIGZ1bmN0aW9uIHNvIHNvbWUgYXBwbGljYXRpb25zIG1heSB3aXNoIHRvIG1vZGlmeSBpdFxuICogdG8gYXZvaWQgYWxsb2NhdGluZyBhIGxhcmdlIHN0cm0tPm91dHB1dCBidWZmZXIgYW5kIGNvcHlpbmcgaW50byBpdC5cbiAqIChTZWUgYWxzbyByZWFkX2J1ZigpKS5cbiAqL1xuZnVuY3Rpb24gZmx1c2hfcGVuZGluZyhzdHJtKSB7XG4gIHZhciBzID0gc3RybS5zdGF0ZTtcblxuICAvL190cl9mbHVzaF9iaXRzKHMpO1xuICB2YXIgbGVuID0gcy5wZW5kaW5nO1xuICBpZiAobGVuID4gc3RybS5hdmFpbF9vdXQpIHtcbiAgICBsZW4gPSBzdHJtLmF2YWlsX291dDtcbiAgfVxuICBpZiAobGVuID09PSAwKSB7IHJldHVybjsgfVxuXG4gIHV0aWxzLmFycmF5U2V0KHN0cm0ub3V0cHV0LCBzLnBlbmRpbmdfYnVmLCBzLnBlbmRpbmdfb3V0LCBsZW4sIHN0cm0ubmV4dF9vdXQpO1xuICBzdHJtLm5leHRfb3V0ICs9IGxlbjtcbiAgcy5wZW5kaW5nX291dCArPSBsZW47XG4gIHN0cm0udG90YWxfb3V0ICs9IGxlbjtcbiAgc3RybS5hdmFpbF9vdXQgLT0gbGVuO1xuICBzLnBlbmRpbmcgLT0gbGVuO1xuICBpZiAocy5wZW5kaW5nID09PSAwKSB7XG4gICAgcy5wZW5kaW5nX291dCA9IDA7XG4gIH1cbn1cblxuXG5mdW5jdGlvbiBmbHVzaF9ibG9ja19vbmx5KHMsIGxhc3QpIHtcbiAgdHJlZXMuX3RyX2ZsdXNoX2Jsb2NrKHMsIChzLmJsb2NrX3N0YXJ0ID49IDAgPyBzLmJsb2NrX3N0YXJ0IDogLTEpLCBzLnN0cnN0YXJ0IC0gcy5ibG9ja19zdGFydCwgbGFzdCk7XG4gIHMuYmxvY2tfc3RhcnQgPSBzLnN0cnN0YXJ0O1xuICBmbHVzaF9wZW5kaW5nKHMuc3RybSk7XG59XG5cblxuZnVuY3Rpb24gcHV0X2J5dGUocywgYikge1xuICBzLnBlbmRpbmdfYnVmW3MucGVuZGluZysrXSA9IGI7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogUHV0IGEgc2hvcnQgaW4gdGhlIHBlbmRpbmcgYnVmZmVyLiBUaGUgMTYtYml0IHZhbHVlIGlzIHB1dCBpbiBNU0Igb3JkZXIuXG4gKiBJTiBhc3NlcnRpb246IHRoZSBzdHJlYW0gc3RhdGUgaXMgY29ycmVjdCBhbmQgdGhlcmUgaXMgZW5vdWdoIHJvb20gaW5cbiAqIHBlbmRpbmdfYnVmLlxuICovXG5mdW5jdGlvbiBwdXRTaG9ydE1TQihzLCBiKSB7XG4vLyAgcHV0X2J5dGUocywgKEJ5dGUpKGIgPj4gOCkpO1xuLy8gIHB1dF9ieXRlKHMsIChCeXRlKShiICYgMHhmZikpO1xuICBzLnBlbmRpbmdfYnVmW3MucGVuZGluZysrXSA9IChiID4+PiA4KSAmIDB4ZmY7XG4gIHMucGVuZGluZ19idWZbcy5wZW5kaW5nKytdID0gYiAmIDB4ZmY7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBSZWFkIGEgbmV3IGJ1ZmZlciBmcm9tIHRoZSBjdXJyZW50IGlucHV0IHN0cmVhbSwgdXBkYXRlIHRoZSBhZGxlcjMyXG4gKiBhbmQgdG90YWwgbnVtYmVyIG9mIGJ5dGVzIHJlYWQuICBBbGwgZGVmbGF0ZSgpIGlucHV0IGdvZXMgdGhyb3VnaFxuICogdGhpcyBmdW5jdGlvbiBzbyBzb21lIGFwcGxpY2F0aW9ucyBtYXkgd2lzaCB0byBtb2RpZnkgaXQgdG8gYXZvaWRcbiAqIGFsbG9jYXRpbmcgYSBsYXJnZSBzdHJtLT5pbnB1dCBidWZmZXIgYW5kIGNvcHlpbmcgZnJvbSBpdC5cbiAqIChTZWUgYWxzbyBmbHVzaF9wZW5kaW5nKCkpLlxuICovXG5mdW5jdGlvbiByZWFkX2J1ZihzdHJtLCBidWYsIHN0YXJ0LCBzaXplKSB7XG4gIHZhciBsZW4gPSBzdHJtLmF2YWlsX2luO1xuXG4gIGlmIChsZW4gPiBzaXplKSB7IGxlbiA9IHNpemU7IH1cbiAgaWYgKGxlbiA9PT0gMCkgeyByZXR1cm4gMDsgfVxuXG4gIHN0cm0uYXZhaWxfaW4gLT0gbGVuO1xuXG4gIC8vIHptZW1jcHkoYnVmLCBzdHJtLT5uZXh0X2luLCBsZW4pO1xuICB1dGlscy5hcnJheVNldChidWYsIHN0cm0uaW5wdXQsIHN0cm0ubmV4dF9pbiwgbGVuLCBzdGFydCk7XG4gIGlmIChzdHJtLnN0YXRlLndyYXAgPT09IDEpIHtcbiAgICBzdHJtLmFkbGVyID0gYWRsZXIzMihzdHJtLmFkbGVyLCBidWYsIGxlbiwgc3RhcnQpO1xuICB9XG5cbiAgZWxzZSBpZiAoc3RybS5zdGF0ZS53cmFwID09PSAyKSB7XG4gICAgc3RybS5hZGxlciA9IGNyYzMyKHN0cm0uYWRsZXIsIGJ1ZiwgbGVuLCBzdGFydCk7XG4gIH1cblxuICBzdHJtLm5leHRfaW4gKz0gbGVuO1xuICBzdHJtLnRvdGFsX2luICs9IGxlbjtcblxuICByZXR1cm4gbGVuO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogU2V0IG1hdGNoX3N0YXJ0IHRvIHRoZSBsb25nZXN0IG1hdGNoIHN0YXJ0aW5nIGF0IHRoZSBnaXZlbiBzdHJpbmcgYW5kXG4gKiByZXR1cm4gaXRzIGxlbmd0aC4gTWF0Y2hlcyBzaG9ydGVyIG9yIGVxdWFsIHRvIHByZXZfbGVuZ3RoIGFyZSBkaXNjYXJkZWQsXG4gKiBpbiB3aGljaCBjYXNlIHRoZSByZXN1bHQgaXMgZXF1YWwgdG8gcHJldl9sZW5ndGggYW5kIG1hdGNoX3N0YXJ0IGlzXG4gKiBnYXJiYWdlLlxuICogSU4gYXNzZXJ0aW9uczogY3VyX21hdGNoIGlzIHRoZSBoZWFkIG9mIHRoZSBoYXNoIGNoYWluIGZvciB0aGUgY3VycmVudFxuICogICBzdHJpbmcgKHN0cnN0YXJ0KSBhbmQgaXRzIGRpc3RhbmNlIGlzIDw9IE1BWF9ESVNULCBhbmQgcHJldl9sZW5ndGggPj0gMVxuICogT1VUIGFzc2VydGlvbjogdGhlIG1hdGNoIGxlbmd0aCBpcyBub3QgZ3JlYXRlciB0aGFuIHMtPmxvb2thaGVhZC5cbiAqL1xuZnVuY3Rpb24gbG9uZ2VzdF9tYXRjaChzLCBjdXJfbWF0Y2gpIHtcbiAgdmFyIGNoYWluX2xlbmd0aCA9IHMubWF4X2NoYWluX2xlbmd0aDsgICAgICAvKiBtYXggaGFzaCBjaGFpbiBsZW5ndGggKi9cbiAgdmFyIHNjYW4gPSBzLnN0cnN0YXJ0OyAvKiBjdXJyZW50IHN0cmluZyAqL1xuICB2YXIgbWF0Y2g7ICAgICAgICAgICAgICAgICAgICAgICAvKiBtYXRjaGVkIHN0cmluZyAqL1xuICB2YXIgbGVuOyAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIGxlbmd0aCBvZiBjdXJyZW50IG1hdGNoICovXG4gIHZhciBiZXN0X2xlbiA9IHMucHJldl9sZW5ndGg7ICAgICAgICAgICAgICAvKiBiZXN0IG1hdGNoIGxlbmd0aCBzbyBmYXIgKi9cbiAgdmFyIG5pY2VfbWF0Y2ggPSBzLm5pY2VfbWF0Y2g7ICAgICAgICAgICAgIC8qIHN0b3AgaWYgbWF0Y2ggbG9uZyBlbm91Z2ggKi9cbiAgdmFyIGxpbWl0ID0gKHMuc3Ryc3RhcnQgPiAocy53X3NpemUgLSBNSU5fTE9PS0FIRUFEKSkgP1xuICAgICAgcy5zdHJzdGFydCAtIChzLndfc2l6ZSAtIE1JTl9MT09LQUhFQUQpIDogMC8qTklMKi87XG5cbiAgdmFyIF93aW4gPSBzLndpbmRvdzsgLy8gc2hvcnRjdXRcblxuICB2YXIgd21hc2sgPSBzLndfbWFzaztcbiAgdmFyIHByZXYgID0gcy5wcmV2O1xuXG4gIC8qIFN0b3Agd2hlbiBjdXJfbWF0Y2ggYmVjb21lcyA8PSBsaW1pdC4gVG8gc2ltcGxpZnkgdGhlIGNvZGUsXG4gICAqIHdlIHByZXZlbnQgbWF0Y2hlcyB3aXRoIHRoZSBzdHJpbmcgb2Ygd2luZG93IGluZGV4IDAuXG4gICAqL1xuXG4gIHZhciBzdHJlbmQgPSBzLnN0cnN0YXJ0ICsgTUFYX01BVENIO1xuICB2YXIgc2Nhbl9lbmQxICA9IF93aW5bc2NhbiArIGJlc3RfbGVuIC0gMV07XG4gIHZhciBzY2FuX2VuZCAgID0gX3dpbltzY2FuICsgYmVzdF9sZW5dO1xuXG4gIC8qIFRoZSBjb2RlIGlzIG9wdGltaXplZCBmb3IgSEFTSF9CSVRTID49IDggYW5kIE1BWF9NQVRDSC0yIG11bHRpcGxlIG9mIDE2LlxuICAgKiBJdCBpcyBlYXN5IHRvIGdldCByaWQgb2YgdGhpcyBvcHRpbWl6YXRpb24gaWYgbmVjZXNzYXJ5LlxuICAgKi9cbiAgLy8gQXNzZXJ0KHMtPmhhc2hfYml0cyA+PSA4ICYmIE1BWF9NQVRDSCA9PSAyNTgsIFwiQ29kZSB0b28gY2xldmVyXCIpO1xuXG4gIC8qIERvIG5vdCB3YXN0ZSB0b28gbXVjaCB0aW1lIGlmIHdlIGFscmVhZHkgaGF2ZSBhIGdvb2QgbWF0Y2g6ICovXG4gIGlmIChzLnByZXZfbGVuZ3RoID49IHMuZ29vZF9tYXRjaCkge1xuICAgIGNoYWluX2xlbmd0aCA+Pj0gMjtcbiAgfVxuICAvKiBEbyBub3QgbG9vayBmb3IgbWF0Y2hlcyBiZXlvbmQgdGhlIGVuZCBvZiB0aGUgaW5wdXQuIFRoaXMgaXMgbmVjZXNzYXJ5XG4gICAqIHRvIG1ha2UgZGVmbGF0ZSBkZXRlcm1pbmlzdGljLlxuICAgKi9cbiAgaWYgKG5pY2VfbWF0Y2ggPiBzLmxvb2thaGVhZCkgeyBuaWNlX21hdGNoID0gcy5sb29rYWhlYWQ7IH1cblxuICAvLyBBc3NlcnQoKHVsZylzLT5zdHJzdGFydCA8PSBzLT53aW5kb3dfc2l6ZS1NSU5fTE9PS0FIRUFELCBcIm5lZWQgbG9va2FoZWFkXCIpO1xuXG4gIGRvIHtcbiAgICAvLyBBc3NlcnQoY3VyX21hdGNoIDwgcy0+c3Ryc3RhcnQsIFwibm8gZnV0dXJlXCIpO1xuICAgIG1hdGNoID0gY3VyX21hdGNoO1xuXG4gICAgLyogU2tpcCB0byBuZXh0IG1hdGNoIGlmIHRoZSBtYXRjaCBsZW5ndGggY2Fubm90IGluY3JlYXNlXG4gICAgICogb3IgaWYgdGhlIG1hdGNoIGxlbmd0aCBpcyBsZXNzIHRoYW4gMi4gIE5vdGUgdGhhdCB0aGUgY2hlY2tzIGJlbG93XG4gICAgICogZm9yIGluc3VmZmljaWVudCBsb29rYWhlYWQgb25seSBvY2N1ciBvY2Nhc2lvbmFsbHkgZm9yIHBlcmZvcm1hbmNlXG4gICAgICogcmVhc29ucy4gIFRoZXJlZm9yZSB1bmluaXRpYWxpemVkIG1lbW9yeSB3aWxsIGJlIGFjY2Vzc2VkLCBhbmRcbiAgICAgKiBjb25kaXRpb25hbCBqdW1wcyB3aWxsIGJlIG1hZGUgdGhhdCBkZXBlbmQgb24gdGhvc2UgdmFsdWVzLlxuICAgICAqIEhvd2V2ZXIgdGhlIGxlbmd0aCBvZiB0aGUgbWF0Y2ggaXMgbGltaXRlZCB0byB0aGUgbG9va2FoZWFkLCBzb1xuICAgICAqIHRoZSBvdXRwdXQgb2YgZGVmbGF0ZSBpcyBub3QgYWZmZWN0ZWQgYnkgdGhlIHVuaW5pdGlhbGl6ZWQgdmFsdWVzLlxuICAgICAqL1xuXG4gICAgaWYgKF93aW5bbWF0Y2ggKyBiZXN0X2xlbl0gICAgICE9PSBzY2FuX2VuZCAgfHxcbiAgICAgICAgX3dpblttYXRjaCArIGJlc3RfbGVuIC0gMV0gIT09IHNjYW5fZW5kMSB8fFxuICAgICAgICBfd2luW21hdGNoXSAgICAgICAgICAgICAgICAhPT0gX3dpbltzY2FuXSB8fFxuICAgICAgICBfd2luWysrbWF0Y2hdICAgICAgICAgICAgICAhPT0gX3dpbltzY2FuICsgMV0pIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8qIFRoZSBjaGVjayBhdCBiZXN0X2xlbi0xIGNhbiBiZSByZW1vdmVkIGJlY2F1c2UgaXQgd2lsbCBiZSBtYWRlXG4gICAgICogYWdhaW4gbGF0ZXIuIChUaGlzIGhldXJpc3RpYyBpcyBub3QgYWx3YXlzIGEgd2luLilcbiAgICAgKiBJdCBpcyBub3QgbmVjZXNzYXJ5IHRvIGNvbXBhcmUgc2NhblsyXSBhbmQgbWF0Y2hbMl0gc2luY2UgdGhleVxuICAgICAqIGFyZSBhbHdheXMgZXF1YWwgd2hlbiB0aGUgb3RoZXIgYnl0ZXMgbWF0Y2gsIGdpdmVuIHRoYXRcbiAgICAgKiB0aGUgaGFzaCBrZXlzIGFyZSBlcXVhbCBhbmQgdGhhdCBIQVNIX0JJVFMgPj0gOC5cbiAgICAgKi9cbiAgICBzY2FuICs9IDI7XG4gICAgbWF0Y2grKztcbiAgICAvLyBBc3NlcnQoKnNjYW4gPT0gKm1hdGNoLCBcIm1hdGNoWzJdP1wiKTtcblxuICAgIC8qIFdlIGNoZWNrIGZvciBpbnN1ZmZpY2llbnQgbG9va2FoZWFkIG9ubHkgZXZlcnkgOHRoIGNvbXBhcmlzb247XG4gICAgICogdGhlIDI1NnRoIGNoZWNrIHdpbGwgYmUgbWFkZSBhdCBzdHJzdGFydCsyNTguXG4gICAgICovXG4gICAgZG8ge1xuICAgICAgLypqc2hpbnQgbm9lbXB0eTpmYWxzZSovXG4gICAgfSB3aGlsZSAoX3dpblsrK3NjYW5dID09PSBfd2luWysrbWF0Y2hdICYmIF93aW5bKytzY2FuXSA9PT0gX3dpblsrK21hdGNoXSAmJlxuICAgICAgICAgICAgIF93aW5bKytzY2FuXSA9PT0gX3dpblsrK21hdGNoXSAmJiBfd2luWysrc2Nhbl0gPT09IF93aW5bKyttYXRjaF0gJiZcbiAgICAgICAgICAgICBfd2luWysrc2Nhbl0gPT09IF93aW5bKyttYXRjaF0gJiYgX3dpblsrK3NjYW5dID09PSBfd2luWysrbWF0Y2hdICYmXG4gICAgICAgICAgICAgX3dpblsrK3NjYW5dID09PSBfd2luWysrbWF0Y2hdICYmIF93aW5bKytzY2FuXSA9PT0gX3dpblsrK21hdGNoXSAmJlxuICAgICAgICAgICAgIHNjYW4gPCBzdHJlbmQpO1xuXG4gICAgLy8gQXNzZXJ0KHNjYW4gPD0gcy0+d2luZG93Kyh1bnNpZ25lZCkocy0+d2luZG93X3NpemUtMSksIFwid2lsZCBzY2FuXCIpO1xuXG4gICAgbGVuID0gTUFYX01BVENIIC0gKHN0cmVuZCAtIHNjYW4pO1xuICAgIHNjYW4gPSBzdHJlbmQgLSBNQVhfTUFUQ0g7XG5cbiAgICBpZiAobGVuID4gYmVzdF9sZW4pIHtcbiAgICAgIHMubWF0Y2hfc3RhcnQgPSBjdXJfbWF0Y2g7XG4gICAgICBiZXN0X2xlbiA9IGxlbjtcbiAgICAgIGlmIChsZW4gPj0gbmljZV9tYXRjaCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHNjYW5fZW5kMSAgPSBfd2luW3NjYW4gKyBiZXN0X2xlbiAtIDFdO1xuICAgICAgc2Nhbl9lbmQgICA9IF93aW5bc2NhbiArIGJlc3RfbGVuXTtcbiAgICB9XG4gIH0gd2hpbGUgKChjdXJfbWF0Y2ggPSBwcmV2W2N1cl9tYXRjaCAmIHdtYXNrXSkgPiBsaW1pdCAmJiAtLWNoYWluX2xlbmd0aCAhPT0gMCk7XG5cbiAgaWYgKGJlc3RfbGVuIDw9IHMubG9va2FoZWFkKSB7XG4gICAgcmV0dXJuIGJlc3RfbGVuO1xuICB9XG4gIHJldHVybiBzLmxvb2thaGVhZDtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEZpbGwgdGhlIHdpbmRvdyB3aGVuIHRoZSBsb29rYWhlYWQgYmVjb21lcyBpbnN1ZmZpY2llbnQuXG4gKiBVcGRhdGVzIHN0cnN0YXJ0IGFuZCBsb29rYWhlYWQuXG4gKlxuICogSU4gYXNzZXJ0aW9uOiBsb29rYWhlYWQgPCBNSU5fTE9PS0FIRUFEXG4gKiBPVVQgYXNzZXJ0aW9uczogc3Ryc3RhcnQgPD0gd2luZG93X3NpemUtTUlOX0xPT0tBSEVBRFxuICogICAgQXQgbGVhc3Qgb25lIGJ5dGUgaGFzIGJlZW4gcmVhZCwgb3IgYXZhaWxfaW4gPT0gMDsgcmVhZHMgYXJlXG4gKiAgICBwZXJmb3JtZWQgZm9yIGF0IGxlYXN0IHR3byBieXRlcyAocmVxdWlyZWQgZm9yIHRoZSB6aXAgdHJhbnNsYXRlX2VvbFxuICogICAgb3B0aW9uIC0tIG5vdCBzdXBwb3J0ZWQgaGVyZSkuXG4gKi9cbmZ1bmN0aW9uIGZpbGxfd2luZG93KHMpIHtcbiAgdmFyIF93X3NpemUgPSBzLndfc2l6ZTtcbiAgdmFyIHAsIG4sIG0sIG1vcmUsIHN0cjtcblxuICAvL0Fzc2VydChzLT5sb29rYWhlYWQgPCBNSU5fTE9PS0FIRUFELCBcImFscmVhZHkgZW5vdWdoIGxvb2thaGVhZFwiKTtcblxuICBkbyB7XG4gICAgbW9yZSA9IHMud2luZG93X3NpemUgLSBzLmxvb2thaGVhZCAtIHMuc3Ryc3RhcnQ7XG5cbiAgICAvLyBKUyBpbnRzIGhhdmUgMzIgYml0LCBibG9jayBiZWxvdyBub3QgbmVlZGVkXG4gICAgLyogRGVhbCB3aXRoICFAIyQlIDY0SyBsaW1pdDogKi9cbiAgICAvL2lmIChzaXplb2YoaW50KSA8PSAyKSB7XG4gICAgLy8gICAgaWYgKG1vcmUgPT0gMCAmJiBzLT5zdHJzdGFydCA9PSAwICYmIHMtPmxvb2thaGVhZCA9PSAwKSB7XG4gICAgLy8gICAgICAgIG1vcmUgPSB3c2l6ZTtcbiAgICAvL1xuICAgIC8vICB9IGVsc2UgaWYgKG1vcmUgPT0gKHVuc2lnbmVkKSgtMSkpIHtcbiAgICAvLyAgICAgICAgLyogVmVyeSB1bmxpa2VseSwgYnV0IHBvc3NpYmxlIG9uIDE2IGJpdCBtYWNoaW5lIGlmXG4gICAgLy8gICAgICAgICAqIHN0cnN0YXJ0ID09IDAgJiYgbG9va2FoZWFkID09IDEgKGlucHV0IGRvbmUgYSBieXRlIGF0IHRpbWUpXG4gICAgLy8gICAgICAgICAqL1xuICAgIC8vICAgICAgICBtb3JlLS07XG4gICAgLy8gICAgfVxuICAgIC8vfVxuXG5cbiAgICAvKiBJZiB0aGUgd2luZG93IGlzIGFsbW9zdCBmdWxsIGFuZCB0aGVyZSBpcyBpbnN1ZmZpY2llbnQgbG9va2FoZWFkLFxuICAgICAqIG1vdmUgdGhlIHVwcGVyIGhhbGYgdG8gdGhlIGxvd2VyIG9uZSB0byBtYWtlIHJvb20gaW4gdGhlIHVwcGVyIGhhbGYuXG4gICAgICovXG4gICAgaWYgKHMuc3Ryc3RhcnQgPj0gX3dfc2l6ZSArIChfd19zaXplIC0gTUlOX0xPT0tBSEVBRCkpIHtcblxuICAgICAgdXRpbHMuYXJyYXlTZXQocy53aW5kb3csIHMud2luZG93LCBfd19zaXplLCBfd19zaXplLCAwKTtcbiAgICAgIHMubWF0Y2hfc3RhcnQgLT0gX3dfc2l6ZTtcbiAgICAgIHMuc3Ryc3RhcnQgLT0gX3dfc2l6ZTtcbiAgICAgIC8qIHdlIG5vdyBoYXZlIHN0cnN0YXJ0ID49IE1BWF9ESVNUICovXG4gICAgICBzLmJsb2NrX3N0YXJ0IC09IF93X3NpemU7XG5cbiAgICAgIC8qIFNsaWRlIHRoZSBoYXNoIHRhYmxlIChjb3VsZCBiZSBhdm9pZGVkIHdpdGggMzIgYml0IHZhbHVlc1xuICAgICAgIGF0IHRoZSBleHBlbnNlIG9mIG1lbW9yeSB1c2FnZSkuIFdlIHNsaWRlIGV2ZW4gd2hlbiBsZXZlbCA9PSAwXG4gICAgICAgdG8ga2VlcCB0aGUgaGFzaCB0YWJsZSBjb25zaXN0ZW50IGlmIHdlIHN3aXRjaCBiYWNrIHRvIGxldmVsID4gMFxuICAgICAgIGxhdGVyLiAoVXNpbmcgbGV2ZWwgMCBwZXJtYW5lbnRseSBpcyBub3QgYW4gb3B0aW1hbCB1c2FnZSBvZlxuICAgICAgIHpsaWIsIHNvIHdlIGRvbid0IGNhcmUgYWJvdXQgdGhpcyBwYXRob2xvZ2ljYWwgY2FzZS4pXG4gICAgICAgKi9cblxuICAgICAgbiA9IHMuaGFzaF9zaXplO1xuICAgICAgcCA9IG47XG4gICAgICBkbyB7XG4gICAgICAgIG0gPSBzLmhlYWRbLS1wXTtcbiAgICAgICAgcy5oZWFkW3BdID0gKG0gPj0gX3dfc2l6ZSA/IG0gLSBfd19zaXplIDogMCk7XG4gICAgICB9IHdoaWxlICgtLW4pO1xuXG4gICAgICBuID0gX3dfc2l6ZTtcbiAgICAgIHAgPSBuO1xuICAgICAgZG8ge1xuICAgICAgICBtID0gcy5wcmV2Wy0tcF07XG4gICAgICAgIHMucHJldltwXSA9IChtID49IF93X3NpemUgPyBtIC0gX3dfc2l6ZSA6IDApO1xuICAgICAgICAvKiBJZiBuIGlzIG5vdCBvbiBhbnkgaGFzaCBjaGFpbiwgcHJldltuXSBpcyBnYXJiYWdlIGJ1dFxuICAgICAgICAgKiBpdHMgdmFsdWUgd2lsbCBuZXZlciBiZSB1c2VkLlxuICAgICAgICAgKi9cbiAgICAgIH0gd2hpbGUgKC0tbik7XG5cbiAgICAgIG1vcmUgKz0gX3dfc2l6ZTtcbiAgICB9XG4gICAgaWYgKHMuc3RybS5hdmFpbF9pbiA9PT0gMCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgLyogSWYgdGhlcmUgd2FzIG5vIHNsaWRpbmc6XG4gICAgICogICAgc3Ryc3RhcnQgPD0gV1NJWkUrTUFYX0RJU1QtMSAmJiBsb29rYWhlYWQgPD0gTUlOX0xPT0tBSEVBRCAtIDEgJiZcbiAgICAgKiAgICBtb3JlID09IHdpbmRvd19zaXplIC0gbG9va2FoZWFkIC0gc3Ryc3RhcnRcbiAgICAgKiA9PiBtb3JlID49IHdpbmRvd19zaXplIC0gKE1JTl9MT09LQUhFQUQtMSArIFdTSVpFICsgTUFYX0RJU1QtMSlcbiAgICAgKiA9PiBtb3JlID49IHdpbmRvd19zaXplIC0gMipXU0laRSArIDJcbiAgICAgKiBJbiB0aGUgQklHX01FTSBvciBNTUFQIGNhc2UgKG5vdCB5ZXQgc3VwcG9ydGVkKSxcbiAgICAgKiAgIHdpbmRvd19zaXplID09IGlucHV0X3NpemUgKyBNSU5fTE9PS0FIRUFEICAmJlxuICAgICAqICAgc3Ryc3RhcnQgKyBzLT5sb29rYWhlYWQgPD0gaW5wdXRfc2l6ZSA9PiBtb3JlID49IE1JTl9MT09LQUhFQUQuXG4gICAgICogT3RoZXJ3aXNlLCB3aW5kb3dfc2l6ZSA9PSAyKldTSVpFIHNvIG1vcmUgPj0gMi5cbiAgICAgKiBJZiB0aGVyZSB3YXMgc2xpZGluZywgbW9yZSA+PSBXU0laRS4gU28gaW4gYWxsIGNhc2VzLCBtb3JlID49IDIuXG4gICAgICovXG4gICAgLy9Bc3NlcnQobW9yZSA+PSAyLCBcIm1vcmUgPCAyXCIpO1xuICAgIG4gPSByZWFkX2J1ZihzLnN0cm0sIHMud2luZG93LCBzLnN0cnN0YXJ0ICsgcy5sb29rYWhlYWQsIG1vcmUpO1xuICAgIHMubG9va2FoZWFkICs9IG47XG5cbiAgICAvKiBJbml0aWFsaXplIHRoZSBoYXNoIHZhbHVlIG5vdyB0aGF0IHdlIGhhdmUgc29tZSBpbnB1dDogKi9cbiAgICBpZiAocy5sb29rYWhlYWQgKyBzLmluc2VydCA+PSBNSU5fTUFUQ0gpIHtcbiAgICAgIHN0ciA9IHMuc3Ryc3RhcnQgLSBzLmluc2VydDtcbiAgICAgIHMuaW5zX2ggPSBzLndpbmRvd1tzdHJdO1xuXG4gICAgICAvKiBVUERBVEVfSEFTSChzLCBzLT5pbnNfaCwgcy0+d2luZG93W3N0ciArIDFdKTsgKi9cbiAgICAgIHMuaW5zX2ggPSAoKHMuaW5zX2ggPDwgcy5oYXNoX3NoaWZ0KSBeIHMud2luZG93W3N0ciArIDFdKSAmIHMuaGFzaF9tYXNrO1xuLy8jaWYgTUlOX01BVENIICE9IDNcbi8vICAgICAgICBDYWxsIHVwZGF0ZV9oYXNoKCkgTUlOX01BVENILTMgbW9yZSB0aW1lc1xuLy8jZW5kaWZcbiAgICAgIHdoaWxlIChzLmluc2VydCkge1xuICAgICAgICAvKiBVUERBVEVfSEFTSChzLCBzLT5pbnNfaCwgcy0+d2luZG93W3N0ciArIE1JTl9NQVRDSC0xXSk7ICovXG4gICAgICAgIHMuaW5zX2ggPSAoKHMuaW5zX2ggPDwgcy5oYXNoX3NoaWZ0KSBeIHMud2luZG93W3N0ciArIE1JTl9NQVRDSCAtIDFdKSAmIHMuaGFzaF9tYXNrO1xuXG4gICAgICAgIHMucHJldltzdHIgJiBzLndfbWFza10gPSBzLmhlYWRbcy5pbnNfaF07XG4gICAgICAgIHMuaGVhZFtzLmluc19oXSA9IHN0cjtcbiAgICAgICAgc3RyKys7XG4gICAgICAgIHMuaW5zZXJ0LS07XG4gICAgICAgIGlmIChzLmxvb2thaGVhZCArIHMuaW5zZXJ0IDwgTUlOX01BVENIKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLyogSWYgdGhlIHdob2xlIGlucHV0IGhhcyBsZXNzIHRoYW4gTUlOX01BVENIIGJ5dGVzLCBpbnNfaCBpcyBnYXJiYWdlLFxuICAgICAqIGJ1dCB0aGlzIGlzIG5vdCBpbXBvcnRhbnQgc2luY2Ugb25seSBsaXRlcmFsIGJ5dGVzIHdpbGwgYmUgZW1pdHRlZC5cbiAgICAgKi9cblxuICB9IHdoaWxlIChzLmxvb2thaGVhZCA8IE1JTl9MT09LQUhFQUQgJiYgcy5zdHJtLmF2YWlsX2luICE9PSAwKTtcblxuICAvKiBJZiB0aGUgV0lOX0lOSVQgYnl0ZXMgYWZ0ZXIgdGhlIGVuZCBvZiB0aGUgY3VycmVudCBkYXRhIGhhdmUgbmV2ZXIgYmVlblxuICAgKiB3cml0dGVuLCB0aGVuIHplcm8gdGhvc2UgYnl0ZXMgaW4gb3JkZXIgdG8gYXZvaWQgbWVtb3J5IGNoZWNrIHJlcG9ydHMgb2ZcbiAgICogdGhlIHVzZSBvZiB1bmluaXRpYWxpemVkIChvciB1bmluaXRpYWxpc2VkIGFzIEp1bGlhbiB3cml0ZXMpIGJ5dGVzIGJ5XG4gICAqIHRoZSBsb25nZXN0IG1hdGNoIHJvdXRpbmVzLiAgVXBkYXRlIHRoZSBoaWdoIHdhdGVyIG1hcmsgZm9yIHRoZSBuZXh0XG4gICAqIHRpbWUgdGhyb3VnaCBoZXJlLiAgV0lOX0lOSVQgaXMgc2V0IHRvIE1BWF9NQVRDSCBzaW5jZSB0aGUgbG9uZ2VzdCBtYXRjaFxuICAgKiByb3V0aW5lcyBhbGxvdyBzY2FubmluZyB0byBzdHJzdGFydCArIE1BWF9NQVRDSCwgaWdub3JpbmcgbG9va2FoZWFkLlxuICAgKi9cbi8vICBpZiAocy5oaWdoX3dhdGVyIDwgcy53aW5kb3dfc2l6ZSkge1xuLy8gICAgdmFyIGN1cnIgPSBzLnN0cnN0YXJ0ICsgcy5sb29rYWhlYWQ7XG4vLyAgICB2YXIgaW5pdCA9IDA7XG4vL1xuLy8gICAgaWYgKHMuaGlnaF93YXRlciA8IGN1cnIpIHtcbi8vICAgICAgLyogUHJldmlvdXMgaGlnaCB3YXRlciBtYXJrIGJlbG93IGN1cnJlbnQgZGF0YSAtLSB6ZXJvIFdJTl9JTklUXG4vLyAgICAgICAqIGJ5dGVzIG9yIHVwIHRvIGVuZCBvZiB3aW5kb3csIHdoaWNoZXZlciBpcyBsZXNzLlxuLy8gICAgICAgKi9cbi8vICAgICAgaW5pdCA9IHMud2luZG93X3NpemUgLSBjdXJyO1xuLy8gICAgICBpZiAoaW5pdCA+IFdJTl9JTklUKVxuLy8gICAgICAgIGluaXQgPSBXSU5fSU5JVDtcbi8vICAgICAgem1lbXplcm8ocy0+d2luZG93ICsgY3VyciwgKHVuc2lnbmVkKWluaXQpO1xuLy8gICAgICBzLT5oaWdoX3dhdGVyID0gY3VyciArIGluaXQ7XG4vLyAgICB9XG4vLyAgICBlbHNlIGlmIChzLT5oaWdoX3dhdGVyIDwgKHVsZyljdXJyICsgV0lOX0lOSVQpIHtcbi8vICAgICAgLyogSGlnaCB3YXRlciBtYXJrIGF0IG9yIGFib3ZlIGN1cnJlbnQgZGF0YSwgYnV0IGJlbG93IGN1cnJlbnQgZGF0YVxuLy8gICAgICAgKiBwbHVzIFdJTl9JTklUIC0tIHplcm8gb3V0IHRvIGN1cnJlbnQgZGF0YSBwbHVzIFdJTl9JTklULCBvciB1cFxuLy8gICAgICAgKiB0byBlbmQgb2Ygd2luZG93LCB3aGljaGV2ZXIgaXMgbGVzcy5cbi8vICAgICAgICovXG4vLyAgICAgIGluaXQgPSAodWxnKWN1cnIgKyBXSU5fSU5JVCAtIHMtPmhpZ2hfd2F0ZXI7XG4vLyAgICAgIGlmIChpbml0ID4gcy0+d2luZG93X3NpemUgLSBzLT5oaWdoX3dhdGVyKVxuLy8gICAgICAgIGluaXQgPSBzLT53aW5kb3dfc2l6ZSAtIHMtPmhpZ2hfd2F0ZXI7XG4vLyAgICAgIHptZW16ZXJvKHMtPndpbmRvdyArIHMtPmhpZ2hfd2F0ZXIsICh1bnNpZ25lZClpbml0KTtcbi8vICAgICAgcy0+aGlnaF93YXRlciArPSBpbml0O1xuLy8gICAgfVxuLy8gIH1cbi8vXG4vLyAgQXNzZXJ0KCh1bGcpcy0+c3Ryc3RhcnQgPD0gcy0+d2luZG93X3NpemUgLSBNSU5fTE9PS0FIRUFELFxuLy8gICAgXCJub3QgZW5vdWdoIHJvb20gZm9yIHNlYXJjaFwiKTtcbn1cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDb3B5IHdpdGhvdXQgY29tcHJlc3Npb24gYXMgbXVjaCBhcyBwb3NzaWJsZSBmcm9tIHRoZSBpbnB1dCBzdHJlYW0sIHJldHVyblxuICogdGhlIGN1cnJlbnQgYmxvY2sgc3RhdGUuXG4gKiBUaGlzIGZ1bmN0aW9uIGRvZXMgbm90IGluc2VydCBuZXcgc3RyaW5ncyBpbiB0aGUgZGljdGlvbmFyeSBzaW5jZVxuICogdW5jb21wcmVzc2libGUgZGF0YSBpcyBwcm9iYWJseSBub3QgdXNlZnVsLiBUaGlzIGZ1bmN0aW9uIGlzIHVzZWRcbiAqIG9ubHkgZm9yIHRoZSBsZXZlbD0wIGNvbXByZXNzaW9uIG9wdGlvbi5cbiAqIE5PVEU6IHRoaXMgZnVuY3Rpb24gc2hvdWxkIGJlIG9wdGltaXplZCB0byBhdm9pZCBleHRyYSBjb3B5aW5nIGZyb21cbiAqIHdpbmRvdyB0byBwZW5kaW5nX2J1Zi5cbiAqL1xuZnVuY3Rpb24gZGVmbGF0ZV9zdG9yZWQocywgZmx1c2gpIHtcbiAgLyogU3RvcmVkIGJsb2NrcyBhcmUgbGltaXRlZCB0byAweGZmZmYgYnl0ZXMsIHBlbmRpbmdfYnVmIGlzIGxpbWl0ZWRcbiAgICogdG8gcGVuZGluZ19idWZfc2l6ZSwgYW5kIGVhY2ggc3RvcmVkIGJsb2NrIGhhcyBhIDUgYnl0ZSBoZWFkZXI6XG4gICAqL1xuICB2YXIgbWF4X2Jsb2NrX3NpemUgPSAweGZmZmY7XG5cbiAgaWYgKG1heF9ibG9ja19zaXplID4gcy5wZW5kaW5nX2J1Zl9zaXplIC0gNSkge1xuICAgIG1heF9ibG9ja19zaXplID0gcy5wZW5kaW5nX2J1Zl9zaXplIC0gNTtcbiAgfVxuXG4gIC8qIENvcHkgYXMgbXVjaCBhcyBwb3NzaWJsZSBmcm9tIGlucHV0IHRvIG91dHB1dDogKi9cbiAgZm9yICg7Oykge1xuICAgIC8qIEZpbGwgdGhlIHdpbmRvdyBhcyBtdWNoIGFzIHBvc3NpYmxlOiAqL1xuICAgIGlmIChzLmxvb2thaGVhZCA8PSAxKSB7XG5cbiAgICAgIC8vQXNzZXJ0KHMtPnN0cnN0YXJ0IDwgcy0+d19zaXplK01BWF9ESVNUKHMpIHx8XG4gICAgICAvLyAgcy0+YmxvY2tfc3RhcnQgPj0gKGxvbmcpcy0+d19zaXplLCBcInNsaWRlIHRvbyBsYXRlXCIpO1xuLy8gICAgICBpZiAoIShzLnN0cnN0YXJ0IDwgcy53X3NpemUgKyAocy53X3NpemUgLSBNSU5fTE9PS0FIRUFEKSB8fFxuLy8gICAgICAgIHMuYmxvY2tfc3RhcnQgPj0gcy53X3NpemUpKSB7XG4vLyAgICAgICAgdGhyb3cgIG5ldyBFcnJvcihcInNsaWRlIHRvbyBsYXRlXCIpO1xuLy8gICAgICB9XG5cbiAgICAgIGZpbGxfd2luZG93KHMpO1xuICAgICAgaWYgKHMubG9va2FoZWFkID09PSAwICYmIGZsdXNoID09PSBaX05PX0ZMVVNIKSB7XG4gICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICB9XG5cbiAgICAgIGlmIChzLmxvb2thaGVhZCA9PT0gMCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIC8qIGZsdXNoIHRoZSBjdXJyZW50IGJsb2NrICovXG4gICAgfVxuICAgIC8vQXNzZXJ0KHMtPmJsb2NrX3N0YXJ0ID49IDBMLCBcImJsb2NrIGdvbmVcIik7XG4vLyAgICBpZiAocy5ibG9ja19zdGFydCA8IDApIHRocm93IG5ldyBFcnJvcihcImJsb2NrIGdvbmVcIik7XG5cbiAgICBzLnN0cnN0YXJ0ICs9IHMubG9va2FoZWFkO1xuICAgIHMubG9va2FoZWFkID0gMDtcblxuICAgIC8qIEVtaXQgYSBzdG9yZWQgYmxvY2sgaWYgcGVuZGluZ19idWYgd2lsbCBiZSBmdWxsOiAqL1xuICAgIHZhciBtYXhfc3RhcnQgPSBzLmJsb2NrX3N0YXJ0ICsgbWF4X2Jsb2NrX3NpemU7XG5cbiAgICBpZiAocy5zdHJzdGFydCA9PT0gMCB8fCBzLnN0cnN0YXJ0ID49IG1heF9zdGFydCkge1xuICAgICAgLyogc3Ryc3RhcnQgPT0gMCBpcyBwb3NzaWJsZSB3aGVuIHdyYXBhcm91bmQgb24gMTYtYml0IG1hY2hpbmUgKi9cbiAgICAgIHMubG9va2FoZWFkID0gcy5zdHJzdGFydCAtIG1heF9zdGFydDtcbiAgICAgIHMuc3Ryc3RhcnQgPSBtYXhfc3RhcnQ7XG4gICAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDApOyAqKiovXG4gICAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICB9XG4gICAgICAvKioqL1xuXG5cbiAgICB9XG4gICAgLyogRmx1c2ggaWYgd2UgbWF5IGhhdmUgdG8gc2xpZGUsIG90aGVyd2lzZSBibG9ja19zdGFydCBtYXkgYmVjb21lXG4gICAgICogbmVnYXRpdmUgYW5kIHRoZSBkYXRhIHdpbGwgYmUgZ29uZTpcbiAgICAgKi9cbiAgICBpZiAocy5zdHJzdGFydCAtIHMuYmxvY2tfc3RhcnQgPj0gKHMud19zaXplIC0gTUlOX0xPT0tBSEVBRCkpIHtcbiAgICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgIH1cbiAgICAgIC8qKiovXG4gICAgfVxuICB9XG5cbiAgcy5pbnNlcnQgPSAwO1xuXG4gIGlmIChmbHVzaCA9PT0gWl9GSU5JU0gpIHtcbiAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDEpOyAqKiovXG4gICAgZmx1c2hfYmxvY2tfb25seShzLCB0cnVlKTtcbiAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJTX0ZJTklTSF9TVEFSVEVEO1xuICAgIH1cbiAgICAvKioqL1xuICAgIHJldHVybiBCU19GSU5JU0hfRE9ORTtcbiAgfVxuXG4gIGlmIChzLnN0cnN0YXJ0ID4gcy5ibG9ja19zdGFydCkge1xuICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICB9XG4gICAgLyoqKi9cbiAgfVxuXG4gIHJldHVybiBCU19ORUVEX01PUkU7XG59XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ29tcHJlc3MgYXMgbXVjaCBhcyBwb3NzaWJsZSBmcm9tIHRoZSBpbnB1dCBzdHJlYW0sIHJldHVybiB0aGUgY3VycmVudFxuICogYmxvY2sgc3RhdGUuXG4gKiBUaGlzIGZ1bmN0aW9uIGRvZXMgbm90IHBlcmZvcm0gbGF6eSBldmFsdWF0aW9uIG9mIG1hdGNoZXMgYW5kIGluc2VydHNcbiAqIG5ldyBzdHJpbmdzIGluIHRoZSBkaWN0aW9uYXJ5IG9ubHkgZm9yIHVubWF0Y2hlZCBzdHJpbmdzIG9yIGZvciBzaG9ydFxuICogbWF0Y2hlcy4gSXQgaXMgdXNlZCBvbmx5IGZvciB0aGUgZmFzdCBjb21wcmVzc2lvbiBvcHRpb25zLlxuICovXG5mdW5jdGlvbiBkZWZsYXRlX2Zhc3QocywgZmx1c2gpIHtcbiAgdmFyIGhhc2hfaGVhZDsgICAgICAgIC8qIGhlYWQgb2YgdGhlIGhhc2ggY2hhaW4gKi9cbiAgdmFyIGJmbHVzaDsgICAgICAgICAgIC8qIHNldCBpZiBjdXJyZW50IGJsb2NrIG11c3QgYmUgZmx1c2hlZCAqL1xuXG4gIGZvciAoOzspIHtcbiAgICAvKiBNYWtlIHN1cmUgdGhhdCB3ZSBhbHdheXMgaGF2ZSBlbm91Z2ggbG9va2FoZWFkLCBleGNlcHRcbiAgICAgKiBhdCB0aGUgZW5kIG9mIHRoZSBpbnB1dCBmaWxlLiBXZSBuZWVkIE1BWF9NQVRDSCBieXRlc1xuICAgICAqIGZvciB0aGUgbmV4dCBtYXRjaCwgcGx1cyBNSU5fTUFUQ0ggYnl0ZXMgdG8gaW5zZXJ0IHRoZVxuICAgICAqIHN0cmluZyBmb2xsb3dpbmcgdGhlIG5leHQgbWF0Y2guXG4gICAgICovXG4gICAgaWYgKHMubG9va2FoZWFkIDwgTUlOX0xPT0tBSEVBRCkge1xuICAgICAgZmlsbF93aW5kb3cocyk7XG4gICAgICBpZiAocy5sb29rYWhlYWQgPCBNSU5fTE9PS0FIRUFEICYmIGZsdXNoID09PSBaX05PX0ZMVVNIKSB7XG4gICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICB9XG4gICAgICBpZiAocy5sb29rYWhlYWQgPT09IDApIHtcbiAgICAgICAgYnJlYWs7IC8qIGZsdXNoIHRoZSBjdXJyZW50IGJsb2NrICovXG4gICAgICB9XG4gICAgfVxuXG4gICAgLyogSW5zZXJ0IHRoZSBzdHJpbmcgd2luZG93W3N0cnN0YXJ0IC4uIHN0cnN0YXJ0KzJdIGluIHRoZVxuICAgICAqIGRpY3Rpb25hcnksIGFuZCBzZXQgaGFzaF9oZWFkIHRvIHRoZSBoZWFkIG9mIHRoZSBoYXNoIGNoYWluOlxuICAgICAqL1xuICAgIGhhc2hfaGVhZCA9IDAvKk5JTCovO1xuICAgIGlmIChzLmxvb2thaGVhZCA+PSBNSU5fTUFUQ0gpIHtcbiAgICAgIC8qKiogSU5TRVJUX1NUUklORyhzLCBzLnN0cnN0YXJ0LCBoYXNoX2hlYWQpOyAqKiovXG4gICAgICBzLmluc19oID0gKChzLmluc19oIDw8IHMuaGFzaF9zaGlmdCkgXiBzLndpbmRvd1tzLnN0cnN0YXJ0ICsgTUlOX01BVENIIC0gMV0pICYgcy5oYXNoX21hc2s7XG4gICAgICBoYXNoX2hlYWQgPSBzLnByZXZbcy5zdHJzdGFydCAmIHMud19tYXNrXSA9IHMuaGVhZFtzLmluc19oXTtcbiAgICAgIHMuaGVhZFtzLmluc19oXSA9IHMuc3Ryc3RhcnQ7XG4gICAgICAvKioqL1xuICAgIH1cblxuICAgIC8qIEZpbmQgdGhlIGxvbmdlc3QgbWF0Y2gsIGRpc2NhcmRpbmcgdGhvc2UgPD0gcHJldl9sZW5ndGguXG4gICAgICogQXQgdGhpcyBwb2ludCB3ZSBoYXZlIGFsd2F5cyBtYXRjaF9sZW5ndGggPCBNSU5fTUFUQ0hcbiAgICAgKi9cbiAgICBpZiAoaGFzaF9oZWFkICE9PSAwLypOSUwqLyAmJiAoKHMuc3Ryc3RhcnQgLSBoYXNoX2hlYWQpIDw9IChzLndfc2l6ZSAtIE1JTl9MT09LQUhFQUQpKSkge1xuICAgICAgLyogVG8gc2ltcGxpZnkgdGhlIGNvZGUsIHdlIHByZXZlbnQgbWF0Y2hlcyB3aXRoIHRoZSBzdHJpbmdcbiAgICAgICAqIG9mIHdpbmRvdyBpbmRleCAwIChpbiBwYXJ0aWN1bGFyIHdlIGhhdmUgdG8gYXZvaWQgYSBtYXRjaFxuICAgICAgICogb2YgdGhlIHN0cmluZyB3aXRoIGl0c2VsZiBhdCB0aGUgc3RhcnQgb2YgdGhlIGlucHV0IGZpbGUpLlxuICAgICAgICovXG4gICAgICBzLm1hdGNoX2xlbmd0aCA9IGxvbmdlc3RfbWF0Y2gocywgaGFzaF9oZWFkKTtcbiAgICAgIC8qIGxvbmdlc3RfbWF0Y2goKSBzZXRzIG1hdGNoX3N0YXJ0ICovXG4gICAgfVxuICAgIGlmIChzLm1hdGNoX2xlbmd0aCA+PSBNSU5fTUFUQ0gpIHtcbiAgICAgIC8vIGNoZWNrX21hdGNoKHMsIHMuc3Ryc3RhcnQsIHMubWF0Y2hfc3RhcnQsIHMubWF0Y2hfbGVuZ3RoKTsgLy8gZm9yIGRlYnVnIG9ubHlcblxuICAgICAgLyoqKiBfdHJfdGFsbHlfZGlzdChzLCBzLnN0cnN0YXJ0IC0gcy5tYXRjaF9zdGFydCxcbiAgICAgICAgICAgICAgICAgICAgIHMubWF0Y2hfbGVuZ3RoIC0gTUlOX01BVENILCBiZmx1c2gpOyAqKiovXG4gICAgICBiZmx1c2ggPSB0cmVlcy5fdHJfdGFsbHkocywgcy5zdHJzdGFydCAtIHMubWF0Y2hfc3RhcnQsIHMubWF0Y2hfbGVuZ3RoIC0gTUlOX01BVENIKTtcblxuICAgICAgcy5sb29rYWhlYWQgLT0gcy5tYXRjaF9sZW5ndGg7XG5cbiAgICAgIC8qIEluc2VydCBuZXcgc3RyaW5ncyBpbiB0aGUgaGFzaCB0YWJsZSBvbmx5IGlmIHRoZSBtYXRjaCBsZW5ndGhcbiAgICAgICAqIGlzIG5vdCB0b28gbGFyZ2UuIFRoaXMgc2F2ZXMgdGltZSBidXQgZGVncmFkZXMgY29tcHJlc3Npb24uXG4gICAgICAgKi9cbiAgICAgIGlmIChzLm1hdGNoX2xlbmd0aCA8PSBzLm1heF9sYXp5X21hdGNoLyptYXhfaW5zZXJ0X2xlbmd0aCovICYmIHMubG9va2FoZWFkID49IE1JTl9NQVRDSCkge1xuICAgICAgICBzLm1hdGNoX2xlbmd0aC0tOyAvKiBzdHJpbmcgYXQgc3Ryc3RhcnQgYWxyZWFkeSBpbiB0YWJsZSAqL1xuICAgICAgICBkbyB7XG4gICAgICAgICAgcy5zdHJzdGFydCsrO1xuICAgICAgICAgIC8qKiogSU5TRVJUX1NUUklORyhzLCBzLnN0cnN0YXJ0LCBoYXNoX2hlYWQpOyAqKiovXG4gICAgICAgICAgcy5pbnNfaCA9ICgocy5pbnNfaCA8PCBzLmhhc2hfc2hpZnQpIF4gcy53aW5kb3dbcy5zdHJzdGFydCArIE1JTl9NQVRDSCAtIDFdKSAmIHMuaGFzaF9tYXNrO1xuICAgICAgICAgIGhhc2hfaGVhZCA9IHMucHJldltzLnN0cnN0YXJ0ICYgcy53X21hc2tdID0gcy5oZWFkW3MuaW5zX2hdO1xuICAgICAgICAgIHMuaGVhZFtzLmluc19oXSA9IHMuc3Ryc3RhcnQ7XG4gICAgICAgICAgLyoqKi9cbiAgICAgICAgICAvKiBzdHJzdGFydCBuZXZlciBleGNlZWRzIFdTSVpFLU1BWF9NQVRDSCwgc28gdGhlcmUgYXJlXG4gICAgICAgICAgICogYWx3YXlzIE1JTl9NQVRDSCBieXRlcyBhaGVhZC5cbiAgICAgICAgICAgKi9cbiAgICAgICAgfSB3aGlsZSAoLS1zLm1hdGNoX2xlbmd0aCAhPT0gMCk7XG4gICAgICAgIHMuc3Ryc3RhcnQrKztcbiAgICAgIH0gZWxzZVxuICAgICAge1xuICAgICAgICBzLnN0cnN0YXJ0ICs9IHMubWF0Y2hfbGVuZ3RoO1xuICAgICAgICBzLm1hdGNoX2xlbmd0aCA9IDA7XG4gICAgICAgIHMuaW5zX2ggPSBzLndpbmRvd1tzLnN0cnN0YXJ0XTtcbiAgICAgICAgLyogVVBEQVRFX0hBU0gocywgcy5pbnNfaCwgcy53aW5kb3dbcy5zdHJzdGFydCsxXSk7ICovXG4gICAgICAgIHMuaW5zX2ggPSAoKHMuaW5zX2ggPDwgcy5oYXNoX3NoaWZ0KSBeIHMud2luZG93W3Muc3Ryc3RhcnQgKyAxXSkgJiBzLmhhc2hfbWFzaztcblxuLy8jaWYgTUlOX01BVENIICE9IDNcbi8vICAgICAgICAgICAgICAgIENhbGwgVVBEQVRFX0hBU0goKSBNSU5fTUFUQ0gtMyBtb3JlIHRpbWVzXG4vLyNlbmRpZlxuICAgICAgICAvKiBJZiBsb29rYWhlYWQgPCBNSU5fTUFUQ0gsIGluc19oIGlzIGdhcmJhZ2UsIGJ1dCBpdCBkb2VzIG5vdFxuICAgICAgICAgKiBtYXR0ZXIgc2luY2UgaXQgd2lsbCBiZSByZWNvbXB1dGVkIGF0IG5leHQgZGVmbGF0ZSBjYWxsLlxuICAgICAgICAgKi9cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLyogTm8gbWF0Y2gsIG91dHB1dCBhIGxpdGVyYWwgYnl0ZSAqL1xuICAgICAgLy9UcmFjZXZ2KChzdGRlcnIsXCIlY1wiLCBzLndpbmRvd1tzLnN0cnN0YXJ0XSkpO1xuICAgICAgLyoqKiBfdHJfdGFsbHlfbGl0KHMsIHMud2luZG93W3Muc3Ryc3RhcnRdLCBiZmx1c2gpOyAqKiovXG4gICAgICBiZmx1c2ggPSB0cmVlcy5fdHJfdGFsbHkocywgMCwgcy53aW5kb3dbcy5zdHJzdGFydF0pO1xuXG4gICAgICBzLmxvb2thaGVhZC0tO1xuICAgICAgcy5zdHJzdGFydCsrO1xuICAgIH1cbiAgICBpZiAoYmZsdXNoKSB7XG4gICAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDApOyAqKiovXG4gICAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICB9XG4gICAgICAvKioqL1xuICAgIH1cbiAgfVxuICBzLmluc2VydCA9ICgocy5zdHJzdGFydCA8IChNSU5fTUFUQ0ggLSAxKSkgPyBzLnN0cnN0YXJ0IDogTUlOX01BVENIIC0gMSk7XG4gIGlmIChmbHVzaCA9PT0gWl9GSU5JU0gpIHtcbiAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDEpOyAqKiovXG4gICAgZmx1c2hfYmxvY2tfb25seShzLCB0cnVlKTtcbiAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJTX0ZJTklTSF9TVEFSVEVEO1xuICAgIH1cbiAgICAvKioqL1xuICAgIHJldHVybiBCU19GSU5JU0hfRE9ORTtcbiAgfVxuICBpZiAocy5sYXN0X2xpdCkge1xuICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICB9XG4gICAgLyoqKi9cbiAgfVxuICByZXR1cm4gQlNfQkxPQ0tfRE9ORTtcbn1cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBTYW1lIGFzIGFib3ZlLCBidXQgYWNoaWV2ZXMgYmV0dGVyIGNvbXByZXNzaW9uLiBXZSB1c2UgYSBsYXp5XG4gKiBldmFsdWF0aW9uIGZvciBtYXRjaGVzOiBhIG1hdGNoIGlzIGZpbmFsbHkgYWRvcHRlZCBvbmx5IGlmIHRoZXJlIGlzXG4gKiBubyBiZXR0ZXIgbWF0Y2ggYXQgdGhlIG5leHQgd2luZG93IHBvc2l0aW9uLlxuICovXG5mdW5jdGlvbiBkZWZsYXRlX3Nsb3cocywgZmx1c2gpIHtcbiAgdmFyIGhhc2hfaGVhZDsgICAgICAgICAgLyogaGVhZCBvZiBoYXNoIGNoYWluICovXG4gIHZhciBiZmx1c2g7ICAgICAgICAgICAgICAvKiBzZXQgaWYgY3VycmVudCBibG9jayBtdXN0IGJlIGZsdXNoZWQgKi9cblxuICB2YXIgbWF4X2luc2VydDtcblxuICAvKiBQcm9jZXNzIHRoZSBpbnB1dCBibG9jay4gKi9cbiAgZm9yICg7Oykge1xuICAgIC8qIE1ha2Ugc3VyZSB0aGF0IHdlIGFsd2F5cyBoYXZlIGVub3VnaCBsb29rYWhlYWQsIGV4Y2VwdFxuICAgICAqIGF0IHRoZSBlbmQgb2YgdGhlIGlucHV0IGZpbGUuIFdlIG5lZWQgTUFYX01BVENIIGJ5dGVzXG4gICAgICogZm9yIHRoZSBuZXh0IG1hdGNoLCBwbHVzIE1JTl9NQVRDSCBieXRlcyB0byBpbnNlcnQgdGhlXG4gICAgICogc3RyaW5nIGZvbGxvd2luZyB0aGUgbmV4dCBtYXRjaC5cbiAgICAgKi9cbiAgICBpZiAocy5sb29rYWhlYWQgPCBNSU5fTE9PS0FIRUFEKSB7XG4gICAgICBmaWxsX3dpbmRvdyhzKTtcbiAgICAgIGlmIChzLmxvb2thaGVhZCA8IE1JTl9MT09LQUhFQUQgJiYgZmx1c2ggPT09IFpfTk9fRkxVU0gpIHtcbiAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgIH1cbiAgICAgIGlmIChzLmxvb2thaGVhZCA9PT0gMCkgeyBicmVhazsgfSAvKiBmbHVzaCB0aGUgY3VycmVudCBibG9jayAqL1xuICAgIH1cblxuICAgIC8qIEluc2VydCB0aGUgc3RyaW5nIHdpbmRvd1tzdHJzdGFydCAuLiBzdHJzdGFydCsyXSBpbiB0aGVcbiAgICAgKiBkaWN0aW9uYXJ5LCBhbmQgc2V0IGhhc2hfaGVhZCB0byB0aGUgaGVhZCBvZiB0aGUgaGFzaCBjaGFpbjpcbiAgICAgKi9cbiAgICBoYXNoX2hlYWQgPSAwLypOSUwqLztcbiAgICBpZiAocy5sb29rYWhlYWQgPj0gTUlOX01BVENIKSB7XG4gICAgICAvKioqIElOU0VSVF9TVFJJTkcocywgcy5zdHJzdGFydCwgaGFzaF9oZWFkKTsgKioqL1xuICAgICAgcy5pbnNfaCA9ICgocy5pbnNfaCA8PCBzLmhhc2hfc2hpZnQpIF4gcy53aW5kb3dbcy5zdHJzdGFydCArIE1JTl9NQVRDSCAtIDFdKSAmIHMuaGFzaF9tYXNrO1xuICAgICAgaGFzaF9oZWFkID0gcy5wcmV2W3Muc3Ryc3RhcnQgJiBzLndfbWFza10gPSBzLmhlYWRbcy5pbnNfaF07XG4gICAgICBzLmhlYWRbcy5pbnNfaF0gPSBzLnN0cnN0YXJ0O1xuICAgICAgLyoqKi9cbiAgICB9XG5cbiAgICAvKiBGaW5kIHRoZSBsb25nZXN0IG1hdGNoLCBkaXNjYXJkaW5nIHRob3NlIDw9IHByZXZfbGVuZ3RoLlxuICAgICAqL1xuICAgIHMucHJldl9sZW5ndGggPSBzLm1hdGNoX2xlbmd0aDtcbiAgICBzLnByZXZfbWF0Y2ggPSBzLm1hdGNoX3N0YXJ0O1xuICAgIHMubWF0Y2hfbGVuZ3RoID0gTUlOX01BVENIIC0gMTtcblxuICAgIGlmIChoYXNoX2hlYWQgIT09IDAvKk5JTCovICYmIHMucHJldl9sZW5ndGggPCBzLm1heF9sYXp5X21hdGNoICYmXG4gICAgICAgIHMuc3Ryc3RhcnQgLSBoYXNoX2hlYWQgPD0gKHMud19zaXplIC0gTUlOX0xPT0tBSEVBRCkvKk1BWF9ESVNUKHMpKi8pIHtcbiAgICAgIC8qIFRvIHNpbXBsaWZ5IHRoZSBjb2RlLCB3ZSBwcmV2ZW50IG1hdGNoZXMgd2l0aCB0aGUgc3RyaW5nXG4gICAgICAgKiBvZiB3aW5kb3cgaW5kZXggMCAoaW4gcGFydGljdWxhciB3ZSBoYXZlIHRvIGF2b2lkIGEgbWF0Y2hcbiAgICAgICAqIG9mIHRoZSBzdHJpbmcgd2l0aCBpdHNlbGYgYXQgdGhlIHN0YXJ0IG9mIHRoZSBpbnB1dCBmaWxlKS5cbiAgICAgICAqL1xuICAgICAgcy5tYXRjaF9sZW5ndGggPSBsb25nZXN0X21hdGNoKHMsIGhhc2hfaGVhZCk7XG4gICAgICAvKiBsb25nZXN0X21hdGNoKCkgc2V0cyBtYXRjaF9zdGFydCAqL1xuXG4gICAgICBpZiAocy5tYXRjaF9sZW5ndGggPD0gNSAmJlxuICAgICAgICAgKHMuc3RyYXRlZ3kgPT09IFpfRklMVEVSRUQgfHwgKHMubWF0Y2hfbGVuZ3RoID09PSBNSU5fTUFUQ0ggJiYgcy5zdHJzdGFydCAtIHMubWF0Y2hfc3RhcnQgPiA0MDk2LypUT09fRkFSKi8pKSkge1xuXG4gICAgICAgIC8qIElmIHByZXZfbWF0Y2ggaXMgYWxzbyBNSU5fTUFUQ0gsIG1hdGNoX3N0YXJ0IGlzIGdhcmJhZ2VcbiAgICAgICAgICogYnV0IHdlIHdpbGwgaWdub3JlIHRoZSBjdXJyZW50IG1hdGNoIGFueXdheS5cbiAgICAgICAgICovXG4gICAgICAgIHMubWF0Y2hfbGVuZ3RoID0gTUlOX01BVENIIC0gMTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyogSWYgdGhlcmUgd2FzIGEgbWF0Y2ggYXQgdGhlIHByZXZpb3VzIHN0ZXAgYW5kIHRoZSBjdXJyZW50XG4gICAgICogbWF0Y2ggaXMgbm90IGJldHRlciwgb3V0cHV0IHRoZSBwcmV2aW91cyBtYXRjaDpcbiAgICAgKi9cbiAgICBpZiAocy5wcmV2X2xlbmd0aCA+PSBNSU5fTUFUQ0ggJiYgcy5tYXRjaF9sZW5ndGggPD0gcy5wcmV2X2xlbmd0aCkge1xuICAgICAgbWF4X2luc2VydCA9IHMuc3Ryc3RhcnQgKyBzLmxvb2thaGVhZCAtIE1JTl9NQVRDSDtcbiAgICAgIC8qIERvIG5vdCBpbnNlcnQgc3RyaW5ncyBpbiBoYXNoIHRhYmxlIGJleW9uZCB0aGlzLiAqL1xuXG4gICAgICAvL2NoZWNrX21hdGNoKHMsIHMuc3Ryc3RhcnQtMSwgcy5wcmV2X21hdGNoLCBzLnByZXZfbGVuZ3RoKTtcblxuICAgICAgLyoqKl90cl90YWxseV9kaXN0KHMsIHMuc3Ryc3RhcnQgLSAxIC0gcy5wcmV2X21hdGNoLFxuICAgICAgICAgICAgICAgICAgICAgcy5wcmV2X2xlbmd0aCAtIE1JTl9NQVRDSCwgYmZsdXNoKTsqKiovXG4gICAgICBiZmx1c2ggPSB0cmVlcy5fdHJfdGFsbHkocywgcy5zdHJzdGFydCAtIDEgLSBzLnByZXZfbWF0Y2gsIHMucHJldl9sZW5ndGggLSBNSU5fTUFUQ0gpO1xuICAgICAgLyogSW5zZXJ0IGluIGhhc2ggdGFibGUgYWxsIHN0cmluZ3MgdXAgdG8gdGhlIGVuZCBvZiB0aGUgbWF0Y2guXG4gICAgICAgKiBzdHJzdGFydC0xIGFuZCBzdHJzdGFydCBhcmUgYWxyZWFkeSBpbnNlcnRlZC4gSWYgdGhlcmUgaXMgbm90XG4gICAgICAgKiBlbm91Z2ggbG9va2FoZWFkLCB0aGUgbGFzdCB0d28gc3RyaW5ncyBhcmUgbm90IGluc2VydGVkIGluXG4gICAgICAgKiB0aGUgaGFzaCB0YWJsZS5cbiAgICAgICAqL1xuICAgICAgcy5sb29rYWhlYWQgLT0gcy5wcmV2X2xlbmd0aCAtIDE7XG4gICAgICBzLnByZXZfbGVuZ3RoIC09IDI7XG4gICAgICBkbyB7XG4gICAgICAgIGlmICgrK3Muc3Ryc3RhcnQgPD0gbWF4X2luc2VydCkge1xuICAgICAgICAgIC8qKiogSU5TRVJUX1NUUklORyhzLCBzLnN0cnN0YXJ0LCBoYXNoX2hlYWQpOyAqKiovXG4gICAgICAgICAgcy5pbnNfaCA9ICgocy5pbnNfaCA8PCBzLmhhc2hfc2hpZnQpIF4gcy53aW5kb3dbcy5zdHJzdGFydCArIE1JTl9NQVRDSCAtIDFdKSAmIHMuaGFzaF9tYXNrO1xuICAgICAgICAgIGhhc2hfaGVhZCA9IHMucHJldltzLnN0cnN0YXJ0ICYgcy53X21hc2tdID0gcy5oZWFkW3MuaW5zX2hdO1xuICAgICAgICAgIHMuaGVhZFtzLmluc19oXSA9IHMuc3Ryc3RhcnQ7XG4gICAgICAgICAgLyoqKi9cbiAgICAgICAgfVxuICAgICAgfSB3aGlsZSAoLS1zLnByZXZfbGVuZ3RoICE9PSAwKTtcbiAgICAgIHMubWF0Y2hfYXZhaWxhYmxlID0gMDtcbiAgICAgIHMubWF0Y2hfbGVuZ3RoID0gTUlOX01BVENIIC0gMTtcbiAgICAgIHMuc3Ryc3RhcnQrKztcblxuICAgICAgaWYgKGJmbHVzaCkge1xuICAgICAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDApOyAqKiovXG4gICAgICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgICAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICAgIH1cbiAgICAgICAgLyoqKi9cbiAgICAgIH1cblxuICAgIH0gZWxzZSBpZiAocy5tYXRjaF9hdmFpbGFibGUpIHtcbiAgICAgIC8qIElmIHRoZXJlIHdhcyBubyBtYXRjaCBhdCB0aGUgcHJldmlvdXMgcG9zaXRpb24sIG91dHB1dCBhXG4gICAgICAgKiBzaW5nbGUgbGl0ZXJhbC4gSWYgdGhlcmUgd2FzIGEgbWF0Y2ggYnV0IHRoZSBjdXJyZW50IG1hdGNoXG4gICAgICAgKiBpcyBsb25nZXIsIHRydW5jYXRlIHRoZSBwcmV2aW91cyBtYXRjaCB0byBhIHNpbmdsZSBsaXRlcmFsLlxuICAgICAgICovXG4gICAgICAvL1RyYWNldnYoKHN0ZGVycixcIiVjXCIsIHMtPndpbmRvd1tzLT5zdHJzdGFydC0xXSkpO1xuICAgICAgLyoqKiBfdHJfdGFsbHlfbGl0KHMsIHMud2luZG93W3Muc3Ryc3RhcnQtMV0sIGJmbHVzaCk7ICoqKi9cbiAgICAgIGJmbHVzaCA9IHRyZWVzLl90cl90YWxseShzLCAwLCBzLndpbmRvd1tzLnN0cnN0YXJ0IC0gMV0pO1xuXG4gICAgICBpZiAoYmZsdXNoKSB7XG4gICAgICAgIC8qKiogRkxVU0hfQkxPQ0tfT05MWShzLCAwKSAqKiovXG4gICAgICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgICAgICAvKioqL1xuICAgICAgfVxuICAgICAgcy5zdHJzdGFydCsrO1xuICAgICAgcy5sb29rYWhlYWQtLTtcbiAgICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8qIFRoZXJlIGlzIG5vIHByZXZpb3VzIG1hdGNoIHRvIGNvbXBhcmUgd2l0aCwgd2FpdCBmb3JcbiAgICAgICAqIHRoZSBuZXh0IHN0ZXAgdG8gZGVjaWRlLlxuICAgICAgICovXG4gICAgICBzLm1hdGNoX2F2YWlsYWJsZSA9IDE7XG4gICAgICBzLnN0cnN0YXJ0Kys7XG4gICAgICBzLmxvb2thaGVhZC0tO1xuICAgIH1cbiAgfVxuICAvL0Fzc2VydCAoZmx1c2ggIT0gWl9OT19GTFVTSCwgXCJubyBmbHVzaD9cIik7XG4gIGlmIChzLm1hdGNoX2F2YWlsYWJsZSkge1xuICAgIC8vVHJhY2V2digoc3RkZXJyLFwiJWNcIiwgcy0+d2luZG93W3MtPnN0cnN0YXJ0LTFdKSk7XG4gICAgLyoqKiBfdHJfdGFsbHlfbGl0KHMsIHMud2luZG93W3Muc3Ryc3RhcnQtMV0sIGJmbHVzaCk7ICoqKi9cbiAgICBiZmx1c2ggPSB0cmVlcy5fdHJfdGFsbHkocywgMCwgcy53aW5kb3dbcy5zdHJzdGFydCAtIDFdKTtcblxuICAgIHMubWF0Y2hfYXZhaWxhYmxlID0gMDtcbiAgfVxuICBzLmluc2VydCA9IHMuc3Ryc3RhcnQgPCBNSU5fTUFUQ0ggLSAxID8gcy5zdHJzdGFydCA6IE1JTl9NQVRDSCAtIDE7XG4gIGlmIChmbHVzaCA9PT0gWl9GSU5JU0gpIHtcbiAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDEpOyAqKiovXG4gICAgZmx1c2hfYmxvY2tfb25seShzLCB0cnVlKTtcbiAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJTX0ZJTklTSF9TVEFSVEVEO1xuICAgIH1cbiAgICAvKioqL1xuICAgIHJldHVybiBCU19GSU5JU0hfRE9ORTtcbiAgfVxuICBpZiAocy5sYXN0X2xpdCkge1xuICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICB9XG4gICAgLyoqKi9cbiAgfVxuXG4gIHJldHVybiBCU19CTE9DS19ET05FO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogRm9yIFpfUkxFLCBzaW1wbHkgbG9vayBmb3IgcnVucyBvZiBieXRlcywgZ2VuZXJhdGUgbWF0Y2hlcyBvbmx5IG9mIGRpc3RhbmNlXG4gKiBvbmUuICBEbyBub3QgbWFpbnRhaW4gYSBoYXNoIHRhYmxlLiAgKEl0IHdpbGwgYmUgcmVnZW5lcmF0ZWQgaWYgdGhpcyBydW4gb2ZcbiAqIGRlZmxhdGUgc3dpdGNoZXMgYXdheSBmcm9tIFpfUkxFLilcbiAqL1xuZnVuY3Rpb24gZGVmbGF0ZV9ybGUocywgZmx1c2gpIHtcbiAgdmFyIGJmbHVzaDsgICAgICAgICAgICAvKiBzZXQgaWYgY3VycmVudCBibG9jayBtdXN0IGJlIGZsdXNoZWQgKi9cbiAgdmFyIHByZXY7ICAgICAgICAgICAgICAvKiBieXRlIGF0IGRpc3RhbmNlIG9uZSB0byBtYXRjaCAqL1xuICB2YXIgc2Nhbiwgc3RyZW5kOyAgICAgIC8qIHNjYW4gZ29lcyB1cCB0byBzdHJlbmQgZm9yIGxlbmd0aCBvZiBydW4gKi9cblxuICB2YXIgX3dpbiA9IHMud2luZG93O1xuXG4gIGZvciAoOzspIHtcbiAgICAvKiBNYWtlIHN1cmUgdGhhdCB3ZSBhbHdheXMgaGF2ZSBlbm91Z2ggbG9va2FoZWFkLCBleGNlcHRcbiAgICAgKiBhdCB0aGUgZW5kIG9mIHRoZSBpbnB1dCBmaWxlLiBXZSBuZWVkIE1BWF9NQVRDSCBieXRlc1xuICAgICAqIGZvciB0aGUgbG9uZ2VzdCBydW4sIHBsdXMgb25lIGZvciB0aGUgdW5yb2xsZWQgbG9vcC5cbiAgICAgKi9cbiAgICBpZiAocy5sb29rYWhlYWQgPD0gTUFYX01BVENIKSB7XG4gICAgICBmaWxsX3dpbmRvdyhzKTtcbiAgICAgIGlmIChzLmxvb2thaGVhZCA8PSBNQVhfTUFUQ0ggJiYgZmx1c2ggPT09IFpfTk9fRkxVU0gpIHtcbiAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgIH1cbiAgICAgIGlmIChzLmxvb2thaGVhZCA9PT0gMCkgeyBicmVhazsgfSAvKiBmbHVzaCB0aGUgY3VycmVudCBibG9jayAqL1xuICAgIH1cblxuICAgIC8qIFNlZSBob3cgbWFueSB0aW1lcyB0aGUgcHJldmlvdXMgYnl0ZSByZXBlYXRzICovXG4gICAgcy5tYXRjaF9sZW5ndGggPSAwO1xuICAgIGlmIChzLmxvb2thaGVhZCA+PSBNSU5fTUFUQ0ggJiYgcy5zdHJzdGFydCA+IDApIHtcbiAgICAgIHNjYW4gPSBzLnN0cnN0YXJ0IC0gMTtcbiAgICAgIHByZXYgPSBfd2luW3NjYW5dO1xuICAgICAgaWYgKHByZXYgPT09IF93aW5bKytzY2FuXSAmJiBwcmV2ID09PSBfd2luWysrc2Nhbl0gJiYgcHJldiA9PT0gX3dpblsrK3NjYW5dKSB7XG4gICAgICAgIHN0cmVuZCA9IHMuc3Ryc3RhcnQgKyBNQVhfTUFUQ0g7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAvKmpzaGludCBub2VtcHR5OmZhbHNlKi9cbiAgICAgICAgfSB3aGlsZSAocHJldiA9PT0gX3dpblsrK3NjYW5dICYmIHByZXYgPT09IF93aW5bKytzY2FuXSAmJlxuICAgICAgICAgICAgICAgICBwcmV2ID09PSBfd2luWysrc2Nhbl0gJiYgcHJldiA9PT0gX3dpblsrK3NjYW5dICYmXG4gICAgICAgICAgICAgICAgIHByZXYgPT09IF93aW5bKytzY2FuXSAmJiBwcmV2ID09PSBfd2luWysrc2Nhbl0gJiZcbiAgICAgICAgICAgICAgICAgcHJldiA9PT0gX3dpblsrK3NjYW5dICYmIHByZXYgPT09IF93aW5bKytzY2FuXSAmJlxuICAgICAgICAgICAgICAgICBzY2FuIDwgc3RyZW5kKTtcbiAgICAgICAgcy5tYXRjaF9sZW5ndGggPSBNQVhfTUFUQ0ggLSAoc3RyZW5kIC0gc2Nhbik7XG4gICAgICAgIGlmIChzLm1hdGNoX2xlbmd0aCA+IHMubG9va2FoZWFkKSB7XG4gICAgICAgICAgcy5tYXRjaF9sZW5ndGggPSBzLmxvb2thaGVhZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy9Bc3NlcnQoc2NhbiA8PSBzLT53aW5kb3crKHVJbnQpKHMtPndpbmRvd19zaXplLTEpLCBcIndpbGQgc2NhblwiKTtcbiAgICB9XG5cbiAgICAvKiBFbWl0IG1hdGNoIGlmIGhhdmUgcnVuIG9mIE1JTl9NQVRDSCBvciBsb25nZXIsIGVsc2UgZW1pdCBsaXRlcmFsICovXG4gICAgaWYgKHMubWF0Y2hfbGVuZ3RoID49IE1JTl9NQVRDSCkge1xuICAgICAgLy9jaGVja19tYXRjaChzLCBzLnN0cnN0YXJ0LCBzLnN0cnN0YXJ0IC0gMSwgcy5tYXRjaF9sZW5ndGgpO1xuXG4gICAgICAvKioqIF90cl90YWxseV9kaXN0KHMsIDEsIHMubWF0Y2hfbGVuZ3RoIC0gTUlOX01BVENILCBiZmx1c2gpOyAqKiovXG4gICAgICBiZmx1c2ggPSB0cmVlcy5fdHJfdGFsbHkocywgMSwgcy5tYXRjaF9sZW5ndGggLSBNSU5fTUFUQ0gpO1xuXG4gICAgICBzLmxvb2thaGVhZCAtPSBzLm1hdGNoX2xlbmd0aDtcbiAgICAgIHMuc3Ryc3RhcnQgKz0gcy5tYXRjaF9sZW5ndGg7XG4gICAgICBzLm1hdGNoX2xlbmd0aCA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8qIE5vIG1hdGNoLCBvdXRwdXQgYSBsaXRlcmFsIGJ5dGUgKi9cbiAgICAgIC8vVHJhY2V2digoc3RkZXJyLFwiJWNcIiwgcy0+d2luZG93W3MtPnN0cnN0YXJ0XSkpO1xuICAgICAgLyoqKiBfdHJfdGFsbHlfbGl0KHMsIHMud2luZG93W3Muc3Ryc3RhcnRdLCBiZmx1c2gpOyAqKiovXG4gICAgICBiZmx1c2ggPSB0cmVlcy5fdHJfdGFsbHkocywgMCwgcy53aW5kb3dbcy5zdHJzdGFydF0pO1xuXG4gICAgICBzLmxvb2thaGVhZC0tO1xuICAgICAgcy5zdHJzdGFydCsrO1xuICAgIH1cbiAgICBpZiAoYmZsdXNoKSB7XG4gICAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDApOyAqKiovXG4gICAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICB9XG4gICAgICAvKioqL1xuICAgIH1cbiAgfVxuICBzLmluc2VydCA9IDA7XG4gIGlmIChmbHVzaCA9PT0gWl9GSU5JU0gpIHtcbiAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDEpOyAqKiovXG4gICAgZmx1c2hfYmxvY2tfb25seShzLCB0cnVlKTtcbiAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJTX0ZJTklTSF9TVEFSVEVEO1xuICAgIH1cbiAgICAvKioqL1xuICAgIHJldHVybiBCU19GSU5JU0hfRE9ORTtcbiAgfVxuICBpZiAocy5sYXN0X2xpdCkge1xuICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICB9XG4gICAgLyoqKi9cbiAgfVxuICByZXR1cm4gQlNfQkxPQ0tfRE9ORTtcbn1cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBGb3IgWl9IVUZGTUFOX09OTFksIGRvIG5vdCBsb29rIGZvciBtYXRjaGVzLiAgRG8gbm90IG1haW50YWluIGEgaGFzaCB0YWJsZS5cbiAqIChJdCB3aWxsIGJlIHJlZ2VuZXJhdGVkIGlmIHRoaXMgcnVuIG9mIGRlZmxhdGUgc3dpdGNoZXMgYXdheSBmcm9tIEh1ZmZtYW4uKVxuICovXG5mdW5jdGlvbiBkZWZsYXRlX2h1ZmYocywgZmx1c2gpIHtcbiAgdmFyIGJmbHVzaDsgICAgICAgICAgICAgLyogc2V0IGlmIGN1cnJlbnQgYmxvY2sgbXVzdCBiZSBmbHVzaGVkICovXG5cbiAgZm9yICg7Oykge1xuICAgIC8qIE1ha2Ugc3VyZSB0aGF0IHdlIGhhdmUgYSBsaXRlcmFsIHRvIHdyaXRlLiAqL1xuICAgIGlmIChzLmxvb2thaGVhZCA9PT0gMCkge1xuICAgICAgZmlsbF93aW5kb3cocyk7XG4gICAgICBpZiAocy5sb29rYWhlYWQgPT09IDApIHtcbiAgICAgICAgaWYgKGZsdXNoID09PSBaX05PX0ZMVVNIKSB7XG4gICAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgICAgfVxuICAgICAgICBicmVhazsgICAgICAvKiBmbHVzaCB0aGUgY3VycmVudCBibG9jayAqL1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qIE91dHB1dCBhIGxpdGVyYWwgYnl0ZSAqL1xuICAgIHMubWF0Y2hfbGVuZ3RoID0gMDtcbiAgICAvL1RyYWNldnYoKHN0ZGVycixcIiVjXCIsIHMtPndpbmRvd1tzLT5zdHJzdGFydF0pKTtcbiAgICAvKioqIF90cl90YWxseV9saXQocywgcy53aW5kb3dbcy5zdHJzdGFydF0sIGJmbHVzaCk7ICoqKi9cbiAgICBiZmx1c2ggPSB0cmVlcy5fdHJfdGFsbHkocywgMCwgcy53aW5kb3dbcy5zdHJzdGFydF0pO1xuICAgIHMubG9va2FoZWFkLS07XG4gICAgcy5zdHJzdGFydCsrO1xuICAgIGlmIChiZmx1c2gpIHtcbiAgICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgIH1cbiAgICAgIC8qKiovXG4gICAgfVxuICB9XG4gIHMuaW5zZXJ0ID0gMDtcbiAgaWYgKGZsdXNoID09PSBaX0ZJTklTSCkge1xuICAgIC8qKiogRkxVU0hfQkxPQ0socywgMSk7ICoqKi9cbiAgICBmbHVzaF9ibG9ja19vbmx5KHMsIHRydWUpO1xuICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICByZXR1cm4gQlNfRklOSVNIX1NUQVJURUQ7XG4gICAgfVxuICAgIC8qKiovXG4gICAgcmV0dXJuIEJTX0ZJTklTSF9ET05FO1xuICB9XG4gIGlmIChzLmxhc3RfbGl0KSB7XG4gICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAwKTsgKioqL1xuICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgIH1cbiAgICAvKioqL1xuICB9XG4gIHJldHVybiBCU19CTE9DS19ET05FO1xufVxuXG4vKiBWYWx1ZXMgZm9yIG1heF9sYXp5X21hdGNoLCBnb29kX21hdGNoIGFuZCBtYXhfY2hhaW5fbGVuZ3RoLCBkZXBlbmRpbmcgb25cbiAqIHRoZSBkZXNpcmVkIHBhY2sgbGV2ZWwgKDAuLjkpLiBUaGUgdmFsdWVzIGdpdmVuIGJlbG93IGhhdmUgYmVlbiB0dW5lZCB0b1xuICogZXhjbHVkZSB3b3JzdCBjYXNlIHBlcmZvcm1hbmNlIGZvciBwYXRob2xvZ2ljYWwgZmlsZXMuIEJldHRlciB2YWx1ZXMgbWF5IGJlXG4gKiBmb3VuZCBmb3Igc3BlY2lmaWMgZmlsZXMuXG4gKi9cbmZ1bmN0aW9uIENvbmZpZyhnb29kX2xlbmd0aCwgbWF4X2xhenksIG5pY2VfbGVuZ3RoLCBtYXhfY2hhaW4sIGZ1bmMpIHtcbiAgdGhpcy5nb29kX2xlbmd0aCA9IGdvb2RfbGVuZ3RoO1xuICB0aGlzLm1heF9sYXp5ID0gbWF4X2xhenk7XG4gIHRoaXMubmljZV9sZW5ndGggPSBuaWNlX2xlbmd0aDtcbiAgdGhpcy5tYXhfY2hhaW4gPSBtYXhfY2hhaW47XG4gIHRoaXMuZnVuYyA9IGZ1bmM7XG59XG5cbnZhciBjb25maWd1cmF0aW9uX3RhYmxlO1xuXG5jb25maWd1cmF0aW9uX3RhYmxlID0gW1xuICAvKiAgICAgIGdvb2QgbGF6eSBuaWNlIGNoYWluICovXG4gIG5ldyBDb25maWcoMCwgMCwgMCwgMCwgZGVmbGF0ZV9zdG9yZWQpLCAgICAgICAgICAvKiAwIHN0b3JlIG9ubHkgKi9cbiAgbmV3IENvbmZpZyg0LCA0LCA4LCA0LCBkZWZsYXRlX2Zhc3QpLCAgICAgICAgICAgIC8qIDEgbWF4IHNwZWVkLCBubyBsYXp5IG1hdGNoZXMgKi9cbiAgbmV3IENvbmZpZyg0LCA1LCAxNiwgOCwgZGVmbGF0ZV9mYXN0KSwgICAgICAgICAgIC8qIDIgKi9cbiAgbmV3IENvbmZpZyg0LCA2LCAzMiwgMzIsIGRlZmxhdGVfZmFzdCksICAgICAgICAgIC8qIDMgKi9cblxuICBuZXcgQ29uZmlnKDQsIDQsIDE2LCAxNiwgZGVmbGF0ZV9zbG93KSwgICAgICAgICAgLyogNCBsYXp5IG1hdGNoZXMgKi9cbiAgbmV3IENvbmZpZyg4LCAxNiwgMzIsIDMyLCBkZWZsYXRlX3Nsb3cpLCAgICAgICAgIC8qIDUgKi9cbiAgbmV3IENvbmZpZyg4LCAxNiwgMTI4LCAxMjgsIGRlZmxhdGVfc2xvdyksICAgICAgIC8qIDYgKi9cbiAgbmV3IENvbmZpZyg4LCAzMiwgMTI4LCAyNTYsIGRlZmxhdGVfc2xvdyksICAgICAgIC8qIDcgKi9cbiAgbmV3IENvbmZpZygzMiwgMTI4LCAyNTgsIDEwMjQsIGRlZmxhdGVfc2xvdyksICAgIC8qIDggKi9cbiAgbmV3IENvbmZpZygzMiwgMjU4LCAyNTgsIDQwOTYsIGRlZmxhdGVfc2xvdykgICAgIC8qIDkgbWF4IGNvbXByZXNzaW9uICovXG5dO1xuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogSW5pdGlhbGl6ZSB0aGUgXCJsb25nZXN0IG1hdGNoXCIgcm91dGluZXMgZm9yIGEgbmV3IHpsaWIgc3RyZWFtXG4gKi9cbmZ1bmN0aW9uIGxtX2luaXQocykge1xuICBzLndpbmRvd19zaXplID0gMiAqIHMud19zaXplO1xuXG4gIC8qKiogQ0xFQVJfSEFTSChzKTsgKioqL1xuICB6ZXJvKHMuaGVhZCk7IC8vIEZpbGwgd2l0aCBOSUwgKD0gMCk7XG5cbiAgLyogU2V0IHRoZSBkZWZhdWx0IGNvbmZpZ3VyYXRpb24gcGFyYW1ldGVyczpcbiAgICovXG4gIHMubWF4X2xhenlfbWF0Y2ggPSBjb25maWd1cmF0aW9uX3RhYmxlW3MubGV2ZWxdLm1heF9sYXp5O1xuICBzLmdvb2RfbWF0Y2ggPSBjb25maWd1cmF0aW9uX3RhYmxlW3MubGV2ZWxdLmdvb2RfbGVuZ3RoO1xuICBzLm5pY2VfbWF0Y2ggPSBjb25maWd1cmF0aW9uX3RhYmxlW3MubGV2ZWxdLm5pY2VfbGVuZ3RoO1xuICBzLm1heF9jaGFpbl9sZW5ndGggPSBjb25maWd1cmF0aW9uX3RhYmxlW3MubGV2ZWxdLm1heF9jaGFpbjtcblxuICBzLnN0cnN0YXJ0ID0gMDtcbiAgcy5ibG9ja19zdGFydCA9IDA7XG4gIHMubG9va2FoZWFkID0gMDtcbiAgcy5pbnNlcnQgPSAwO1xuICBzLm1hdGNoX2xlbmd0aCA9IHMucHJldl9sZW5ndGggPSBNSU5fTUFUQ0ggLSAxO1xuICBzLm1hdGNoX2F2YWlsYWJsZSA9IDA7XG4gIHMuaW5zX2ggPSAwO1xufVxuXG5cbmZ1bmN0aW9uIERlZmxhdGVTdGF0ZSgpIHtcbiAgdGhpcy5zdHJtID0gbnVsbDsgICAgICAgICAgICAvKiBwb2ludGVyIGJhY2sgdG8gdGhpcyB6bGliIHN0cmVhbSAqL1xuICB0aGlzLnN0YXR1cyA9IDA7ICAgICAgICAgICAgLyogYXMgdGhlIG5hbWUgaW1wbGllcyAqL1xuICB0aGlzLnBlbmRpbmdfYnVmID0gbnVsbDsgICAgICAvKiBvdXRwdXQgc3RpbGwgcGVuZGluZyAqL1xuICB0aGlzLnBlbmRpbmdfYnVmX3NpemUgPSAwOyAgLyogc2l6ZSBvZiBwZW5kaW5nX2J1ZiAqL1xuICB0aGlzLnBlbmRpbmdfb3V0ID0gMDsgICAgICAgLyogbmV4dCBwZW5kaW5nIGJ5dGUgdG8gb3V0cHV0IHRvIHRoZSBzdHJlYW0gKi9cbiAgdGhpcy5wZW5kaW5nID0gMDsgICAgICAgICAgIC8qIG5iIG9mIGJ5dGVzIGluIHRoZSBwZW5kaW5nIGJ1ZmZlciAqL1xuICB0aGlzLndyYXAgPSAwOyAgICAgICAgICAgICAgLyogYml0IDAgdHJ1ZSBmb3IgemxpYiwgYml0IDEgdHJ1ZSBmb3IgZ3ppcCAqL1xuICB0aGlzLmd6aGVhZCA9IG51bGw7ICAgICAgICAgLyogZ3ppcCBoZWFkZXIgaW5mb3JtYXRpb24gdG8gd3JpdGUgKi9cbiAgdGhpcy5nemluZGV4ID0gMDsgICAgICAgICAgIC8qIHdoZXJlIGluIGV4dHJhLCBuYW1lLCBvciBjb21tZW50ICovXG4gIHRoaXMubWV0aG9kID0gWl9ERUZMQVRFRDsgLyogY2FuIG9ubHkgYmUgREVGTEFURUQgKi9cbiAgdGhpcy5sYXN0X2ZsdXNoID0gLTE7ICAgLyogdmFsdWUgb2YgZmx1c2ggcGFyYW0gZm9yIHByZXZpb3VzIGRlZmxhdGUgY2FsbCAqL1xuXG4gIHRoaXMud19zaXplID0gMDsgIC8qIExaNzcgd2luZG93IHNpemUgKDMySyBieSBkZWZhdWx0KSAqL1xuICB0aGlzLndfYml0cyA9IDA7ICAvKiBsb2cyKHdfc2l6ZSkgICg4Li4xNikgKi9cbiAgdGhpcy53X21hc2sgPSAwOyAgLyogd19zaXplIC0gMSAqL1xuXG4gIHRoaXMud2luZG93ID0gbnVsbDtcbiAgLyogU2xpZGluZyB3aW5kb3cuIElucHV0IGJ5dGVzIGFyZSByZWFkIGludG8gdGhlIHNlY29uZCBoYWxmIG9mIHRoZSB3aW5kb3csXG4gICAqIGFuZCBtb3ZlIHRvIHRoZSBmaXJzdCBoYWxmIGxhdGVyIHRvIGtlZXAgYSBkaWN0aW9uYXJ5IG9mIGF0IGxlYXN0IHdTaXplXG4gICAqIGJ5dGVzLiBXaXRoIHRoaXMgb3JnYW5pemF0aW9uLCBtYXRjaGVzIGFyZSBsaW1pdGVkIHRvIGEgZGlzdGFuY2Ugb2ZcbiAgICogd1NpemUtTUFYX01BVENIIGJ5dGVzLCBidXQgdGhpcyBlbnN1cmVzIHRoYXQgSU8gaXMgYWx3YXlzXG4gICAqIHBlcmZvcm1lZCB3aXRoIGEgbGVuZ3RoIG11bHRpcGxlIG9mIHRoZSBibG9jayBzaXplLlxuICAgKi9cblxuICB0aGlzLndpbmRvd19zaXplID0gMDtcbiAgLyogQWN0dWFsIHNpemUgb2Ygd2luZG93OiAyKndTaXplLCBleGNlcHQgd2hlbiB0aGUgdXNlciBpbnB1dCBidWZmZXJcbiAgICogaXMgZGlyZWN0bHkgdXNlZCBhcyBzbGlkaW5nIHdpbmRvdy5cbiAgICovXG5cbiAgdGhpcy5wcmV2ID0gbnVsbDtcbiAgLyogTGluayB0byBvbGRlciBzdHJpbmcgd2l0aCBzYW1lIGhhc2ggaW5kZXguIFRvIGxpbWl0IHRoZSBzaXplIG9mIHRoaXNcbiAgICogYXJyYXkgdG8gNjRLLCB0aGlzIGxpbmsgaXMgbWFpbnRhaW5lZCBvbmx5IGZvciB0aGUgbGFzdCAzMksgc3RyaW5ncy5cbiAgICogQW4gaW5kZXggaW4gdGhpcyBhcnJheSBpcyB0aHVzIGEgd2luZG93IGluZGV4IG1vZHVsbyAzMksuXG4gICAqL1xuXG4gIHRoaXMuaGVhZCA9IG51bGw7ICAgLyogSGVhZHMgb2YgdGhlIGhhc2ggY2hhaW5zIG9yIE5JTC4gKi9cblxuICB0aGlzLmluc19oID0gMDsgICAgICAgLyogaGFzaCBpbmRleCBvZiBzdHJpbmcgdG8gYmUgaW5zZXJ0ZWQgKi9cbiAgdGhpcy5oYXNoX3NpemUgPSAwOyAgIC8qIG51bWJlciBvZiBlbGVtZW50cyBpbiBoYXNoIHRhYmxlICovXG4gIHRoaXMuaGFzaF9iaXRzID0gMDsgICAvKiBsb2cyKGhhc2hfc2l6ZSkgKi9cbiAgdGhpcy5oYXNoX21hc2sgPSAwOyAgIC8qIGhhc2hfc2l6ZS0xICovXG5cbiAgdGhpcy5oYXNoX3NoaWZ0ID0gMDtcbiAgLyogTnVtYmVyIG9mIGJpdHMgYnkgd2hpY2ggaW5zX2ggbXVzdCBiZSBzaGlmdGVkIGF0IGVhY2ggaW5wdXRcbiAgICogc3RlcC4gSXQgbXVzdCBiZSBzdWNoIHRoYXQgYWZ0ZXIgTUlOX01BVENIIHN0ZXBzLCB0aGUgb2xkZXN0XG4gICAqIGJ5dGUgbm8gbG9uZ2VyIHRha2VzIHBhcnQgaW4gdGhlIGhhc2gga2V5LCB0aGF0IGlzOlxuICAgKiAgIGhhc2hfc2hpZnQgKiBNSU5fTUFUQ0ggPj0gaGFzaF9iaXRzXG4gICAqL1xuXG4gIHRoaXMuYmxvY2tfc3RhcnQgPSAwO1xuICAvKiBXaW5kb3cgcG9zaXRpb24gYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgY3VycmVudCBvdXRwdXQgYmxvY2suIEdldHNcbiAgICogbmVnYXRpdmUgd2hlbiB0aGUgd2luZG93IGlzIG1vdmVkIGJhY2t3YXJkcy5cbiAgICovXG5cbiAgdGhpcy5tYXRjaF9sZW5ndGggPSAwOyAgICAgIC8qIGxlbmd0aCBvZiBiZXN0IG1hdGNoICovXG4gIHRoaXMucHJldl9tYXRjaCA9IDA7ICAgICAgICAvKiBwcmV2aW91cyBtYXRjaCAqL1xuICB0aGlzLm1hdGNoX2F2YWlsYWJsZSA9IDA7ICAgLyogc2V0IGlmIHByZXZpb3VzIG1hdGNoIGV4aXN0cyAqL1xuICB0aGlzLnN0cnN0YXJ0ID0gMDsgICAgICAgICAgLyogc3RhcnQgb2Ygc3RyaW5nIHRvIGluc2VydCAqL1xuICB0aGlzLm1hdGNoX3N0YXJ0ID0gMDsgICAgICAgLyogc3RhcnQgb2YgbWF0Y2hpbmcgc3RyaW5nICovXG4gIHRoaXMubG9va2FoZWFkID0gMDsgICAgICAgICAvKiBudW1iZXIgb2YgdmFsaWQgYnl0ZXMgYWhlYWQgaW4gd2luZG93ICovXG5cbiAgdGhpcy5wcmV2X2xlbmd0aCA9IDA7XG4gIC8qIExlbmd0aCBvZiB0aGUgYmVzdCBtYXRjaCBhdCBwcmV2aW91cyBzdGVwLiBNYXRjaGVzIG5vdCBncmVhdGVyIHRoYW4gdGhpc1xuICAgKiBhcmUgZGlzY2FyZGVkLiBUaGlzIGlzIHVzZWQgaW4gdGhlIGxhenkgbWF0Y2ggZXZhbHVhdGlvbi5cbiAgICovXG5cbiAgdGhpcy5tYXhfY2hhaW5fbGVuZ3RoID0gMDtcbiAgLyogVG8gc3BlZWQgdXAgZGVmbGF0aW9uLCBoYXNoIGNoYWlucyBhcmUgbmV2ZXIgc2VhcmNoZWQgYmV5b25kIHRoaXNcbiAgICogbGVuZ3RoLiAgQSBoaWdoZXIgbGltaXQgaW1wcm92ZXMgY29tcHJlc3Npb24gcmF0aW8gYnV0IGRlZ3JhZGVzIHRoZVxuICAgKiBzcGVlZC5cbiAgICovXG5cbiAgdGhpcy5tYXhfbGF6eV9tYXRjaCA9IDA7XG4gIC8qIEF0dGVtcHQgdG8gZmluZCBhIGJldHRlciBtYXRjaCBvbmx5IHdoZW4gdGhlIGN1cnJlbnQgbWF0Y2ggaXMgc3RyaWN0bHlcbiAgICogc21hbGxlciB0aGFuIHRoaXMgdmFsdWUuIFRoaXMgbWVjaGFuaXNtIGlzIHVzZWQgb25seSBmb3IgY29tcHJlc3Npb25cbiAgICogbGV2ZWxzID49IDQuXG4gICAqL1xuICAvLyBUaGF0J3MgYWxpYXMgdG8gbWF4X2xhenlfbWF0Y2gsIGRvbid0IHVzZSBkaXJlY3RseVxuICAvL3RoaXMubWF4X2luc2VydF9sZW5ndGggPSAwO1xuICAvKiBJbnNlcnQgbmV3IHN0cmluZ3MgaW4gdGhlIGhhc2ggdGFibGUgb25seSBpZiB0aGUgbWF0Y2ggbGVuZ3RoIGlzIG5vdFxuICAgKiBncmVhdGVyIHRoYW4gdGhpcyBsZW5ndGguIFRoaXMgc2F2ZXMgdGltZSBidXQgZGVncmFkZXMgY29tcHJlc3Npb24uXG4gICAqIG1heF9pbnNlcnRfbGVuZ3RoIGlzIHVzZWQgb25seSBmb3IgY29tcHJlc3Npb24gbGV2ZWxzIDw9IDMuXG4gICAqL1xuXG4gIHRoaXMubGV2ZWwgPSAwOyAgICAgLyogY29tcHJlc3Npb24gbGV2ZWwgKDEuLjkpICovXG4gIHRoaXMuc3RyYXRlZ3kgPSAwOyAgLyogZmF2b3Igb3IgZm9yY2UgSHVmZm1hbiBjb2RpbmcqL1xuXG4gIHRoaXMuZ29vZF9tYXRjaCA9IDA7XG4gIC8qIFVzZSBhIGZhc3RlciBzZWFyY2ggd2hlbiB0aGUgcHJldmlvdXMgbWF0Y2ggaXMgbG9uZ2VyIHRoYW4gdGhpcyAqL1xuXG4gIHRoaXMubmljZV9tYXRjaCA9IDA7IC8qIFN0b3Agc2VhcmNoaW5nIHdoZW4gY3VycmVudCBtYXRjaCBleGNlZWRzIHRoaXMgKi9cblxuICAgICAgICAgICAgICAvKiB1c2VkIGJ5IHRyZWVzLmM6ICovXG5cbiAgLyogRGlkbid0IHVzZSBjdF9kYXRhIHR5cGVkZWYgYmVsb3cgdG8gc3VwcHJlc3MgY29tcGlsZXIgd2FybmluZyAqL1xuXG4gIC8vIHN0cnVjdCBjdF9kYXRhX3MgZHluX2x0cmVlW0hFQVBfU0laRV07ICAgLyogbGl0ZXJhbCBhbmQgbGVuZ3RoIHRyZWUgKi9cbiAgLy8gc3RydWN0IGN0X2RhdGFfcyBkeW5fZHRyZWVbMipEX0NPREVTKzFdOyAvKiBkaXN0YW5jZSB0cmVlICovXG4gIC8vIHN0cnVjdCBjdF9kYXRhX3MgYmxfdHJlZVsyKkJMX0NPREVTKzFdOyAgLyogSHVmZm1hbiB0cmVlIGZvciBiaXQgbGVuZ3RocyAqL1xuXG4gIC8vIFVzZSBmbGF0IGFycmF5IG9mIERPVUJMRSBzaXplLCB3aXRoIGludGVybGVhdmVkIGZhdGEsXG4gIC8vIGJlY2F1c2UgSlMgZG9lcyBub3Qgc3VwcG9ydCBlZmZlY3RpdmVcbiAgdGhpcy5keW5fbHRyZWUgID0gbmV3IHV0aWxzLkJ1ZjE2KEhFQVBfU0laRSAqIDIpO1xuICB0aGlzLmR5bl9kdHJlZSAgPSBuZXcgdXRpbHMuQnVmMTYoKDIgKiBEX0NPREVTICsgMSkgKiAyKTtcbiAgdGhpcy5ibF90cmVlICAgID0gbmV3IHV0aWxzLkJ1ZjE2KCgyICogQkxfQ09ERVMgKyAxKSAqIDIpO1xuICB6ZXJvKHRoaXMuZHluX2x0cmVlKTtcbiAgemVybyh0aGlzLmR5bl9kdHJlZSk7XG4gIHplcm8odGhpcy5ibF90cmVlKTtcblxuICB0aGlzLmxfZGVzYyAgID0gbnVsbDsgICAgICAgICAvKiBkZXNjLiBmb3IgbGl0ZXJhbCB0cmVlICovXG4gIHRoaXMuZF9kZXNjICAgPSBudWxsOyAgICAgICAgIC8qIGRlc2MuIGZvciBkaXN0YW5jZSB0cmVlICovXG4gIHRoaXMuYmxfZGVzYyAgPSBudWxsOyAgICAgICAgIC8qIGRlc2MuIGZvciBiaXQgbGVuZ3RoIHRyZWUgKi9cblxuICAvL3VzaCBibF9jb3VudFtNQVhfQklUUysxXTtcbiAgdGhpcy5ibF9jb3VudCA9IG5ldyB1dGlscy5CdWYxNihNQVhfQklUUyArIDEpO1xuICAvKiBudW1iZXIgb2YgY29kZXMgYXQgZWFjaCBiaXQgbGVuZ3RoIGZvciBhbiBvcHRpbWFsIHRyZWUgKi9cblxuICAvL2ludCBoZWFwWzIqTF9DT0RFUysxXTsgICAgICAvKiBoZWFwIHVzZWQgdG8gYnVpbGQgdGhlIEh1ZmZtYW4gdHJlZXMgKi9cbiAgdGhpcy5oZWFwID0gbmV3IHV0aWxzLkJ1ZjE2KDIgKiBMX0NPREVTICsgMSk7ICAvKiBoZWFwIHVzZWQgdG8gYnVpbGQgdGhlIEh1ZmZtYW4gdHJlZXMgKi9cbiAgemVybyh0aGlzLmhlYXApO1xuXG4gIHRoaXMuaGVhcF9sZW4gPSAwOyAgICAgICAgICAgICAgIC8qIG51bWJlciBvZiBlbGVtZW50cyBpbiB0aGUgaGVhcCAqL1xuICB0aGlzLmhlYXBfbWF4ID0gMDsgICAgICAgICAgICAgICAvKiBlbGVtZW50IG9mIGxhcmdlc3QgZnJlcXVlbmN5ICovXG4gIC8qIFRoZSBzb25zIG9mIGhlYXBbbl0gYXJlIGhlYXBbMipuXSBhbmQgaGVhcFsyKm4rMV0uIGhlYXBbMF0gaXMgbm90IHVzZWQuXG4gICAqIFRoZSBzYW1lIGhlYXAgYXJyYXkgaXMgdXNlZCB0byBidWlsZCBhbGwgdHJlZXMuXG4gICAqL1xuXG4gIHRoaXMuZGVwdGggPSBuZXcgdXRpbHMuQnVmMTYoMiAqIExfQ09ERVMgKyAxKTsgLy91Y2ggZGVwdGhbMipMX0NPREVTKzFdO1xuICB6ZXJvKHRoaXMuZGVwdGgpO1xuICAvKiBEZXB0aCBvZiBlYWNoIHN1YnRyZWUgdXNlZCBhcyB0aWUgYnJlYWtlciBmb3IgdHJlZXMgb2YgZXF1YWwgZnJlcXVlbmN5XG4gICAqL1xuXG4gIHRoaXMubF9idWYgPSAwOyAgICAgICAgICAvKiBidWZmZXIgaW5kZXggZm9yIGxpdGVyYWxzIG9yIGxlbmd0aHMgKi9cblxuICB0aGlzLmxpdF9idWZzaXplID0gMDtcbiAgLyogU2l6ZSBvZiBtYXRjaCBidWZmZXIgZm9yIGxpdGVyYWxzL2xlbmd0aHMuICBUaGVyZSBhcmUgNCByZWFzb25zIGZvclxuICAgKiBsaW1pdGluZyBsaXRfYnVmc2l6ZSB0byA2NEs6XG4gICAqICAgLSBmcmVxdWVuY2llcyBjYW4gYmUga2VwdCBpbiAxNiBiaXQgY291bnRlcnNcbiAgICogICAtIGlmIGNvbXByZXNzaW9uIGlzIG5vdCBzdWNjZXNzZnVsIGZvciB0aGUgZmlyc3QgYmxvY2ssIGFsbCBpbnB1dFxuICAgKiAgICAgZGF0YSBpcyBzdGlsbCBpbiB0aGUgd2luZG93IHNvIHdlIGNhbiBzdGlsbCBlbWl0IGEgc3RvcmVkIGJsb2NrIGV2ZW5cbiAgICogICAgIHdoZW4gaW5wdXQgY29tZXMgZnJvbSBzdGFuZGFyZCBpbnB1dC4gIChUaGlzIGNhbiBhbHNvIGJlIGRvbmUgZm9yXG4gICAqICAgICBhbGwgYmxvY2tzIGlmIGxpdF9idWZzaXplIGlzIG5vdCBncmVhdGVyIHRoYW4gMzJLLilcbiAgICogICAtIGlmIGNvbXByZXNzaW9uIGlzIG5vdCBzdWNjZXNzZnVsIGZvciBhIGZpbGUgc21hbGxlciB0aGFuIDY0Sywgd2UgY2FuXG4gICAqICAgICBldmVuIGVtaXQgYSBzdG9yZWQgZmlsZSBpbnN0ZWFkIG9mIGEgc3RvcmVkIGJsb2NrIChzYXZpbmcgNSBieXRlcykuXG4gICAqICAgICBUaGlzIGlzIGFwcGxpY2FibGUgb25seSBmb3IgemlwIChub3QgZ3ppcCBvciB6bGliKS5cbiAgICogICAtIGNyZWF0aW5nIG5ldyBIdWZmbWFuIHRyZWVzIGxlc3MgZnJlcXVlbnRseSBtYXkgbm90IHByb3ZpZGUgZmFzdFxuICAgKiAgICAgYWRhcHRhdGlvbiB0byBjaGFuZ2VzIGluIHRoZSBpbnB1dCBkYXRhIHN0YXRpc3RpY3MuIChUYWtlIGZvclxuICAgKiAgICAgZXhhbXBsZSBhIGJpbmFyeSBmaWxlIHdpdGggcG9vcmx5IGNvbXByZXNzaWJsZSBjb2RlIGZvbGxvd2VkIGJ5XG4gICAqICAgICBhIGhpZ2hseSBjb21wcmVzc2libGUgc3RyaW5nIHRhYmxlLikgU21hbGxlciBidWZmZXIgc2l6ZXMgZ2l2ZVxuICAgKiAgICAgZmFzdCBhZGFwdGF0aW9uIGJ1dCBoYXZlIG9mIGNvdXJzZSB0aGUgb3ZlcmhlYWQgb2YgdHJhbnNtaXR0aW5nXG4gICAqICAgICB0cmVlcyBtb3JlIGZyZXF1ZW50bHkuXG4gICAqICAgLSBJIGNhbid0IGNvdW50IGFib3ZlIDRcbiAgICovXG5cbiAgdGhpcy5sYXN0X2xpdCA9IDA7ICAgICAgLyogcnVubmluZyBpbmRleCBpbiBsX2J1ZiAqL1xuXG4gIHRoaXMuZF9idWYgPSAwO1xuICAvKiBCdWZmZXIgaW5kZXggZm9yIGRpc3RhbmNlcy4gVG8gc2ltcGxpZnkgdGhlIGNvZGUsIGRfYnVmIGFuZCBsX2J1ZiBoYXZlXG4gICAqIHRoZSBzYW1lIG51bWJlciBvZiBlbGVtZW50cy4gVG8gdXNlIGRpZmZlcmVudCBsZW5ndGhzLCBhbiBleHRyYSBmbGFnXG4gICAqIGFycmF5IHdvdWxkIGJlIG5lY2Vzc2FyeS5cbiAgICovXG5cbiAgdGhpcy5vcHRfbGVuID0gMDsgICAgICAgLyogYml0IGxlbmd0aCBvZiBjdXJyZW50IGJsb2NrIHdpdGggb3B0aW1hbCB0cmVlcyAqL1xuICB0aGlzLnN0YXRpY19sZW4gPSAwOyAgICAvKiBiaXQgbGVuZ3RoIG9mIGN1cnJlbnQgYmxvY2sgd2l0aCBzdGF0aWMgdHJlZXMgKi9cbiAgdGhpcy5tYXRjaGVzID0gMDsgICAgICAgLyogbnVtYmVyIG9mIHN0cmluZyBtYXRjaGVzIGluIGN1cnJlbnQgYmxvY2sgKi9cbiAgdGhpcy5pbnNlcnQgPSAwOyAgICAgICAgLyogYnl0ZXMgYXQgZW5kIG9mIHdpbmRvdyBsZWZ0IHRvIGluc2VydCAqL1xuXG5cbiAgdGhpcy5iaV9idWYgPSAwO1xuICAvKiBPdXRwdXQgYnVmZmVyLiBiaXRzIGFyZSBpbnNlcnRlZCBzdGFydGluZyBhdCB0aGUgYm90dG9tIChsZWFzdFxuICAgKiBzaWduaWZpY2FudCBiaXRzKS5cbiAgICovXG4gIHRoaXMuYmlfdmFsaWQgPSAwO1xuICAvKiBOdW1iZXIgb2YgdmFsaWQgYml0cyBpbiBiaV9idWYuICBBbGwgYml0cyBhYm92ZSB0aGUgbGFzdCB2YWxpZCBiaXRcbiAgICogYXJlIGFsd2F5cyB6ZXJvLlxuICAgKi9cblxuICAvLyBVc2VkIGZvciB3aW5kb3cgbWVtb3J5IGluaXQuIFdlIHNhZmVseSBpZ25vcmUgaXQgZm9yIEpTLiBUaGF0IG1ha2VzXG4gIC8vIHNlbnNlIG9ubHkgZm9yIHBvaW50ZXJzIGFuZCBtZW1vcnkgY2hlY2sgdG9vbHMuXG4gIC8vdGhpcy5oaWdoX3dhdGVyID0gMDtcbiAgLyogSGlnaCB3YXRlciBtYXJrIG9mZnNldCBpbiB3aW5kb3cgZm9yIGluaXRpYWxpemVkIGJ5dGVzIC0tIGJ5dGVzIGFib3ZlXG4gICAqIHRoaXMgYXJlIHNldCB0byB6ZXJvIGluIG9yZGVyIHRvIGF2b2lkIG1lbW9yeSBjaGVjayB3YXJuaW5ncyB3aGVuXG4gICAqIGxvbmdlc3QgbWF0Y2ggcm91dGluZXMgYWNjZXNzIGJ5dGVzIHBhc3QgdGhlIGlucHV0LiAgVGhpcyBpcyB0aGVuXG4gICAqIHVwZGF0ZWQgdG8gdGhlIG5ldyBoaWdoIHdhdGVyIG1hcmsuXG4gICAqL1xufVxuXG5cbmZ1bmN0aW9uIGRlZmxhdGVSZXNldEtlZXAoc3RybSkge1xuICB2YXIgcztcblxuICBpZiAoIXN0cm0gfHwgIXN0cm0uc3RhdGUpIHtcbiAgICByZXR1cm4gZXJyKHN0cm0sIFpfU1RSRUFNX0VSUk9SKTtcbiAgfVxuXG4gIHN0cm0udG90YWxfaW4gPSBzdHJtLnRvdGFsX291dCA9IDA7XG4gIHN0cm0uZGF0YV90eXBlID0gWl9VTktOT1dOO1xuXG4gIHMgPSBzdHJtLnN0YXRlO1xuICBzLnBlbmRpbmcgPSAwO1xuICBzLnBlbmRpbmdfb3V0ID0gMDtcblxuICBpZiAocy53cmFwIDwgMCkge1xuICAgIHMud3JhcCA9IC1zLndyYXA7XG4gICAgLyogd2FzIG1hZGUgbmVnYXRpdmUgYnkgZGVmbGF0ZSguLi4sIFpfRklOSVNIKTsgKi9cbiAgfVxuICBzLnN0YXR1cyA9IChzLndyYXAgPyBJTklUX1NUQVRFIDogQlVTWV9TVEFURSk7XG4gIHN0cm0uYWRsZXIgPSAocy53cmFwID09PSAyKSA/XG4gICAgMCAgLy8gY3JjMzIoMCwgWl9OVUxMLCAwKVxuICA6XG4gICAgMTsgLy8gYWRsZXIzMigwLCBaX05VTEwsIDApXG4gIHMubGFzdF9mbHVzaCA9IFpfTk9fRkxVU0g7XG4gIHRyZWVzLl90cl9pbml0KHMpO1xuICByZXR1cm4gWl9PSztcbn1cblxuXG5mdW5jdGlvbiBkZWZsYXRlUmVzZXQoc3RybSkge1xuICB2YXIgcmV0ID0gZGVmbGF0ZVJlc2V0S2VlcChzdHJtKTtcbiAgaWYgKHJldCA9PT0gWl9PSykge1xuICAgIGxtX2luaXQoc3RybS5zdGF0ZSk7XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuXG5mdW5jdGlvbiBkZWZsYXRlU2V0SGVhZGVyKHN0cm0sIGhlYWQpIHtcbiAgaWYgKCFzdHJtIHx8ICFzdHJtLnN0YXRlKSB7IHJldHVybiBaX1NUUkVBTV9FUlJPUjsgfVxuICBpZiAoc3RybS5zdGF0ZS53cmFwICE9PSAyKSB7IHJldHVybiBaX1NUUkVBTV9FUlJPUjsgfVxuICBzdHJtLnN0YXRlLmd6aGVhZCA9IGhlYWQ7XG4gIHJldHVybiBaX09LO1xufVxuXG5cbmZ1bmN0aW9uIGRlZmxhdGVJbml0MihzdHJtLCBsZXZlbCwgbWV0aG9kLCB3aW5kb3dCaXRzLCBtZW1MZXZlbCwgc3RyYXRlZ3kpIHtcbiAgaWYgKCFzdHJtKSB7IC8vID09PSBaX05VTExcbiAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7XG4gIH1cbiAgdmFyIHdyYXAgPSAxO1xuXG4gIGlmIChsZXZlbCA9PT0gWl9ERUZBVUxUX0NPTVBSRVNTSU9OKSB7XG4gICAgbGV2ZWwgPSA2O1xuICB9XG5cbiAgaWYgKHdpbmRvd0JpdHMgPCAwKSB7IC8qIHN1cHByZXNzIHpsaWIgd3JhcHBlciAqL1xuICAgIHdyYXAgPSAwO1xuICAgIHdpbmRvd0JpdHMgPSAtd2luZG93Qml0cztcbiAgfVxuXG4gIGVsc2UgaWYgKHdpbmRvd0JpdHMgPiAxNSkge1xuICAgIHdyYXAgPSAyOyAgICAgICAgICAgLyogd3JpdGUgZ3ppcCB3cmFwcGVyIGluc3RlYWQgKi9cbiAgICB3aW5kb3dCaXRzIC09IDE2O1xuICB9XG5cblxuICBpZiAobWVtTGV2ZWwgPCAxIHx8IG1lbUxldmVsID4gTUFYX01FTV9MRVZFTCB8fCBtZXRob2QgIT09IFpfREVGTEFURUQgfHxcbiAgICB3aW5kb3dCaXRzIDwgOCB8fCB3aW5kb3dCaXRzID4gMTUgfHwgbGV2ZWwgPCAwIHx8IGxldmVsID4gOSB8fFxuICAgIHN0cmF0ZWd5IDwgMCB8fCBzdHJhdGVneSA+IFpfRklYRUQpIHtcbiAgICByZXR1cm4gZXJyKHN0cm0sIFpfU1RSRUFNX0VSUk9SKTtcbiAgfVxuXG5cbiAgaWYgKHdpbmRvd0JpdHMgPT09IDgpIHtcbiAgICB3aW5kb3dCaXRzID0gOTtcbiAgfVxuICAvKiB1bnRpbCAyNTYtYnl0ZSB3aW5kb3cgYnVnIGZpeGVkICovXG5cbiAgdmFyIHMgPSBuZXcgRGVmbGF0ZVN0YXRlKCk7XG5cbiAgc3RybS5zdGF0ZSA9IHM7XG4gIHMuc3RybSA9IHN0cm07XG5cbiAgcy53cmFwID0gd3JhcDtcbiAgcy5nemhlYWQgPSBudWxsO1xuICBzLndfYml0cyA9IHdpbmRvd0JpdHM7XG4gIHMud19zaXplID0gMSA8PCBzLndfYml0cztcbiAgcy53X21hc2sgPSBzLndfc2l6ZSAtIDE7XG5cbiAgcy5oYXNoX2JpdHMgPSBtZW1MZXZlbCArIDc7XG4gIHMuaGFzaF9zaXplID0gMSA8PCBzLmhhc2hfYml0cztcbiAgcy5oYXNoX21hc2sgPSBzLmhhc2hfc2l6ZSAtIDE7XG4gIHMuaGFzaF9zaGlmdCA9IH5+KChzLmhhc2hfYml0cyArIE1JTl9NQVRDSCAtIDEpIC8gTUlOX01BVENIKTtcblxuICBzLndpbmRvdyA9IG5ldyB1dGlscy5CdWY4KHMud19zaXplICogMik7XG4gIHMuaGVhZCA9IG5ldyB1dGlscy5CdWYxNihzLmhhc2hfc2l6ZSk7XG4gIHMucHJldiA9IG5ldyB1dGlscy5CdWYxNihzLndfc2l6ZSk7XG5cbiAgLy8gRG9uJ3QgbmVlZCBtZW0gaW5pdCBtYWdpYyBmb3IgSlMuXG4gIC8vcy5oaWdoX3dhdGVyID0gMDsgIC8qIG5vdGhpbmcgd3JpdHRlbiB0byBzLT53aW5kb3cgeWV0ICovXG5cbiAgcy5saXRfYnVmc2l6ZSA9IDEgPDwgKG1lbUxldmVsICsgNik7IC8qIDE2SyBlbGVtZW50cyBieSBkZWZhdWx0ICovXG5cbiAgcy5wZW5kaW5nX2J1Zl9zaXplID0gcy5saXRfYnVmc2l6ZSAqIDQ7XG4gIHMucGVuZGluZ19idWYgPSBuZXcgdXRpbHMuQnVmOChzLnBlbmRpbmdfYnVmX3NpemUpO1xuXG4gIHMuZF9idWYgPSBzLmxpdF9idWZzaXplID4+IDE7XG4gIHMubF9idWYgPSAoMSArIDIpICogcy5saXRfYnVmc2l6ZTtcblxuICBzLmxldmVsID0gbGV2ZWw7XG4gIHMuc3RyYXRlZ3kgPSBzdHJhdGVneTtcbiAgcy5tZXRob2QgPSBtZXRob2Q7XG5cbiAgcmV0dXJuIGRlZmxhdGVSZXNldChzdHJtKTtcbn1cblxuZnVuY3Rpb24gZGVmbGF0ZUluaXQoc3RybSwgbGV2ZWwpIHtcbiAgcmV0dXJuIGRlZmxhdGVJbml0MihzdHJtLCBsZXZlbCwgWl9ERUZMQVRFRCwgTUFYX1dCSVRTLCBERUZfTUVNX0xFVkVMLCBaX0RFRkFVTFRfU1RSQVRFR1kpO1xufVxuXG5cbmZ1bmN0aW9uIGRlZmxhdGUoc3RybSwgZmx1c2gpIHtcbiAgdmFyIG9sZF9mbHVzaCwgcztcbiAgdmFyIGJlZywgdmFsOyAvLyBmb3IgZ3ppcCBoZWFkZXIgd3JpdGUgb25seVxuXG4gIGlmICghc3RybSB8fCAhc3RybS5zdGF0ZSB8fFxuICAgIGZsdXNoID4gWl9CTE9DSyB8fCBmbHVzaCA8IDApIHtcbiAgICByZXR1cm4gc3RybSA/IGVycihzdHJtLCBaX1NUUkVBTV9FUlJPUikgOiBaX1NUUkVBTV9FUlJPUjtcbiAgfVxuXG4gIHMgPSBzdHJtLnN0YXRlO1xuXG4gIGlmICghc3RybS5vdXRwdXQgfHxcbiAgICAgICghc3RybS5pbnB1dCAmJiBzdHJtLmF2YWlsX2luICE9PSAwKSB8fFxuICAgICAgKHMuc3RhdHVzID09PSBGSU5JU0hfU1RBVEUgJiYgZmx1c2ggIT09IFpfRklOSVNIKSkge1xuICAgIHJldHVybiBlcnIoc3RybSwgKHN0cm0uYXZhaWxfb3V0ID09PSAwKSA/IFpfQlVGX0VSUk9SIDogWl9TVFJFQU1fRVJST1IpO1xuICB9XG5cbiAgcy5zdHJtID0gc3RybTsgLyoganVzdCBpbiBjYXNlICovXG4gIG9sZF9mbHVzaCA9IHMubGFzdF9mbHVzaDtcbiAgcy5sYXN0X2ZsdXNoID0gZmx1c2g7XG5cbiAgLyogV3JpdGUgdGhlIGhlYWRlciAqL1xuICBpZiAocy5zdGF0dXMgPT09IElOSVRfU1RBVEUpIHtcblxuICAgIGlmIChzLndyYXAgPT09IDIpIHsgLy8gR1pJUCBoZWFkZXJcbiAgICAgIHN0cm0uYWRsZXIgPSAwOyAgLy9jcmMzMigwTCwgWl9OVUxMLCAwKTtcbiAgICAgIHB1dF9ieXRlKHMsIDMxKTtcbiAgICAgIHB1dF9ieXRlKHMsIDEzOSk7XG4gICAgICBwdXRfYnl0ZShzLCA4KTtcbiAgICAgIGlmICghcy5nemhlYWQpIHsgLy8gcy0+Z3poZWFkID09IFpfTlVMTFxuICAgICAgICBwdXRfYnl0ZShzLCAwKTtcbiAgICAgICAgcHV0X2J5dGUocywgMCk7XG4gICAgICAgIHB1dF9ieXRlKHMsIDApO1xuICAgICAgICBwdXRfYnl0ZShzLCAwKTtcbiAgICAgICAgcHV0X2J5dGUocywgMCk7XG4gICAgICAgIHB1dF9ieXRlKHMsIHMubGV2ZWwgPT09IDkgPyAyIDpcbiAgICAgICAgICAgICAgICAgICAgKHMuc3RyYXRlZ3kgPj0gWl9IVUZGTUFOX09OTFkgfHwgcy5sZXZlbCA8IDIgP1xuICAgICAgICAgICAgICAgICAgICAgNCA6IDApKTtcbiAgICAgICAgcHV0X2J5dGUocywgT1NfQ09ERSk7XG4gICAgICAgIHMuc3RhdHVzID0gQlVTWV9TVEFURTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBwdXRfYnl0ZShzLCAocy5nemhlYWQudGV4dCA/IDEgOiAwKSArXG4gICAgICAgICAgICAgICAgICAgIChzLmd6aGVhZC5oY3JjID8gMiA6IDApICtcbiAgICAgICAgICAgICAgICAgICAgKCFzLmd6aGVhZC5leHRyYSA/IDAgOiA0KSArXG4gICAgICAgICAgICAgICAgICAgICghcy5nemhlYWQubmFtZSA/IDAgOiA4KSArXG4gICAgICAgICAgICAgICAgICAgICghcy5nemhlYWQuY29tbWVudCA/IDAgOiAxNilcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICBwdXRfYnl0ZShzLCBzLmd6aGVhZC50aW1lICYgMHhmZik7XG4gICAgICAgIHB1dF9ieXRlKHMsIChzLmd6aGVhZC50aW1lID4+IDgpICYgMHhmZik7XG4gICAgICAgIHB1dF9ieXRlKHMsIChzLmd6aGVhZC50aW1lID4+IDE2KSAmIDB4ZmYpO1xuICAgICAgICBwdXRfYnl0ZShzLCAocy5nemhlYWQudGltZSA+PiAyNCkgJiAweGZmKTtcbiAgICAgICAgcHV0X2J5dGUocywgcy5sZXZlbCA9PT0gOSA/IDIgOlxuICAgICAgICAgICAgICAgICAgICAocy5zdHJhdGVneSA+PSBaX0hVRkZNQU5fT05MWSB8fCBzLmxldmVsIDwgMiA/XG4gICAgICAgICAgICAgICAgICAgICA0IDogMCkpO1xuICAgICAgICBwdXRfYnl0ZShzLCBzLmd6aGVhZC5vcyAmIDB4ZmYpO1xuICAgICAgICBpZiAocy5nemhlYWQuZXh0cmEgJiYgcy5nemhlYWQuZXh0cmEubGVuZ3RoKSB7XG4gICAgICAgICAgcHV0X2J5dGUocywgcy5nemhlYWQuZXh0cmEubGVuZ3RoICYgMHhmZik7XG4gICAgICAgICAgcHV0X2J5dGUocywgKHMuZ3poZWFkLmV4dHJhLmxlbmd0aCA+PiA4KSAmIDB4ZmYpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzLmd6aGVhZC5oY3JjKSB7XG4gICAgICAgICAgc3RybS5hZGxlciA9IGNyYzMyKHN0cm0uYWRsZXIsIHMucGVuZGluZ19idWYsIHMucGVuZGluZywgMCk7XG4gICAgICAgIH1cbiAgICAgICAgcy5nemluZGV4ID0gMDtcbiAgICAgICAgcy5zdGF0dXMgPSBFWFRSQV9TVEFURTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSAvLyBERUZMQVRFIGhlYWRlclxuICAgIHtcbiAgICAgIHZhciBoZWFkZXIgPSAoWl9ERUZMQVRFRCArICgocy53X2JpdHMgLSA4KSA8PCA0KSkgPDwgODtcbiAgICAgIHZhciBsZXZlbF9mbGFncyA9IC0xO1xuXG4gICAgICBpZiAocy5zdHJhdGVneSA+PSBaX0hVRkZNQU5fT05MWSB8fCBzLmxldmVsIDwgMikge1xuICAgICAgICBsZXZlbF9mbGFncyA9IDA7XG4gICAgICB9IGVsc2UgaWYgKHMubGV2ZWwgPCA2KSB7XG4gICAgICAgIGxldmVsX2ZsYWdzID0gMTtcbiAgICAgIH0gZWxzZSBpZiAocy5sZXZlbCA9PT0gNikge1xuICAgICAgICBsZXZlbF9mbGFncyA9IDI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZXZlbF9mbGFncyA9IDM7XG4gICAgICB9XG4gICAgICBoZWFkZXIgfD0gKGxldmVsX2ZsYWdzIDw8IDYpO1xuICAgICAgaWYgKHMuc3Ryc3RhcnQgIT09IDApIHsgaGVhZGVyIHw9IFBSRVNFVF9ESUNUOyB9XG4gICAgICBoZWFkZXIgKz0gMzEgLSAoaGVhZGVyICUgMzEpO1xuXG4gICAgICBzLnN0YXR1cyA9IEJVU1lfU1RBVEU7XG4gICAgICBwdXRTaG9ydE1TQihzLCBoZWFkZXIpO1xuXG4gICAgICAvKiBTYXZlIHRoZSBhZGxlcjMyIG9mIHRoZSBwcmVzZXQgZGljdGlvbmFyeTogKi9cbiAgICAgIGlmIChzLnN0cnN0YXJ0ICE9PSAwKSB7XG4gICAgICAgIHB1dFNob3J0TVNCKHMsIHN0cm0uYWRsZXIgPj4+IDE2KTtcbiAgICAgICAgcHV0U2hvcnRNU0Iocywgc3RybS5hZGxlciAmIDB4ZmZmZik7XG4gICAgICB9XG4gICAgICBzdHJtLmFkbGVyID0gMTsgLy8gYWRsZXIzMigwTCwgWl9OVUxMLCAwKTtcbiAgICB9XG4gIH1cblxuLy8jaWZkZWYgR1pJUFxuICBpZiAocy5zdGF0dXMgPT09IEVYVFJBX1NUQVRFKSB7XG4gICAgaWYgKHMuZ3poZWFkLmV4dHJhLyogIT0gWl9OVUxMKi8pIHtcbiAgICAgIGJlZyA9IHMucGVuZGluZzsgIC8qIHN0YXJ0IG9mIGJ5dGVzIHRvIHVwZGF0ZSBjcmMgKi9cblxuICAgICAgd2hpbGUgKHMuZ3ppbmRleCA8IChzLmd6aGVhZC5leHRyYS5sZW5ndGggJiAweGZmZmYpKSB7XG4gICAgICAgIGlmIChzLnBlbmRpbmcgPT09IHMucGVuZGluZ19idWZfc2l6ZSkge1xuICAgICAgICAgIGlmIChzLmd6aGVhZC5oY3JjICYmIHMucGVuZGluZyA+IGJlZykge1xuICAgICAgICAgICAgc3RybS5hZGxlciA9IGNyYzMyKHN0cm0uYWRsZXIsIHMucGVuZGluZ19idWYsIHMucGVuZGluZyAtIGJlZywgYmVnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZmx1c2hfcGVuZGluZyhzdHJtKTtcbiAgICAgICAgICBiZWcgPSBzLnBlbmRpbmc7XG4gICAgICAgICAgaWYgKHMucGVuZGluZyA9PT0gcy5wZW5kaW5nX2J1Zl9zaXplKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcHV0X2J5dGUocywgcy5nemhlYWQuZXh0cmFbcy5nemluZGV4XSAmIDB4ZmYpO1xuICAgICAgICBzLmd6aW5kZXgrKztcbiAgICAgIH1cbiAgICAgIGlmIChzLmd6aGVhZC5oY3JjICYmIHMucGVuZGluZyA+IGJlZykge1xuICAgICAgICBzdHJtLmFkbGVyID0gY3JjMzIoc3RybS5hZGxlciwgcy5wZW5kaW5nX2J1Ziwgcy5wZW5kaW5nIC0gYmVnLCBiZWcpO1xuICAgICAgfVxuICAgICAgaWYgKHMuZ3ppbmRleCA9PT0gcy5nemhlYWQuZXh0cmEubGVuZ3RoKSB7XG4gICAgICAgIHMuZ3ppbmRleCA9IDA7XG4gICAgICAgIHMuc3RhdHVzID0gTkFNRV9TVEFURTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBzLnN0YXR1cyA9IE5BTUVfU1RBVEU7XG4gICAgfVxuICB9XG4gIGlmIChzLnN0YXR1cyA9PT0gTkFNRV9TVEFURSkge1xuICAgIGlmIChzLmd6aGVhZC5uYW1lLyogIT0gWl9OVUxMKi8pIHtcbiAgICAgIGJlZyA9IHMucGVuZGluZzsgIC8qIHN0YXJ0IG9mIGJ5dGVzIHRvIHVwZGF0ZSBjcmMgKi9cbiAgICAgIC8vaW50IHZhbDtcblxuICAgICAgZG8ge1xuICAgICAgICBpZiAocy5wZW5kaW5nID09PSBzLnBlbmRpbmdfYnVmX3NpemUpIHtcbiAgICAgICAgICBpZiAocy5nemhlYWQuaGNyYyAmJiBzLnBlbmRpbmcgPiBiZWcpIHtcbiAgICAgICAgICAgIHN0cm0uYWRsZXIgPSBjcmMzMihzdHJtLmFkbGVyLCBzLnBlbmRpbmdfYnVmLCBzLnBlbmRpbmcgLSBiZWcsIGJlZyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZsdXNoX3BlbmRpbmcoc3RybSk7XG4gICAgICAgICAgYmVnID0gcy5wZW5kaW5nO1xuICAgICAgICAgIGlmIChzLnBlbmRpbmcgPT09IHMucGVuZGluZ19idWZfc2l6ZSkge1xuICAgICAgICAgICAgdmFsID0gMTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBKUyBzcGVjaWZpYzogbGl0dGxlIG1hZ2ljIHRvIGFkZCB6ZXJvIHRlcm1pbmF0b3IgdG8gZW5kIG9mIHN0cmluZ1xuICAgICAgICBpZiAocy5nemluZGV4IDwgcy5nemhlYWQubmFtZS5sZW5ndGgpIHtcbiAgICAgICAgICB2YWwgPSBzLmd6aGVhZC5uYW1lLmNoYXJDb2RlQXQocy5nemluZGV4KyspICYgMHhmZjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWwgPSAwO1xuICAgICAgICB9XG4gICAgICAgIHB1dF9ieXRlKHMsIHZhbCk7XG4gICAgICB9IHdoaWxlICh2YWwgIT09IDApO1xuXG4gICAgICBpZiAocy5nemhlYWQuaGNyYyAmJiBzLnBlbmRpbmcgPiBiZWcpIHtcbiAgICAgICAgc3RybS5hZGxlciA9IGNyYzMyKHN0cm0uYWRsZXIsIHMucGVuZGluZ19idWYsIHMucGVuZGluZyAtIGJlZywgYmVnKTtcbiAgICAgIH1cbiAgICAgIGlmICh2YWwgPT09IDApIHtcbiAgICAgICAgcy5nemluZGV4ID0gMDtcbiAgICAgICAgcy5zdGF0dXMgPSBDT01NRU5UX1NUQVRFO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHMuc3RhdHVzID0gQ09NTUVOVF9TVEFURTtcbiAgICB9XG4gIH1cbiAgaWYgKHMuc3RhdHVzID09PSBDT01NRU5UX1NUQVRFKSB7XG4gICAgaWYgKHMuZ3poZWFkLmNvbW1lbnQvKiAhPSBaX05VTEwqLykge1xuICAgICAgYmVnID0gcy5wZW5kaW5nOyAgLyogc3RhcnQgb2YgYnl0ZXMgdG8gdXBkYXRlIGNyYyAqL1xuICAgICAgLy9pbnQgdmFsO1xuXG4gICAgICBkbyB7XG4gICAgICAgIGlmIChzLnBlbmRpbmcgPT09IHMucGVuZGluZ19idWZfc2l6ZSkge1xuICAgICAgICAgIGlmIChzLmd6aGVhZC5oY3JjICYmIHMucGVuZGluZyA+IGJlZykge1xuICAgICAgICAgICAgc3RybS5hZGxlciA9IGNyYzMyKHN0cm0uYWRsZXIsIHMucGVuZGluZ19idWYsIHMucGVuZGluZyAtIGJlZywgYmVnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZmx1c2hfcGVuZGluZyhzdHJtKTtcbiAgICAgICAgICBiZWcgPSBzLnBlbmRpbmc7XG4gICAgICAgICAgaWYgKHMucGVuZGluZyA9PT0gcy5wZW5kaW5nX2J1Zl9zaXplKSB7XG4gICAgICAgICAgICB2YWwgPSAxO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEpTIHNwZWNpZmljOiBsaXR0bGUgbWFnaWMgdG8gYWRkIHplcm8gdGVybWluYXRvciB0byBlbmQgb2Ygc3RyaW5nXG4gICAgICAgIGlmIChzLmd6aW5kZXggPCBzLmd6aGVhZC5jb21tZW50Lmxlbmd0aCkge1xuICAgICAgICAgIHZhbCA9IHMuZ3poZWFkLmNvbW1lbnQuY2hhckNvZGVBdChzLmd6aW5kZXgrKykgJiAweGZmO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgcHV0X2J5dGUocywgdmFsKTtcbiAgICAgIH0gd2hpbGUgKHZhbCAhPT0gMCk7XG5cbiAgICAgIGlmIChzLmd6aGVhZC5oY3JjICYmIHMucGVuZGluZyA+IGJlZykge1xuICAgICAgICBzdHJtLmFkbGVyID0gY3JjMzIoc3RybS5hZGxlciwgcy5wZW5kaW5nX2J1Ziwgcy5wZW5kaW5nIC0gYmVnLCBiZWcpO1xuICAgICAgfVxuICAgICAgaWYgKHZhbCA9PT0gMCkge1xuICAgICAgICBzLnN0YXR1cyA9IEhDUkNfU1RBVEU7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcy5zdGF0dXMgPSBIQ1JDX1NUQVRFO1xuICAgIH1cbiAgfVxuICBpZiAocy5zdGF0dXMgPT09IEhDUkNfU1RBVEUpIHtcbiAgICBpZiAocy5nemhlYWQuaGNyYykge1xuICAgICAgaWYgKHMucGVuZGluZyArIDIgPiBzLnBlbmRpbmdfYnVmX3NpemUpIHtcbiAgICAgICAgZmx1c2hfcGVuZGluZyhzdHJtKTtcbiAgICAgIH1cbiAgICAgIGlmIChzLnBlbmRpbmcgKyAyIDw9IHMucGVuZGluZ19idWZfc2l6ZSkge1xuICAgICAgICBwdXRfYnl0ZShzLCBzdHJtLmFkbGVyICYgMHhmZik7XG4gICAgICAgIHB1dF9ieXRlKHMsIChzdHJtLmFkbGVyID4+IDgpICYgMHhmZik7XG4gICAgICAgIHN0cm0uYWRsZXIgPSAwOyAvL2NyYzMyKDBMLCBaX05VTEwsIDApO1xuICAgICAgICBzLnN0YXR1cyA9IEJVU1lfU1RBVEU7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcy5zdGF0dXMgPSBCVVNZX1NUQVRFO1xuICAgIH1cbiAgfVxuLy8jZW5kaWZcblxuICAvKiBGbHVzaCBhcyBtdWNoIHBlbmRpbmcgb3V0cHV0IGFzIHBvc3NpYmxlICovXG4gIGlmIChzLnBlbmRpbmcgIT09IDApIHtcbiAgICBmbHVzaF9wZW5kaW5nKHN0cm0pO1xuICAgIGlmIChzdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgLyogU2luY2UgYXZhaWxfb3V0IGlzIDAsIGRlZmxhdGUgd2lsbCBiZSBjYWxsZWQgYWdhaW4gd2l0aFxuICAgICAgICogbW9yZSBvdXRwdXQgc3BhY2UsIGJ1dCBwb3NzaWJseSB3aXRoIGJvdGggcGVuZGluZyBhbmRcbiAgICAgICAqIGF2YWlsX2luIGVxdWFsIHRvIHplcm8uIFRoZXJlIHdvbid0IGJlIGFueXRoaW5nIHRvIGRvLFxuICAgICAgICogYnV0IHRoaXMgaXMgbm90IGFuIGVycm9yIHNpdHVhdGlvbiBzbyBtYWtlIHN1cmUgd2VcbiAgICAgICAqIHJldHVybiBPSyBpbnN0ZWFkIG9mIEJVRl9FUlJPUiBhdCBuZXh0IGNhbGwgb2YgZGVmbGF0ZTpcbiAgICAgICAqL1xuICAgICAgcy5sYXN0X2ZsdXNoID0gLTE7XG4gICAgICByZXR1cm4gWl9PSztcbiAgICB9XG5cbiAgICAvKiBNYWtlIHN1cmUgdGhlcmUgaXMgc29tZXRoaW5nIHRvIGRvIGFuZCBhdm9pZCBkdXBsaWNhdGUgY29uc2VjdXRpdmVcbiAgICAgKiBmbHVzaGVzLiBGb3IgcmVwZWF0ZWQgYW5kIHVzZWxlc3MgY2FsbHMgd2l0aCBaX0ZJTklTSCwgd2Uga2VlcFxuICAgICAqIHJldHVybmluZyBaX1NUUkVBTV9FTkQgaW5zdGVhZCBvZiBaX0JVRl9FUlJPUi5cbiAgICAgKi9cbiAgfSBlbHNlIGlmIChzdHJtLmF2YWlsX2luID09PSAwICYmIHJhbmsoZmx1c2gpIDw9IHJhbmsob2xkX2ZsdXNoKSAmJlxuICAgIGZsdXNoICE9PSBaX0ZJTklTSCkge1xuICAgIHJldHVybiBlcnIoc3RybSwgWl9CVUZfRVJST1IpO1xuICB9XG5cbiAgLyogVXNlciBtdXN0IG5vdCBwcm92aWRlIG1vcmUgaW5wdXQgYWZ0ZXIgdGhlIGZpcnN0IEZJTklTSDogKi9cbiAgaWYgKHMuc3RhdHVzID09PSBGSU5JU0hfU1RBVEUgJiYgc3RybS5hdmFpbF9pbiAhPT0gMCkge1xuICAgIHJldHVybiBlcnIoc3RybSwgWl9CVUZfRVJST1IpO1xuICB9XG5cbiAgLyogU3RhcnQgYSBuZXcgYmxvY2sgb3IgY29udGludWUgdGhlIGN1cnJlbnQgb25lLlxuICAgKi9cbiAgaWYgKHN0cm0uYXZhaWxfaW4gIT09IDAgfHwgcy5sb29rYWhlYWQgIT09IDAgfHxcbiAgICAoZmx1c2ggIT09IFpfTk9fRkxVU0ggJiYgcy5zdGF0dXMgIT09IEZJTklTSF9TVEFURSkpIHtcbiAgICB2YXIgYnN0YXRlID0gKHMuc3RyYXRlZ3kgPT09IFpfSFVGRk1BTl9PTkxZKSA/IGRlZmxhdGVfaHVmZihzLCBmbHVzaCkgOlxuICAgICAgKHMuc3RyYXRlZ3kgPT09IFpfUkxFID8gZGVmbGF0ZV9ybGUocywgZmx1c2gpIDpcbiAgICAgICAgY29uZmlndXJhdGlvbl90YWJsZVtzLmxldmVsXS5mdW5jKHMsIGZsdXNoKSk7XG5cbiAgICBpZiAoYnN0YXRlID09PSBCU19GSU5JU0hfU1RBUlRFRCB8fCBic3RhdGUgPT09IEJTX0ZJTklTSF9ET05FKSB7XG4gICAgICBzLnN0YXR1cyA9IEZJTklTSF9TVEFURTtcbiAgICB9XG4gICAgaWYgKGJzdGF0ZSA9PT0gQlNfTkVFRF9NT1JFIHx8IGJzdGF0ZSA9PT0gQlNfRklOSVNIX1NUQVJURUQpIHtcbiAgICAgIGlmIChzdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgICBzLmxhc3RfZmx1c2ggPSAtMTtcbiAgICAgICAgLyogYXZvaWQgQlVGX0VSUk9SIG5leHQgY2FsbCwgc2VlIGFib3ZlICovXG4gICAgICB9XG4gICAgICByZXR1cm4gWl9PSztcbiAgICAgIC8qIElmIGZsdXNoICE9IFpfTk9fRkxVU0ggJiYgYXZhaWxfb3V0ID09IDAsIHRoZSBuZXh0IGNhbGxcbiAgICAgICAqIG9mIGRlZmxhdGUgc2hvdWxkIHVzZSB0aGUgc2FtZSBmbHVzaCBwYXJhbWV0ZXIgdG8gbWFrZSBzdXJlXG4gICAgICAgKiB0aGF0IHRoZSBmbHVzaCBpcyBjb21wbGV0ZS4gU28gd2UgZG9uJ3QgaGF2ZSB0byBvdXRwdXQgYW5cbiAgICAgICAqIGVtcHR5IGJsb2NrIGhlcmUsIHRoaXMgd2lsbCBiZSBkb25lIGF0IG5leHQgY2FsbC4gVGhpcyBhbHNvXG4gICAgICAgKiBlbnN1cmVzIHRoYXQgZm9yIGEgdmVyeSBzbWFsbCBvdXRwdXQgYnVmZmVyLCB3ZSBlbWl0IGF0IG1vc3RcbiAgICAgICAqIG9uZSBlbXB0eSBibG9jay5cbiAgICAgICAqL1xuICAgIH1cbiAgICBpZiAoYnN0YXRlID09PSBCU19CTE9DS19ET05FKSB7XG4gICAgICBpZiAoZmx1c2ggPT09IFpfUEFSVElBTF9GTFVTSCkge1xuICAgICAgICB0cmVlcy5fdHJfYWxpZ24ocyk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChmbHVzaCAhPT0gWl9CTE9DSykgeyAvKiBGVUxMX0ZMVVNIIG9yIFNZTkNfRkxVU0ggKi9cblxuICAgICAgICB0cmVlcy5fdHJfc3RvcmVkX2Jsb2NrKHMsIDAsIDAsIGZhbHNlKTtcbiAgICAgICAgLyogRm9yIGEgZnVsbCBmbHVzaCwgdGhpcyBlbXB0eSBibG9jayB3aWxsIGJlIHJlY29nbml6ZWRcbiAgICAgICAgICogYXMgYSBzcGVjaWFsIG1hcmtlciBieSBpbmZsYXRlX3N5bmMoKS5cbiAgICAgICAgICovXG4gICAgICAgIGlmIChmbHVzaCA9PT0gWl9GVUxMX0ZMVVNIKSB7XG4gICAgICAgICAgLyoqKiBDTEVBUl9IQVNIKHMpOyAqKiovICAgICAgICAgICAgIC8qIGZvcmdldCBoaXN0b3J5ICovXG4gICAgICAgICAgemVybyhzLmhlYWQpOyAvLyBGaWxsIHdpdGggTklMICg9IDApO1xuXG4gICAgICAgICAgaWYgKHMubG9va2FoZWFkID09PSAwKSB7XG4gICAgICAgICAgICBzLnN0cnN0YXJ0ID0gMDtcbiAgICAgICAgICAgIHMuYmxvY2tfc3RhcnQgPSAwO1xuICAgICAgICAgICAgcy5pbnNlcnQgPSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZmx1c2hfcGVuZGluZyhzdHJtKTtcbiAgICAgIGlmIChzdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgICBzLmxhc3RfZmx1c2ggPSAtMTsgLyogYXZvaWQgQlVGX0VSUk9SIGF0IG5leHQgY2FsbCwgc2VlIGFib3ZlICovXG4gICAgICAgIHJldHVybiBaX09LO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvL0Fzc2VydChzdHJtLT5hdmFpbF9vdXQgPiAwLCBcImJ1ZzJcIik7XG4gIC8vaWYgKHN0cm0uYXZhaWxfb3V0IDw9IDApIHsgdGhyb3cgbmV3IEVycm9yKFwiYnVnMlwiKTt9XG5cbiAgaWYgKGZsdXNoICE9PSBaX0ZJTklTSCkgeyByZXR1cm4gWl9PSzsgfVxuICBpZiAocy53cmFwIDw9IDApIHsgcmV0dXJuIFpfU1RSRUFNX0VORDsgfVxuXG4gIC8qIFdyaXRlIHRoZSB0cmFpbGVyICovXG4gIGlmIChzLndyYXAgPT09IDIpIHtcbiAgICBwdXRfYnl0ZShzLCBzdHJtLmFkbGVyICYgMHhmZik7XG4gICAgcHV0X2J5dGUocywgKHN0cm0uYWRsZXIgPj4gOCkgJiAweGZmKTtcbiAgICBwdXRfYnl0ZShzLCAoc3RybS5hZGxlciA+PiAxNikgJiAweGZmKTtcbiAgICBwdXRfYnl0ZShzLCAoc3RybS5hZGxlciA+PiAyNCkgJiAweGZmKTtcbiAgICBwdXRfYnl0ZShzLCBzdHJtLnRvdGFsX2luICYgMHhmZik7XG4gICAgcHV0X2J5dGUocywgKHN0cm0udG90YWxfaW4gPj4gOCkgJiAweGZmKTtcbiAgICBwdXRfYnl0ZShzLCAoc3RybS50b3RhbF9pbiA+PiAxNikgJiAweGZmKTtcbiAgICBwdXRfYnl0ZShzLCAoc3RybS50b3RhbF9pbiA+PiAyNCkgJiAweGZmKTtcbiAgfVxuICBlbHNlXG4gIHtcbiAgICBwdXRTaG9ydE1TQihzLCBzdHJtLmFkbGVyID4+PiAxNik7XG4gICAgcHV0U2hvcnRNU0Iocywgc3RybS5hZGxlciAmIDB4ZmZmZik7XG4gIH1cblxuICBmbHVzaF9wZW5kaW5nKHN0cm0pO1xuICAvKiBJZiBhdmFpbF9vdXQgaXMgemVybywgdGhlIGFwcGxpY2F0aW9uIHdpbGwgY2FsbCBkZWZsYXRlIGFnYWluXG4gICAqIHRvIGZsdXNoIHRoZSByZXN0LlxuICAgKi9cbiAgaWYgKHMud3JhcCA+IDApIHsgcy53cmFwID0gLXMud3JhcDsgfVxuICAvKiB3cml0ZSB0aGUgdHJhaWxlciBvbmx5IG9uY2UhICovXG4gIHJldHVybiBzLnBlbmRpbmcgIT09IDAgPyBaX09LIDogWl9TVFJFQU1fRU5EO1xufVxuXG5mdW5jdGlvbiBkZWZsYXRlRW5kKHN0cm0pIHtcbiAgdmFyIHN0YXR1cztcblxuICBpZiAoIXN0cm0vKj09IFpfTlVMTCovIHx8ICFzdHJtLnN0YXRlLyo9PSBaX05VTEwqLykge1xuICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjtcbiAgfVxuXG4gIHN0YXR1cyA9IHN0cm0uc3RhdGUuc3RhdHVzO1xuICBpZiAoc3RhdHVzICE9PSBJTklUX1NUQVRFICYmXG4gICAgc3RhdHVzICE9PSBFWFRSQV9TVEFURSAmJlxuICAgIHN0YXR1cyAhPT0gTkFNRV9TVEFURSAmJlxuICAgIHN0YXR1cyAhPT0gQ09NTUVOVF9TVEFURSAmJlxuICAgIHN0YXR1cyAhPT0gSENSQ19TVEFURSAmJlxuICAgIHN0YXR1cyAhPT0gQlVTWV9TVEFURSAmJlxuICAgIHN0YXR1cyAhPT0gRklOSVNIX1NUQVRFXG4gICkge1xuICAgIHJldHVybiBlcnIoc3RybSwgWl9TVFJFQU1fRVJST1IpO1xuICB9XG5cbiAgc3RybS5zdGF0ZSA9IG51bGw7XG5cbiAgcmV0dXJuIHN0YXR1cyA9PT0gQlVTWV9TVEFURSA/IGVycihzdHJtLCBaX0RBVEFfRVJST1IpIDogWl9PSztcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBJbml0aWFsaXplcyB0aGUgY29tcHJlc3Npb24gZGljdGlvbmFyeSBmcm9tIHRoZSBnaXZlbiBieXRlXG4gKiBzZXF1ZW5jZSB3aXRob3V0IHByb2R1Y2luZyBhbnkgY29tcHJlc3NlZCBvdXRwdXQuXG4gKi9cbmZ1bmN0aW9uIGRlZmxhdGVTZXREaWN0aW9uYXJ5KHN0cm0sIGRpY3Rpb25hcnkpIHtcbiAgdmFyIGRpY3RMZW5ndGggPSBkaWN0aW9uYXJ5Lmxlbmd0aDtcblxuICB2YXIgcztcbiAgdmFyIHN0ciwgbjtcbiAgdmFyIHdyYXA7XG4gIHZhciBhdmFpbDtcbiAgdmFyIG5leHQ7XG4gIHZhciBpbnB1dDtcbiAgdmFyIHRtcERpY3Q7XG5cbiAgaWYgKCFzdHJtLyo9PSBaX05VTEwqLyB8fCAhc3RybS5zdGF0ZS8qPT0gWl9OVUxMKi8pIHtcbiAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7XG4gIH1cblxuICBzID0gc3RybS5zdGF0ZTtcbiAgd3JhcCA9IHMud3JhcDtcblxuICBpZiAod3JhcCA9PT0gMiB8fCAod3JhcCA9PT0gMSAmJiBzLnN0YXR1cyAhPT0gSU5JVF9TVEFURSkgfHwgcy5sb29rYWhlYWQpIHtcbiAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7XG4gIH1cblxuICAvKiB3aGVuIHVzaW5nIHpsaWIgd3JhcHBlcnMsIGNvbXB1dGUgQWRsZXItMzIgZm9yIHByb3ZpZGVkIGRpY3Rpb25hcnkgKi9cbiAgaWYgKHdyYXAgPT09IDEpIHtcbiAgICAvKiBhZGxlcjMyKHN0cm0tPmFkbGVyLCBkaWN0aW9uYXJ5LCBkaWN0TGVuZ3RoKTsgKi9cbiAgICBzdHJtLmFkbGVyID0gYWRsZXIzMihzdHJtLmFkbGVyLCBkaWN0aW9uYXJ5LCBkaWN0TGVuZ3RoLCAwKTtcbiAgfVxuXG4gIHMud3JhcCA9IDA7ICAgLyogYXZvaWQgY29tcHV0aW5nIEFkbGVyLTMyIGluIHJlYWRfYnVmICovXG5cbiAgLyogaWYgZGljdGlvbmFyeSB3b3VsZCBmaWxsIHdpbmRvdywganVzdCByZXBsYWNlIHRoZSBoaXN0b3J5ICovXG4gIGlmIChkaWN0TGVuZ3RoID49IHMud19zaXplKSB7XG4gICAgaWYgKHdyYXAgPT09IDApIHsgICAgICAgICAgICAvKiBhbHJlYWR5IGVtcHR5IG90aGVyd2lzZSAqL1xuICAgICAgLyoqKiBDTEVBUl9IQVNIKHMpOyAqKiovXG4gICAgICB6ZXJvKHMuaGVhZCk7IC8vIEZpbGwgd2l0aCBOSUwgKD0gMCk7XG4gICAgICBzLnN0cnN0YXJ0ID0gMDtcbiAgICAgIHMuYmxvY2tfc3RhcnQgPSAwO1xuICAgICAgcy5pbnNlcnQgPSAwO1xuICAgIH1cbiAgICAvKiB1c2UgdGhlIHRhaWwgKi9cbiAgICAvLyBkaWN0aW9uYXJ5ID0gZGljdGlvbmFyeS5zbGljZShkaWN0TGVuZ3RoIC0gcy53X3NpemUpO1xuICAgIHRtcERpY3QgPSBuZXcgdXRpbHMuQnVmOChzLndfc2l6ZSk7XG4gICAgdXRpbHMuYXJyYXlTZXQodG1wRGljdCwgZGljdGlvbmFyeSwgZGljdExlbmd0aCAtIHMud19zaXplLCBzLndfc2l6ZSwgMCk7XG4gICAgZGljdGlvbmFyeSA9IHRtcERpY3Q7XG4gICAgZGljdExlbmd0aCA9IHMud19zaXplO1xuICB9XG4gIC8qIGluc2VydCBkaWN0aW9uYXJ5IGludG8gd2luZG93IGFuZCBoYXNoICovXG4gIGF2YWlsID0gc3RybS5hdmFpbF9pbjtcbiAgbmV4dCA9IHN0cm0ubmV4dF9pbjtcbiAgaW5wdXQgPSBzdHJtLmlucHV0O1xuICBzdHJtLmF2YWlsX2luID0gZGljdExlbmd0aDtcbiAgc3RybS5uZXh0X2luID0gMDtcbiAgc3RybS5pbnB1dCA9IGRpY3Rpb25hcnk7XG4gIGZpbGxfd2luZG93KHMpO1xuICB3aGlsZSAocy5sb29rYWhlYWQgPj0gTUlOX01BVENIKSB7XG4gICAgc3RyID0gcy5zdHJzdGFydDtcbiAgICBuID0gcy5sb29rYWhlYWQgLSAoTUlOX01BVENIIC0gMSk7XG4gICAgZG8ge1xuICAgICAgLyogVVBEQVRFX0hBU0gocywgcy0+aW5zX2gsIHMtPndpbmRvd1tzdHIgKyBNSU5fTUFUQ0gtMV0pOyAqL1xuICAgICAgcy5pbnNfaCA9ICgocy5pbnNfaCA8PCBzLmhhc2hfc2hpZnQpIF4gcy53aW5kb3dbc3RyICsgTUlOX01BVENIIC0gMV0pICYgcy5oYXNoX21hc2s7XG5cbiAgICAgIHMucHJldltzdHIgJiBzLndfbWFza10gPSBzLmhlYWRbcy5pbnNfaF07XG5cbiAgICAgIHMuaGVhZFtzLmluc19oXSA9IHN0cjtcbiAgICAgIHN0cisrO1xuICAgIH0gd2hpbGUgKC0tbik7XG4gICAgcy5zdHJzdGFydCA9IHN0cjtcbiAgICBzLmxvb2thaGVhZCA9IE1JTl9NQVRDSCAtIDE7XG4gICAgZmlsbF93aW5kb3cocyk7XG4gIH1cbiAgcy5zdHJzdGFydCArPSBzLmxvb2thaGVhZDtcbiAgcy5ibG9ja19zdGFydCA9IHMuc3Ryc3RhcnQ7XG4gIHMuaW5zZXJ0ID0gcy5sb29rYWhlYWQ7XG4gIHMubG9va2FoZWFkID0gMDtcbiAgcy5tYXRjaF9sZW5ndGggPSBzLnByZXZfbGVuZ3RoID0gTUlOX01BVENIIC0gMTtcbiAgcy5tYXRjaF9hdmFpbGFibGUgPSAwO1xuICBzdHJtLm5leHRfaW4gPSBuZXh0O1xuICBzdHJtLmlucHV0ID0gaW5wdXQ7XG4gIHN0cm0uYXZhaWxfaW4gPSBhdmFpbDtcbiAgcy53cmFwID0gd3JhcDtcbiAgcmV0dXJuIFpfT0s7XG59XG5cblxuZXhwb3J0cy5kZWZsYXRlSW5pdCA9IGRlZmxhdGVJbml0O1xuZXhwb3J0cy5kZWZsYXRlSW5pdDIgPSBkZWZsYXRlSW5pdDI7XG5leHBvcnRzLmRlZmxhdGVSZXNldCA9IGRlZmxhdGVSZXNldDtcbmV4cG9ydHMuZGVmbGF0ZVJlc2V0S2VlcCA9IGRlZmxhdGVSZXNldEtlZXA7XG5leHBvcnRzLmRlZmxhdGVTZXRIZWFkZXIgPSBkZWZsYXRlU2V0SGVhZGVyO1xuZXhwb3J0cy5kZWZsYXRlID0gZGVmbGF0ZTtcbmV4cG9ydHMuZGVmbGF0ZUVuZCA9IGRlZmxhdGVFbmQ7XG5leHBvcnRzLmRlZmxhdGVTZXREaWN0aW9uYXJ5ID0gZGVmbGF0ZVNldERpY3Rpb25hcnk7XG5leHBvcnRzLmRlZmxhdGVJbmZvID0gJ3Bha28gZGVmbGF0ZSAoZnJvbSBOb2RlY2EgcHJvamVjdCknO1xuXG4vKiBOb3QgaW1wbGVtZW50ZWRcbmV4cG9ydHMuZGVmbGF0ZUJvdW5kID0gZGVmbGF0ZUJvdW5kO1xuZXhwb3J0cy5kZWZsYXRlQ29weSA9IGRlZmxhdGVDb3B5O1xuZXhwb3J0cy5kZWZsYXRlUGFyYW1zID0gZGVmbGF0ZVBhcmFtcztcbmV4cG9ydHMuZGVmbGF0ZVBlbmRpbmcgPSBkZWZsYXRlUGVuZGluZztcbmV4cG9ydHMuZGVmbGF0ZVByaW1lID0gZGVmbGF0ZVByaW1lO1xuZXhwb3J0cy5kZWZsYXRlVHVuZSA9IGRlZmxhdGVUdW5lO1xuKi9cbiIsIid1c2Ugc3RyaWN0JztcblxuXG5mdW5jdGlvbiBHWmhlYWRlcigpIHtcbiAgLyogdHJ1ZSBpZiBjb21wcmVzc2VkIGRhdGEgYmVsaWV2ZWQgdG8gYmUgdGV4dCAqL1xuICB0aGlzLnRleHQgICAgICAgPSAwO1xuICAvKiBtb2RpZmljYXRpb24gdGltZSAqL1xuICB0aGlzLnRpbWUgICAgICAgPSAwO1xuICAvKiBleHRyYSBmbGFncyAobm90IHVzZWQgd2hlbiB3cml0aW5nIGEgZ3ppcCBmaWxlKSAqL1xuICB0aGlzLnhmbGFncyAgICAgPSAwO1xuICAvKiBvcGVyYXRpbmcgc3lzdGVtICovXG4gIHRoaXMub3MgICAgICAgICA9IDA7XG4gIC8qIHBvaW50ZXIgdG8gZXh0cmEgZmllbGQgb3IgWl9OVUxMIGlmIG5vbmUgKi9cbiAgdGhpcy5leHRyYSAgICAgID0gbnVsbDtcbiAgLyogZXh0cmEgZmllbGQgbGVuZ3RoICh2YWxpZCBpZiBleHRyYSAhPSBaX05VTEwpICovXG4gIHRoaXMuZXh0cmFfbGVuICA9IDA7IC8vIEFjdHVhbGx5LCB3ZSBkb24ndCBuZWVkIGl0IGluIEpTLFxuICAgICAgICAgICAgICAgICAgICAgICAvLyBidXQgbGVhdmUgZm9yIGZldyBjb2RlIG1vZGlmaWNhdGlvbnNcblxuICAvL1xuICAvLyBTZXR1cCBsaW1pdHMgaXMgbm90IG5lY2Vzc2FyeSBiZWNhdXNlIGluIGpzIHdlIHNob3VsZCBub3QgcHJlYWxsb2NhdGUgbWVtb3J5XG4gIC8vIGZvciBpbmZsYXRlIHVzZSBjb25zdGFudCBsaW1pdCBpbiA2NTUzNiBieXRlc1xuICAvL1xuXG4gIC8qIHNwYWNlIGF0IGV4dHJhIChvbmx5IHdoZW4gcmVhZGluZyBoZWFkZXIpICovXG4gIC8vIHRoaXMuZXh0cmFfbWF4ICA9IDA7XG4gIC8qIHBvaW50ZXIgdG8gemVyby10ZXJtaW5hdGVkIGZpbGUgbmFtZSBvciBaX05VTEwgKi9cbiAgdGhpcy5uYW1lICAgICAgID0gJyc7XG4gIC8qIHNwYWNlIGF0IG5hbWUgKG9ubHkgd2hlbiByZWFkaW5nIGhlYWRlcikgKi9cbiAgLy8gdGhpcy5uYW1lX21heCAgID0gMDtcbiAgLyogcG9pbnRlciB0byB6ZXJvLXRlcm1pbmF0ZWQgY29tbWVudCBvciBaX05VTEwgKi9cbiAgdGhpcy5jb21tZW50ICAgID0gJyc7XG4gIC8qIHNwYWNlIGF0IGNvbW1lbnQgKG9ubHkgd2hlbiByZWFkaW5nIGhlYWRlcikgKi9cbiAgLy8gdGhpcy5jb21tX21heCAgID0gMDtcbiAgLyogdHJ1ZSBpZiB0aGVyZSB3YXMgb3Igd2lsbCBiZSBhIGhlYWRlciBjcmMgKi9cbiAgdGhpcy5oY3JjICAgICAgID0gMDtcbiAgLyogdHJ1ZSB3aGVuIGRvbmUgcmVhZGluZyBnemlwIGhlYWRlciAobm90IHVzZWQgd2hlbiB3cml0aW5nIGEgZ3ppcCBmaWxlKSAqL1xuICB0aGlzLmRvbmUgICAgICAgPSBmYWxzZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBHWmhlYWRlcjtcbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gU2VlIHN0YXRlIGRlZnMgZnJvbSBpbmZsYXRlLmpzXG52YXIgQkFEID0gMzA7ICAgICAgIC8qIGdvdCBhIGRhdGEgZXJyb3IgLS0gcmVtYWluIGhlcmUgdW50aWwgcmVzZXQgKi9cbnZhciBUWVBFID0gMTI7ICAgICAgLyogaTogd2FpdGluZyBmb3IgdHlwZSBiaXRzLCBpbmNsdWRpbmcgbGFzdC1mbGFnIGJpdCAqL1xuXG4vKlxuICAgRGVjb2RlIGxpdGVyYWwsIGxlbmd0aCwgYW5kIGRpc3RhbmNlIGNvZGVzIGFuZCB3cml0ZSBvdXQgdGhlIHJlc3VsdGluZ1xuICAgbGl0ZXJhbCBhbmQgbWF0Y2ggYnl0ZXMgdW50aWwgZWl0aGVyIG5vdCBlbm91Z2ggaW5wdXQgb3Igb3V0cHV0IGlzXG4gICBhdmFpbGFibGUsIGFuIGVuZC1vZi1ibG9jayBpcyBlbmNvdW50ZXJlZCwgb3IgYSBkYXRhIGVycm9yIGlzIGVuY291bnRlcmVkLlxuICAgV2hlbiBsYXJnZSBlbm91Z2ggaW5wdXQgYW5kIG91dHB1dCBidWZmZXJzIGFyZSBzdXBwbGllZCB0byBpbmZsYXRlKCksIGZvclxuICAgZXhhbXBsZSwgYSAxNksgaW5wdXQgYnVmZmVyIGFuZCBhIDY0SyBvdXRwdXQgYnVmZmVyLCBtb3JlIHRoYW4gOTUlIG9mIHRoZVxuICAgaW5mbGF0ZSBleGVjdXRpb24gdGltZSBpcyBzcGVudCBpbiB0aGlzIHJvdXRpbmUuXG5cbiAgIEVudHJ5IGFzc3VtcHRpb25zOlxuXG4gICAgICAgIHN0YXRlLm1vZGUgPT09IExFTlxuICAgICAgICBzdHJtLmF2YWlsX2luID49IDZcbiAgICAgICAgc3RybS5hdmFpbF9vdXQgPj0gMjU4XG4gICAgICAgIHN0YXJ0ID49IHN0cm0uYXZhaWxfb3V0XG4gICAgICAgIHN0YXRlLmJpdHMgPCA4XG5cbiAgIE9uIHJldHVybiwgc3RhdGUubW9kZSBpcyBvbmUgb2Y6XG5cbiAgICAgICAgTEVOIC0tIHJhbiBvdXQgb2YgZW5vdWdoIG91dHB1dCBzcGFjZSBvciBlbm91Z2ggYXZhaWxhYmxlIGlucHV0XG4gICAgICAgIFRZUEUgLS0gcmVhY2hlZCBlbmQgb2YgYmxvY2sgY29kZSwgaW5mbGF0ZSgpIHRvIGludGVycHJldCBuZXh0IGJsb2NrXG4gICAgICAgIEJBRCAtLSBlcnJvciBpbiBibG9jayBkYXRhXG5cbiAgIE5vdGVzOlxuXG4gICAgLSBUaGUgbWF4aW11bSBpbnB1dCBiaXRzIHVzZWQgYnkgYSBsZW5ndGgvZGlzdGFuY2UgcGFpciBpcyAxNSBiaXRzIGZvciB0aGVcbiAgICAgIGxlbmd0aCBjb2RlLCA1IGJpdHMgZm9yIHRoZSBsZW5ndGggZXh0cmEsIDE1IGJpdHMgZm9yIHRoZSBkaXN0YW5jZSBjb2RlLFxuICAgICAgYW5kIDEzIGJpdHMgZm9yIHRoZSBkaXN0YW5jZSBleHRyYS4gIFRoaXMgdG90YWxzIDQ4IGJpdHMsIG9yIHNpeCBieXRlcy5cbiAgICAgIFRoZXJlZm9yZSBpZiBzdHJtLmF2YWlsX2luID49IDYsIHRoZW4gdGhlcmUgaXMgZW5vdWdoIGlucHV0IHRvIGF2b2lkXG4gICAgICBjaGVja2luZyBmb3IgYXZhaWxhYmxlIGlucHV0IHdoaWxlIGRlY29kaW5nLlxuXG4gICAgLSBUaGUgbWF4aW11bSBieXRlcyB0aGF0IGEgc2luZ2xlIGxlbmd0aC9kaXN0YW5jZSBwYWlyIGNhbiBvdXRwdXQgaXMgMjU4XG4gICAgICBieXRlcywgd2hpY2ggaXMgdGhlIG1heGltdW0gbGVuZ3RoIHRoYXQgY2FuIGJlIGNvZGVkLiAgaW5mbGF0ZV9mYXN0KClcbiAgICAgIHJlcXVpcmVzIHN0cm0uYXZhaWxfb3V0ID49IDI1OCBmb3IgZWFjaCBsb29wIHRvIGF2b2lkIGNoZWNraW5nIGZvclxuICAgICAgb3V0cHV0IHNwYWNlLlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluZmxhdGVfZmFzdChzdHJtLCBzdGFydCkge1xuICB2YXIgc3RhdGU7XG4gIHZhciBfaW47ICAgICAgICAgICAgICAgICAgICAvKiBsb2NhbCBzdHJtLmlucHV0ICovXG4gIHZhciBsYXN0OyAgICAgICAgICAgICAgICAgICAvKiBoYXZlIGVub3VnaCBpbnB1dCB3aGlsZSBpbiA8IGxhc3QgKi9cbiAgdmFyIF9vdXQ7ICAgICAgICAgICAgICAgICAgIC8qIGxvY2FsIHN0cm0ub3V0cHV0ICovXG4gIHZhciBiZWc7ICAgICAgICAgICAgICAgICAgICAvKiBpbmZsYXRlKCkncyBpbml0aWFsIHN0cm0ub3V0cHV0ICovXG4gIHZhciBlbmQ7ICAgICAgICAgICAgICAgICAgICAvKiB3aGlsZSBvdXQgPCBlbmQsIGVub3VnaCBzcGFjZSBhdmFpbGFibGUgKi9cbi8vI2lmZGVmIElORkxBVEVfU1RSSUNUXG4gIHZhciBkbWF4OyAgICAgICAgICAgICAgICAgICAvKiBtYXhpbXVtIGRpc3RhbmNlIGZyb20gemxpYiBoZWFkZXIgKi9cbi8vI2VuZGlmXG4gIHZhciB3c2l6ZTsgICAgICAgICAgICAgICAgICAvKiB3aW5kb3cgc2l6ZSBvciB6ZXJvIGlmIG5vdCB1c2luZyB3aW5kb3cgKi9cbiAgdmFyIHdoYXZlOyAgICAgICAgICAgICAgICAgIC8qIHZhbGlkIGJ5dGVzIGluIHRoZSB3aW5kb3cgKi9cbiAgdmFyIHduZXh0OyAgICAgICAgICAgICAgICAgIC8qIHdpbmRvdyB3cml0ZSBpbmRleCAqL1xuICAvLyBVc2UgYHNfd2luZG93YCBpbnN0ZWFkIGB3aW5kb3dgLCBhdm9pZCBjb25mbGljdCB3aXRoIGluc3RydW1lbnRhdGlvbiB0b29sc1xuICB2YXIgc193aW5kb3c7ICAgICAgICAgICAgICAgLyogYWxsb2NhdGVkIHNsaWRpbmcgd2luZG93LCBpZiB3c2l6ZSAhPSAwICovXG4gIHZhciBob2xkOyAgICAgICAgICAgICAgICAgICAvKiBsb2NhbCBzdHJtLmhvbGQgKi9cbiAgdmFyIGJpdHM7ICAgICAgICAgICAgICAgICAgIC8qIGxvY2FsIHN0cm0uYml0cyAqL1xuICB2YXIgbGNvZGU7ICAgICAgICAgICAgICAgICAgLyogbG9jYWwgc3RybS5sZW5jb2RlICovXG4gIHZhciBkY29kZTsgICAgICAgICAgICAgICAgICAvKiBsb2NhbCBzdHJtLmRpc3Rjb2RlICovXG4gIHZhciBsbWFzazsgICAgICAgICAgICAgICAgICAvKiBtYXNrIGZvciBmaXJzdCBsZXZlbCBvZiBsZW5ndGggY29kZXMgKi9cbiAgdmFyIGRtYXNrOyAgICAgICAgICAgICAgICAgIC8qIG1hc2sgZm9yIGZpcnN0IGxldmVsIG9mIGRpc3RhbmNlIGNvZGVzICovXG4gIHZhciBoZXJlOyAgICAgICAgICAgICAgICAgICAvKiByZXRyaWV2ZWQgdGFibGUgZW50cnkgKi9cbiAgdmFyIG9wOyAgICAgICAgICAgICAgICAgICAgIC8qIGNvZGUgYml0cywgb3BlcmF0aW9uLCBleHRyYSBiaXRzLCBvciAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogIHdpbmRvdyBwb3NpdGlvbiwgd2luZG93IGJ5dGVzIHRvIGNvcHkgKi9cbiAgdmFyIGxlbjsgICAgICAgICAgICAgICAgICAgIC8qIG1hdGNoIGxlbmd0aCwgdW51c2VkIGJ5dGVzICovXG4gIHZhciBkaXN0OyAgICAgICAgICAgICAgICAgICAvKiBtYXRjaCBkaXN0YW5jZSAqL1xuICB2YXIgZnJvbTsgICAgICAgICAgICAgICAgICAgLyogd2hlcmUgdG8gY29weSBtYXRjaCBmcm9tICovXG4gIHZhciBmcm9tX3NvdXJjZTtcblxuXG4gIHZhciBpbnB1dCwgb3V0cHV0OyAvLyBKUyBzcGVjaWZpYywgYmVjYXVzZSB3ZSBoYXZlIG5vIHBvaW50ZXJzXG5cbiAgLyogY29weSBzdGF0ZSB0byBsb2NhbCB2YXJpYWJsZXMgKi9cbiAgc3RhdGUgPSBzdHJtLnN0YXRlO1xuICAvL2hlcmUgPSBzdGF0ZS5oZXJlO1xuICBfaW4gPSBzdHJtLm5leHRfaW47XG4gIGlucHV0ID0gc3RybS5pbnB1dDtcbiAgbGFzdCA9IF9pbiArIChzdHJtLmF2YWlsX2luIC0gNSk7XG4gIF9vdXQgPSBzdHJtLm5leHRfb3V0O1xuICBvdXRwdXQgPSBzdHJtLm91dHB1dDtcbiAgYmVnID0gX291dCAtIChzdGFydCAtIHN0cm0uYXZhaWxfb3V0KTtcbiAgZW5kID0gX291dCArIChzdHJtLmF2YWlsX291dCAtIDI1Nyk7XG4vLyNpZmRlZiBJTkZMQVRFX1NUUklDVFxuICBkbWF4ID0gc3RhdGUuZG1heDtcbi8vI2VuZGlmXG4gIHdzaXplID0gc3RhdGUud3NpemU7XG4gIHdoYXZlID0gc3RhdGUud2hhdmU7XG4gIHduZXh0ID0gc3RhdGUud25leHQ7XG4gIHNfd2luZG93ID0gc3RhdGUud2luZG93O1xuICBob2xkID0gc3RhdGUuaG9sZDtcbiAgYml0cyA9IHN0YXRlLmJpdHM7XG4gIGxjb2RlID0gc3RhdGUubGVuY29kZTtcbiAgZGNvZGUgPSBzdGF0ZS5kaXN0Y29kZTtcbiAgbG1hc2sgPSAoMSA8PCBzdGF0ZS5sZW5iaXRzKSAtIDE7XG4gIGRtYXNrID0gKDEgPDwgc3RhdGUuZGlzdGJpdHMpIC0gMTtcblxuXG4gIC8qIGRlY29kZSBsaXRlcmFscyBhbmQgbGVuZ3RoL2Rpc3RhbmNlcyB1bnRpbCBlbmQtb2YtYmxvY2sgb3Igbm90IGVub3VnaFxuICAgICBpbnB1dCBkYXRhIG9yIG91dHB1dCBzcGFjZSAqL1xuXG4gIHRvcDpcbiAgZG8ge1xuICAgIGlmIChiaXRzIDwgMTUpIHtcbiAgICAgIGhvbGQgKz0gaW5wdXRbX2luKytdIDw8IGJpdHM7XG4gICAgICBiaXRzICs9IDg7XG4gICAgICBob2xkICs9IGlucHV0W19pbisrXSA8PCBiaXRzO1xuICAgICAgYml0cyArPSA4O1xuICAgIH1cblxuICAgIGhlcmUgPSBsY29kZVtob2xkICYgbG1hc2tdO1xuXG4gICAgZG9sZW46XG4gICAgZm9yICg7OykgeyAvLyBHb3RvIGVtdWxhdGlvblxuICAgICAgb3AgPSBoZXJlID4+PiAyNC8qaGVyZS5iaXRzKi87XG4gICAgICBob2xkID4+Pj0gb3A7XG4gICAgICBiaXRzIC09IG9wO1xuICAgICAgb3AgPSAoaGVyZSA+Pj4gMTYpICYgMHhmZi8qaGVyZS5vcCovO1xuICAgICAgaWYgKG9wID09PSAwKSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBsaXRlcmFsICovXG4gICAgICAgIC8vVHJhY2V2digoc3RkZXJyLCBoZXJlLnZhbCA+PSAweDIwICYmIGhlcmUudmFsIDwgMHg3ZiA/XG4gICAgICAgIC8vICAgICAgICBcImluZmxhdGU6ICAgICAgICAgbGl0ZXJhbCAnJWMnXFxuXCIgOlxuICAgICAgICAvLyAgICAgICAgXCJpbmZsYXRlOiAgICAgICAgIGxpdGVyYWwgMHglMDJ4XFxuXCIsIGhlcmUudmFsKSk7XG4gICAgICAgIG91dHB1dFtfb3V0KytdID0gaGVyZSAmIDB4ZmZmZi8qaGVyZS52YWwqLztcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKG9wICYgMTYpIHsgICAgICAgICAgICAgICAgICAgICAvKiBsZW5ndGggYmFzZSAqL1xuICAgICAgICBsZW4gPSBoZXJlICYgMHhmZmZmLypoZXJlLnZhbCovO1xuICAgICAgICBvcCAmPSAxNTsgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBudW1iZXIgb2YgZXh0cmEgYml0cyAqL1xuICAgICAgICBpZiAob3ApIHtcbiAgICAgICAgICBpZiAoYml0cyA8IG9wKSB7XG4gICAgICAgICAgICBob2xkICs9IGlucHV0W19pbisrXSA8PCBiaXRzO1xuICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgIH1cbiAgICAgICAgICBsZW4gKz0gaG9sZCAmICgoMSA8PCBvcCkgLSAxKTtcbiAgICAgICAgICBob2xkID4+Pj0gb3A7XG4gICAgICAgICAgYml0cyAtPSBvcDtcbiAgICAgICAgfVxuICAgICAgICAvL1RyYWNldnYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgICAgIGxlbmd0aCAldVxcblwiLCBsZW4pKTtcbiAgICAgICAgaWYgKGJpdHMgPCAxNSkge1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbX2luKytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbX2luKytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICB9XG4gICAgICAgIGhlcmUgPSBkY29kZVtob2xkICYgZG1hc2tdO1xuXG4gICAgICAgIGRvZGlzdDpcbiAgICAgICAgZm9yICg7OykgeyAvLyBnb3RvIGVtdWxhdGlvblxuICAgICAgICAgIG9wID0gaGVyZSA+Pj4gMjQvKmhlcmUuYml0cyovO1xuICAgICAgICAgIGhvbGQgPj4+PSBvcDtcbiAgICAgICAgICBiaXRzIC09IG9wO1xuICAgICAgICAgIG9wID0gKGhlcmUgPj4+IDE2KSAmIDB4ZmYvKmhlcmUub3AqLztcblxuICAgICAgICAgIGlmIChvcCAmIDE2KSB7ICAgICAgICAgICAgICAgICAgICAgIC8qIGRpc3RhbmNlIGJhc2UgKi9cbiAgICAgICAgICAgIGRpc3QgPSBoZXJlICYgMHhmZmZmLypoZXJlLnZhbCovO1xuICAgICAgICAgICAgb3AgJj0gMTU7ICAgICAgICAgICAgICAgICAgICAgICAvKiBudW1iZXIgb2YgZXh0cmEgYml0cyAqL1xuICAgICAgICAgICAgaWYgKGJpdHMgPCBvcCkge1xuICAgICAgICAgICAgICBob2xkICs9IGlucHV0W19pbisrXSA8PCBiaXRzO1xuICAgICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgICAgIGlmIChiaXRzIDwgb3ApIHtcbiAgICAgICAgICAgICAgICBob2xkICs9IGlucHV0W19pbisrXSA8PCBiaXRzO1xuICAgICAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGlzdCArPSBob2xkICYgKCgxIDw8IG9wKSAtIDEpO1xuLy8jaWZkZWYgSU5GTEFURV9TVFJJQ1RcbiAgICAgICAgICAgIGlmIChkaXN0ID4gZG1heCkge1xuICAgICAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGRpc3RhbmNlIHRvbyBmYXIgYmFjayc7XG4gICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgICAgIGJyZWFrIHRvcDtcbiAgICAgICAgICAgIH1cbi8vI2VuZGlmXG4gICAgICAgICAgICBob2xkID4+Pj0gb3A7XG4gICAgICAgICAgICBiaXRzIC09IG9wO1xuICAgICAgICAgICAgLy9UcmFjZXZ2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgICAgICBkaXN0YW5jZSAldVxcblwiLCBkaXN0KSk7XG4gICAgICAgICAgICBvcCA9IF9vdXQgLSBiZWc7ICAgICAgICAgICAgICAgIC8qIG1heCBkaXN0YW5jZSBpbiBvdXRwdXQgKi9cbiAgICAgICAgICAgIGlmIChkaXN0ID4gb3ApIHsgICAgICAgICAgICAgICAgLyogc2VlIGlmIGNvcHkgZnJvbSB3aW5kb3cgKi9cbiAgICAgICAgICAgICAgb3AgPSBkaXN0IC0gb3A7ICAgICAgICAgICAgICAgLyogZGlzdGFuY2UgYmFjayBpbiB3aW5kb3cgKi9cbiAgICAgICAgICAgICAgaWYgKG9wID4gd2hhdmUpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3RhdGUuc2FuZSkge1xuICAgICAgICAgICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBkaXN0YW5jZSB0b28gZmFyIGJhY2snO1xuICAgICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICAgICAgICAgIGJyZWFrIHRvcDtcbiAgICAgICAgICAgICAgICB9XG5cbi8vICghKSBUaGlzIGJsb2NrIGlzIGRpc2FibGVkIGluIHpsaWIgZGVmYWlsdHMsXG4vLyBkb24ndCBlbmFibGUgaXQgZm9yIGJpbmFyeSBjb21wYXRpYmlsaXR5XG4vLyNpZmRlZiBJTkZMQVRFX0FMTE9XX0lOVkFMSURfRElTVEFOQ0VfVE9PRkFSX0FSUlJcbi8vICAgICAgICAgICAgICAgIGlmIChsZW4gPD0gb3AgLSB3aGF2ZSkge1xuLy8gICAgICAgICAgICAgICAgICBkbyB7XG4vLyAgICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSAwO1xuLy8gICAgICAgICAgICAgICAgICB9IHdoaWxlICgtLWxlbik7XG4vLyAgICAgICAgICAgICAgICAgIGNvbnRpbnVlIHRvcDtcbi8vICAgICAgICAgICAgICAgIH1cbi8vICAgICAgICAgICAgICAgIGxlbiAtPSBvcCAtIHdoYXZlO1xuLy8gICAgICAgICAgICAgICAgZG8ge1xuLy8gICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IDA7XG4vLyAgICAgICAgICAgICAgICB9IHdoaWxlICgtLW9wID4gd2hhdmUpO1xuLy8gICAgICAgICAgICAgICAgaWYgKG9wID09PSAwKSB7XG4vLyAgICAgICAgICAgICAgICAgIGZyb20gPSBfb3V0IC0gZGlzdDtcbi8vICAgICAgICAgICAgICAgICAgZG8ge1xuLy8gICAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gb3V0cHV0W2Zyb20rK107XG4vLyAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKC0tbGVuKTtcbi8vICAgICAgICAgICAgICAgICAgY29udGludWUgdG9wO1xuLy8gICAgICAgICAgICAgICAgfVxuLy8jZW5kaWZcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBmcm9tID0gMDsgLy8gd2luZG93IGluZGV4XG4gICAgICAgICAgICAgIGZyb21fc291cmNlID0gc193aW5kb3c7XG4gICAgICAgICAgICAgIGlmICh3bmV4dCA9PT0gMCkgeyAgICAgICAgICAgLyogdmVyeSBjb21tb24gY2FzZSAqL1xuICAgICAgICAgICAgICAgIGZyb20gKz0gd3NpemUgLSBvcDtcbiAgICAgICAgICAgICAgICBpZiAob3AgPCBsZW4pIHsgICAgICAgICAvKiBzb21lIGZyb20gd2luZG93ICovXG4gICAgICAgICAgICAgICAgICBsZW4gLT0gb3A7XG4gICAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gc193aW5kb3dbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKC0tb3ApO1xuICAgICAgICAgICAgICAgICAgZnJvbSA9IF9vdXQgLSBkaXN0OyAgLyogcmVzdCBmcm9tIG91dHB1dCAqL1xuICAgICAgICAgICAgICAgICAgZnJvbV9zb3VyY2UgPSBvdXRwdXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2UgaWYgKHduZXh0IDwgb3ApIHsgICAgICAvKiB3cmFwIGFyb3VuZCB3aW5kb3cgKi9cbiAgICAgICAgICAgICAgICBmcm9tICs9IHdzaXplICsgd25leHQgLSBvcDtcbiAgICAgICAgICAgICAgICBvcCAtPSB3bmV4dDtcbiAgICAgICAgICAgICAgICBpZiAob3AgPCBsZW4pIHsgICAgICAgICAvKiBzb21lIGZyb20gZW5kIG9mIHdpbmRvdyAqL1xuICAgICAgICAgICAgICAgICAgbGVuIC09IG9wO1xuICAgICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IHNfd2luZG93W2Zyb20rK107XG4gICAgICAgICAgICAgICAgICB9IHdoaWxlICgtLW9wKTtcbiAgICAgICAgICAgICAgICAgIGZyb20gPSAwO1xuICAgICAgICAgICAgICAgICAgaWYgKHduZXh0IDwgbGVuKSB7ICAvKiBzb21lIGZyb20gc3RhcnQgb2Ygd2luZG93ICovXG4gICAgICAgICAgICAgICAgICAgIG9wID0gd25leHQ7XG4gICAgICAgICAgICAgICAgICAgIGxlbiAtPSBvcDtcbiAgICAgICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gc193aW5kb3dbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICAgICAgfSB3aGlsZSAoLS1vcCk7XG4gICAgICAgICAgICAgICAgICAgIGZyb20gPSBfb3V0IC0gZGlzdDsgICAgICAvKiByZXN0IGZyb20gb3V0cHV0ICovXG4gICAgICAgICAgICAgICAgICAgIGZyb21fc291cmNlID0gb3V0cHV0O1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIHsgICAgICAgICAgICAgICAgICAgICAgLyogY29udGlndW91cyBpbiB3aW5kb3cgKi9cbiAgICAgICAgICAgICAgICBmcm9tICs9IHduZXh0IC0gb3A7XG4gICAgICAgICAgICAgICAgaWYgKG9wIDwgbGVuKSB7ICAgICAgICAgLyogc29tZSBmcm9tIHdpbmRvdyAqL1xuICAgICAgICAgICAgICAgICAgbGVuIC09IG9wO1xuICAgICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IHNfd2luZG93W2Zyb20rK107XG4gICAgICAgICAgICAgICAgICB9IHdoaWxlICgtLW9wKTtcbiAgICAgICAgICAgICAgICAgIGZyb20gPSBfb3V0IC0gZGlzdDsgIC8qIHJlc3QgZnJvbSBvdXRwdXQgKi9cbiAgICAgICAgICAgICAgICAgIGZyb21fc291cmNlID0gb3V0cHV0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB3aGlsZSAobGVuID4gMikge1xuICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gZnJvbV9zb3VyY2VbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IGZyb21fc291cmNlW2Zyb20rK107XG4gICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBmcm9tX3NvdXJjZVtmcm9tKytdO1xuICAgICAgICAgICAgICAgIGxlbiAtPSAzO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChsZW4pIHtcbiAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IGZyb21fc291cmNlW2Zyb20rK107XG4gICAgICAgICAgICAgICAgaWYgKGxlbiA+IDEpIHtcbiAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gZnJvbV9zb3VyY2VbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICBmcm9tID0gX291dCAtIGRpc3Q7ICAgICAgICAgIC8qIGNvcHkgZGlyZWN0IGZyb20gb3V0cHV0ICovXG4gICAgICAgICAgICAgIGRvIHsgICAgICAgICAgICAgICAgICAgICAgICAvKiBtaW5pbXVtIGxlbmd0aCBpcyB0aHJlZSAqL1xuICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gb3V0cHV0W2Zyb20rK107XG4gICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBvdXRwdXRbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IG91dHB1dFtmcm9tKytdO1xuICAgICAgICAgICAgICAgIGxlbiAtPSAzO1xuICAgICAgICAgICAgICB9IHdoaWxlIChsZW4gPiAyKTtcbiAgICAgICAgICAgICAgaWYgKGxlbikge1xuICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gb3V0cHV0W2Zyb20rK107XG4gICAgICAgICAgICAgICAgaWYgKGxlbiA+IDEpIHtcbiAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gb3V0cHV0W2Zyb20rK107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKChvcCAmIDY0KSA9PT0gMCkgeyAgICAgICAgICAvKiAybmQgbGV2ZWwgZGlzdGFuY2UgY29kZSAqL1xuICAgICAgICAgICAgaGVyZSA9IGRjb2RlWyhoZXJlICYgMHhmZmZmKS8qaGVyZS52YWwqLyArIChob2xkICYgKCgxIDw8IG9wKSAtIDEpKV07XG4gICAgICAgICAgICBjb250aW51ZSBkb2Rpc3Q7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBkaXN0YW5jZSBjb2RlJztcbiAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgICBicmVhayB0b3A7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7IC8vIG5lZWQgdG8gZW11bGF0ZSBnb3RvIHZpYSBcImNvbnRpbnVlXCJcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSBpZiAoKG9wICYgNjQpID09PSAwKSB7ICAgICAgICAgICAgICAvKiAybmQgbGV2ZWwgbGVuZ3RoIGNvZGUgKi9cbiAgICAgICAgaGVyZSA9IGxjb2RlWyhoZXJlICYgMHhmZmZmKS8qaGVyZS52YWwqLyArIChob2xkICYgKCgxIDw8IG9wKSAtIDEpKV07XG4gICAgICAgIGNvbnRpbnVlIGRvbGVuO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAob3AgJiAzMikgeyAgICAgICAgICAgICAgICAgICAgIC8qIGVuZC1vZi1ibG9jayAqL1xuICAgICAgICAvL1RyYWNldnYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgICAgIGVuZCBvZiBibG9ja1xcblwiKSk7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBUWVBFO1xuICAgICAgICBicmVhayB0b3A7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBsaXRlcmFsL2xlbmd0aCBjb2RlJztcbiAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgYnJlYWsgdG9wO1xuICAgICAgfVxuXG4gICAgICBicmVhazsgLy8gbmVlZCB0byBlbXVsYXRlIGdvdG8gdmlhIFwiY29udGludWVcIlxuICAgIH1cbiAgfSB3aGlsZSAoX2luIDwgbGFzdCAmJiBfb3V0IDwgZW5kKTtcblxuICAvKiByZXR1cm4gdW51c2VkIGJ5dGVzIChvbiBlbnRyeSwgYml0cyA8IDgsIHNvIGluIHdvbid0IGdvIHRvbyBmYXIgYmFjaykgKi9cbiAgbGVuID0gYml0cyA+PiAzO1xuICBfaW4gLT0gbGVuO1xuICBiaXRzIC09IGxlbiA8PCAzO1xuICBob2xkICY9ICgxIDw8IGJpdHMpIC0gMTtcblxuICAvKiB1cGRhdGUgc3RhdGUgYW5kIHJldHVybiAqL1xuICBzdHJtLm5leHRfaW4gPSBfaW47XG4gIHN0cm0ubmV4dF9vdXQgPSBfb3V0O1xuICBzdHJtLmF2YWlsX2luID0gKF9pbiA8IGxhc3QgPyA1ICsgKGxhc3QgLSBfaW4pIDogNSAtIChfaW4gLSBsYXN0KSk7XG4gIHN0cm0uYXZhaWxfb3V0ID0gKF9vdXQgPCBlbmQgPyAyNTcgKyAoZW5kIC0gX291dCkgOiAyNTcgLSAoX291dCAtIGVuZCkpO1xuICBzdGF0ZS5ob2xkID0gaG9sZDtcbiAgc3RhdGUuYml0cyA9IGJpdHM7XG4gIHJldHVybjtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cblxudmFyIHV0aWxzICAgICAgICAgPSByZXF1aXJlKCcuLi91dGlscy9jb21tb24nKTtcbnZhciBhZGxlcjMyICAgICAgID0gcmVxdWlyZSgnLi9hZGxlcjMyJyk7XG52YXIgY3JjMzIgICAgICAgICA9IHJlcXVpcmUoJy4vY3JjMzInKTtcbnZhciBpbmZsYXRlX2Zhc3QgID0gcmVxdWlyZSgnLi9pbmZmYXN0Jyk7XG52YXIgaW5mbGF0ZV90YWJsZSA9IHJlcXVpcmUoJy4vaW5mdHJlZXMnKTtcblxudmFyIENPREVTID0gMDtcbnZhciBMRU5TID0gMTtcbnZhciBESVNUUyA9IDI7XG5cbi8qIFB1YmxpYyBjb25zdGFudHMgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG5cbi8qIEFsbG93ZWQgZmx1c2ggdmFsdWVzOyBzZWUgZGVmbGF0ZSgpIGFuZCBpbmZsYXRlKCkgYmVsb3cgZm9yIGRldGFpbHMgKi9cbi8vdmFyIFpfTk9fRkxVU0ggICAgICA9IDA7XG4vL3ZhciBaX1BBUlRJQUxfRkxVU0ggPSAxO1xuLy92YXIgWl9TWU5DX0ZMVVNIICAgID0gMjtcbi8vdmFyIFpfRlVMTF9GTFVTSCAgICA9IDM7XG52YXIgWl9GSU5JU0ggICAgICAgID0gNDtcbnZhciBaX0JMT0NLICAgICAgICAgPSA1O1xudmFyIFpfVFJFRVMgICAgICAgICA9IDY7XG5cblxuLyogUmV0dXJuIGNvZGVzIGZvciB0aGUgY29tcHJlc3Npb24vZGVjb21wcmVzc2lvbiBmdW5jdGlvbnMuIE5lZ2F0aXZlIHZhbHVlc1xuICogYXJlIGVycm9ycywgcG9zaXRpdmUgdmFsdWVzIGFyZSB1c2VkIGZvciBzcGVjaWFsIGJ1dCBub3JtYWwgZXZlbnRzLlxuICovXG52YXIgWl9PSyAgICAgICAgICAgID0gMDtcbnZhciBaX1NUUkVBTV9FTkQgICAgPSAxO1xudmFyIFpfTkVFRF9ESUNUICAgICA9IDI7XG4vL3ZhciBaX0VSUk5PICAgICAgICAgPSAtMTtcbnZhciBaX1NUUkVBTV9FUlJPUiAgPSAtMjtcbnZhciBaX0RBVEFfRVJST1IgICAgPSAtMztcbnZhciBaX01FTV9FUlJPUiAgICAgPSAtNDtcbnZhciBaX0JVRl9FUlJPUiAgICAgPSAtNTtcbi8vdmFyIFpfVkVSU0lPTl9FUlJPUiA9IC02O1xuXG4vKiBUaGUgZGVmbGF0ZSBjb21wcmVzc2lvbiBtZXRob2QgKi9cbnZhciBaX0RFRkxBVEVEICA9IDg7XG5cblxuLyogU1RBVEVTID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cblxudmFyICAgIEhFQUQgPSAxOyAgICAgICAvKiBpOiB3YWl0aW5nIGZvciBtYWdpYyBoZWFkZXIgKi9cbnZhciAgICBGTEFHUyA9IDI7ICAgICAgLyogaTogd2FpdGluZyBmb3IgbWV0aG9kIGFuZCBmbGFncyAoZ3ppcCkgKi9cbnZhciAgICBUSU1FID0gMzsgICAgICAgLyogaTogd2FpdGluZyBmb3IgbW9kaWZpY2F0aW9uIHRpbWUgKGd6aXApICovXG52YXIgICAgT1MgPSA0OyAgICAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIGV4dHJhIGZsYWdzIGFuZCBvcGVyYXRpbmcgc3lzdGVtIChnemlwKSAqL1xudmFyICAgIEVYTEVOID0gNTsgICAgICAvKiBpOiB3YWl0aW5nIGZvciBleHRyYSBsZW5ndGggKGd6aXApICovXG52YXIgICAgRVhUUkEgPSA2OyAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIGV4dHJhIGJ5dGVzIChnemlwKSAqL1xudmFyICAgIE5BTUUgPSA3OyAgICAgICAvKiBpOiB3YWl0aW5nIGZvciBlbmQgb2YgZmlsZSBuYW1lIChnemlwKSAqL1xudmFyICAgIENPTU1FTlQgPSA4OyAgICAvKiBpOiB3YWl0aW5nIGZvciBlbmQgb2YgY29tbWVudCAoZ3ppcCkgKi9cbnZhciAgICBIQ1JDID0gOTsgICAgICAgLyogaTogd2FpdGluZyBmb3IgaGVhZGVyIGNyYyAoZ3ppcCkgKi9cbnZhciAgICBESUNUSUQgPSAxMDsgICAgLyogaTogd2FpdGluZyBmb3IgZGljdGlvbmFyeSBjaGVjayB2YWx1ZSAqL1xudmFyICAgIERJQ1QgPSAxMTsgICAgICAvKiB3YWl0aW5nIGZvciBpbmZsYXRlU2V0RGljdGlvbmFyeSgpIGNhbGwgKi9cbnZhciAgICAgICAgVFlQRSA9IDEyOyAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIHR5cGUgYml0cywgaW5jbHVkaW5nIGxhc3QtZmxhZyBiaXQgKi9cbnZhciAgICAgICAgVFlQRURPID0gMTM7ICAgIC8qIGk6IHNhbWUsIGJ1dCBza2lwIGNoZWNrIHRvIGV4aXQgaW5mbGF0ZSBvbiBuZXcgYmxvY2sgKi9cbnZhciAgICAgICAgU1RPUkVEID0gMTQ7ICAgIC8qIGk6IHdhaXRpbmcgZm9yIHN0b3JlZCBzaXplIChsZW5ndGggYW5kIGNvbXBsZW1lbnQpICovXG52YXIgICAgICAgIENPUFlfID0gMTU7ICAgICAvKiBpL286IHNhbWUgYXMgQ09QWSBiZWxvdywgYnV0IG9ubHkgZmlyc3QgdGltZSBpbiAqL1xudmFyICAgICAgICBDT1BZID0gMTY7ICAgICAgLyogaS9vOiB3YWl0aW5nIGZvciBpbnB1dCBvciBvdXRwdXQgdG8gY29weSBzdG9yZWQgYmxvY2sgKi9cbnZhciAgICAgICAgVEFCTEUgPSAxNzsgICAgIC8qIGk6IHdhaXRpbmcgZm9yIGR5bmFtaWMgYmxvY2sgdGFibGUgbGVuZ3RocyAqL1xudmFyICAgICAgICBMRU5MRU5TID0gMTg7ICAgLyogaTogd2FpdGluZyBmb3IgY29kZSBsZW5ndGggY29kZSBsZW5ndGhzICovXG52YXIgICAgICAgIENPREVMRU5TID0gMTk7ICAvKiBpOiB3YWl0aW5nIGZvciBsZW5ndGgvbGl0IGFuZCBkaXN0YW5jZSBjb2RlIGxlbmd0aHMgKi9cbnZhciAgICAgICAgICAgIExFTl8gPSAyMDsgICAgICAvKiBpOiBzYW1lIGFzIExFTiBiZWxvdywgYnV0IG9ubHkgZmlyc3QgdGltZSBpbiAqL1xudmFyICAgICAgICAgICAgTEVOID0gMjE7ICAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIGxlbmd0aC9saXQvZW9iIGNvZGUgKi9cbnZhciAgICAgICAgICAgIExFTkVYVCA9IDIyOyAgICAvKiBpOiB3YWl0aW5nIGZvciBsZW5ndGggZXh0cmEgYml0cyAqL1xudmFyICAgICAgICAgICAgRElTVCA9IDIzOyAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIGRpc3RhbmNlIGNvZGUgKi9cbnZhciAgICAgICAgICAgIERJU1RFWFQgPSAyNDsgICAvKiBpOiB3YWl0aW5nIGZvciBkaXN0YW5jZSBleHRyYSBiaXRzICovXG52YXIgICAgICAgICAgICBNQVRDSCA9IDI1OyAgICAgLyogbzogd2FpdGluZyBmb3Igb3V0cHV0IHNwYWNlIHRvIGNvcHkgc3RyaW5nICovXG52YXIgICAgICAgICAgICBMSVQgPSAyNjsgICAgICAgLyogbzogd2FpdGluZyBmb3Igb3V0cHV0IHNwYWNlIHRvIHdyaXRlIGxpdGVyYWwgKi9cbnZhciAgICBDSEVDSyA9IDI3OyAgICAgLyogaTogd2FpdGluZyBmb3IgMzItYml0IGNoZWNrIHZhbHVlICovXG52YXIgICAgTEVOR1RIID0gMjg7ICAgIC8qIGk6IHdhaXRpbmcgZm9yIDMyLWJpdCBsZW5ndGggKGd6aXApICovXG52YXIgICAgRE9ORSA9IDI5OyAgICAgIC8qIGZpbmlzaGVkIGNoZWNrLCBkb25lIC0tIHJlbWFpbiBoZXJlIHVudGlsIHJlc2V0ICovXG52YXIgICAgQkFEID0gMzA7ICAgICAgIC8qIGdvdCBhIGRhdGEgZXJyb3IgLS0gcmVtYWluIGhlcmUgdW50aWwgcmVzZXQgKi9cbnZhciAgICBNRU0gPSAzMTsgICAgICAgLyogZ290IGFuIGluZmxhdGUoKSBtZW1vcnkgZXJyb3IgLS0gcmVtYWluIGhlcmUgdW50aWwgcmVzZXQgKi9cbnZhciAgICBTWU5DID0gMzI7ICAgICAgLyogbG9va2luZyBmb3Igc3luY2hyb25pemF0aW9uIGJ5dGVzIHRvIHJlc3RhcnQgaW5mbGF0ZSgpICovXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cblxuXG52YXIgRU5PVUdIX0xFTlMgPSA4NTI7XG52YXIgRU5PVUdIX0RJU1RTID0gNTkyO1xuLy92YXIgRU5PVUdIID0gIChFTk9VR0hfTEVOUytFTk9VR0hfRElTVFMpO1xuXG52YXIgTUFYX1dCSVRTID0gMTU7XG4vKiAzMksgTFo3NyB3aW5kb3cgKi9cbnZhciBERUZfV0JJVFMgPSBNQVhfV0JJVFM7XG5cblxuZnVuY3Rpb24genN3YXAzMihxKSB7XG4gIHJldHVybiAgKCgocSA+Pj4gMjQpICYgMHhmZikgK1xuICAgICAgICAgICgocSA+Pj4gOCkgJiAweGZmMDApICtcbiAgICAgICAgICAoKHEgJiAweGZmMDApIDw8IDgpICtcbiAgICAgICAgICAoKHEgJiAweGZmKSA8PCAyNCkpO1xufVxuXG5cbmZ1bmN0aW9uIEluZmxhdGVTdGF0ZSgpIHtcbiAgdGhpcy5tb2RlID0gMDsgICAgICAgICAgICAgLyogY3VycmVudCBpbmZsYXRlIG1vZGUgKi9cbiAgdGhpcy5sYXN0ID0gZmFsc2U7ICAgICAgICAgIC8qIHRydWUgaWYgcHJvY2Vzc2luZyBsYXN0IGJsb2NrICovXG4gIHRoaXMud3JhcCA9IDA7ICAgICAgICAgICAgICAvKiBiaXQgMCB0cnVlIGZvciB6bGliLCBiaXQgMSB0cnVlIGZvciBnemlwICovXG4gIHRoaXMuaGF2ZWRpY3QgPSBmYWxzZTsgICAgICAvKiB0cnVlIGlmIGRpY3Rpb25hcnkgcHJvdmlkZWQgKi9cbiAgdGhpcy5mbGFncyA9IDA7ICAgICAgICAgICAgIC8qIGd6aXAgaGVhZGVyIG1ldGhvZCBhbmQgZmxhZ3MgKDAgaWYgemxpYikgKi9cbiAgdGhpcy5kbWF4ID0gMDsgICAgICAgICAgICAgIC8qIHpsaWIgaGVhZGVyIG1heCBkaXN0YW5jZSAoSU5GTEFURV9TVFJJQ1QpICovXG4gIHRoaXMuY2hlY2sgPSAwOyAgICAgICAgICAgICAvKiBwcm90ZWN0ZWQgY29weSBvZiBjaGVjayB2YWx1ZSAqL1xuICB0aGlzLnRvdGFsID0gMDsgICAgICAgICAgICAgLyogcHJvdGVjdGVkIGNvcHkgb2Ygb3V0cHV0IGNvdW50ICovXG4gIC8vIFRPRE86IG1heSBiZSB7fVxuICB0aGlzLmhlYWQgPSBudWxsOyAgICAgICAgICAgLyogd2hlcmUgdG8gc2F2ZSBnemlwIGhlYWRlciBpbmZvcm1hdGlvbiAqL1xuXG4gIC8qIHNsaWRpbmcgd2luZG93ICovXG4gIHRoaXMud2JpdHMgPSAwOyAgICAgICAgICAgICAvKiBsb2cgYmFzZSAyIG9mIHJlcXVlc3RlZCB3aW5kb3cgc2l6ZSAqL1xuICB0aGlzLndzaXplID0gMDsgICAgICAgICAgICAgLyogd2luZG93IHNpemUgb3IgemVybyBpZiBub3QgdXNpbmcgd2luZG93ICovXG4gIHRoaXMud2hhdmUgPSAwOyAgICAgICAgICAgICAvKiB2YWxpZCBieXRlcyBpbiB0aGUgd2luZG93ICovXG4gIHRoaXMud25leHQgPSAwOyAgICAgICAgICAgICAvKiB3aW5kb3cgd3JpdGUgaW5kZXggKi9cbiAgdGhpcy53aW5kb3cgPSBudWxsOyAgICAgICAgIC8qIGFsbG9jYXRlZCBzbGlkaW5nIHdpbmRvdywgaWYgbmVlZGVkICovXG5cbiAgLyogYml0IGFjY3VtdWxhdG9yICovXG4gIHRoaXMuaG9sZCA9IDA7ICAgICAgICAgICAgICAvKiBpbnB1dCBiaXQgYWNjdW11bGF0b3IgKi9cbiAgdGhpcy5iaXRzID0gMDsgICAgICAgICAgICAgIC8qIG51bWJlciBvZiBiaXRzIGluIFwiaW5cIiAqL1xuXG4gIC8qIGZvciBzdHJpbmcgYW5kIHN0b3JlZCBibG9jayBjb3B5aW5nICovXG4gIHRoaXMubGVuZ3RoID0gMDsgICAgICAgICAgICAvKiBsaXRlcmFsIG9yIGxlbmd0aCBvZiBkYXRhIHRvIGNvcHkgKi9cbiAgdGhpcy5vZmZzZXQgPSAwOyAgICAgICAgICAgIC8qIGRpc3RhbmNlIGJhY2sgdG8gY29weSBzdHJpbmcgZnJvbSAqL1xuXG4gIC8qIGZvciB0YWJsZSBhbmQgY29kZSBkZWNvZGluZyAqL1xuICB0aGlzLmV4dHJhID0gMDsgICAgICAgICAgICAgLyogZXh0cmEgYml0cyBuZWVkZWQgKi9cblxuICAvKiBmaXhlZCBhbmQgZHluYW1pYyBjb2RlIHRhYmxlcyAqL1xuICB0aGlzLmxlbmNvZGUgPSBudWxsOyAgICAgICAgICAvKiBzdGFydGluZyB0YWJsZSBmb3IgbGVuZ3RoL2xpdGVyYWwgY29kZXMgKi9cbiAgdGhpcy5kaXN0Y29kZSA9IG51bGw7ICAgICAgICAgLyogc3RhcnRpbmcgdGFibGUgZm9yIGRpc3RhbmNlIGNvZGVzICovXG4gIHRoaXMubGVuYml0cyA9IDA7ICAgICAgICAgICAvKiBpbmRleCBiaXRzIGZvciBsZW5jb2RlICovXG4gIHRoaXMuZGlzdGJpdHMgPSAwOyAgICAgICAgICAvKiBpbmRleCBiaXRzIGZvciBkaXN0Y29kZSAqL1xuXG4gIC8qIGR5bmFtaWMgdGFibGUgYnVpbGRpbmcgKi9cbiAgdGhpcy5uY29kZSA9IDA7ICAgICAgICAgICAgIC8qIG51bWJlciBvZiBjb2RlIGxlbmd0aCBjb2RlIGxlbmd0aHMgKi9cbiAgdGhpcy5ubGVuID0gMDsgICAgICAgICAgICAgIC8qIG51bWJlciBvZiBsZW5ndGggY29kZSBsZW5ndGhzICovXG4gIHRoaXMubmRpc3QgPSAwOyAgICAgICAgICAgICAvKiBudW1iZXIgb2YgZGlzdGFuY2UgY29kZSBsZW5ndGhzICovXG4gIHRoaXMuaGF2ZSA9IDA7ICAgICAgICAgICAgICAvKiBudW1iZXIgb2YgY29kZSBsZW5ndGhzIGluIGxlbnNbXSAqL1xuICB0aGlzLm5leHQgPSBudWxsOyAgICAgICAgICAgICAgLyogbmV4dCBhdmFpbGFibGUgc3BhY2UgaW4gY29kZXNbXSAqL1xuXG4gIHRoaXMubGVucyA9IG5ldyB1dGlscy5CdWYxNigzMjApOyAvKiB0ZW1wb3Jhcnkgc3RvcmFnZSBmb3IgY29kZSBsZW5ndGhzICovXG4gIHRoaXMud29yayA9IG5ldyB1dGlscy5CdWYxNigyODgpOyAvKiB3b3JrIGFyZWEgZm9yIGNvZGUgdGFibGUgYnVpbGRpbmcgKi9cblxuICAvKlxuICAgYmVjYXVzZSB3ZSBkb24ndCBoYXZlIHBvaW50ZXJzIGluIGpzLCB3ZSB1c2UgbGVuY29kZSBhbmQgZGlzdGNvZGUgZGlyZWN0bHlcbiAgIGFzIGJ1ZmZlcnMgc28gd2UgZG9uJ3QgbmVlZCBjb2Rlc1xuICAqL1xuICAvL3RoaXMuY29kZXMgPSBuZXcgdXRpbHMuQnVmMzIoRU5PVUdIKTsgICAgICAgLyogc3BhY2UgZm9yIGNvZGUgdGFibGVzICovXG4gIHRoaXMubGVuZHluID0gbnVsbDsgICAgICAgICAgICAgIC8qIGR5bmFtaWMgdGFibGUgZm9yIGxlbmd0aC9saXRlcmFsIGNvZGVzIChKUyBzcGVjaWZpYykgKi9cbiAgdGhpcy5kaXN0ZHluID0gbnVsbDsgICAgICAgICAgICAgLyogZHluYW1pYyB0YWJsZSBmb3IgZGlzdGFuY2UgY29kZXMgKEpTIHNwZWNpZmljKSAqL1xuICB0aGlzLnNhbmUgPSAwOyAgICAgICAgICAgICAgICAgICAvKiBpZiBmYWxzZSwgYWxsb3cgaW52YWxpZCBkaXN0YW5jZSB0b28gZmFyICovXG4gIHRoaXMuYmFjayA9IDA7ICAgICAgICAgICAgICAgICAgIC8qIGJpdHMgYmFjayBvZiBsYXN0IHVucHJvY2Vzc2VkIGxlbmd0aC9saXQgKi9cbiAgdGhpcy53YXMgPSAwOyAgICAgICAgICAgICAgICAgICAgLyogaW5pdGlhbCBsZW5ndGggb2YgbWF0Y2ggKi9cbn1cblxuZnVuY3Rpb24gaW5mbGF0ZVJlc2V0S2VlcChzdHJtKSB7XG4gIHZhciBzdGF0ZTtcblxuICBpZiAoIXN0cm0gfHwgIXN0cm0uc3RhdGUpIHsgcmV0dXJuIFpfU1RSRUFNX0VSUk9SOyB9XG4gIHN0YXRlID0gc3RybS5zdGF0ZTtcbiAgc3RybS50b3RhbF9pbiA9IHN0cm0udG90YWxfb3V0ID0gc3RhdGUudG90YWwgPSAwO1xuICBzdHJtLm1zZyA9ICcnOyAvKlpfTlVMTCovXG4gIGlmIChzdGF0ZS53cmFwKSB7ICAgICAgIC8qIHRvIHN1cHBvcnQgaWxsLWNvbmNlaXZlZCBKYXZhIHRlc3Qgc3VpdGUgKi9cbiAgICBzdHJtLmFkbGVyID0gc3RhdGUud3JhcCAmIDE7XG4gIH1cbiAgc3RhdGUubW9kZSA9IEhFQUQ7XG4gIHN0YXRlLmxhc3QgPSAwO1xuICBzdGF0ZS5oYXZlZGljdCA9IDA7XG4gIHN0YXRlLmRtYXggPSAzMjc2ODtcbiAgc3RhdGUuaGVhZCA9IG51bGwvKlpfTlVMTCovO1xuICBzdGF0ZS5ob2xkID0gMDtcbiAgc3RhdGUuYml0cyA9IDA7XG4gIC8vc3RhdGUubGVuY29kZSA9IHN0YXRlLmRpc3Rjb2RlID0gc3RhdGUubmV4dCA9IHN0YXRlLmNvZGVzO1xuICBzdGF0ZS5sZW5jb2RlID0gc3RhdGUubGVuZHluID0gbmV3IHV0aWxzLkJ1ZjMyKEVOT1VHSF9MRU5TKTtcbiAgc3RhdGUuZGlzdGNvZGUgPSBzdGF0ZS5kaXN0ZHluID0gbmV3IHV0aWxzLkJ1ZjMyKEVOT1VHSF9ESVNUUyk7XG5cbiAgc3RhdGUuc2FuZSA9IDE7XG4gIHN0YXRlLmJhY2sgPSAtMTtcbiAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiByZXNldFxcblwiKSk7XG4gIHJldHVybiBaX09LO1xufVxuXG5mdW5jdGlvbiBpbmZsYXRlUmVzZXQoc3RybSkge1xuICB2YXIgc3RhdGU7XG5cbiAgaWYgKCFzdHJtIHx8ICFzdHJtLnN0YXRlKSB7IHJldHVybiBaX1NUUkVBTV9FUlJPUjsgfVxuICBzdGF0ZSA9IHN0cm0uc3RhdGU7XG4gIHN0YXRlLndzaXplID0gMDtcbiAgc3RhdGUud2hhdmUgPSAwO1xuICBzdGF0ZS53bmV4dCA9IDA7XG4gIHJldHVybiBpbmZsYXRlUmVzZXRLZWVwKHN0cm0pO1xuXG59XG5cbmZ1bmN0aW9uIGluZmxhdGVSZXNldDIoc3RybSwgd2luZG93Qml0cykge1xuICB2YXIgd3JhcDtcbiAgdmFyIHN0YXRlO1xuXG4gIC8qIGdldCB0aGUgc3RhdGUgKi9cbiAgaWYgKCFzdHJtIHx8ICFzdHJtLnN0YXRlKSB7IHJldHVybiBaX1NUUkVBTV9FUlJPUjsgfVxuICBzdGF0ZSA9IHN0cm0uc3RhdGU7XG5cbiAgLyogZXh0cmFjdCB3cmFwIHJlcXVlc3QgZnJvbSB3aW5kb3dCaXRzIHBhcmFtZXRlciAqL1xuICBpZiAod2luZG93Qml0cyA8IDApIHtcbiAgICB3cmFwID0gMDtcbiAgICB3aW5kb3dCaXRzID0gLXdpbmRvd0JpdHM7XG4gIH1cbiAgZWxzZSB7XG4gICAgd3JhcCA9ICh3aW5kb3dCaXRzID4+IDQpICsgMTtcbiAgICBpZiAod2luZG93Qml0cyA8IDQ4KSB7XG4gICAgICB3aW5kb3dCaXRzICY9IDE1O1xuICAgIH1cbiAgfVxuXG4gIC8qIHNldCBudW1iZXIgb2Ygd2luZG93IGJpdHMsIGZyZWUgd2luZG93IGlmIGRpZmZlcmVudCAqL1xuICBpZiAod2luZG93Qml0cyAmJiAod2luZG93Qml0cyA8IDggfHwgd2luZG93Qml0cyA+IDE1KSkge1xuICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjtcbiAgfVxuICBpZiAoc3RhdGUud2luZG93ICE9PSBudWxsICYmIHN0YXRlLndiaXRzICE9PSB3aW5kb3dCaXRzKSB7XG4gICAgc3RhdGUud2luZG93ID0gbnVsbDtcbiAgfVxuXG4gIC8qIHVwZGF0ZSBzdGF0ZSBhbmQgcmVzZXQgdGhlIHJlc3Qgb2YgaXQgKi9cbiAgc3RhdGUud3JhcCA9IHdyYXA7XG4gIHN0YXRlLndiaXRzID0gd2luZG93Qml0cztcbiAgcmV0dXJuIGluZmxhdGVSZXNldChzdHJtKTtcbn1cblxuZnVuY3Rpb24gaW5mbGF0ZUluaXQyKHN0cm0sIHdpbmRvd0JpdHMpIHtcbiAgdmFyIHJldDtcbiAgdmFyIHN0YXRlO1xuXG4gIGlmICghc3RybSkgeyByZXR1cm4gWl9TVFJFQU1fRVJST1I7IH1cbiAgLy9zdHJtLm1zZyA9IFpfTlVMTDsgICAgICAgICAgICAgICAgIC8qIGluIGNhc2Ugd2UgcmV0dXJuIGFuIGVycm9yICovXG5cbiAgc3RhdGUgPSBuZXcgSW5mbGF0ZVN0YXRlKCk7XG5cbiAgLy9pZiAoc3RhdGUgPT09IFpfTlVMTCkgcmV0dXJuIFpfTUVNX0VSUk9SO1xuICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6IGFsbG9jYXRlZFxcblwiKSk7XG4gIHN0cm0uc3RhdGUgPSBzdGF0ZTtcbiAgc3RhdGUud2luZG93ID0gbnVsbC8qWl9OVUxMKi87XG4gIHJldCA9IGluZmxhdGVSZXNldDIoc3RybSwgd2luZG93Qml0cyk7XG4gIGlmIChyZXQgIT09IFpfT0spIHtcbiAgICBzdHJtLnN0YXRlID0gbnVsbC8qWl9OVUxMKi87XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gaW5mbGF0ZUluaXQoc3RybSkge1xuICByZXR1cm4gaW5mbGF0ZUluaXQyKHN0cm0sIERFRl9XQklUUyk7XG59XG5cblxuLypcbiBSZXR1cm4gc3RhdGUgd2l0aCBsZW5ndGggYW5kIGRpc3RhbmNlIGRlY29kaW5nIHRhYmxlcyBhbmQgaW5kZXggc2l6ZXMgc2V0IHRvXG4gZml4ZWQgY29kZSBkZWNvZGluZy4gIE5vcm1hbGx5IHRoaXMgcmV0dXJucyBmaXhlZCB0YWJsZXMgZnJvbSBpbmZmaXhlZC5oLlxuIElmIEJVSUxERklYRUQgaXMgZGVmaW5lZCwgdGhlbiBpbnN0ZWFkIHRoaXMgcm91dGluZSBidWlsZHMgdGhlIHRhYmxlcyB0aGVcbiBmaXJzdCB0aW1lIGl0J3MgY2FsbGVkLCBhbmQgcmV0dXJucyB0aG9zZSB0YWJsZXMgdGhlIGZpcnN0IHRpbWUgYW5kXG4gdGhlcmVhZnRlci4gIFRoaXMgcmVkdWNlcyB0aGUgc2l6ZSBvZiB0aGUgY29kZSBieSBhYm91dCAySyBieXRlcywgaW5cbiBleGNoYW5nZSBmb3IgYSBsaXR0bGUgZXhlY3V0aW9uIHRpbWUuICBIb3dldmVyLCBCVUlMREZJWEVEIHNob3VsZCBub3QgYmVcbiB1c2VkIGZvciB0aHJlYWRlZCBhcHBsaWNhdGlvbnMsIHNpbmNlIHRoZSByZXdyaXRpbmcgb2YgdGhlIHRhYmxlcyBhbmQgdmlyZ2luXG4gbWF5IG5vdCBiZSB0aHJlYWQtc2FmZS5cbiAqL1xudmFyIHZpcmdpbiA9IHRydWU7XG5cbnZhciBsZW5maXgsIGRpc3RmaXg7IC8vIFdlIGhhdmUgbm8gcG9pbnRlcnMgaW4gSlMsIHNvIGtlZXAgdGFibGVzIHNlcGFyYXRlXG5cbmZ1bmN0aW9uIGZpeGVkdGFibGVzKHN0YXRlKSB7XG4gIC8qIGJ1aWxkIGZpeGVkIGh1ZmZtYW4gdGFibGVzIGlmIGZpcnN0IGNhbGwgKG1heSBub3QgYmUgdGhyZWFkIHNhZmUpICovXG4gIGlmICh2aXJnaW4pIHtcbiAgICB2YXIgc3ltO1xuXG4gICAgbGVuZml4ID0gbmV3IHV0aWxzLkJ1ZjMyKDUxMik7XG4gICAgZGlzdGZpeCA9IG5ldyB1dGlscy5CdWYzMigzMik7XG5cbiAgICAvKiBsaXRlcmFsL2xlbmd0aCB0YWJsZSAqL1xuICAgIHN5bSA9IDA7XG4gICAgd2hpbGUgKHN5bSA8IDE0NCkgeyBzdGF0ZS5sZW5zW3N5bSsrXSA9IDg7IH1cbiAgICB3aGlsZSAoc3ltIDwgMjU2KSB7IHN0YXRlLmxlbnNbc3ltKytdID0gOTsgfVxuICAgIHdoaWxlIChzeW0gPCAyODApIHsgc3RhdGUubGVuc1tzeW0rK10gPSA3OyB9XG4gICAgd2hpbGUgKHN5bSA8IDI4OCkgeyBzdGF0ZS5sZW5zW3N5bSsrXSA9IDg7IH1cblxuICAgIGluZmxhdGVfdGFibGUoTEVOUywgIHN0YXRlLmxlbnMsIDAsIDI4OCwgbGVuZml4LCAgIDAsIHN0YXRlLndvcmssIHsgYml0czogOSB9KTtcblxuICAgIC8qIGRpc3RhbmNlIHRhYmxlICovXG4gICAgc3ltID0gMDtcbiAgICB3aGlsZSAoc3ltIDwgMzIpIHsgc3RhdGUubGVuc1tzeW0rK10gPSA1OyB9XG5cbiAgICBpbmZsYXRlX3RhYmxlKERJU1RTLCBzdGF0ZS5sZW5zLCAwLCAzMiwgICBkaXN0Zml4LCAwLCBzdGF0ZS53b3JrLCB7IGJpdHM6IDUgfSk7XG5cbiAgICAvKiBkbyB0aGlzIGp1c3Qgb25jZSAqL1xuICAgIHZpcmdpbiA9IGZhbHNlO1xuICB9XG5cbiAgc3RhdGUubGVuY29kZSA9IGxlbmZpeDtcbiAgc3RhdGUubGVuYml0cyA9IDk7XG4gIHN0YXRlLmRpc3Rjb2RlID0gZGlzdGZpeDtcbiAgc3RhdGUuZGlzdGJpdHMgPSA1O1xufVxuXG5cbi8qXG4gVXBkYXRlIHRoZSB3aW5kb3cgd2l0aCB0aGUgbGFzdCB3c2l6ZSAobm9ybWFsbHkgMzJLKSBieXRlcyB3cml0dGVuIGJlZm9yZVxuIHJldHVybmluZy4gIElmIHdpbmRvdyBkb2VzIG5vdCBleGlzdCB5ZXQsIGNyZWF0ZSBpdC4gIFRoaXMgaXMgb25seSBjYWxsZWRcbiB3aGVuIGEgd2luZG93IGlzIGFscmVhZHkgaW4gdXNlLCBvciB3aGVuIG91dHB1dCBoYXMgYmVlbiB3cml0dGVuIGR1cmluZyB0aGlzXG4gaW5mbGF0ZSBjYWxsLCBidXQgdGhlIGVuZCBvZiB0aGUgZGVmbGF0ZSBzdHJlYW0gaGFzIG5vdCBiZWVuIHJlYWNoZWQgeWV0LlxuIEl0IGlzIGFsc28gY2FsbGVkIHRvIGNyZWF0ZSBhIHdpbmRvdyBmb3IgZGljdGlvbmFyeSBkYXRhIHdoZW4gYSBkaWN0aW9uYXJ5XG4gaXMgbG9hZGVkLlxuXG4gUHJvdmlkaW5nIG91dHB1dCBidWZmZXJzIGxhcmdlciB0aGFuIDMySyB0byBpbmZsYXRlKCkgc2hvdWxkIHByb3ZpZGUgYSBzcGVlZFxuIGFkdmFudGFnZSwgc2luY2Ugb25seSB0aGUgbGFzdCAzMksgb2Ygb3V0cHV0IGlzIGNvcGllZCB0byB0aGUgc2xpZGluZyB3aW5kb3dcbiB1cG9uIHJldHVybiBmcm9tIGluZmxhdGUoKSwgYW5kIHNpbmNlIGFsbCBkaXN0YW5jZXMgYWZ0ZXIgdGhlIGZpcnN0IDMySyBvZlxuIG91dHB1dCB3aWxsIGZhbGwgaW4gdGhlIG91dHB1dCBkYXRhLCBtYWtpbmcgbWF0Y2ggY29waWVzIHNpbXBsZXIgYW5kIGZhc3Rlci5cbiBUaGUgYWR2YW50YWdlIG1heSBiZSBkZXBlbmRlbnQgb24gdGhlIHNpemUgb2YgdGhlIHByb2Nlc3NvcidzIGRhdGEgY2FjaGVzLlxuICovXG5mdW5jdGlvbiB1cGRhdGV3aW5kb3coc3RybSwgc3JjLCBlbmQsIGNvcHkpIHtcbiAgdmFyIGRpc3Q7XG4gIHZhciBzdGF0ZSA9IHN0cm0uc3RhdGU7XG5cbiAgLyogaWYgaXQgaGFzbid0IGJlZW4gZG9uZSBhbHJlYWR5LCBhbGxvY2F0ZSBzcGFjZSBmb3IgdGhlIHdpbmRvdyAqL1xuICBpZiAoc3RhdGUud2luZG93ID09PSBudWxsKSB7XG4gICAgc3RhdGUud3NpemUgPSAxIDw8IHN0YXRlLndiaXRzO1xuICAgIHN0YXRlLnduZXh0ID0gMDtcbiAgICBzdGF0ZS53aGF2ZSA9IDA7XG5cbiAgICBzdGF0ZS53aW5kb3cgPSBuZXcgdXRpbHMuQnVmOChzdGF0ZS53c2l6ZSk7XG4gIH1cblxuICAvKiBjb3B5IHN0YXRlLT53c2l6ZSBvciBsZXNzIG91dHB1dCBieXRlcyBpbnRvIHRoZSBjaXJjdWxhciB3aW5kb3cgKi9cbiAgaWYgKGNvcHkgPj0gc3RhdGUud3NpemUpIHtcbiAgICB1dGlscy5hcnJheVNldChzdGF0ZS53aW5kb3csIHNyYywgZW5kIC0gc3RhdGUud3NpemUsIHN0YXRlLndzaXplLCAwKTtcbiAgICBzdGF0ZS53bmV4dCA9IDA7XG4gICAgc3RhdGUud2hhdmUgPSBzdGF0ZS53c2l6ZTtcbiAgfVxuICBlbHNlIHtcbiAgICBkaXN0ID0gc3RhdGUud3NpemUgLSBzdGF0ZS53bmV4dDtcbiAgICBpZiAoZGlzdCA+IGNvcHkpIHtcbiAgICAgIGRpc3QgPSBjb3B5O1xuICAgIH1cbiAgICAvL3ptZW1jcHkoc3RhdGUtPndpbmRvdyArIHN0YXRlLT53bmV4dCwgZW5kIC0gY29weSwgZGlzdCk7XG4gICAgdXRpbHMuYXJyYXlTZXQoc3RhdGUud2luZG93LCBzcmMsIGVuZCAtIGNvcHksIGRpc3QsIHN0YXRlLnduZXh0KTtcbiAgICBjb3B5IC09IGRpc3Q7XG4gICAgaWYgKGNvcHkpIHtcbiAgICAgIC8vem1lbWNweShzdGF0ZS0+d2luZG93LCBlbmQgLSBjb3B5LCBjb3B5KTtcbiAgICAgIHV0aWxzLmFycmF5U2V0KHN0YXRlLndpbmRvdywgc3JjLCBlbmQgLSBjb3B5LCBjb3B5LCAwKTtcbiAgICAgIHN0YXRlLnduZXh0ID0gY29weTtcbiAgICAgIHN0YXRlLndoYXZlID0gc3RhdGUud3NpemU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgc3RhdGUud25leHQgKz0gZGlzdDtcbiAgICAgIGlmIChzdGF0ZS53bmV4dCA9PT0gc3RhdGUud3NpemUpIHsgc3RhdGUud25leHQgPSAwOyB9XG4gICAgICBpZiAoc3RhdGUud2hhdmUgPCBzdGF0ZS53c2l6ZSkgeyBzdGF0ZS53aGF2ZSArPSBkaXN0OyB9XG4gICAgfVxuICB9XG4gIHJldHVybiAwO1xufVxuXG5mdW5jdGlvbiBpbmZsYXRlKHN0cm0sIGZsdXNoKSB7XG4gIHZhciBzdGF0ZTtcbiAgdmFyIGlucHV0LCBvdXRwdXQ7ICAgICAgICAgIC8vIGlucHV0L291dHB1dCBidWZmZXJzXG4gIHZhciBuZXh0OyAgICAgICAgICAgICAgICAgICAvKiBuZXh0IGlucHV0IElOREVYICovXG4gIHZhciBwdXQ7ICAgICAgICAgICAgICAgICAgICAvKiBuZXh0IG91dHB1dCBJTkRFWCAqL1xuICB2YXIgaGF2ZSwgbGVmdDsgICAgICAgICAgICAgLyogYXZhaWxhYmxlIGlucHV0IGFuZCBvdXRwdXQgKi9cbiAgdmFyIGhvbGQ7ICAgICAgICAgICAgICAgICAgIC8qIGJpdCBidWZmZXIgKi9cbiAgdmFyIGJpdHM7ICAgICAgICAgICAgICAgICAgIC8qIGJpdHMgaW4gYml0IGJ1ZmZlciAqL1xuICB2YXIgX2luLCBfb3V0OyAgICAgICAgICAgICAgLyogc2F2ZSBzdGFydGluZyBhdmFpbGFibGUgaW5wdXQgYW5kIG91dHB1dCAqL1xuICB2YXIgY29weTsgICAgICAgICAgICAgICAgICAgLyogbnVtYmVyIG9mIHN0b3JlZCBvciBtYXRjaCBieXRlcyB0byBjb3B5ICovXG4gIHZhciBmcm9tOyAgICAgICAgICAgICAgICAgICAvKiB3aGVyZSB0byBjb3B5IG1hdGNoIGJ5dGVzIGZyb20gKi9cbiAgdmFyIGZyb21fc291cmNlO1xuICB2YXIgaGVyZSA9IDA7ICAgICAgICAgICAgICAgLyogY3VycmVudCBkZWNvZGluZyB0YWJsZSBlbnRyeSAqL1xuICB2YXIgaGVyZV9iaXRzLCBoZXJlX29wLCBoZXJlX3ZhbDsgLy8gcGFrZWQgXCJoZXJlXCIgZGVub3JtYWxpemVkIChKUyBzcGVjaWZpYylcbiAgLy92YXIgbGFzdDsgICAgICAgICAgICAgICAgICAgLyogcGFyZW50IHRhYmxlIGVudHJ5ICovXG4gIHZhciBsYXN0X2JpdHMsIGxhc3Rfb3AsIGxhc3RfdmFsOyAvLyBwYWtlZCBcImxhc3RcIiBkZW5vcm1hbGl6ZWQgKEpTIHNwZWNpZmljKVxuICB2YXIgbGVuOyAgICAgICAgICAgICAgICAgICAgLyogbGVuZ3RoIHRvIGNvcHkgZm9yIHJlcGVhdHMsIGJpdHMgdG8gZHJvcCAqL1xuICB2YXIgcmV0OyAgICAgICAgICAgICAgICAgICAgLyogcmV0dXJuIGNvZGUgKi9cbiAgdmFyIGhidWYgPSBuZXcgdXRpbHMuQnVmOCg0KTsgICAgLyogYnVmZmVyIGZvciBnemlwIGhlYWRlciBjcmMgY2FsY3VsYXRpb24gKi9cbiAgdmFyIG9wdHM7XG5cbiAgdmFyIG47IC8vIHRlbXBvcmFyeSB2YXIgZm9yIE5FRURfQklUU1xuXG4gIHZhciBvcmRlciA9IC8qIHBlcm11dGF0aW9uIG9mIGNvZGUgbGVuZ3RocyAqL1xuICAgIFsgMTYsIDE3LCAxOCwgMCwgOCwgNywgOSwgNiwgMTAsIDUsIDExLCA0LCAxMiwgMywgMTMsIDIsIDE0LCAxLCAxNSBdO1xuXG5cbiAgaWYgKCFzdHJtIHx8ICFzdHJtLnN0YXRlIHx8ICFzdHJtLm91dHB1dCB8fFxuICAgICAgKCFzdHJtLmlucHV0ICYmIHN0cm0uYXZhaWxfaW4gIT09IDApKSB7XG4gICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SO1xuICB9XG5cbiAgc3RhdGUgPSBzdHJtLnN0YXRlO1xuICBpZiAoc3RhdGUubW9kZSA9PT0gVFlQRSkgeyBzdGF0ZS5tb2RlID0gVFlQRURPOyB9ICAgIC8qIHNraXAgY2hlY2sgKi9cblxuXG4gIC8vLS0tIExPQUQoKSAtLS1cbiAgcHV0ID0gc3RybS5uZXh0X291dDtcbiAgb3V0cHV0ID0gc3RybS5vdXRwdXQ7XG4gIGxlZnQgPSBzdHJtLmF2YWlsX291dDtcbiAgbmV4dCA9IHN0cm0ubmV4dF9pbjtcbiAgaW5wdXQgPSBzdHJtLmlucHV0O1xuICBoYXZlID0gc3RybS5hdmFpbF9pbjtcbiAgaG9sZCA9IHN0YXRlLmhvbGQ7XG4gIGJpdHMgPSBzdGF0ZS5iaXRzO1xuICAvLy0tLVxuXG4gIF9pbiA9IGhhdmU7XG4gIF9vdXQgPSBsZWZ0O1xuICByZXQgPSBaX09LO1xuXG4gIGluZl9sZWF2ZTogLy8gZ290byBlbXVsYXRpb25cbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoc3RhdGUubW9kZSkge1xuICAgIGNhc2UgSEVBRDpcbiAgICAgIGlmIChzdGF0ZS53cmFwID09PSAwKSB7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBUWVBFRE87XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgLy89PT0gTkVFREJJVFMoMTYpO1xuICAgICAgd2hpbGUgKGJpdHMgPCAxNikge1xuICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgaGF2ZS0tO1xuICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgYml0cyArPSA4O1xuICAgICAgfVxuICAgICAgLy89PT0vL1xuICAgICAgaWYgKChzdGF0ZS53cmFwICYgMikgJiYgaG9sZCA9PT0gMHg4YjFmKSB7ICAvKiBnemlwIGhlYWRlciAqL1xuICAgICAgICBzdGF0ZS5jaGVjayA9IDAvKmNyYzMyKDBMLCBaX05VTEwsIDApKi87XG4gICAgICAgIC8vPT09IENSQzIoc3RhdGUuY2hlY2ssIGhvbGQpO1xuICAgICAgICBoYnVmWzBdID0gaG9sZCAmIDB4ZmY7XG4gICAgICAgIGhidWZbMV0gPSAoaG9sZCA+Pj4gOCkgJiAweGZmO1xuICAgICAgICBzdGF0ZS5jaGVjayA9IGNyYzMyKHN0YXRlLmNoZWNrLCBoYnVmLCAyLCAwKTtcbiAgICAgICAgLy89PT0vL1xuXG4gICAgICAgIC8vPT09IElOSVRCSVRTKCk7XG4gICAgICAgIGhvbGQgPSAwO1xuICAgICAgICBiaXRzID0gMDtcbiAgICAgICAgLy89PT0vL1xuICAgICAgICBzdGF0ZS5tb2RlID0gRkxBR1M7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgc3RhdGUuZmxhZ3MgPSAwOyAgICAgICAgICAgLyogZXhwZWN0IHpsaWIgaGVhZGVyICovXG4gICAgICBpZiAoc3RhdGUuaGVhZCkge1xuICAgICAgICBzdGF0ZS5oZWFkLmRvbmUgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmICghKHN0YXRlLndyYXAgJiAxKSB8fCAgIC8qIGNoZWNrIGlmIHpsaWIgaGVhZGVyIGFsbG93ZWQgKi9cbiAgICAgICAgKCgoaG9sZCAmIDB4ZmYpLypCSVRTKDgpKi8gPDwgOCkgKyAoaG9sZCA+PiA4KSkgJSAzMSkge1xuICAgICAgICBzdHJtLm1zZyA9ICdpbmNvcnJlY3QgaGVhZGVyIGNoZWNrJztcbiAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAoKGhvbGQgJiAweDBmKS8qQklUUyg0KSovICE9PSBaX0RFRkxBVEVEKSB7XG4gICAgICAgIHN0cm0ubXNnID0gJ3Vua25vd24gY29tcHJlc3Npb24gbWV0aG9kJztcbiAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICAvLy0tLSBEUk9QQklUUyg0KSAtLS0vL1xuICAgICAgaG9sZCA+Pj49IDQ7XG4gICAgICBiaXRzIC09IDQ7XG4gICAgICAvLy0tLS8vXG4gICAgICBsZW4gPSAoaG9sZCAmIDB4MGYpLypCSVRTKDQpKi8gKyA4O1xuICAgICAgaWYgKHN0YXRlLndiaXRzID09PSAwKSB7XG4gICAgICAgIHN0YXRlLndiaXRzID0gbGVuO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAobGVuID4gc3RhdGUud2JpdHMpIHtcbiAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCB3aW5kb3cgc2l6ZSc7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgc3RhdGUuZG1heCA9IDEgPDwgbGVuO1xuICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgIHpsaWIgaGVhZGVyIG9rXFxuXCIpKTtcbiAgICAgIHN0cm0uYWRsZXIgPSBzdGF0ZS5jaGVjayA9IDEvKmFkbGVyMzIoMEwsIFpfTlVMTCwgMCkqLztcbiAgICAgIHN0YXRlLm1vZGUgPSBob2xkICYgMHgyMDAgPyBESUNUSUQgOiBUWVBFO1xuICAgICAgLy89PT0gSU5JVEJJVFMoKTtcbiAgICAgIGhvbGQgPSAwO1xuICAgICAgYml0cyA9IDA7XG4gICAgICAvLz09PS8vXG4gICAgICBicmVhaztcbiAgICBjYXNlIEZMQUdTOlxuICAgICAgLy89PT0gTkVFREJJVFMoMTYpOyAqL1xuICAgICAgd2hpbGUgKGJpdHMgPCAxNikge1xuICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgaGF2ZS0tO1xuICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgYml0cyArPSA4O1xuICAgICAgfVxuICAgICAgLy89PT0vL1xuICAgICAgc3RhdGUuZmxhZ3MgPSBob2xkO1xuICAgICAgaWYgKChzdGF0ZS5mbGFncyAmIDB4ZmYpICE9PSBaX0RFRkxBVEVEKSB7XG4gICAgICAgIHN0cm0ubXNnID0gJ3Vua25vd24gY29tcHJlc3Npb24gbWV0aG9kJztcbiAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweGUwMDApIHtcbiAgICAgICAgc3RybS5tc2cgPSAndW5rbm93biBoZWFkZXIgZmxhZ3Mgc2V0JztcbiAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAoc3RhdGUuaGVhZCkge1xuICAgICAgICBzdGF0ZS5oZWFkLnRleHQgPSAoKGhvbGQgPj4gOCkgJiAxKTtcbiAgICAgIH1cbiAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MDIwMCkge1xuICAgICAgICAvLz09PSBDUkMyKHN0YXRlLmNoZWNrLCBob2xkKTtcbiAgICAgICAgaGJ1ZlswXSA9IGhvbGQgJiAweGZmO1xuICAgICAgICBoYnVmWzFdID0gKGhvbGQgPj4+IDgpICYgMHhmZjtcbiAgICAgICAgc3RhdGUuY2hlY2sgPSBjcmMzMihzdGF0ZS5jaGVjaywgaGJ1ZiwgMiwgMCk7XG4gICAgICAgIC8vPT09Ly9cbiAgICAgIH1cbiAgICAgIC8vPT09IElOSVRCSVRTKCk7XG4gICAgICBob2xkID0gMDtcbiAgICAgIGJpdHMgPSAwO1xuICAgICAgLy89PT0vL1xuICAgICAgc3RhdGUubW9kZSA9IFRJTUU7XG4gICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgY2FzZSBUSU1FOlxuICAgICAgLy89PT0gTkVFREJJVFMoMzIpOyAqL1xuICAgICAgd2hpbGUgKGJpdHMgPCAzMikge1xuICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgaGF2ZS0tO1xuICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgYml0cyArPSA4O1xuICAgICAgfVxuICAgICAgLy89PT0vL1xuICAgICAgaWYgKHN0YXRlLmhlYWQpIHtcbiAgICAgICAgc3RhdGUuaGVhZC50aW1lID0gaG9sZDtcbiAgICAgIH1cbiAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MDIwMCkge1xuICAgICAgICAvLz09PSBDUkM0KHN0YXRlLmNoZWNrLCBob2xkKVxuICAgICAgICBoYnVmWzBdID0gaG9sZCAmIDB4ZmY7XG4gICAgICAgIGhidWZbMV0gPSAoaG9sZCA+Pj4gOCkgJiAweGZmO1xuICAgICAgICBoYnVmWzJdID0gKGhvbGQgPj4+IDE2KSAmIDB4ZmY7XG4gICAgICAgIGhidWZbM10gPSAoaG9sZCA+Pj4gMjQpICYgMHhmZjtcbiAgICAgICAgc3RhdGUuY2hlY2sgPSBjcmMzMihzdGF0ZS5jaGVjaywgaGJ1ZiwgNCwgMCk7XG4gICAgICAgIC8vPT09XG4gICAgICB9XG4gICAgICAvLz09PSBJTklUQklUUygpO1xuICAgICAgaG9sZCA9IDA7XG4gICAgICBiaXRzID0gMDtcbiAgICAgIC8vPT09Ly9cbiAgICAgIHN0YXRlLm1vZGUgPSBPUztcbiAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICBjYXNlIE9TOlxuICAgICAgLy89PT0gTkVFREJJVFMoMTYpOyAqL1xuICAgICAgd2hpbGUgKGJpdHMgPCAxNikge1xuICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgaGF2ZS0tO1xuICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgYml0cyArPSA4O1xuICAgICAgfVxuICAgICAgLy89PT0vL1xuICAgICAgaWYgKHN0YXRlLmhlYWQpIHtcbiAgICAgICAgc3RhdGUuaGVhZC54ZmxhZ3MgPSAoaG9sZCAmIDB4ZmYpO1xuICAgICAgICBzdGF0ZS5oZWFkLm9zID0gKGhvbGQgPj4gOCk7XG4gICAgICB9XG4gICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDAyMDApIHtcbiAgICAgICAgLy89PT0gQ1JDMihzdGF0ZS5jaGVjaywgaG9sZCk7XG4gICAgICAgIGhidWZbMF0gPSBob2xkICYgMHhmZjtcbiAgICAgICAgaGJ1ZlsxXSA9IChob2xkID4+PiA4KSAmIDB4ZmY7XG4gICAgICAgIHN0YXRlLmNoZWNrID0gY3JjMzIoc3RhdGUuY2hlY2ssIGhidWYsIDIsIDApO1xuICAgICAgICAvLz09PS8vXG4gICAgICB9XG4gICAgICAvLz09PSBJTklUQklUUygpO1xuICAgICAgaG9sZCA9IDA7XG4gICAgICBiaXRzID0gMDtcbiAgICAgIC8vPT09Ly9cbiAgICAgIHN0YXRlLm1vZGUgPSBFWExFTjtcbiAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICBjYXNlIEVYTEVOOlxuICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgwNDAwKSB7XG4gICAgICAgIC8vPT09IE5FRURCSVRTKDE2KTsgKi9cbiAgICAgICAgd2hpbGUgKGJpdHMgPCAxNikge1xuICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgIH1cbiAgICAgICAgLy89PT0vL1xuICAgICAgICBzdGF0ZS5sZW5ndGggPSBob2xkO1xuICAgICAgICBpZiAoc3RhdGUuaGVhZCkge1xuICAgICAgICAgIHN0YXRlLmhlYWQuZXh0cmFfbGVuID0gaG9sZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDAyMDApIHtcbiAgICAgICAgICAvLz09PSBDUkMyKHN0YXRlLmNoZWNrLCBob2xkKTtcbiAgICAgICAgICBoYnVmWzBdID0gaG9sZCAmIDB4ZmY7XG4gICAgICAgICAgaGJ1ZlsxXSA9IChob2xkID4+PiA4KSAmIDB4ZmY7XG4gICAgICAgICAgc3RhdGUuY2hlY2sgPSBjcmMzMihzdGF0ZS5jaGVjaywgaGJ1ZiwgMiwgMCk7XG4gICAgICAgICAgLy89PT0vL1xuICAgICAgICB9XG4gICAgICAgIC8vPT09IElOSVRCSVRTKCk7XG4gICAgICAgIGhvbGQgPSAwO1xuICAgICAgICBiaXRzID0gMDtcbiAgICAgICAgLy89PT0vL1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoc3RhdGUuaGVhZCkge1xuICAgICAgICBzdGF0ZS5oZWFkLmV4dHJhID0gbnVsbC8qWl9OVUxMKi87XG4gICAgICB9XG4gICAgICBzdGF0ZS5tb2RlID0gRVhUUkE7XG4gICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgY2FzZSBFWFRSQTpcbiAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MDQwMCkge1xuICAgICAgICBjb3B5ID0gc3RhdGUubGVuZ3RoO1xuICAgICAgICBpZiAoY29weSA+IGhhdmUpIHsgY29weSA9IGhhdmU7IH1cbiAgICAgICAgaWYgKGNvcHkpIHtcbiAgICAgICAgICBpZiAoc3RhdGUuaGVhZCkge1xuICAgICAgICAgICAgbGVuID0gc3RhdGUuaGVhZC5leHRyYV9sZW4gLSBzdGF0ZS5sZW5ndGg7XG4gICAgICAgICAgICBpZiAoIXN0YXRlLmhlYWQuZXh0cmEpIHtcbiAgICAgICAgICAgICAgLy8gVXNlIHVudHlwZWQgYXJyYXkgZm9yIG1vcmUgY29udmVuaWVuZCBwcm9jZXNzaW5nIGxhdGVyXG4gICAgICAgICAgICAgIHN0YXRlLmhlYWQuZXh0cmEgPSBuZXcgQXJyYXkoc3RhdGUuaGVhZC5leHRyYV9sZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdXRpbHMuYXJyYXlTZXQoXG4gICAgICAgICAgICAgIHN0YXRlLmhlYWQuZXh0cmEsXG4gICAgICAgICAgICAgIGlucHV0LFxuICAgICAgICAgICAgICBuZXh0LFxuICAgICAgICAgICAgICAvLyBleHRyYSBmaWVsZCBpcyBsaW1pdGVkIHRvIDY1NTM2IGJ5dGVzXG4gICAgICAgICAgICAgIC8vIC0gbm8gbmVlZCBmb3IgYWRkaXRpb25hbCBzaXplIGNoZWNrXG4gICAgICAgICAgICAgIGNvcHksXG4gICAgICAgICAgICAgIC8qbGVuICsgY29weSA+IHN0YXRlLmhlYWQuZXh0cmFfbWF4IC0gbGVuID8gc3RhdGUuaGVhZC5leHRyYV9tYXggOiBjb3B5LCovXG4gICAgICAgICAgICAgIGxlblxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIC8vem1lbWNweShzdGF0ZS5oZWFkLmV4dHJhICsgbGVuLCBuZXh0LFxuICAgICAgICAgICAgLy8gICAgICAgIGxlbiArIGNvcHkgPiBzdGF0ZS5oZWFkLmV4dHJhX21heCA/XG4gICAgICAgICAgICAvLyAgICAgICAgc3RhdGUuaGVhZC5leHRyYV9tYXggLSBsZW4gOiBjb3B5KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgwMjAwKSB7XG4gICAgICAgICAgICBzdGF0ZS5jaGVjayA9IGNyYzMyKHN0YXRlLmNoZWNrLCBpbnB1dCwgY29weSwgbmV4dCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGhhdmUgLT0gY29weTtcbiAgICAgICAgICBuZXh0ICs9IGNvcHk7XG4gICAgICAgICAgc3RhdGUubGVuZ3RoIC09IGNvcHk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXRlLmxlbmd0aCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgIH1cbiAgICAgIHN0YXRlLmxlbmd0aCA9IDA7XG4gICAgICBzdGF0ZS5tb2RlID0gTkFNRTtcbiAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICBjYXNlIE5BTUU6XG4gICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDA4MDApIHtcbiAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgIGNvcHkgPSAwO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgLy8gVE9ETzogMiBvciAxIGJ5dGVzP1xuICAgICAgICAgIGxlbiA9IGlucHV0W25leHQgKyBjb3B5KytdO1xuICAgICAgICAgIC8qIHVzZSBjb25zdGFudCBsaW1pdCBiZWNhdXNlIGluIGpzIHdlIHNob3VsZCBub3QgcHJlYWxsb2NhdGUgbWVtb3J5ICovXG4gICAgICAgICAgaWYgKHN0YXRlLmhlYWQgJiYgbGVuICYmXG4gICAgICAgICAgICAgIChzdGF0ZS5sZW5ndGggPCA2NTUzNiAvKnN0YXRlLmhlYWQubmFtZV9tYXgqLykpIHtcbiAgICAgICAgICAgIHN0YXRlLmhlYWQubmFtZSArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGxlbik7XG4gICAgICAgICAgfVxuICAgICAgICB9IHdoaWxlIChsZW4gJiYgY29weSA8IGhhdmUpO1xuXG4gICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MDIwMCkge1xuICAgICAgICAgIHN0YXRlLmNoZWNrID0gY3JjMzIoc3RhdGUuY2hlY2ssIGlucHV0LCBjb3B5LCBuZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBoYXZlIC09IGNvcHk7XG4gICAgICAgIG5leHQgKz0gY29weTtcbiAgICAgICAgaWYgKGxlbikgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHN0YXRlLmhlYWQpIHtcbiAgICAgICAgc3RhdGUuaGVhZC5uYW1lID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIHN0YXRlLmxlbmd0aCA9IDA7XG4gICAgICBzdGF0ZS5tb2RlID0gQ09NTUVOVDtcbiAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICBjYXNlIENPTU1FTlQ6XG4gICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDEwMDApIHtcbiAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgIGNvcHkgPSAwO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgbGVuID0gaW5wdXRbbmV4dCArIGNvcHkrK107XG4gICAgICAgICAgLyogdXNlIGNvbnN0YW50IGxpbWl0IGJlY2F1c2UgaW4ganMgd2Ugc2hvdWxkIG5vdCBwcmVhbGxvY2F0ZSBtZW1vcnkgKi9cbiAgICAgICAgICBpZiAoc3RhdGUuaGVhZCAmJiBsZW4gJiZcbiAgICAgICAgICAgICAgKHN0YXRlLmxlbmd0aCA8IDY1NTM2IC8qc3RhdGUuaGVhZC5jb21tX21heCovKSkge1xuICAgICAgICAgICAgc3RhdGUuaGVhZC5jb21tZW50ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUobGVuKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gd2hpbGUgKGxlbiAmJiBjb3B5IDwgaGF2ZSk7XG4gICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MDIwMCkge1xuICAgICAgICAgIHN0YXRlLmNoZWNrID0gY3JjMzIoc3RhdGUuY2hlY2ssIGlucHV0LCBjb3B5LCBuZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBoYXZlIC09IGNvcHk7XG4gICAgICAgIG5leHQgKz0gY29weTtcbiAgICAgICAgaWYgKGxlbikgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHN0YXRlLmhlYWQpIHtcbiAgICAgICAgc3RhdGUuaGVhZC5jb21tZW50ID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIHN0YXRlLm1vZGUgPSBIQ1JDO1xuICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgIGNhc2UgSENSQzpcbiAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MDIwMCkge1xuICAgICAgICAvLz09PSBORUVEQklUUygxNik7ICovXG4gICAgICAgIHdoaWxlIChiaXRzIDwgMTYpIHtcbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICB9XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgaWYgKGhvbGQgIT09IChzdGF0ZS5jaGVjayAmIDB4ZmZmZikpIHtcbiAgICAgICAgICBzdHJtLm1zZyA9ICdoZWFkZXIgY3JjIG1pc21hdGNoJztcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIC8vPT09IElOSVRCSVRTKCk7XG4gICAgICAgIGhvbGQgPSAwO1xuICAgICAgICBiaXRzID0gMDtcbiAgICAgICAgLy89PT0vL1xuICAgICAgfVxuICAgICAgaWYgKHN0YXRlLmhlYWQpIHtcbiAgICAgICAgc3RhdGUuaGVhZC5oY3JjID0gKChzdGF0ZS5mbGFncyA+PiA5KSAmIDEpO1xuICAgICAgICBzdGF0ZS5oZWFkLmRvbmUgPSB0cnVlO1xuICAgICAgfVxuICAgICAgc3RybS5hZGxlciA9IHN0YXRlLmNoZWNrID0gMDtcbiAgICAgIHN0YXRlLm1vZGUgPSBUWVBFO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBESUNUSUQ6XG4gICAgICAvLz09PSBORUVEQklUUygzMik7ICovXG4gICAgICB3aGlsZSAoYml0cyA8IDMyKSB7XG4gICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICBoYXZlLS07XG4gICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICBiaXRzICs9IDg7XG4gICAgICB9XG4gICAgICAvLz09PS8vXG4gICAgICBzdHJtLmFkbGVyID0gc3RhdGUuY2hlY2sgPSB6c3dhcDMyKGhvbGQpO1xuICAgICAgLy89PT0gSU5JVEJJVFMoKTtcbiAgICAgIGhvbGQgPSAwO1xuICAgICAgYml0cyA9IDA7XG4gICAgICAvLz09PS8vXG4gICAgICBzdGF0ZS5tb2RlID0gRElDVDtcbiAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICBjYXNlIERJQ1Q6XG4gICAgICBpZiAoc3RhdGUuaGF2ZWRpY3QgPT09IDApIHtcbiAgICAgICAgLy8tLS0gUkVTVE9SRSgpIC0tLVxuICAgICAgICBzdHJtLm5leHRfb3V0ID0gcHV0O1xuICAgICAgICBzdHJtLmF2YWlsX291dCA9IGxlZnQ7XG4gICAgICAgIHN0cm0ubmV4dF9pbiA9IG5leHQ7XG4gICAgICAgIHN0cm0uYXZhaWxfaW4gPSBoYXZlO1xuICAgICAgICBzdGF0ZS5ob2xkID0gaG9sZDtcbiAgICAgICAgc3RhdGUuYml0cyA9IGJpdHM7XG4gICAgICAgIC8vLS0tXG4gICAgICAgIHJldHVybiBaX05FRURfRElDVDtcbiAgICAgIH1cbiAgICAgIHN0cm0uYWRsZXIgPSBzdGF0ZS5jaGVjayA9IDEvKmFkbGVyMzIoMEwsIFpfTlVMTCwgMCkqLztcbiAgICAgIHN0YXRlLm1vZGUgPSBUWVBFO1xuICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgIGNhc2UgVFlQRTpcbiAgICAgIGlmIChmbHVzaCA9PT0gWl9CTE9DSyB8fCBmbHVzaCA9PT0gWl9UUkVFUykgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICBjYXNlIFRZUEVETzpcbiAgICAgIGlmIChzdGF0ZS5sYXN0KSB7XG4gICAgICAgIC8vLS0tIEJZVEVCSVRTKCkgLS0tLy9cbiAgICAgICAgaG9sZCA+Pj49IGJpdHMgJiA3O1xuICAgICAgICBiaXRzIC09IGJpdHMgJiA3O1xuICAgICAgICAvLy0tLS8vXG4gICAgICAgIHN0YXRlLm1vZGUgPSBDSEVDSztcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICAvLz09PSBORUVEQklUUygzKTsgKi9cbiAgICAgIHdoaWxlIChiaXRzIDwgMykge1xuICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgaGF2ZS0tO1xuICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgYml0cyArPSA4O1xuICAgICAgfVxuICAgICAgLy89PT0vL1xuICAgICAgc3RhdGUubGFzdCA9IChob2xkICYgMHgwMSkvKkJJVFMoMSkqLztcbiAgICAgIC8vLS0tIERST1BCSVRTKDEpIC0tLS8vXG4gICAgICBob2xkID4+Pj0gMTtcbiAgICAgIGJpdHMgLT0gMTtcbiAgICAgIC8vLS0tLy9cblxuICAgICAgc3dpdGNoICgoaG9sZCAmIDB4MDMpLypCSVRTKDIpKi8pIHtcbiAgICAgIGNhc2UgMDogICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIHN0b3JlZCBibG9jayAqL1xuICAgICAgICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6ICAgICBzdG9yZWQgYmxvY2slc1xcblwiLFxuICAgICAgICAvLyAgICAgICAgc3RhdGUubGFzdCA/IFwiIChsYXN0KVwiIDogXCJcIikpO1xuICAgICAgICBzdGF0ZS5tb2RlID0gU1RPUkVEO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTogICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIGZpeGVkIGJsb2NrICovXG4gICAgICAgIGZpeGVkdGFibGVzKHN0YXRlKTtcbiAgICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgZml4ZWQgY29kZXMgYmxvY2slc1xcblwiLFxuICAgICAgICAvLyAgICAgICAgc3RhdGUubGFzdCA/IFwiIChsYXN0KVwiIDogXCJcIikpO1xuICAgICAgICBzdGF0ZS5tb2RlID0gTEVOXzsgICAgICAgICAgICAgLyogZGVjb2RlIGNvZGVzICovXG4gICAgICAgIGlmIChmbHVzaCA9PT0gWl9UUkVFUykge1xuICAgICAgICAgIC8vLS0tIERST1BCSVRTKDIpIC0tLS8vXG4gICAgICAgICAgaG9sZCA+Pj49IDI7XG4gICAgICAgICAgYml0cyAtPSAyO1xuICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICBicmVhayBpbmZfbGVhdmU7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBkeW5hbWljIGJsb2NrICovXG4gICAgICAgIC8vVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgIGR5bmFtaWMgY29kZXMgYmxvY2slc1xcblwiLFxuICAgICAgICAvLyAgICAgICAgc3RhdGUubGFzdCA/IFwiIChsYXN0KVwiIDogXCJcIikpO1xuICAgICAgICBzdGF0ZS5tb2RlID0gVEFCTEU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAzOlxuICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGJsb2NrIHR5cGUnO1xuICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgfVxuICAgICAgLy8tLS0gRFJPUEJJVFMoMikgLS0tLy9cbiAgICAgIGhvbGQgPj4+PSAyO1xuICAgICAgYml0cyAtPSAyO1xuICAgICAgLy8tLS0vL1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBTVE9SRUQ6XG4gICAgICAvLy0tLSBCWVRFQklUUygpIC0tLS8vIC8qIGdvIHRvIGJ5dGUgYm91bmRhcnkgKi9cbiAgICAgIGhvbGQgPj4+PSBiaXRzICYgNztcbiAgICAgIGJpdHMgLT0gYml0cyAmIDc7XG4gICAgICAvLy0tLS8vXG4gICAgICAvLz09PSBORUVEQklUUygzMik7ICovXG4gICAgICB3aGlsZSAoYml0cyA8IDMyKSB7XG4gICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICBoYXZlLS07XG4gICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICBiaXRzICs9IDg7XG4gICAgICB9XG4gICAgICAvLz09PS8vXG4gICAgICBpZiAoKGhvbGQgJiAweGZmZmYpICE9PSAoKGhvbGQgPj4+IDE2KSBeIDB4ZmZmZikpIHtcbiAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBzdG9yZWQgYmxvY2sgbGVuZ3Rocyc7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgc3RhdGUubGVuZ3RoID0gaG9sZCAmIDB4ZmZmZjtcbiAgICAgIC8vVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgICAgc3RvcmVkIGxlbmd0aCAldVxcblwiLFxuICAgICAgLy8gICAgICAgIHN0YXRlLmxlbmd0aCkpO1xuICAgICAgLy89PT0gSU5JVEJJVFMoKTtcbiAgICAgIGhvbGQgPSAwO1xuICAgICAgYml0cyA9IDA7XG4gICAgICAvLz09PS8vXG4gICAgICBzdGF0ZS5tb2RlID0gQ09QWV87XG4gICAgICBpZiAoZmx1c2ggPT09IFpfVFJFRVMpIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgY2FzZSBDT1BZXzpcbiAgICAgIHN0YXRlLm1vZGUgPSBDT1BZO1xuICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgIGNhc2UgQ09QWTpcbiAgICAgIGNvcHkgPSBzdGF0ZS5sZW5ndGg7XG4gICAgICBpZiAoY29weSkge1xuICAgICAgICBpZiAoY29weSA+IGhhdmUpIHsgY29weSA9IGhhdmU7IH1cbiAgICAgICAgaWYgKGNvcHkgPiBsZWZ0KSB7IGNvcHkgPSBsZWZ0OyB9XG4gICAgICAgIGlmIChjb3B5ID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAvLy0tLSB6bWVtY3B5KHB1dCwgbmV4dCwgY29weSk7IC0tLVxuICAgICAgICB1dGlscy5hcnJheVNldChvdXRwdXQsIGlucHV0LCBuZXh0LCBjb3B5LCBwdXQpO1xuICAgICAgICAvLy0tLS8vXG4gICAgICAgIGhhdmUgLT0gY29weTtcbiAgICAgICAgbmV4dCArPSBjb3B5O1xuICAgICAgICBsZWZ0IC09IGNvcHk7XG4gICAgICAgIHB1dCArPSBjb3B5O1xuICAgICAgICBzdGF0ZS5sZW5ndGggLT0gY29weTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6ICAgICAgIHN0b3JlZCBlbmRcXG5cIikpO1xuICAgICAgc3RhdGUubW9kZSA9IFRZUEU7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFRBQkxFOlxuICAgICAgLy89PT0gTkVFREJJVFMoMTQpOyAqL1xuICAgICAgd2hpbGUgKGJpdHMgPCAxNCkge1xuICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgaGF2ZS0tO1xuICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgYml0cyArPSA4O1xuICAgICAgfVxuICAgICAgLy89PT0vL1xuICAgICAgc3RhdGUubmxlbiA9IChob2xkICYgMHgxZikvKkJJVFMoNSkqLyArIDI1NztcbiAgICAgIC8vLS0tIERST1BCSVRTKDUpIC0tLS8vXG4gICAgICBob2xkID4+Pj0gNTtcbiAgICAgIGJpdHMgLT0gNTtcbiAgICAgIC8vLS0tLy9cbiAgICAgIHN0YXRlLm5kaXN0ID0gKGhvbGQgJiAweDFmKS8qQklUUyg1KSovICsgMTtcbiAgICAgIC8vLS0tIERST1BCSVRTKDUpIC0tLS8vXG4gICAgICBob2xkID4+Pj0gNTtcbiAgICAgIGJpdHMgLT0gNTtcbiAgICAgIC8vLS0tLy9cbiAgICAgIHN0YXRlLm5jb2RlID0gKGhvbGQgJiAweDBmKS8qQklUUyg0KSovICsgNDtcbiAgICAgIC8vLS0tIERST1BCSVRTKDQpIC0tLS8vXG4gICAgICBob2xkID4+Pj0gNDtcbiAgICAgIGJpdHMgLT0gNDtcbiAgICAgIC8vLS0tLy9cbi8vI2lmbmRlZiBQS1pJUF9CVUdfV09SS0FST1VORFxuICAgICAgaWYgKHN0YXRlLm5sZW4gPiAyODYgfHwgc3RhdGUubmRpc3QgPiAzMCkge1xuICAgICAgICBzdHJtLm1zZyA9ICd0b28gbWFueSBsZW5ndGggb3IgZGlzdGFuY2Ugc3ltYm9scyc7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuLy8jZW5kaWZcbiAgICAgIC8vVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgICAgdGFibGUgc2l6ZXMgb2tcXG5cIikpO1xuICAgICAgc3RhdGUuaGF2ZSA9IDA7XG4gICAgICBzdGF0ZS5tb2RlID0gTEVOTEVOUztcbiAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICBjYXNlIExFTkxFTlM6XG4gICAgICB3aGlsZSAoc3RhdGUuaGF2ZSA8IHN0YXRlLm5jb2RlKSB7XG4gICAgICAgIC8vPT09IE5FRURCSVRTKDMpO1xuICAgICAgICB3aGlsZSAoYml0cyA8IDMpIHtcbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICB9XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgc3RhdGUubGVuc1tvcmRlcltzdGF0ZS5oYXZlKytdXSA9IChob2xkICYgMHgwNyk7Ly9CSVRTKDMpO1xuICAgICAgICAvLy0tLSBEUk9QQklUUygzKSAtLS0vL1xuICAgICAgICBob2xkID4+Pj0gMztcbiAgICAgICAgYml0cyAtPSAzO1xuICAgICAgICAvLy0tLS8vXG4gICAgICB9XG4gICAgICB3aGlsZSAoc3RhdGUuaGF2ZSA8IDE5KSB7XG4gICAgICAgIHN0YXRlLmxlbnNbb3JkZXJbc3RhdGUuaGF2ZSsrXV0gPSAwO1xuICAgICAgfVxuICAgICAgLy8gV2UgaGF2ZSBzZXBhcmF0ZSB0YWJsZXMgJiBubyBwb2ludGVycy4gMiBjb21tZW50ZWQgbGluZXMgYmVsb3cgbm90IG5lZWRlZC5cbiAgICAgIC8vc3RhdGUubmV4dCA9IHN0YXRlLmNvZGVzO1xuICAgICAgLy9zdGF0ZS5sZW5jb2RlID0gc3RhdGUubmV4dDtcbiAgICAgIC8vIFN3aXRjaCB0byB1c2UgZHluYW1pYyB0YWJsZVxuICAgICAgc3RhdGUubGVuY29kZSA9IHN0YXRlLmxlbmR5bjtcbiAgICAgIHN0YXRlLmxlbmJpdHMgPSA3O1xuXG4gICAgICBvcHRzID0geyBiaXRzOiBzdGF0ZS5sZW5iaXRzIH07XG4gICAgICByZXQgPSBpbmZsYXRlX3RhYmxlKENPREVTLCBzdGF0ZS5sZW5zLCAwLCAxOSwgc3RhdGUubGVuY29kZSwgMCwgc3RhdGUud29yaywgb3B0cyk7XG4gICAgICBzdGF0ZS5sZW5iaXRzID0gb3B0cy5iaXRzO1xuXG4gICAgICBpZiAocmV0KSB7XG4gICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgY29kZSBsZW5ndGhzIHNldCc7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgICBjb2RlIGxlbmd0aHMgb2tcXG5cIikpO1xuICAgICAgc3RhdGUuaGF2ZSA9IDA7XG4gICAgICBzdGF0ZS5tb2RlID0gQ09ERUxFTlM7XG4gICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgY2FzZSBDT0RFTEVOUzpcbiAgICAgIHdoaWxlIChzdGF0ZS5oYXZlIDwgc3RhdGUubmxlbiArIHN0YXRlLm5kaXN0KSB7XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICBoZXJlID0gc3RhdGUubGVuY29kZVtob2xkICYgKCgxIDw8IHN0YXRlLmxlbmJpdHMpIC0gMSldOy8qQklUUyhzdGF0ZS5sZW5iaXRzKSovXG4gICAgICAgICAgaGVyZV9iaXRzID0gaGVyZSA+Pj4gMjQ7XG4gICAgICAgICAgaGVyZV9vcCA9IChoZXJlID4+PiAxNikgJiAweGZmO1xuICAgICAgICAgIGhlcmVfdmFsID0gaGVyZSAmIDB4ZmZmZjtcblxuICAgICAgICAgIGlmICgoaGVyZV9iaXRzKSA8PSBiaXRzKSB7IGJyZWFrOyB9XG4gICAgICAgICAgLy8tLS0gUFVMTEJZVEUoKSAtLS0vL1xuICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgLy8tLS0vL1xuICAgICAgICB9XG4gICAgICAgIGlmIChoZXJlX3ZhbCA8IDE2KSB7XG4gICAgICAgICAgLy8tLS0gRFJPUEJJVFMoaGVyZS5iaXRzKSAtLS0vL1xuICAgICAgICAgIGhvbGQgPj4+PSBoZXJlX2JpdHM7XG4gICAgICAgICAgYml0cyAtPSBoZXJlX2JpdHM7XG4gICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgIHN0YXRlLmxlbnNbc3RhdGUuaGF2ZSsrXSA9IGhlcmVfdmFsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGlmIChoZXJlX3ZhbCA9PT0gMTYpIHtcbiAgICAgICAgICAgIC8vPT09IE5FRURCSVRTKGhlcmUuYml0cyArIDIpO1xuICAgICAgICAgICAgbiA9IGhlcmVfYml0cyArIDI7XG4gICAgICAgICAgICB3aGlsZSAoYml0cyA8IG4pIHtcbiAgICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgICAgIC8vLS0tIERST1BCSVRTKGhlcmUuYml0cykgLS0tLy9cbiAgICAgICAgICAgIGhvbGQgPj4+PSBoZXJlX2JpdHM7XG4gICAgICAgICAgICBiaXRzIC09IGhlcmVfYml0cztcbiAgICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICAgIGlmIChzdGF0ZS5oYXZlID09PSAwKSB7XG4gICAgICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgYml0IGxlbmd0aCByZXBlYXQnO1xuICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxlbiA9IHN0YXRlLmxlbnNbc3RhdGUuaGF2ZSAtIDFdO1xuICAgICAgICAgICAgY29weSA9IDMgKyAoaG9sZCAmIDB4MDMpOy8vQklUUygyKTtcbiAgICAgICAgICAgIC8vLS0tIERST1BCSVRTKDIpIC0tLS8vXG4gICAgICAgICAgICBob2xkID4+Pj0gMjtcbiAgICAgICAgICAgIGJpdHMgLT0gMjtcbiAgICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAoaGVyZV92YWwgPT09IDE3KSB7XG4gICAgICAgICAgICAvLz09PSBORUVEQklUUyhoZXJlLmJpdHMgKyAzKTtcbiAgICAgICAgICAgIG4gPSBoZXJlX2JpdHMgKyAzO1xuICAgICAgICAgICAgd2hpbGUgKGJpdHMgPCBuKSB7XG4gICAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgICAvLy0tLSBEUk9QQklUUyhoZXJlLmJpdHMpIC0tLS8vXG4gICAgICAgICAgICBob2xkID4+Pj0gaGVyZV9iaXRzO1xuICAgICAgICAgICAgYml0cyAtPSBoZXJlX2JpdHM7XG4gICAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgICBsZW4gPSAwO1xuICAgICAgICAgICAgY29weSA9IDMgKyAoaG9sZCAmIDB4MDcpOy8vQklUUygzKTtcbiAgICAgICAgICAgIC8vLS0tIERST1BCSVRTKDMpIC0tLS8vXG4gICAgICAgICAgICBob2xkID4+Pj0gMztcbiAgICAgICAgICAgIGJpdHMgLT0gMztcbiAgICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLz09PSBORUVEQklUUyhoZXJlLmJpdHMgKyA3KTtcbiAgICAgICAgICAgIG4gPSBoZXJlX2JpdHMgKyA3O1xuICAgICAgICAgICAgd2hpbGUgKGJpdHMgPCBuKSB7XG4gICAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgICAvLy0tLSBEUk9QQklUUyhoZXJlLmJpdHMpIC0tLS8vXG4gICAgICAgICAgICBob2xkID4+Pj0gaGVyZV9iaXRzO1xuICAgICAgICAgICAgYml0cyAtPSBoZXJlX2JpdHM7XG4gICAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgICBsZW4gPSAwO1xuICAgICAgICAgICAgY29weSA9IDExICsgKGhvbGQgJiAweDdmKTsvL0JJVFMoNyk7XG4gICAgICAgICAgICAvLy0tLSBEUk9QQklUUyg3KSAtLS0vL1xuICAgICAgICAgICAgaG9sZCA+Pj49IDc7XG4gICAgICAgICAgICBiaXRzIC09IDc7XG4gICAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzdGF0ZS5oYXZlICsgY29weSA+IHN0YXRlLm5sZW4gKyBzdGF0ZS5uZGlzdCkge1xuICAgICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBiaXQgbGVuZ3RoIHJlcGVhdCc7XG4gICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIHdoaWxlIChjb3B5LS0pIHtcbiAgICAgICAgICAgIHN0YXRlLmxlbnNbc3RhdGUuaGF2ZSsrXSA9IGxlbjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyogaGFuZGxlIGVycm9yIGJyZWFrcyBpbiB3aGlsZSAqL1xuICAgICAgaWYgKHN0YXRlLm1vZGUgPT09IEJBRCkgeyBicmVhazsgfVxuXG4gICAgICAvKiBjaGVjayBmb3IgZW5kLW9mLWJsb2NrIGNvZGUgKGJldHRlciBoYXZlIG9uZSkgKi9cbiAgICAgIGlmIChzdGF0ZS5sZW5zWzI1Nl0gPT09IDApIHtcbiAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBjb2RlIC0tIG1pc3NpbmcgZW5kLW9mLWJsb2NrJztcbiAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIC8qIGJ1aWxkIGNvZGUgdGFibGVzIC0tIG5vdGU6IGRvIG5vdCBjaGFuZ2UgdGhlIGxlbmJpdHMgb3IgZGlzdGJpdHNcbiAgICAgICAgIHZhbHVlcyBoZXJlICg5IGFuZCA2KSB3aXRob3V0IHJlYWRpbmcgdGhlIGNvbW1lbnRzIGluIGluZnRyZWVzLmhcbiAgICAgICAgIGNvbmNlcm5pbmcgdGhlIEVOT1VHSCBjb25zdGFudHMsIHdoaWNoIGRlcGVuZCBvbiB0aG9zZSB2YWx1ZXMgKi9cbiAgICAgIHN0YXRlLmxlbmJpdHMgPSA5O1xuXG4gICAgICBvcHRzID0geyBiaXRzOiBzdGF0ZS5sZW5iaXRzIH07XG4gICAgICByZXQgPSBpbmZsYXRlX3RhYmxlKExFTlMsIHN0YXRlLmxlbnMsIDAsIHN0YXRlLm5sZW4sIHN0YXRlLmxlbmNvZGUsIDAsIHN0YXRlLndvcmssIG9wdHMpO1xuICAgICAgLy8gV2UgaGF2ZSBzZXBhcmF0ZSB0YWJsZXMgJiBubyBwb2ludGVycy4gMiBjb21tZW50ZWQgbGluZXMgYmVsb3cgbm90IG5lZWRlZC5cbiAgICAgIC8vIHN0YXRlLm5leHRfaW5kZXggPSBvcHRzLnRhYmxlX2luZGV4O1xuICAgICAgc3RhdGUubGVuYml0cyA9IG9wdHMuYml0cztcbiAgICAgIC8vIHN0YXRlLmxlbmNvZGUgPSBzdGF0ZS5uZXh0O1xuXG4gICAgICBpZiAocmV0KSB7XG4gICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgbGl0ZXJhbC9sZW5ndGhzIHNldCc7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBzdGF0ZS5kaXN0Yml0cyA9IDY7XG4gICAgICAvL3N0YXRlLmRpc3Rjb2RlLmNvcHkoc3RhdGUuY29kZXMpO1xuICAgICAgLy8gU3dpdGNoIHRvIHVzZSBkeW5hbWljIHRhYmxlXG4gICAgICBzdGF0ZS5kaXN0Y29kZSA9IHN0YXRlLmRpc3RkeW47XG4gICAgICBvcHRzID0geyBiaXRzOiBzdGF0ZS5kaXN0Yml0cyB9O1xuICAgICAgcmV0ID0gaW5mbGF0ZV90YWJsZShESVNUUywgc3RhdGUubGVucywgc3RhdGUubmxlbiwgc3RhdGUubmRpc3QsIHN0YXRlLmRpc3Rjb2RlLCAwLCBzdGF0ZS53b3JrLCBvcHRzKTtcbiAgICAgIC8vIFdlIGhhdmUgc2VwYXJhdGUgdGFibGVzICYgbm8gcG9pbnRlcnMuIDIgY29tbWVudGVkIGxpbmVzIGJlbG93IG5vdCBuZWVkZWQuXG4gICAgICAvLyBzdGF0ZS5uZXh0X2luZGV4ID0gb3B0cy50YWJsZV9pbmRleDtcbiAgICAgIHN0YXRlLmRpc3RiaXRzID0gb3B0cy5iaXRzO1xuICAgICAgLy8gc3RhdGUuZGlzdGNvZGUgPSBzdGF0ZS5uZXh0O1xuXG4gICAgICBpZiAocmV0KSB7XG4gICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgZGlzdGFuY2VzIHNldCc7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgJ2luZmxhdGU6ICAgICAgIGNvZGVzIG9rXFxuJykpO1xuICAgICAgc3RhdGUubW9kZSA9IExFTl87XG4gICAgICBpZiAoZmx1c2ggPT09IFpfVFJFRVMpIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgY2FzZSBMRU5fOlxuICAgICAgc3RhdGUubW9kZSA9IExFTjtcbiAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICBjYXNlIExFTjpcbiAgICAgIGlmIChoYXZlID49IDYgJiYgbGVmdCA+PSAyNTgpIHtcbiAgICAgICAgLy8tLS0gUkVTVE9SRSgpIC0tLVxuICAgICAgICBzdHJtLm5leHRfb3V0ID0gcHV0O1xuICAgICAgICBzdHJtLmF2YWlsX291dCA9IGxlZnQ7XG4gICAgICAgIHN0cm0ubmV4dF9pbiA9IG5leHQ7XG4gICAgICAgIHN0cm0uYXZhaWxfaW4gPSBoYXZlO1xuICAgICAgICBzdGF0ZS5ob2xkID0gaG9sZDtcbiAgICAgICAgc3RhdGUuYml0cyA9IGJpdHM7XG4gICAgICAgIC8vLS0tXG4gICAgICAgIGluZmxhdGVfZmFzdChzdHJtLCBfb3V0KTtcbiAgICAgICAgLy8tLS0gTE9BRCgpIC0tLVxuICAgICAgICBwdXQgPSBzdHJtLm5leHRfb3V0O1xuICAgICAgICBvdXRwdXQgPSBzdHJtLm91dHB1dDtcbiAgICAgICAgbGVmdCA9IHN0cm0uYXZhaWxfb3V0O1xuICAgICAgICBuZXh0ID0gc3RybS5uZXh0X2luO1xuICAgICAgICBpbnB1dCA9IHN0cm0uaW5wdXQ7XG4gICAgICAgIGhhdmUgPSBzdHJtLmF2YWlsX2luO1xuICAgICAgICBob2xkID0gc3RhdGUuaG9sZDtcbiAgICAgICAgYml0cyA9IHN0YXRlLmJpdHM7XG4gICAgICAgIC8vLS0tXG5cbiAgICAgICAgaWYgKHN0YXRlLm1vZGUgPT09IFRZUEUpIHtcbiAgICAgICAgICBzdGF0ZS5iYWNrID0gLTE7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBzdGF0ZS5iYWNrID0gMDtcbiAgICAgIGZvciAoOzspIHtcbiAgICAgICAgaGVyZSA9IHN0YXRlLmxlbmNvZGVbaG9sZCAmICgoMSA8PCBzdGF0ZS5sZW5iaXRzKSAtIDEpXTsgIC8qQklUUyhzdGF0ZS5sZW5iaXRzKSovXG4gICAgICAgIGhlcmVfYml0cyA9IGhlcmUgPj4+IDI0O1xuICAgICAgICBoZXJlX29wID0gKGhlcmUgPj4+IDE2KSAmIDB4ZmY7XG4gICAgICAgIGhlcmVfdmFsID0gaGVyZSAmIDB4ZmZmZjtcblxuICAgICAgICBpZiAoaGVyZV9iaXRzIDw9IGJpdHMpIHsgYnJlYWs7IH1cbiAgICAgICAgLy8tLS0gUFVMTEJZVEUoKSAtLS0vL1xuICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgaGF2ZS0tO1xuICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAvLy0tLS8vXG4gICAgICB9XG4gICAgICBpZiAoaGVyZV9vcCAmJiAoaGVyZV9vcCAmIDB4ZjApID09PSAwKSB7XG4gICAgICAgIGxhc3RfYml0cyA9IGhlcmVfYml0cztcbiAgICAgICAgbGFzdF9vcCA9IGhlcmVfb3A7XG4gICAgICAgIGxhc3RfdmFsID0gaGVyZV92YWw7XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICBoZXJlID0gc3RhdGUubGVuY29kZVtsYXN0X3ZhbCArXG4gICAgICAgICAgICAgICAgICAoKGhvbGQgJiAoKDEgPDwgKGxhc3RfYml0cyArIGxhc3Rfb3ApKSAtIDEpKS8qQklUUyhsYXN0LmJpdHMgKyBsYXN0Lm9wKSovID4+IGxhc3RfYml0cyldO1xuICAgICAgICAgIGhlcmVfYml0cyA9IGhlcmUgPj4+IDI0O1xuICAgICAgICAgIGhlcmVfb3AgPSAoaGVyZSA+Pj4gMTYpICYgMHhmZjtcbiAgICAgICAgICBoZXJlX3ZhbCA9IGhlcmUgJiAweGZmZmY7XG5cbiAgICAgICAgICBpZiAoKGxhc3RfYml0cyArIGhlcmVfYml0cykgPD0gYml0cykgeyBicmVhazsgfVxuICAgICAgICAgIC8vLS0tIFBVTExCWVRFKCkgLS0tLy9cbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgfVxuICAgICAgICAvLy0tLSBEUk9QQklUUyhsYXN0LmJpdHMpIC0tLS8vXG4gICAgICAgIGhvbGQgPj4+PSBsYXN0X2JpdHM7XG4gICAgICAgIGJpdHMgLT0gbGFzdF9iaXRzO1xuICAgICAgICAvLy0tLS8vXG4gICAgICAgIHN0YXRlLmJhY2sgKz0gbGFzdF9iaXRzO1xuICAgICAgfVxuICAgICAgLy8tLS0gRFJPUEJJVFMoaGVyZS5iaXRzKSAtLS0vL1xuICAgICAgaG9sZCA+Pj49IGhlcmVfYml0cztcbiAgICAgIGJpdHMgLT0gaGVyZV9iaXRzO1xuICAgICAgLy8tLS0vL1xuICAgICAgc3RhdGUuYmFjayArPSBoZXJlX2JpdHM7XG4gICAgICBzdGF0ZS5sZW5ndGggPSBoZXJlX3ZhbDtcbiAgICAgIGlmIChoZXJlX29wID09PSAwKSB7XG4gICAgICAgIC8vVHJhY2V2digoc3RkZXJyLCBoZXJlLnZhbCA+PSAweDIwICYmIGhlcmUudmFsIDwgMHg3ZiA/XG4gICAgICAgIC8vICAgICAgICBcImluZmxhdGU6ICAgICAgICAgbGl0ZXJhbCAnJWMnXFxuXCIgOlxuICAgICAgICAvLyAgICAgICAgXCJpbmZsYXRlOiAgICAgICAgIGxpdGVyYWwgMHglMDJ4XFxuXCIsIGhlcmUudmFsKSk7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBMSVQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKGhlcmVfb3AgJiAzMikge1xuICAgICAgICAvL1RyYWNldnYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgICAgIGVuZCBvZiBibG9ja1xcblwiKSk7XG4gICAgICAgIHN0YXRlLmJhY2sgPSAtMTtcbiAgICAgICAgc3RhdGUubW9kZSA9IFRZUEU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKGhlcmVfb3AgJiA2NCkge1xuICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGxpdGVyYWwvbGVuZ3RoIGNvZGUnO1xuICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHN0YXRlLmV4dHJhID0gaGVyZV9vcCAmIDE1O1xuICAgICAgc3RhdGUubW9kZSA9IExFTkVYVDtcbiAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICBjYXNlIExFTkVYVDpcbiAgICAgIGlmIChzdGF0ZS5leHRyYSkge1xuICAgICAgICAvLz09PSBORUVEQklUUyhzdGF0ZS5leHRyYSk7XG4gICAgICAgIG4gPSBzdGF0ZS5leHRyYTtcbiAgICAgICAgd2hpbGUgKGJpdHMgPCBuKSB7XG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgfVxuICAgICAgICAvLz09PS8vXG4gICAgICAgIHN0YXRlLmxlbmd0aCArPSBob2xkICYgKCgxIDw8IHN0YXRlLmV4dHJhKSAtIDEpLypCSVRTKHN0YXRlLmV4dHJhKSovO1xuICAgICAgICAvLy0tLSBEUk9QQklUUyhzdGF0ZS5leHRyYSkgLS0tLy9cbiAgICAgICAgaG9sZCA+Pj49IHN0YXRlLmV4dHJhO1xuICAgICAgICBiaXRzIC09IHN0YXRlLmV4dHJhO1xuICAgICAgICAvLy0tLS8vXG4gICAgICAgIHN0YXRlLmJhY2sgKz0gc3RhdGUuZXh0cmE7XG4gICAgICB9XG4gICAgICAvL1RyYWNldnYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgICAgIGxlbmd0aCAldVxcblwiLCBzdGF0ZS5sZW5ndGgpKTtcbiAgICAgIHN0YXRlLndhcyA9IHN0YXRlLmxlbmd0aDtcbiAgICAgIHN0YXRlLm1vZGUgPSBESVNUO1xuICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgIGNhc2UgRElTVDpcbiAgICAgIGZvciAoOzspIHtcbiAgICAgICAgaGVyZSA9IHN0YXRlLmRpc3Rjb2RlW2hvbGQgJiAoKDEgPDwgc3RhdGUuZGlzdGJpdHMpIC0gMSldOy8qQklUUyhzdGF0ZS5kaXN0Yml0cykqL1xuICAgICAgICBoZXJlX2JpdHMgPSBoZXJlID4+PiAyNDtcbiAgICAgICAgaGVyZV9vcCA9IChoZXJlID4+PiAxNikgJiAweGZmO1xuICAgICAgICBoZXJlX3ZhbCA9IGhlcmUgJiAweGZmZmY7XG5cbiAgICAgICAgaWYgKChoZXJlX2JpdHMpIDw9IGJpdHMpIHsgYnJlYWs7IH1cbiAgICAgICAgLy8tLS0gUFVMTEJZVEUoKSAtLS0vL1xuICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgaGF2ZS0tO1xuICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAvLy0tLS8vXG4gICAgICB9XG4gICAgICBpZiAoKGhlcmVfb3AgJiAweGYwKSA9PT0gMCkge1xuICAgICAgICBsYXN0X2JpdHMgPSBoZXJlX2JpdHM7XG4gICAgICAgIGxhc3Rfb3AgPSBoZXJlX29wO1xuICAgICAgICBsYXN0X3ZhbCA9IGhlcmVfdmFsO1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgaGVyZSA9IHN0YXRlLmRpc3Rjb2RlW2xhc3RfdmFsICtcbiAgICAgICAgICAgICAgICAgICgoaG9sZCAmICgoMSA8PCAobGFzdF9iaXRzICsgbGFzdF9vcCkpIC0gMSkpLypCSVRTKGxhc3QuYml0cyArIGxhc3Qub3ApKi8gPj4gbGFzdF9iaXRzKV07XG4gICAgICAgICAgaGVyZV9iaXRzID0gaGVyZSA+Pj4gMjQ7XG4gICAgICAgICAgaGVyZV9vcCA9IChoZXJlID4+PiAxNikgJiAweGZmO1xuICAgICAgICAgIGhlcmVfdmFsID0gaGVyZSAmIDB4ZmZmZjtcblxuICAgICAgICAgIGlmICgobGFzdF9iaXRzICsgaGVyZV9iaXRzKSA8PSBiaXRzKSB7IGJyZWFrOyB9XG4gICAgICAgICAgLy8tLS0gUFVMTEJZVEUoKSAtLS0vL1xuICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgLy8tLS0vL1xuICAgICAgICB9XG4gICAgICAgIC8vLS0tIERST1BCSVRTKGxhc3QuYml0cykgLS0tLy9cbiAgICAgICAgaG9sZCA+Pj49IGxhc3RfYml0cztcbiAgICAgICAgYml0cyAtPSBsYXN0X2JpdHM7XG4gICAgICAgIC8vLS0tLy9cbiAgICAgICAgc3RhdGUuYmFjayArPSBsYXN0X2JpdHM7XG4gICAgICB9XG4gICAgICAvLy0tLSBEUk9QQklUUyhoZXJlLmJpdHMpIC0tLS8vXG4gICAgICBob2xkID4+Pj0gaGVyZV9iaXRzO1xuICAgICAgYml0cyAtPSBoZXJlX2JpdHM7XG4gICAgICAvLy0tLS8vXG4gICAgICBzdGF0ZS5iYWNrICs9IGhlcmVfYml0cztcbiAgICAgIGlmIChoZXJlX29wICYgNjQpIHtcbiAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBkaXN0YW5jZSBjb2RlJztcbiAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBzdGF0ZS5vZmZzZXQgPSBoZXJlX3ZhbDtcbiAgICAgIHN0YXRlLmV4dHJhID0gKGhlcmVfb3ApICYgMTU7XG4gICAgICBzdGF0ZS5tb2RlID0gRElTVEVYVDtcbiAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICBjYXNlIERJU1RFWFQ6XG4gICAgICBpZiAoc3RhdGUuZXh0cmEpIHtcbiAgICAgICAgLy89PT0gTkVFREJJVFMoc3RhdGUuZXh0cmEpO1xuICAgICAgICBuID0gc3RhdGUuZXh0cmE7XG4gICAgICAgIHdoaWxlIChiaXRzIDwgbikge1xuICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgIH1cbiAgICAgICAgLy89PT0vL1xuICAgICAgICBzdGF0ZS5vZmZzZXQgKz0gaG9sZCAmICgoMSA8PCBzdGF0ZS5leHRyYSkgLSAxKS8qQklUUyhzdGF0ZS5leHRyYSkqLztcbiAgICAgICAgLy8tLS0gRFJPUEJJVFMoc3RhdGUuZXh0cmEpIC0tLS8vXG4gICAgICAgIGhvbGQgPj4+PSBzdGF0ZS5leHRyYTtcbiAgICAgICAgYml0cyAtPSBzdGF0ZS5leHRyYTtcbiAgICAgICAgLy8tLS0vL1xuICAgICAgICBzdGF0ZS5iYWNrICs9IHN0YXRlLmV4dHJhO1xuICAgICAgfVxuLy8jaWZkZWYgSU5GTEFURV9TVFJJQ1RcbiAgICAgIGlmIChzdGF0ZS5vZmZzZXQgPiBzdGF0ZS5kbWF4KSB7XG4gICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgZGlzdGFuY2UgdG9vIGZhciBiYWNrJztcbiAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4vLyNlbmRpZlxuICAgICAgLy9UcmFjZXZ2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgICAgICBkaXN0YW5jZSAldVxcblwiLCBzdGF0ZS5vZmZzZXQpKTtcbiAgICAgIHN0YXRlLm1vZGUgPSBNQVRDSDtcbiAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICBjYXNlIE1BVENIOlxuICAgICAgaWYgKGxlZnQgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICBjb3B5ID0gX291dCAtIGxlZnQ7XG4gICAgICBpZiAoc3RhdGUub2Zmc2V0ID4gY29weSkgeyAgICAgICAgIC8qIGNvcHkgZnJvbSB3aW5kb3cgKi9cbiAgICAgICAgY29weSA9IHN0YXRlLm9mZnNldCAtIGNvcHk7XG4gICAgICAgIGlmIChjb3B5ID4gc3RhdGUud2hhdmUpIHtcbiAgICAgICAgICBpZiAoc3RhdGUuc2FuZSkge1xuICAgICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBkaXN0YW5jZSB0b28gZmFyIGJhY2snO1xuICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbi8vICghKSBUaGlzIGJsb2NrIGlzIGRpc2FibGVkIGluIHpsaWIgZGVmYWlsdHMsXG4vLyBkb24ndCBlbmFibGUgaXQgZm9yIGJpbmFyeSBjb21wYXRpYmlsaXR5XG4vLyNpZmRlZiBJTkZMQVRFX0FMTE9XX0lOVkFMSURfRElTVEFOQ0VfVE9PRkFSX0FSUlJcbi8vICAgICAgICAgIFRyYWNlKChzdGRlcnIsIFwiaW5mbGF0ZS5jIHRvbyBmYXJcXG5cIikpO1xuLy8gICAgICAgICAgY29weSAtPSBzdGF0ZS53aGF2ZTtcbi8vICAgICAgICAgIGlmIChjb3B5ID4gc3RhdGUubGVuZ3RoKSB7IGNvcHkgPSBzdGF0ZS5sZW5ndGg7IH1cbi8vICAgICAgICAgIGlmIChjb3B5ID4gbGVmdCkgeyBjb3B5ID0gbGVmdDsgfVxuLy8gICAgICAgICAgbGVmdCAtPSBjb3B5O1xuLy8gICAgICAgICAgc3RhdGUubGVuZ3RoIC09IGNvcHk7XG4vLyAgICAgICAgICBkbyB7XG4vLyAgICAgICAgICAgIG91dHB1dFtwdXQrK10gPSAwO1xuLy8gICAgICAgICAgfSB3aGlsZSAoLS1jb3B5KTtcbi8vICAgICAgICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIHsgc3RhdGUubW9kZSA9IExFTjsgfVxuLy8gICAgICAgICAgYnJlYWs7XG4vLyNlbmRpZlxuICAgICAgICB9XG4gICAgICAgIGlmIChjb3B5ID4gc3RhdGUud25leHQpIHtcbiAgICAgICAgICBjb3B5IC09IHN0YXRlLnduZXh0O1xuICAgICAgICAgIGZyb20gPSBzdGF0ZS53c2l6ZSAtIGNvcHk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgZnJvbSA9IHN0YXRlLnduZXh0IC0gY29weTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29weSA+IHN0YXRlLmxlbmd0aCkgeyBjb3B5ID0gc3RhdGUubGVuZ3RoOyB9XG4gICAgICAgIGZyb21fc291cmNlID0gc3RhdGUud2luZG93O1xuICAgICAgfVxuICAgICAgZWxzZSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogY29weSBmcm9tIG91dHB1dCAqL1xuICAgICAgICBmcm9tX3NvdXJjZSA9IG91dHB1dDtcbiAgICAgICAgZnJvbSA9IHB1dCAtIHN0YXRlLm9mZnNldDtcbiAgICAgICAgY29weSA9IHN0YXRlLmxlbmd0aDtcbiAgICAgIH1cbiAgICAgIGlmIChjb3B5ID4gbGVmdCkgeyBjb3B5ID0gbGVmdDsgfVxuICAgICAgbGVmdCAtPSBjb3B5O1xuICAgICAgc3RhdGUubGVuZ3RoIC09IGNvcHk7XG4gICAgICBkbyB7XG4gICAgICAgIG91dHB1dFtwdXQrK10gPSBmcm9tX3NvdXJjZVtmcm9tKytdO1xuICAgICAgfSB3aGlsZSAoLS1jb3B5KTtcbiAgICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIHsgc3RhdGUubW9kZSA9IExFTjsgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSBMSVQ6XG4gICAgICBpZiAobGVmdCA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgIG91dHB1dFtwdXQrK10gPSBzdGF0ZS5sZW5ndGg7XG4gICAgICBsZWZ0LS07XG4gICAgICBzdGF0ZS5tb2RlID0gTEVOO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBDSEVDSzpcbiAgICAgIGlmIChzdGF0ZS53cmFwKSB7XG4gICAgICAgIC8vPT09IE5FRURCSVRTKDMyKTtcbiAgICAgICAgd2hpbGUgKGJpdHMgPCAzMikge1xuICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICAvLyBVc2UgJ3wnIGluc2RlYWQgb2YgJysnIHRvIG1ha2Ugc3VyZSB0aGF0IHJlc3VsdCBpcyBzaWduZWRcbiAgICAgICAgICBob2xkIHw9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgIH1cbiAgICAgICAgLy89PT0vL1xuICAgICAgICBfb3V0IC09IGxlZnQ7XG4gICAgICAgIHN0cm0udG90YWxfb3V0ICs9IF9vdXQ7XG4gICAgICAgIHN0YXRlLnRvdGFsICs9IF9vdXQ7XG4gICAgICAgIGlmIChfb3V0KSB7XG4gICAgICAgICAgc3RybS5hZGxlciA9IHN0YXRlLmNoZWNrID1cbiAgICAgICAgICAgICAgLypVUERBVEUoc3RhdGUuY2hlY2ssIHB1dCAtIF9vdXQsIF9vdXQpOyovXG4gICAgICAgICAgICAgIChzdGF0ZS5mbGFncyA/IGNyYzMyKHN0YXRlLmNoZWNrLCBvdXRwdXQsIF9vdXQsIHB1dCAtIF9vdXQpIDogYWRsZXIzMihzdGF0ZS5jaGVjaywgb3V0cHV0LCBfb3V0LCBwdXQgLSBfb3V0KSk7XG5cbiAgICAgICAgfVxuICAgICAgICBfb3V0ID0gbGVmdDtcbiAgICAgICAgLy8gTkI6IGNyYzMyIHN0b3JlZCBhcyBzaWduZWQgMzItYml0IGludCwgenN3YXAzMiByZXR1cm5zIHNpZ25lZCB0b29cbiAgICAgICAgaWYgKChzdGF0ZS5mbGFncyA/IGhvbGQgOiB6c3dhcDMyKGhvbGQpKSAhPT0gc3RhdGUuY2hlY2spIHtcbiAgICAgICAgICBzdHJtLm1zZyA9ICdpbmNvcnJlY3QgZGF0YSBjaGVjayc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICAvLz09PSBJTklUQklUUygpO1xuICAgICAgICBob2xkID0gMDtcbiAgICAgICAgYml0cyA9IDA7XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgIGNoZWNrIG1hdGNoZXMgdHJhaWxlclxcblwiKSk7XG4gICAgICB9XG4gICAgICBzdGF0ZS5tb2RlID0gTEVOR1RIO1xuICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgIGNhc2UgTEVOR1RIOlxuICAgICAgaWYgKHN0YXRlLndyYXAgJiYgc3RhdGUuZmxhZ3MpIHtcbiAgICAgICAgLy89PT0gTkVFREJJVFMoMzIpO1xuICAgICAgICB3aGlsZSAoYml0cyA8IDMyKSB7XG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgfVxuICAgICAgICAvLz09PS8vXG4gICAgICAgIGlmIChob2xkICE9PSAoc3RhdGUudG90YWwgJiAweGZmZmZmZmZmKSkge1xuICAgICAgICAgIHN0cm0ubXNnID0gJ2luY29ycmVjdCBsZW5ndGggY2hlY2snO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgLy89PT0gSU5JVEJJVFMoKTtcbiAgICAgICAgaG9sZCA9IDA7XG4gICAgICAgIGJpdHMgPSAwO1xuICAgICAgICAvLz09PS8vXG4gICAgICAgIC8vVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogICBsZW5ndGggbWF0Y2hlcyB0cmFpbGVyXFxuXCIpKTtcbiAgICAgIH1cbiAgICAgIHN0YXRlLm1vZGUgPSBET05FO1xuICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgIGNhc2UgRE9ORTpcbiAgICAgIHJldCA9IFpfU1RSRUFNX0VORDtcbiAgICAgIGJyZWFrIGluZl9sZWF2ZTtcbiAgICBjYXNlIEJBRDpcbiAgICAgIHJldCA9IFpfREFUQV9FUlJPUjtcbiAgICAgIGJyZWFrIGluZl9sZWF2ZTtcbiAgICBjYXNlIE1FTTpcbiAgICAgIHJldHVybiBaX01FTV9FUlJPUjtcbiAgICBjYXNlIFNZTkM6XG4gICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjtcbiAgICB9XG4gIH1cblxuICAvLyBpbmZfbGVhdmUgPC0gaGVyZSBpcyByZWFsIHBsYWNlIGZvciBcImdvdG8gaW5mX2xlYXZlXCIsIGVtdWxhdGVkIHZpYSBcImJyZWFrIGluZl9sZWF2ZVwiXG5cbiAgLypcbiAgICAgUmV0dXJuIGZyb20gaW5mbGF0ZSgpLCB1cGRhdGluZyB0aGUgdG90YWwgY291bnRzIGFuZCB0aGUgY2hlY2sgdmFsdWUuXG4gICAgIElmIHRoZXJlIHdhcyBubyBwcm9ncmVzcyBkdXJpbmcgdGhlIGluZmxhdGUoKSBjYWxsLCByZXR1cm4gYSBidWZmZXJcbiAgICAgZXJyb3IuICBDYWxsIHVwZGF0ZXdpbmRvdygpIHRvIGNyZWF0ZSBhbmQvb3IgdXBkYXRlIHRoZSB3aW5kb3cgc3RhdGUuXG4gICAgIE5vdGU6IGEgbWVtb3J5IGVycm9yIGZyb20gaW5mbGF0ZSgpIGlzIG5vbi1yZWNvdmVyYWJsZS5cbiAgICovXG5cbiAgLy8tLS0gUkVTVE9SRSgpIC0tLVxuICBzdHJtLm5leHRfb3V0ID0gcHV0O1xuICBzdHJtLmF2YWlsX291dCA9IGxlZnQ7XG4gIHN0cm0ubmV4dF9pbiA9IG5leHQ7XG4gIHN0cm0uYXZhaWxfaW4gPSBoYXZlO1xuICBzdGF0ZS5ob2xkID0gaG9sZDtcbiAgc3RhdGUuYml0cyA9IGJpdHM7XG4gIC8vLS0tXG5cbiAgaWYgKHN0YXRlLndzaXplIHx8IChfb3V0ICE9PSBzdHJtLmF2YWlsX291dCAmJiBzdGF0ZS5tb2RlIDwgQkFEICYmXG4gICAgICAgICAgICAgICAgICAgICAgKHN0YXRlLm1vZGUgPCBDSEVDSyB8fCBmbHVzaCAhPT0gWl9GSU5JU0gpKSkge1xuICAgIGlmICh1cGRhdGV3aW5kb3coc3RybSwgc3RybS5vdXRwdXQsIHN0cm0ubmV4dF9vdXQsIF9vdXQgLSBzdHJtLmF2YWlsX291dCkpIHtcbiAgICAgIHN0YXRlLm1vZGUgPSBNRU07XG4gICAgICByZXR1cm4gWl9NRU1fRVJST1I7XG4gICAgfVxuICB9XG4gIF9pbiAtPSBzdHJtLmF2YWlsX2luO1xuICBfb3V0IC09IHN0cm0uYXZhaWxfb3V0O1xuICBzdHJtLnRvdGFsX2luICs9IF9pbjtcbiAgc3RybS50b3RhbF9vdXQgKz0gX291dDtcbiAgc3RhdGUudG90YWwgKz0gX291dDtcbiAgaWYgKHN0YXRlLndyYXAgJiYgX291dCkge1xuICAgIHN0cm0uYWRsZXIgPSBzdGF0ZS5jaGVjayA9IC8qVVBEQVRFKHN0YXRlLmNoZWNrLCBzdHJtLm5leHRfb3V0IC0gX291dCwgX291dCk7Ki9cbiAgICAgIChzdGF0ZS5mbGFncyA/IGNyYzMyKHN0YXRlLmNoZWNrLCBvdXRwdXQsIF9vdXQsIHN0cm0ubmV4dF9vdXQgLSBfb3V0KSA6IGFkbGVyMzIoc3RhdGUuY2hlY2ssIG91dHB1dCwgX291dCwgc3RybS5uZXh0X291dCAtIF9vdXQpKTtcbiAgfVxuICBzdHJtLmRhdGFfdHlwZSA9IHN0YXRlLmJpdHMgKyAoc3RhdGUubGFzdCA/IDY0IDogMCkgK1xuICAgICAgICAgICAgICAgICAgICAoc3RhdGUubW9kZSA9PT0gVFlQRSA/IDEyOCA6IDApICtcbiAgICAgICAgICAgICAgICAgICAgKHN0YXRlLm1vZGUgPT09IExFTl8gfHwgc3RhdGUubW9kZSA9PT0gQ09QWV8gPyAyNTYgOiAwKTtcbiAgaWYgKCgoX2luID09PSAwICYmIF9vdXQgPT09IDApIHx8IGZsdXNoID09PSBaX0ZJTklTSCkgJiYgcmV0ID09PSBaX09LKSB7XG4gICAgcmV0ID0gWl9CVUZfRVJST1I7XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gaW5mbGF0ZUVuZChzdHJtKSB7XG5cbiAgaWYgKCFzdHJtIHx8ICFzdHJtLnN0YXRlIC8qfHwgc3RybS0+emZyZWUgPT0gKGZyZWVfZnVuYykwKi8pIHtcbiAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7XG4gIH1cblxuICB2YXIgc3RhdGUgPSBzdHJtLnN0YXRlO1xuICBpZiAoc3RhdGUud2luZG93KSB7XG4gICAgc3RhdGUud2luZG93ID0gbnVsbDtcbiAgfVxuICBzdHJtLnN0YXRlID0gbnVsbDtcbiAgcmV0dXJuIFpfT0s7XG59XG5cbmZ1bmN0aW9uIGluZmxhdGVHZXRIZWFkZXIoc3RybSwgaGVhZCkge1xuICB2YXIgc3RhdGU7XG5cbiAgLyogY2hlY2sgc3RhdGUgKi9cbiAgaWYgKCFzdHJtIHx8ICFzdHJtLnN0YXRlKSB7IHJldHVybiBaX1NUUkVBTV9FUlJPUjsgfVxuICBzdGF0ZSA9IHN0cm0uc3RhdGU7XG4gIGlmICgoc3RhdGUud3JhcCAmIDIpID09PSAwKSB7IHJldHVybiBaX1NUUkVBTV9FUlJPUjsgfVxuXG4gIC8qIHNhdmUgaGVhZGVyIHN0cnVjdHVyZSAqL1xuICBzdGF0ZS5oZWFkID0gaGVhZDtcbiAgaGVhZC5kb25lID0gZmFsc2U7XG4gIHJldHVybiBaX09LO1xufVxuXG5mdW5jdGlvbiBpbmZsYXRlU2V0RGljdGlvbmFyeShzdHJtLCBkaWN0aW9uYXJ5KSB7XG4gIHZhciBkaWN0TGVuZ3RoID0gZGljdGlvbmFyeS5sZW5ndGg7XG5cbiAgdmFyIHN0YXRlO1xuICB2YXIgZGljdGlkO1xuICB2YXIgcmV0O1xuXG4gIC8qIGNoZWNrIHN0YXRlICovXG4gIGlmICghc3RybSAvKiA9PSBaX05VTEwgKi8gfHwgIXN0cm0uc3RhdGUgLyogPT0gWl9OVUxMICovKSB7IHJldHVybiBaX1NUUkVBTV9FUlJPUjsgfVxuICBzdGF0ZSA9IHN0cm0uc3RhdGU7XG5cbiAgaWYgKHN0YXRlLndyYXAgIT09IDAgJiYgc3RhdGUubW9kZSAhPT0gRElDVCkge1xuICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjtcbiAgfVxuXG4gIC8qIGNoZWNrIGZvciBjb3JyZWN0IGRpY3Rpb25hcnkgaWRlbnRpZmllciAqL1xuICBpZiAoc3RhdGUubW9kZSA9PT0gRElDVCkge1xuICAgIGRpY3RpZCA9IDE7IC8qIGFkbGVyMzIoMCwgbnVsbCwgMCkqL1xuICAgIC8qIGRpY3RpZCA9IGFkbGVyMzIoZGljdGlkLCBkaWN0aW9uYXJ5LCBkaWN0TGVuZ3RoKTsgKi9cbiAgICBkaWN0aWQgPSBhZGxlcjMyKGRpY3RpZCwgZGljdGlvbmFyeSwgZGljdExlbmd0aCwgMCk7XG4gICAgaWYgKGRpY3RpZCAhPT0gc3RhdGUuY2hlY2spIHtcbiAgICAgIHJldHVybiBaX0RBVEFfRVJST1I7XG4gICAgfVxuICB9XG4gIC8qIGNvcHkgZGljdGlvbmFyeSB0byB3aW5kb3cgdXNpbmcgdXBkYXRld2luZG93KCksIHdoaWNoIHdpbGwgYW1lbmQgdGhlXG4gICBleGlzdGluZyBkaWN0aW9uYXJ5IGlmIGFwcHJvcHJpYXRlICovXG4gIHJldCA9IHVwZGF0ZXdpbmRvdyhzdHJtLCBkaWN0aW9uYXJ5LCBkaWN0TGVuZ3RoLCBkaWN0TGVuZ3RoKTtcbiAgaWYgKHJldCkge1xuICAgIHN0YXRlLm1vZGUgPSBNRU07XG4gICAgcmV0dXJuIFpfTUVNX0VSUk9SO1xuICB9XG4gIHN0YXRlLmhhdmVkaWN0ID0gMTtcbiAgLy8gVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogICBkaWN0aW9uYXJ5IHNldFxcblwiKSk7XG4gIHJldHVybiBaX09LO1xufVxuXG5leHBvcnRzLmluZmxhdGVSZXNldCA9IGluZmxhdGVSZXNldDtcbmV4cG9ydHMuaW5mbGF0ZVJlc2V0MiA9IGluZmxhdGVSZXNldDI7XG5leHBvcnRzLmluZmxhdGVSZXNldEtlZXAgPSBpbmZsYXRlUmVzZXRLZWVwO1xuZXhwb3J0cy5pbmZsYXRlSW5pdCA9IGluZmxhdGVJbml0O1xuZXhwb3J0cy5pbmZsYXRlSW5pdDIgPSBpbmZsYXRlSW5pdDI7XG5leHBvcnRzLmluZmxhdGUgPSBpbmZsYXRlO1xuZXhwb3J0cy5pbmZsYXRlRW5kID0gaW5mbGF0ZUVuZDtcbmV4cG9ydHMuaW5mbGF0ZUdldEhlYWRlciA9IGluZmxhdGVHZXRIZWFkZXI7XG5leHBvcnRzLmluZmxhdGVTZXREaWN0aW9uYXJ5ID0gaW5mbGF0ZVNldERpY3Rpb25hcnk7XG5leHBvcnRzLmluZmxhdGVJbmZvID0gJ3Bha28gaW5mbGF0ZSAoZnJvbSBOb2RlY2EgcHJvamVjdCknO1xuXG4vKiBOb3QgaW1wbGVtZW50ZWRcbmV4cG9ydHMuaW5mbGF0ZUNvcHkgPSBpbmZsYXRlQ29weTtcbmV4cG9ydHMuaW5mbGF0ZUdldERpY3Rpb25hcnkgPSBpbmZsYXRlR2V0RGljdGlvbmFyeTtcbmV4cG9ydHMuaW5mbGF0ZU1hcmsgPSBpbmZsYXRlTWFyaztcbmV4cG9ydHMuaW5mbGF0ZVByaW1lID0gaW5mbGF0ZVByaW1lO1xuZXhwb3J0cy5pbmZsYXRlU3luYyA9IGluZmxhdGVTeW5jO1xuZXhwb3J0cy5pbmZsYXRlU3luY1BvaW50ID0gaW5mbGF0ZVN5bmNQb2ludDtcbmV4cG9ydHMuaW5mbGF0ZVVuZGVybWluZSA9IGluZmxhdGVVbmRlcm1pbmU7XG4qL1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzL2NvbW1vbicpO1xuXG52YXIgTUFYQklUUyA9IDE1O1xudmFyIEVOT1VHSF9MRU5TID0gODUyO1xudmFyIEVOT1VHSF9ESVNUUyA9IDU5Mjtcbi8vdmFyIEVOT1VHSCA9IChFTk9VR0hfTEVOUytFTk9VR0hfRElTVFMpO1xuXG52YXIgQ09ERVMgPSAwO1xudmFyIExFTlMgPSAxO1xudmFyIERJU1RTID0gMjtcblxudmFyIGxiYXNlID0gWyAvKiBMZW5ndGggY29kZXMgMjU3Li4yODUgYmFzZSAqL1xuICAzLCA0LCA1LCA2LCA3LCA4LCA5LCAxMCwgMTEsIDEzLCAxNSwgMTcsIDE5LCAyMywgMjcsIDMxLFxuICAzNSwgNDMsIDUxLCA1OSwgNjcsIDgzLCA5OSwgMTE1LCAxMzEsIDE2MywgMTk1LCAyMjcsIDI1OCwgMCwgMFxuXTtcblxudmFyIGxleHQgPSBbIC8qIExlbmd0aCBjb2RlcyAyNTcuLjI4NSBleHRyYSAqL1xuICAxNiwgMTYsIDE2LCAxNiwgMTYsIDE2LCAxNiwgMTYsIDE3LCAxNywgMTcsIDE3LCAxOCwgMTgsIDE4LCAxOCxcbiAgMTksIDE5LCAxOSwgMTksIDIwLCAyMCwgMjAsIDIwLCAyMSwgMjEsIDIxLCAyMSwgMTYsIDcyLCA3OFxuXTtcblxudmFyIGRiYXNlID0gWyAvKiBEaXN0YW5jZSBjb2RlcyAwLi4yOSBiYXNlICovXG4gIDEsIDIsIDMsIDQsIDUsIDcsIDksIDEzLCAxNywgMjUsIDMzLCA0OSwgNjUsIDk3LCAxMjksIDE5MyxcbiAgMjU3LCAzODUsIDUxMywgNzY5LCAxMDI1LCAxNTM3LCAyMDQ5LCAzMDczLCA0MDk3LCA2MTQ1LFxuICA4MTkzLCAxMjI4OSwgMTYzODUsIDI0NTc3LCAwLCAwXG5dO1xuXG52YXIgZGV4dCA9IFsgLyogRGlzdGFuY2UgY29kZXMgMC4uMjkgZXh0cmEgKi9cbiAgMTYsIDE2LCAxNiwgMTYsIDE3LCAxNywgMTgsIDE4LCAxOSwgMTksIDIwLCAyMCwgMjEsIDIxLCAyMiwgMjIsXG4gIDIzLCAyMywgMjQsIDI0LCAyNSwgMjUsIDI2LCAyNiwgMjcsIDI3LFxuICAyOCwgMjgsIDI5LCAyOSwgNjQsIDY0XG5dO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluZmxhdGVfdGFibGUodHlwZSwgbGVucywgbGVuc19pbmRleCwgY29kZXMsIHRhYmxlLCB0YWJsZV9pbmRleCwgd29yaywgb3B0cylcbntcbiAgdmFyIGJpdHMgPSBvcHRzLmJpdHM7XG4gICAgICAvL2hlcmUgPSBvcHRzLmhlcmU7IC8qIHRhYmxlIGVudHJ5IGZvciBkdXBsaWNhdGlvbiAqL1xuXG4gIHZhciBsZW4gPSAwOyAgICAgICAgICAgICAgIC8qIGEgY29kZSdzIGxlbmd0aCBpbiBiaXRzICovXG4gIHZhciBzeW0gPSAwOyAgICAgICAgICAgICAgIC8qIGluZGV4IG9mIGNvZGUgc3ltYm9scyAqL1xuICB2YXIgbWluID0gMCwgbWF4ID0gMDsgICAgICAgICAgLyogbWluaW11bSBhbmQgbWF4aW11bSBjb2RlIGxlbmd0aHMgKi9cbiAgdmFyIHJvb3QgPSAwOyAgICAgICAgICAgICAgLyogbnVtYmVyIG9mIGluZGV4IGJpdHMgZm9yIHJvb3QgdGFibGUgKi9cbiAgdmFyIGN1cnIgPSAwOyAgICAgICAgICAgICAgLyogbnVtYmVyIG9mIGluZGV4IGJpdHMgZm9yIGN1cnJlbnQgdGFibGUgKi9cbiAgdmFyIGRyb3AgPSAwOyAgICAgICAgICAgICAgLyogY29kZSBiaXRzIHRvIGRyb3AgZm9yIHN1Yi10YWJsZSAqL1xuICB2YXIgbGVmdCA9IDA7ICAgICAgICAgICAgICAgICAgIC8qIG51bWJlciBvZiBwcmVmaXggY29kZXMgYXZhaWxhYmxlICovXG4gIHZhciB1c2VkID0gMDsgICAgICAgICAgICAgIC8qIGNvZGUgZW50cmllcyBpbiB0YWJsZSB1c2VkICovXG4gIHZhciBodWZmID0gMDsgICAgICAgICAgICAgIC8qIEh1ZmZtYW4gY29kZSAqL1xuICB2YXIgaW5jcjsgICAgICAgICAgICAgIC8qIGZvciBpbmNyZW1lbnRpbmcgY29kZSwgaW5kZXggKi9cbiAgdmFyIGZpbGw7ICAgICAgICAgICAgICAvKiBpbmRleCBmb3IgcmVwbGljYXRpbmcgZW50cmllcyAqL1xuICB2YXIgbG93OyAgICAgICAgICAgICAgIC8qIGxvdyBiaXRzIGZvciBjdXJyZW50IHJvb3QgZW50cnkgKi9cbiAgdmFyIG1hc2s7ICAgICAgICAgICAgICAvKiBtYXNrIGZvciBsb3cgcm9vdCBiaXRzICovXG4gIHZhciBuZXh0OyAgICAgICAgICAgICAvKiBuZXh0IGF2YWlsYWJsZSBzcGFjZSBpbiB0YWJsZSAqL1xuICB2YXIgYmFzZSA9IG51bGw7ICAgICAvKiBiYXNlIHZhbHVlIHRhYmxlIHRvIHVzZSAqL1xuICB2YXIgYmFzZV9pbmRleCA9IDA7XG4vLyAgdmFyIHNob2V4dHJhOyAgICAvKiBleHRyYSBiaXRzIHRhYmxlIHRvIHVzZSAqL1xuICB2YXIgZW5kOyAgICAgICAgICAgICAgICAgICAgLyogdXNlIGJhc2UgYW5kIGV4dHJhIGZvciBzeW1ib2wgPiBlbmQgKi9cbiAgdmFyIGNvdW50ID0gbmV3IHV0aWxzLkJ1ZjE2KE1BWEJJVFMgKyAxKTsgLy9bTUFYQklUUysxXTsgICAgLyogbnVtYmVyIG9mIGNvZGVzIG9mIGVhY2ggbGVuZ3RoICovXG4gIHZhciBvZmZzID0gbmV3IHV0aWxzLkJ1ZjE2KE1BWEJJVFMgKyAxKTsgLy9bTUFYQklUUysxXTsgICAgIC8qIG9mZnNldHMgaW4gdGFibGUgZm9yIGVhY2ggbGVuZ3RoICovXG4gIHZhciBleHRyYSA9IG51bGw7XG4gIHZhciBleHRyYV9pbmRleCA9IDA7XG5cbiAgdmFyIGhlcmVfYml0cywgaGVyZV9vcCwgaGVyZV92YWw7XG5cbiAgLypcbiAgIFByb2Nlc3MgYSBzZXQgb2YgY29kZSBsZW5ndGhzIHRvIGNyZWF0ZSBhIGNhbm9uaWNhbCBIdWZmbWFuIGNvZGUuICBUaGVcbiAgIGNvZGUgbGVuZ3RocyBhcmUgbGVuc1swLi5jb2Rlcy0xXS4gIEVhY2ggbGVuZ3RoIGNvcnJlc3BvbmRzIHRvIHRoZVxuICAgc3ltYm9scyAwLi5jb2Rlcy0xLiAgVGhlIEh1ZmZtYW4gY29kZSBpcyBnZW5lcmF0ZWQgYnkgZmlyc3Qgc29ydGluZyB0aGVcbiAgIHN5bWJvbHMgYnkgbGVuZ3RoIGZyb20gc2hvcnQgdG8gbG9uZywgYW5kIHJldGFpbmluZyB0aGUgc3ltYm9sIG9yZGVyXG4gICBmb3IgY29kZXMgd2l0aCBlcXVhbCBsZW5ndGhzLiAgVGhlbiB0aGUgY29kZSBzdGFydHMgd2l0aCBhbGwgemVybyBiaXRzXG4gICBmb3IgdGhlIGZpcnN0IGNvZGUgb2YgdGhlIHNob3J0ZXN0IGxlbmd0aCwgYW5kIHRoZSBjb2RlcyBhcmUgaW50ZWdlclxuICAgaW5jcmVtZW50cyBmb3IgdGhlIHNhbWUgbGVuZ3RoLCBhbmQgemVyb3MgYXJlIGFwcGVuZGVkIGFzIHRoZSBsZW5ndGhcbiAgIGluY3JlYXNlcy4gIEZvciB0aGUgZGVmbGF0ZSBmb3JtYXQsIHRoZXNlIGJpdHMgYXJlIHN0b3JlZCBiYWNrd2FyZHNcbiAgIGZyb20gdGhlaXIgbW9yZSBuYXR1cmFsIGludGVnZXIgaW5jcmVtZW50IG9yZGVyaW5nLCBhbmQgc28gd2hlbiB0aGVcbiAgIGRlY29kaW5nIHRhYmxlcyBhcmUgYnVpbHQgaW4gdGhlIGxhcmdlIGxvb3AgYmVsb3csIHRoZSBpbnRlZ2VyIGNvZGVzXG4gICBhcmUgaW5jcmVtZW50ZWQgYmFja3dhcmRzLlxuXG4gICBUaGlzIHJvdXRpbmUgYXNzdW1lcywgYnV0IGRvZXMgbm90IGNoZWNrLCB0aGF0IGFsbCBvZiB0aGUgZW50cmllcyBpblxuICAgbGVuc1tdIGFyZSBpbiB0aGUgcmFuZ2UgMC4uTUFYQklUUy4gIFRoZSBjYWxsZXIgbXVzdCBhc3N1cmUgdGhpcy5cbiAgIDEuLk1BWEJJVFMgaXMgaW50ZXJwcmV0ZWQgYXMgdGhhdCBjb2RlIGxlbmd0aC4gIHplcm8gbWVhbnMgdGhhdCB0aGF0XG4gICBzeW1ib2wgZG9lcyBub3Qgb2NjdXIgaW4gdGhpcyBjb2RlLlxuXG4gICBUaGUgY29kZXMgYXJlIHNvcnRlZCBieSBjb21wdXRpbmcgYSBjb3VudCBvZiBjb2RlcyBmb3IgZWFjaCBsZW5ndGgsXG4gICBjcmVhdGluZyBmcm9tIHRoYXQgYSB0YWJsZSBvZiBzdGFydGluZyBpbmRpY2VzIGZvciBlYWNoIGxlbmd0aCBpbiB0aGVcbiAgIHNvcnRlZCB0YWJsZSwgYW5kIHRoZW4gZW50ZXJpbmcgdGhlIHN5bWJvbHMgaW4gb3JkZXIgaW4gdGhlIHNvcnRlZFxuICAgdGFibGUuICBUaGUgc29ydGVkIHRhYmxlIGlzIHdvcmtbXSwgd2l0aCB0aGF0IHNwYWNlIGJlaW5nIHByb3ZpZGVkIGJ5XG4gICB0aGUgY2FsbGVyLlxuXG4gICBUaGUgbGVuZ3RoIGNvdW50cyBhcmUgdXNlZCBmb3Igb3RoZXIgcHVycG9zZXMgYXMgd2VsbCwgaS5lLiBmaW5kaW5nXG4gICB0aGUgbWluaW11bSBhbmQgbWF4aW11bSBsZW5ndGggY29kZXMsIGRldGVybWluaW5nIGlmIHRoZXJlIGFyZSBhbnlcbiAgIGNvZGVzIGF0IGFsbCwgY2hlY2tpbmcgZm9yIGEgdmFsaWQgc2V0IG9mIGxlbmd0aHMsIGFuZCBsb29raW5nIGFoZWFkXG4gICBhdCBsZW5ndGggY291bnRzIHRvIGRldGVybWluZSBzdWItdGFibGUgc2l6ZXMgd2hlbiBidWlsZGluZyB0aGVcbiAgIGRlY29kaW5nIHRhYmxlcy5cbiAgICovXG5cbiAgLyogYWNjdW11bGF0ZSBsZW5ndGhzIGZvciBjb2RlcyAoYXNzdW1lcyBsZW5zW10gYWxsIGluIDAuLk1BWEJJVFMpICovXG4gIGZvciAobGVuID0gMDsgbGVuIDw9IE1BWEJJVFM7IGxlbisrKSB7XG4gICAgY291bnRbbGVuXSA9IDA7XG4gIH1cbiAgZm9yIChzeW0gPSAwOyBzeW0gPCBjb2Rlczsgc3ltKyspIHtcbiAgICBjb3VudFtsZW5zW2xlbnNfaW5kZXggKyBzeW1dXSsrO1xuICB9XG5cbiAgLyogYm91bmQgY29kZSBsZW5ndGhzLCBmb3JjZSByb290IHRvIGJlIHdpdGhpbiBjb2RlIGxlbmd0aHMgKi9cbiAgcm9vdCA9IGJpdHM7XG4gIGZvciAobWF4ID0gTUFYQklUUzsgbWF4ID49IDE7IG1heC0tKSB7XG4gICAgaWYgKGNvdW50W21heF0gIT09IDApIHsgYnJlYWs7IH1cbiAgfVxuICBpZiAocm9vdCA+IG1heCkge1xuICAgIHJvb3QgPSBtYXg7XG4gIH1cbiAgaWYgKG1heCA9PT0gMCkgeyAgICAgICAgICAgICAgICAgICAgIC8qIG5vIHN5bWJvbHMgdG8gY29kZSBhdCBhbGwgKi9cbiAgICAvL3RhYmxlLm9wW29wdHMudGFibGVfaW5kZXhdID0gNjQ7ICAvL2hlcmUub3AgPSAodmFyIGNoYXIpNjQ7ICAgIC8qIGludmFsaWQgY29kZSBtYXJrZXIgKi9cbiAgICAvL3RhYmxlLmJpdHNbb3B0cy50YWJsZV9pbmRleF0gPSAxOyAgIC8vaGVyZS5iaXRzID0gKHZhciBjaGFyKTE7XG4gICAgLy90YWJsZS52YWxbb3B0cy50YWJsZV9pbmRleCsrXSA9IDA7ICAgLy9oZXJlLnZhbCA9ICh2YXIgc2hvcnQpMDtcbiAgICB0YWJsZVt0YWJsZV9pbmRleCsrXSA9ICgxIDw8IDI0KSB8ICg2NCA8PCAxNikgfCAwO1xuXG5cbiAgICAvL3RhYmxlLm9wW29wdHMudGFibGVfaW5kZXhdID0gNjQ7XG4gICAgLy90YWJsZS5iaXRzW29wdHMudGFibGVfaW5kZXhdID0gMTtcbiAgICAvL3RhYmxlLnZhbFtvcHRzLnRhYmxlX2luZGV4KytdID0gMDtcbiAgICB0YWJsZVt0YWJsZV9pbmRleCsrXSA9ICgxIDw8IDI0KSB8ICg2NCA8PCAxNikgfCAwO1xuXG4gICAgb3B0cy5iaXRzID0gMTtcbiAgICByZXR1cm4gMDsgICAgIC8qIG5vIHN5bWJvbHMsIGJ1dCB3YWl0IGZvciBkZWNvZGluZyB0byByZXBvcnQgZXJyb3IgKi9cbiAgfVxuICBmb3IgKG1pbiA9IDE7IG1pbiA8IG1heDsgbWluKyspIHtcbiAgICBpZiAoY291bnRbbWluXSAhPT0gMCkgeyBicmVhazsgfVxuICB9XG4gIGlmIChyb290IDwgbWluKSB7XG4gICAgcm9vdCA9IG1pbjtcbiAgfVxuXG4gIC8qIGNoZWNrIGZvciBhbiBvdmVyLXN1YnNjcmliZWQgb3IgaW5jb21wbGV0ZSBzZXQgb2YgbGVuZ3RocyAqL1xuICBsZWZ0ID0gMTtcbiAgZm9yIChsZW4gPSAxOyBsZW4gPD0gTUFYQklUUzsgbGVuKyspIHtcbiAgICBsZWZ0IDw8PSAxO1xuICAgIGxlZnQgLT0gY291bnRbbGVuXTtcbiAgICBpZiAobGVmdCA8IDApIHtcbiAgICAgIHJldHVybiAtMTtcbiAgICB9ICAgICAgICAvKiBvdmVyLXN1YnNjcmliZWQgKi9cbiAgfVxuICBpZiAobGVmdCA+IDAgJiYgKHR5cGUgPT09IENPREVTIHx8IG1heCAhPT0gMSkpIHtcbiAgICByZXR1cm4gLTE7ICAgICAgICAgICAgICAgICAgICAgIC8qIGluY29tcGxldGUgc2V0ICovXG4gIH1cblxuICAvKiBnZW5lcmF0ZSBvZmZzZXRzIGludG8gc3ltYm9sIHRhYmxlIGZvciBlYWNoIGxlbmd0aCBmb3Igc29ydGluZyAqL1xuICBvZmZzWzFdID0gMDtcbiAgZm9yIChsZW4gPSAxOyBsZW4gPCBNQVhCSVRTOyBsZW4rKykge1xuICAgIG9mZnNbbGVuICsgMV0gPSBvZmZzW2xlbl0gKyBjb3VudFtsZW5dO1xuICB9XG5cbiAgLyogc29ydCBzeW1ib2xzIGJ5IGxlbmd0aCwgYnkgc3ltYm9sIG9yZGVyIHdpdGhpbiBlYWNoIGxlbmd0aCAqL1xuICBmb3IgKHN5bSA9IDA7IHN5bSA8IGNvZGVzOyBzeW0rKykge1xuICAgIGlmIChsZW5zW2xlbnNfaW5kZXggKyBzeW1dICE9PSAwKSB7XG4gICAgICB3b3JrW29mZnNbbGVuc1tsZW5zX2luZGV4ICsgc3ltXV0rK10gPSBzeW07XG4gICAgfVxuICB9XG5cbiAgLypcbiAgIENyZWF0ZSBhbmQgZmlsbCBpbiBkZWNvZGluZyB0YWJsZXMuICBJbiB0aGlzIGxvb3AsIHRoZSB0YWJsZSBiZWluZ1xuICAgZmlsbGVkIGlzIGF0IG5leHQgYW5kIGhhcyBjdXJyIGluZGV4IGJpdHMuICBUaGUgY29kZSBiZWluZyB1c2VkIGlzIGh1ZmZcbiAgIHdpdGggbGVuZ3RoIGxlbi4gIFRoYXQgY29kZSBpcyBjb252ZXJ0ZWQgdG8gYW4gaW5kZXggYnkgZHJvcHBpbmcgZHJvcFxuICAgYml0cyBvZmYgb2YgdGhlIGJvdHRvbS4gIEZvciBjb2RlcyB3aGVyZSBsZW4gaXMgbGVzcyB0aGFuIGRyb3AgKyBjdXJyLFxuICAgdGhvc2UgdG9wIGRyb3AgKyBjdXJyIC0gbGVuIGJpdHMgYXJlIGluY3JlbWVudGVkIHRocm91Z2ggYWxsIHZhbHVlcyB0b1xuICAgZmlsbCB0aGUgdGFibGUgd2l0aCByZXBsaWNhdGVkIGVudHJpZXMuXG5cbiAgIHJvb3QgaXMgdGhlIG51bWJlciBvZiBpbmRleCBiaXRzIGZvciB0aGUgcm9vdCB0YWJsZS4gIFdoZW4gbGVuIGV4Y2VlZHNcbiAgIHJvb3QsIHN1Yi10YWJsZXMgYXJlIGNyZWF0ZWQgcG9pbnRlZCB0byBieSB0aGUgcm9vdCBlbnRyeSB3aXRoIGFuIGluZGV4XG4gICBvZiB0aGUgbG93IHJvb3QgYml0cyBvZiBodWZmLiAgVGhpcyBpcyBzYXZlZCBpbiBsb3cgdG8gY2hlY2sgZm9yIHdoZW4gYVxuICAgbmV3IHN1Yi10YWJsZSBzaG91bGQgYmUgc3RhcnRlZC4gIGRyb3AgaXMgemVybyB3aGVuIHRoZSByb290IHRhYmxlIGlzXG4gICBiZWluZyBmaWxsZWQsIGFuZCBkcm9wIGlzIHJvb3Qgd2hlbiBzdWItdGFibGVzIGFyZSBiZWluZyBmaWxsZWQuXG5cbiAgIFdoZW4gYSBuZXcgc3ViLXRhYmxlIGlzIG5lZWRlZCwgaXQgaXMgbmVjZXNzYXJ5IHRvIGxvb2sgYWhlYWQgaW4gdGhlXG4gICBjb2RlIGxlbmd0aHMgdG8gZGV0ZXJtaW5lIHdoYXQgc2l6ZSBzdWItdGFibGUgaXMgbmVlZGVkLiAgVGhlIGxlbmd0aFxuICAgY291bnRzIGFyZSB1c2VkIGZvciB0aGlzLCBhbmQgc28gY291bnRbXSBpcyBkZWNyZW1lbnRlZCBhcyBjb2RlcyBhcmVcbiAgIGVudGVyZWQgaW4gdGhlIHRhYmxlcy5cblxuICAgdXNlZCBrZWVwcyB0cmFjayBvZiBob3cgbWFueSB0YWJsZSBlbnRyaWVzIGhhdmUgYmVlbiBhbGxvY2F0ZWQgZnJvbSB0aGVcbiAgIHByb3ZpZGVkICp0YWJsZSBzcGFjZS4gIEl0IGlzIGNoZWNrZWQgZm9yIExFTlMgYW5kIERJU1QgdGFibGVzIGFnYWluc3RcbiAgIHRoZSBjb25zdGFudHMgRU5PVUdIX0xFTlMgYW5kIEVOT1VHSF9ESVNUUyB0byBndWFyZCBhZ2FpbnN0IGNoYW5nZXMgaW5cbiAgIHRoZSBpbml0aWFsIHJvb3QgdGFibGUgc2l6ZSBjb25zdGFudHMuICBTZWUgdGhlIGNvbW1lbnRzIGluIGluZnRyZWVzLmhcbiAgIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuXG4gICBzeW0gaW5jcmVtZW50cyB0aHJvdWdoIGFsbCBzeW1ib2xzLCBhbmQgdGhlIGxvb3AgdGVybWluYXRlcyB3aGVuXG4gICBhbGwgY29kZXMgb2YgbGVuZ3RoIG1heCwgaS5lLiBhbGwgY29kZXMsIGhhdmUgYmVlbiBwcm9jZXNzZWQuICBUaGlzXG4gICByb3V0aW5lIHBlcm1pdHMgaW5jb21wbGV0ZSBjb2Rlcywgc28gYW5vdGhlciBsb29wIGFmdGVyIHRoaXMgb25lIGZpbGxzXG4gICBpbiB0aGUgcmVzdCBvZiB0aGUgZGVjb2RpbmcgdGFibGVzIHdpdGggaW52YWxpZCBjb2RlIG1hcmtlcnMuXG4gICAqL1xuXG4gIC8qIHNldCB1cCBmb3IgY29kZSB0eXBlICovXG4gIC8vIHBvb3IgbWFuIG9wdGltaXphdGlvbiAtIHVzZSBpZi1lbHNlIGluc3RlYWQgb2Ygc3dpdGNoLFxuICAvLyB0byBhdm9pZCBkZW9wdHMgaW4gb2xkIHY4XG4gIGlmICh0eXBlID09PSBDT0RFUykge1xuICAgIGJhc2UgPSBleHRyYSA9IHdvcms7ICAgIC8qIGR1bW15IHZhbHVlLS1ub3QgdXNlZCAqL1xuICAgIGVuZCA9IDE5O1xuXG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gTEVOUykge1xuICAgIGJhc2UgPSBsYmFzZTtcbiAgICBiYXNlX2luZGV4IC09IDI1NztcbiAgICBleHRyYSA9IGxleHQ7XG4gICAgZXh0cmFfaW5kZXggLT0gMjU3O1xuICAgIGVuZCA9IDI1NjtcblxuICB9IGVsc2UgeyAgICAgICAgICAgICAgICAgICAgLyogRElTVFMgKi9cbiAgICBiYXNlID0gZGJhc2U7XG4gICAgZXh0cmEgPSBkZXh0O1xuICAgIGVuZCA9IC0xO1xuICB9XG5cbiAgLyogaW5pdGlhbGl6ZSBvcHRzIGZvciBsb29wICovXG4gIGh1ZmYgPSAwOyAgICAgICAgICAgICAgICAgICAvKiBzdGFydGluZyBjb2RlICovXG4gIHN5bSA9IDA7ICAgICAgICAgICAgICAgICAgICAvKiBzdGFydGluZyBjb2RlIHN5bWJvbCAqL1xuICBsZW4gPSBtaW47ICAgICAgICAgICAgICAgICAgLyogc3RhcnRpbmcgY29kZSBsZW5ndGggKi9cbiAgbmV4dCA9IHRhYmxlX2luZGV4OyAgICAgICAgICAgICAgLyogY3VycmVudCB0YWJsZSB0byBmaWxsIGluICovXG4gIGN1cnIgPSByb290OyAgICAgICAgICAgICAgICAvKiBjdXJyZW50IHRhYmxlIGluZGV4IGJpdHMgKi9cbiAgZHJvcCA9IDA7ICAgICAgICAgICAgICAgICAgIC8qIGN1cnJlbnQgYml0cyB0byBkcm9wIGZyb20gY29kZSBmb3IgaW5kZXggKi9cbiAgbG93ID0gLTE7ICAgICAgICAgICAgICAgICAgIC8qIHRyaWdnZXIgbmV3IHN1Yi10YWJsZSB3aGVuIGxlbiA+IHJvb3QgKi9cbiAgdXNlZCA9IDEgPDwgcm9vdDsgICAgICAgICAgLyogdXNlIHJvb3QgdGFibGUgZW50cmllcyAqL1xuICBtYXNrID0gdXNlZCAtIDE7ICAgICAgICAgICAgLyogbWFzayBmb3IgY29tcGFyaW5nIGxvdyAqL1xuXG4gIC8qIGNoZWNrIGF2YWlsYWJsZSB0YWJsZSBzcGFjZSAqL1xuICBpZiAoKHR5cGUgPT09IExFTlMgJiYgdXNlZCA+IEVOT1VHSF9MRU5TKSB8fFxuICAgICh0eXBlID09PSBESVNUUyAmJiB1c2VkID4gRU5PVUdIX0RJU1RTKSkge1xuICAgIHJldHVybiAxO1xuICB9XG5cbiAgdmFyIGkgPSAwO1xuICAvKiBwcm9jZXNzIGFsbCBjb2RlcyBhbmQgbWFrZSB0YWJsZSBlbnRyaWVzICovXG4gIGZvciAoOzspIHtcbiAgICBpKys7XG4gICAgLyogY3JlYXRlIHRhYmxlIGVudHJ5ICovXG4gICAgaGVyZV9iaXRzID0gbGVuIC0gZHJvcDtcbiAgICBpZiAod29ya1tzeW1dIDwgZW5kKSB7XG4gICAgICBoZXJlX29wID0gMDtcbiAgICAgIGhlcmVfdmFsID0gd29ya1tzeW1dO1xuICAgIH1cbiAgICBlbHNlIGlmICh3b3JrW3N5bV0gPiBlbmQpIHtcbiAgICAgIGhlcmVfb3AgPSBleHRyYVtleHRyYV9pbmRleCArIHdvcmtbc3ltXV07XG4gICAgICBoZXJlX3ZhbCA9IGJhc2VbYmFzZV9pbmRleCArIHdvcmtbc3ltXV07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgaGVyZV9vcCA9IDMyICsgNjQ7ICAgICAgICAgLyogZW5kIG9mIGJsb2NrICovXG4gICAgICBoZXJlX3ZhbCA9IDA7XG4gICAgfVxuXG4gICAgLyogcmVwbGljYXRlIGZvciB0aG9zZSBpbmRpY2VzIHdpdGggbG93IGxlbiBiaXRzIGVxdWFsIHRvIGh1ZmYgKi9cbiAgICBpbmNyID0gMSA8PCAobGVuIC0gZHJvcCk7XG4gICAgZmlsbCA9IDEgPDwgY3VycjtcbiAgICBtaW4gPSBmaWxsOyAgICAgICAgICAgICAgICAgLyogc2F2ZSBvZmZzZXQgdG8gbmV4dCB0YWJsZSAqL1xuICAgIGRvIHtcbiAgICAgIGZpbGwgLT0gaW5jcjtcbiAgICAgIHRhYmxlW25leHQgKyAoaHVmZiA+PiBkcm9wKSArIGZpbGxdID0gKGhlcmVfYml0cyA8PCAyNCkgfCAoaGVyZV9vcCA8PCAxNikgfCBoZXJlX3ZhbCB8MDtcbiAgICB9IHdoaWxlIChmaWxsICE9PSAwKTtcblxuICAgIC8qIGJhY2t3YXJkcyBpbmNyZW1lbnQgdGhlIGxlbi1iaXQgY29kZSBodWZmICovXG4gICAgaW5jciA9IDEgPDwgKGxlbiAtIDEpO1xuICAgIHdoaWxlIChodWZmICYgaW5jcikge1xuICAgICAgaW5jciA+Pj0gMTtcbiAgICB9XG4gICAgaWYgKGluY3IgIT09IDApIHtcbiAgICAgIGh1ZmYgJj0gaW5jciAtIDE7XG4gICAgICBodWZmICs9IGluY3I7XG4gICAgfSBlbHNlIHtcbiAgICAgIGh1ZmYgPSAwO1xuICAgIH1cblxuICAgIC8qIGdvIHRvIG5leHQgc3ltYm9sLCB1cGRhdGUgY291bnQsIGxlbiAqL1xuICAgIHN5bSsrO1xuICAgIGlmICgtLWNvdW50W2xlbl0gPT09IDApIHtcbiAgICAgIGlmIChsZW4gPT09IG1heCkgeyBicmVhazsgfVxuICAgICAgbGVuID0gbGVuc1tsZW5zX2luZGV4ICsgd29ya1tzeW1dXTtcbiAgICB9XG5cbiAgICAvKiBjcmVhdGUgbmV3IHN1Yi10YWJsZSBpZiBuZWVkZWQgKi9cbiAgICBpZiAobGVuID4gcm9vdCAmJiAoaHVmZiAmIG1hc2spICE9PSBsb3cpIHtcbiAgICAgIC8qIGlmIGZpcnN0IHRpbWUsIHRyYW5zaXRpb24gdG8gc3ViLXRhYmxlcyAqL1xuICAgICAgaWYgKGRyb3AgPT09IDApIHtcbiAgICAgICAgZHJvcCA9IHJvb3Q7XG4gICAgICB9XG5cbiAgICAgIC8qIGluY3JlbWVudCBwYXN0IGxhc3QgdGFibGUgKi9cbiAgICAgIG5leHQgKz0gbWluOyAgICAgICAgICAgIC8qIGhlcmUgbWluIGlzIDEgPDwgY3VyciAqL1xuXG4gICAgICAvKiBkZXRlcm1pbmUgbGVuZ3RoIG9mIG5leHQgdGFibGUgKi9cbiAgICAgIGN1cnIgPSBsZW4gLSBkcm9wO1xuICAgICAgbGVmdCA9IDEgPDwgY3VycjtcbiAgICAgIHdoaWxlIChjdXJyICsgZHJvcCA8IG1heCkge1xuICAgICAgICBsZWZ0IC09IGNvdW50W2N1cnIgKyBkcm9wXTtcbiAgICAgICAgaWYgKGxlZnQgPD0gMCkgeyBicmVhazsgfVxuICAgICAgICBjdXJyKys7XG4gICAgICAgIGxlZnQgPDw9IDE7XG4gICAgICB9XG5cbiAgICAgIC8qIGNoZWNrIGZvciBlbm91Z2ggc3BhY2UgKi9cbiAgICAgIHVzZWQgKz0gMSA8PCBjdXJyO1xuICAgICAgaWYgKCh0eXBlID09PSBMRU5TICYmIHVzZWQgPiBFTk9VR0hfTEVOUykgfHxcbiAgICAgICAgKHR5cGUgPT09IERJU1RTICYmIHVzZWQgPiBFTk9VR0hfRElTVFMpKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgfVxuXG4gICAgICAvKiBwb2ludCBlbnRyeSBpbiByb290IHRhYmxlIHRvIHN1Yi10YWJsZSAqL1xuICAgICAgbG93ID0gaHVmZiAmIG1hc2s7XG4gICAgICAvKnRhYmxlLm9wW2xvd10gPSBjdXJyO1xuICAgICAgdGFibGUuYml0c1tsb3ddID0gcm9vdDtcbiAgICAgIHRhYmxlLnZhbFtsb3ddID0gbmV4dCAtIG9wdHMudGFibGVfaW5kZXg7Ki9cbiAgICAgIHRhYmxlW2xvd10gPSAocm9vdCA8PCAyNCkgfCAoY3VyciA8PCAxNikgfCAobmV4dCAtIHRhYmxlX2luZGV4KSB8MDtcbiAgICB9XG4gIH1cblxuICAvKiBmaWxsIGluIHJlbWFpbmluZyB0YWJsZSBlbnRyeSBpZiBjb2RlIGlzIGluY29tcGxldGUgKGd1YXJhbnRlZWQgdG8gaGF2ZVxuICAgYXQgbW9zdCBvbmUgcmVtYWluaW5nIGVudHJ5LCBzaW5jZSBpZiB0aGUgY29kZSBpcyBpbmNvbXBsZXRlLCB0aGVcbiAgIG1heGltdW0gY29kZSBsZW5ndGggdGhhdCB3YXMgYWxsb3dlZCB0byBnZXQgdGhpcyBmYXIgaXMgb25lIGJpdCkgKi9cbiAgaWYgKGh1ZmYgIT09IDApIHtcbiAgICAvL3RhYmxlLm9wW25leHQgKyBodWZmXSA9IDY0OyAgICAgICAgICAgIC8qIGludmFsaWQgY29kZSBtYXJrZXIgKi9cbiAgICAvL3RhYmxlLmJpdHNbbmV4dCArIGh1ZmZdID0gbGVuIC0gZHJvcDtcbiAgICAvL3RhYmxlLnZhbFtuZXh0ICsgaHVmZl0gPSAwO1xuICAgIHRhYmxlW25leHQgKyBodWZmXSA9ICgobGVuIC0gZHJvcCkgPDwgMjQpIHwgKDY0IDw8IDE2KSB8MDtcbiAgfVxuXG4gIC8qIHNldCByZXR1cm4gcGFyYW1ldGVycyAqL1xuICAvL29wdHMudGFibGVfaW5kZXggKz0gdXNlZDtcbiAgb3B0cy5iaXRzID0gcm9vdDtcbiAgcmV0dXJuIDA7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgMjogICAgICAnbmVlZCBkaWN0aW9uYXJ5JywgICAgIC8qIFpfTkVFRF9ESUNUICAgICAgIDIgICovXG4gIDE6ICAgICAgJ3N0cmVhbSBlbmQnLCAgICAgICAgICAvKiBaX1NUUkVBTV9FTkQgICAgICAxICAqL1xuICAwOiAgICAgICcnLCAgICAgICAgICAgICAgICAgICAgLyogWl9PSyAgICAgICAgICAgICAgMCAgKi9cbiAgJy0xJzogICAnZmlsZSBlcnJvcicsICAgICAgICAgIC8qIFpfRVJSTk8gICAgICAgICAoLTEpICovXG4gICctMic6ICAgJ3N0cmVhbSBlcnJvcicsICAgICAgICAvKiBaX1NUUkVBTV9FUlJPUiAgKC0yKSAqL1xuICAnLTMnOiAgICdkYXRhIGVycm9yJywgICAgICAgICAgLyogWl9EQVRBX0VSUk9SICAgICgtMykgKi9cbiAgJy00JzogICAnaW5zdWZmaWNpZW50IG1lbW9yeScsIC8qIFpfTUVNX0VSUk9SICAgICAoLTQpICovXG4gICctNSc6ICAgJ2J1ZmZlciBlcnJvcicsICAgICAgICAvKiBaX0JVRl9FUlJPUiAgICAgKC01KSAqL1xuICAnLTYnOiAgICdpbmNvbXBhdGlibGUgdmVyc2lvbicgLyogWl9WRVJTSU9OX0VSUk9SICgtNikgKi9cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMvY29tbW9uJyk7XG5cbi8qIFB1YmxpYyBjb25zdGFudHMgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG5cbi8vdmFyIFpfRklMVEVSRUQgICAgICAgICAgPSAxO1xuLy92YXIgWl9IVUZGTUFOX09OTFkgICAgICA9IDI7XG4vL3ZhciBaX1JMRSAgICAgICAgICAgICAgID0gMztcbnZhciBaX0ZJWEVEICAgICAgICAgICAgICAgPSA0O1xuLy92YXIgWl9ERUZBVUxUX1NUUkFURUdZICA9IDA7XG5cbi8qIFBvc3NpYmxlIHZhbHVlcyBvZiB0aGUgZGF0YV90eXBlIGZpZWxkICh0aG91Z2ggc2VlIGluZmxhdGUoKSkgKi9cbnZhciBaX0JJTkFSWSAgICAgICAgICAgICAgPSAwO1xudmFyIFpfVEVYVCAgICAgICAgICAgICAgICA9IDE7XG4vL3ZhciBaX0FTQ0lJICAgICAgICAgICAgID0gMTsgLy8gPSBaX1RFWFRcbnZhciBaX1VOS05PV04gICAgICAgICAgICAgPSAyO1xuXG4vKj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG5cbmZ1bmN0aW9uIHplcm8oYnVmKSB7IHZhciBsZW4gPSBidWYubGVuZ3RoOyB3aGlsZSAoLS1sZW4gPj0gMCkgeyBidWZbbGVuXSA9IDA7IH0gfVxuXG4vLyBGcm9tIHp1dGlsLmhcblxudmFyIFNUT1JFRF9CTE9DSyA9IDA7XG52YXIgU1RBVElDX1RSRUVTID0gMTtcbnZhciBEWU5fVFJFRVMgICAgPSAyO1xuLyogVGhlIHRocmVlIGtpbmRzIG9mIGJsb2NrIHR5cGUgKi9cblxudmFyIE1JTl9NQVRDSCAgICA9IDM7XG52YXIgTUFYX01BVENIICAgID0gMjU4O1xuLyogVGhlIG1pbmltdW0gYW5kIG1heGltdW0gbWF0Y2ggbGVuZ3RocyAqL1xuXG4vLyBGcm9tIGRlZmxhdGUuaFxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBJbnRlcm5hbCBjb21wcmVzc2lvbiBzdGF0ZS5cbiAqL1xuXG52YXIgTEVOR1RIX0NPREVTICA9IDI5O1xuLyogbnVtYmVyIG9mIGxlbmd0aCBjb2Rlcywgbm90IGNvdW50aW5nIHRoZSBzcGVjaWFsIEVORF9CTE9DSyBjb2RlICovXG5cbnZhciBMSVRFUkFMUyAgICAgID0gMjU2O1xuLyogbnVtYmVyIG9mIGxpdGVyYWwgYnl0ZXMgMC4uMjU1ICovXG5cbnZhciBMX0NPREVTICAgICAgID0gTElURVJBTFMgKyAxICsgTEVOR1RIX0NPREVTO1xuLyogbnVtYmVyIG9mIExpdGVyYWwgb3IgTGVuZ3RoIGNvZGVzLCBpbmNsdWRpbmcgdGhlIEVORF9CTE9DSyBjb2RlICovXG5cbnZhciBEX0NPREVTICAgICAgID0gMzA7XG4vKiBudW1iZXIgb2YgZGlzdGFuY2UgY29kZXMgKi9cblxudmFyIEJMX0NPREVTICAgICAgPSAxOTtcbi8qIG51bWJlciBvZiBjb2RlcyB1c2VkIHRvIHRyYW5zZmVyIHRoZSBiaXQgbGVuZ3RocyAqL1xuXG52YXIgSEVBUF9TSVpFICAgICA9IDIgKiBMX0NPREVTICsgMTtcbi8qIG1heGltdW0gaGVhcCBzaXplICovXG5cbnZhciBNQVhfQklUUyAgICAgID0gMTU7XG4vKiBBbGwgY29kZXMgbXVzdCBub3QgZXhjZWVkIE1BWF9CSVRTIGJpdHMgKi9cblxudmFyIEJ1Zl9zaXplICAgICAgPSAxNjtcbi8qIHNpemUgb2YgYml0IGJ1ZmZlciBpbiBiaV9idWYgKi9cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENvbnN0YW50c1xuICovXG5cbnZhciBNQVhfQkxfQklUUyA9IDc7XG4vKiBCaXQgbGVuZ3RoIGNvZGVzIG11c3Qgbm90IGV4Y2VlZCBNQVhfQkxfQklUUyBiaXRzICovXG5cbnZhciBFTkRfQkxPQ0sgICA9IDI1Njtcbi8qIGVuZCBvZiBibG9jayBsaXRlcmFsIGNvZGUgKi9cblxudmFyIFJFUF8zXzYgICAgID0gMTY7XG4vKiByZXBlYXQgcHJldmlvdXMgYml0IGxlbmd0aCAzLTYgdGltZXMgKDIgYml0cyBvZiByZXBlYXQgY291bnQpICovXG5cbnZhciBSRVBaXzNfMTAgICA9IDE3O1xuLyogcmVwZWF0IGEgemVybyBsZW5ndGggMy0xMCB0aW1lcyAgKDMgYml0cyBvZiByZXBlYXQgY291bnQpICovXG5cbnZhciBSRVBaXzExXzEzOCA9IDE4O1xuLyogcmVwZWF0IGEgemVybyBsZW5ndGggMTEtMTM4IHRpbWVzICAoNyBiaXRzIG9mIHJlcGVhdCBjb3VudCkgKi9cblxuLyogZXNsaW50LWRpc2FibGUgY29tbWEtc3BhY2luZyxhcnJheS1icmFja2V0LXNwYWNpbmcgKi9cbnZhciBleHRyYV9sYml0cyA9ICAgLyogZXh0cmEgYml0cyBmb3IgZWFjaCBsZW5ndGggY29kZSAqL1xuICBbMCwwLDAsMCwwLDAsMCwwLDEsMSwxLDEsMiwyLDIsMiwzLDMsMywzLDQsNCw0LDQsNSw1LDUsNSwwXTtcblxudmFyIGV4dHJhX2RiaXRzID0gICAvKiBleHRyYSBiaXRzIGZvciBlYWNoIGRpc3RhbmNlIGNvZGUgKi9cbiAgWzAsMCwwLDAsMSwxLDIsMiwzLDMsNCw0LDUsNSw2LDYsNyw3LDgsOCw5LDksMTAsMTAsMTEsMTEsMTIsMTIsMTMsMTNdO1xuXG52YXIgZXh0cmFfYmxiaXRzID0gIC8qIGV4dHJhIGJpdHMgZm9yIGVhY2ggYml0IGxlbmd0aCBjb2RlICovXG4gIFswLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDIsMyw3XTtcblxudmFyIGJsX29yZGVyID1cbiAgWzE2LDE3LDE4LDAsOCw3LDksNiwxMCw1LDExLDQsMTIsMywxMywyLDE0LDEsMTVdO1xuLyogZXNsaW50LWVuYWJsZSBjb21tYS1zcGFjaW5nLGFycmF5LWJyYWNrZXQtc3BhY2luZyAqL1xuXG4vKiBUaGUgbGVuZ3RocyBvZiB0aGUgYml0IGxlbmd0aCBjb2RlcyBhcmUgc2VudCBpbiBvcmRlciBvZiBkZWNyZWFzaW5nXG4gKiBwcm9iYWJpbGl0eSwgdG8gYXZvaWQgdHJhbnNtaXR0aW5nIHRoZSBsZW5ndGhzIGZvciB1bnVzZWQgYml0IGxlbmd0aCBjb2Rlcy5cbiAqL1xuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIExvY2FsIGRhdGEuIFRoZXNlIGFyZSBpbml0aWFsaXplZCBvbmx5IG9uY2UuXG4gKi9cblxuLy8gV2UgcHJlLWZpbGwgYXJyYXlzIHdpdGggMCB0byBhdm9pZCB1bmluaXRpYWxpemVkIGdhcHNcblxudmFyIERJU1RfQ09ERV9MRU4gPSA1MTI7IC8qIHNlZSBkZWZpbml0aW9uIG9mIGFycmF5IGRpc3RfY29kZSBiZWxvdyAqL1xuXG4vLyAhISEhIFVzZSBmbGF0IGFycmF5IGluc2RlYWQgb2Ygc3RydWN0dXJlLCBGcmVxID0gaSoyLCBMZW4gPSBpKjIrMVxudmFyIHN0YXRpY19sdHJlZSAgPSBuZXcgQXJyYXkoKExfQ09ERVMgKyAyKSAqIDIpO1xuemVybyhzdGF0aWNfbHRyZWUpO1xuLyogVGhlIHN0YXRpYyBsaXRlcmFsIHRyZWUuIFNpbmNlIHRoZSBiaXQgbGVuZ3RocyBhcmUgaW1wb3NlZCwgdGhlcmUgaXMgbm9cbiAqIG5lZWQgZm9yIHRoZSBMX0NPREVTIGV4dHJhIGNvZGVzIHVzZWQgZHVyaW5nIGhlYXAgY29uc3RydWN0aW9uLiBIb3dldmVyXG4gKiBUaGUgY29kZXMgMjg2IGFuZCAyODcgYXJlIG5lZWRlZCB0byBidWlsZCBhIGNhbm9uaWNhbCB0cmVlIChzZWUgX3RyX2luaXRcbiAqIGJlbG93KS5cbiAqL1xuXG52YXIgc3RhdGljX2R0cmVlICA9IG5ldyBBcnJheShEX0NPREVTICogMik7XG56ZXJvKHN0YXRpY19kdHJlZSk7XG4vKiBUaGUgc3RhdGljIGRpc3RhbmNlIHRyZWUuIChBY3R1YWxseSBhIHRyaXZpYWwgdHJlZSBzaW5jZSBhbGwgY29kZXMgdXNlXG4gKiA1IGJpdHMuKVxuICovXG5cbnZhciBfZGlzdF9jb2RlICAgID0gbmV3IEFycmF5KERJU1RfQ09ERV9MRU4pO1xuemVybyhfZGlzdF9jb2RlKTtcbi8qIERpc3RhbmNlIGNvZGVzLiBUaGUgZmlyc3QgMjU2IHZhbHVlcyBjb3JyZXNwb25kIHRvIHRoZSBkaXN0YW5jZXNcbiAqIDMgLi4gMjU4LCB0aGUgbGFzdCAyNTYgdmFsdWVzIGNvcnJlc3BvbmQgdG8gdGhlIHRvcCA4IGJpdHMgb2ZcbiAqIHRoZSAxNSBiaXQgZGlzdGFuY2VzLlxuICovXG5cbnZhciBfbGVuZ3RoX2NvZGUgID0gbmV3IEFycmF5KE1BWF9NQVRDSCAtIE1JTl9NQVRDSCArIDEpO1xuemVybyhfbGVuZ3RoX2NvZGUpO1xuLyogbGVuZ3RoIGNvZGUgZm9yIGVhY2ggbm9ybWFsaXplZCBtYXRjaCBsZW5ndGggKDAgPT0gTUlOX01BVENIKSAqL1xuXG52YXIgYmFzZV9sZW5ndGggICA9IG5ldyBBcnJheShMRU5HVEhfQ09ERVMpO1xuemVybyhiYXNlX2xlbmd0aCk7XG4vKiBGaXJzdCBub3JtYWxpemVkIGxlbmd0aCBmb3IgZWFjaCBjb2RlICgwID0gTUlOX01BVENIKSAqL1xuXG52YXIgYmFzZV9kaXN0ICAgICA9IG5ldyBBcnJheShEX0NPREVTKTtcbnplcm8oYmFzZV9kaXN0KTtcbi8qIEZpcnN0IG5vcm1hbGl6ZWQgZGlzdGFuY2UgZm9yIGVhY2ggY29kZSAoMCA9IGRpc3RhbmNlIG9mIDEpICovXG5cblxuZnVuY3Rpb24gU3RhdGljVHJlZURlc2Moc3RhdGljX3RyZWUsIGV4dHJhX2JpdHMsIGV4dHJhX2Jhc2UsIGVsZW1zLCBtYXhfbGVuZ3RoKSB7XG5cbiAgdGhpcy5zdGF0aWNfdHJlZSAgPSBzdGF0aWNfdHJlZTsgIC8qIHN0YXRpYyB0cmVlIG9yIE5VTEwgKi9cbiAgdGhpcy5leHRyYV9iaXRzICAgPSBleHRyYV9iaXRzOyAgIC8qIGV4dHJhIGJpdHMgZm9yIGVhY2ggY29kZSBvciBOVUxMICovXG4gIHRoaXMuZXh0cmFfYmFzZSAgID0gZXh0cmFfYmFzZTsgICAvKiBiYXNlIGluZGV4IGZvciBleHRyYV9iaXRzICovXG4gIHRoaXMuZWxlbXMgICAgICAgID0gZWxlbXM7ICAgICAgICAvKiBtYXggbnVtYmVyIG9mIGVsZW1lbnRzIGluIHRoZSB0cmVlICovXG4gIHRoaXMubWF4X2xlbmd0aCAgID0gbWF4X2xlbmd0aDsgICAvKiBtYXggYml0IGxlbmd0aCBmb3IgdGhlIGNvZGVzICovXG5cbiAgLy8gc2hvdyBpZiBgc3RhdGljX3RyZWVgIGhhcyBkYXRhIG9yIGR1bW15IC0gbmVlZGVkIGZvciBtb25vbW9ycGhpYyBvYmplY3RzXG4gIHRoaXMuaGFzX3N0cmVlICAgID0gc3RhdGljX3RyZWUgJiYgc3RhdGljX3RyZWUubGVuZ3RoO1xufVxuXG5cbnZhciBzdGF0aWNfbF9kZXNjO1xudmFyIHN0YXRpY19kX2Rlc2M7XG52YXIgc3RhdGljX2JsX2Rlc2M7XG5cblxuZnVuY3Rpb24gVHJlZURlc2MoZHluX3RyZWUsIHN0YXRfZGVzYykge1xuICB0aGlzLmR5bl90cmVlID0gZHluX3RyZWU7ICAgICAvKiB0aGUgZHluYW1pYyB0cmVlICovXG4gIHRoaXMubWF4X2NvZGUgPSAwOyAgICAgICAgICAgIC8qIGxhcmdlc3QgY29kZSB3aXRoIG5vbiB6ZXJvIGZyZXF1ZW5jeSAqL1xuICB0aGlzLnN0YXRfZGVzYyA9IHN0YXRfZGVzYzsgICAvKiB0aGUgY29ycmVzcG9uZGluZyBzdGF0aWMgdHJlZSAqL1xufVxuXG5cblxuZnVuY3Rpb24gZF9jb2RlKGRpc3QpIHtcbiAgcmV0dXJuIGRpc3QgPCAyNTYgPyBfZGlzdF9jb2RlW2Rpc3RdIDogX2Rpc3RfY29kZVsyNTYgKyAoZGlzdCA+Pj4gNyldO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogT3V0cHV0IGEgc2hvcnQgTFNCIGZpcnN0IG9uIHRoZSBzdHJlYW0uXG4gKiBJTiBhc3NlcnRpb246IHRoZXJlIGlzIGVub3VnaCByb29tIGluIHBlbmRpbmdCdWYuXG4gKi9cbmZ1bmN0aW9uIHB1dF9zaG9ydChzLCB3KSB7XG4vLyAgICBwdXRfYnl0ZShzLCAodWNoKSgodykgJiAweGZmKSk7XG4vLyAgICBwdXRfYnl0ZShzLCAodWNoKSgodXNoKSh3KSA+PiA4KSk7XG4gIHMucGVuZGluZ19idWZbcy5wZW5kaW5nKytdID0gKHcpICYgMHhmZjtcbiAgcy5wZW5kaW5nX2J1ZltzLnBlbmRpbmcrK10gPSAodyA+Pj4gOCkgJiAweGZmO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogU2VuZCBhIHZhbHVlIG9uIGEgZ2l2ZW4gbnVtYmVyIG9mIGJpdHMuXG4gKiBJTiBhc3NlcnRpb246IGxlbmd0aCA8PSAxNiBhbmQgdmFsdWUgZml0cyBpbiBsZW5ndGggYml0cy5cbiAqL1xuZnVuY3Rpb24gc2VuZF9iaXRzKHMsIHZhbHVlLCBsZW5ndGgpIHtcbiAgaWYgKHMuYmlfdmFsaWQgPiAoQnVmX3NpemUgLSBsZW5ndGgpKSB7XG4gICAgcy5iaV9idWYgfD0gKHZhbHVlIDw8IHMuYmlfdmFsaWQpICYgMHhmZmZmO1xuICAgIHB1dF9zaG9ydChzLCBzLmJpX2J1Zik7XG4gICAgcy5iaV9idWYgPSB2YWx1ZSA+PiAoQnVmX3NpemUgLSBzLmJpX3ZhbGlkKTtcbiAgICBzLmJpX3ZhbGlkICs9IGxlbmd0aCAtIEJ1Zl9zaXplO1xuICB9IGVsc2Uge1xuICAgIHMuYmlfYnVmIHw9ICh2YWx1ZSA8PCBzLmJpX3ZhbGlkKSAmIDB4ZmZmZjtcbiAgICBzLmJpX3ZhbGlkICs9IGxlbmd0aDtcbiAgfVxufVxuXG5cbmZ1bmN0aW9uIHNlbmRfY29kZShzLCBjLCB0cmVlKSB7XG4gIHNlbmRfYml0cyhzLCB0cmVlW2MgKiAyXS8qLkNvZGUqLywgdHJlZVtjICogMiArIDFdLyouTGVuKi8pO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogUmV2ZXJzZSB0aGUgZmlyc3QgbGVuIGJpdHMgb2YgYSBjb2RlLCB1c2luZyBzdHJhaWdodGZvcndhcmQgY29kZSAoYSBmYXN0ZXJcbiAqIG1ldGhvZCB3b3VsZCB1c2UgYSB0YWJsZSlcbiAqIElOIGFzc2VydGlvbjogMSA8PSBsZW4gPD0gMTVcbiAqL1xuZnVuY3Rpb24gYmlfcmV2ZXJzZShjb2RlLCBsZW4pIHtcbiAgdmFyIHJlcyA9IDA7XG4gIGRvIHtcbiAgICByZXMgfD0gY29kZSAmIDE7XG4gICAgY29kZSA+Pj49IDE7XG4gICAgcmVzIDw8PSAxO1xuICB9IHdoaWxlICgtLWxlbiA+IDApO1xuICByZXR1cm4gcmVzID4+PiAxO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogRmx1c2ggdGhlIGJpdCBidWZmZXIsIGtlZXBpbmcgYXQgbW9zdCA3IGJpdHMgaW4gaXQuXG4gKi9cbmZ1bmN0aW9uIGJpX2ZsdXNoKHMpIHtcbiAgaWYgKHMuYmlfdmFsaWQgPT09IDE2KSB7XG4gICAgcHV0X3Nob3J0KHMsIHMuYmlfYnVmKTtcbiAgICBzLmJpX2J1ZiA9IDA7XG4gICAgcy5iaV92YWxpZCA9IDA7XG5cbiAgfSBlbHNlIGlmIChzLmJpX3ZhbGlkID49IDgpIHtcbiAgICBzLnBlbmRpbmdfYnVmW3MucGVuZGluZysrXSA9IHMuYmlfYnVmICYgMHhmZjtcbiAgICBzLmJpX2J1ZiA+Pj0gODtcbiAgICBzLmJpX3ZhbGlkIC09IDg7XG4gIH1cbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENvbXB1dGUgdGhlIG9wdGltYWwgYml0IGxlbmd0aHMgZm9yIGEgdHJlZSBhbmQgdXBkYXRlIHRoZSB0b3RhbCBiaXQgbGVuZ3RoXG4gKiBmb3IgdGhlIGN1cnJlbnQgYmxvY2suXG4gKiBJTiBhc3NlcnRpb246IHRoZSBmaWVsZHMgZnJlcSBhbmQgZGFkIGFyZSBzZXQsIGhlYXBbaGVhcF9tYXhdIGFuZFxuICogICAgYWJvdmUgYXJlIHRoZSB0cmVlIG5vZGVzIHNvcnRlZCBieSBpbmNyZWFzaW5nIGZyZXF1ZW5jeS5cbiAqIE9VVCBhc3NlcnRpb25zOiB0aGUgZmllbGQgbGVuIGlzIHNldCB0byB0aGUgb3B0aW1hbCBiaXQgbGVuZ3RoLCB0aGVcbiAqICAgICBhcnJheSBibF9jb3VudCBjb250YWlucyB0aGUgZnJlcXVlbmNpZXMgZm9yIGVhY2ggYml0IGxlbmd0aC5cbiAqICAgICBUaGUgbGVuZ3RoIG9wdF9sZW4gaXMgdXBkYXRlZDsgc3RhdGljX2xlbiBpcyBhbHNvIHVwZGF0ZWQgaWYgc3RyZWUgaXNcbiAqICAgICBub3QgbnVsbC5cbiAqL1xuZnVuY3Rpb24gZ2VuX2JpdGxlbihzLCBkZXNjKVxuLy8gICAgZGVmbGF0ZV9zdGF0ZSAqcztcbi8vICAgIHRyZWVfZGVzYyAqZGVzYzsgICAgLyogdGhlIHRyZWUgZGVzY3JpcHRvciAqL1xue1xuICB2YXIgdHJlZSAgICAgICAgICAgID0gZGVzYy5keW5fdHJlZTtcbiAgdmFyIG1heF9jb2RlICAgICAgICA9IGRlc2MubWF4X2NvZGU7XG4gIHZhciBzdHJlZSAgICAgICAgICAgPSBkZXNjLnN0YXRfZGVzYy5zdGF0aWNfdHJlZTtcbiAgdmFyIGhhc19zdHJlZSAgICAgICA9IGRlc2Muc3RhdF9kZXNjLmhhc19zdHJlZTtcbiAgdmFyIGV4dHJhICAgICAgICAgICA9IGRlc2Muc3RhdF9kZXNjLmV4dHJhX2JpdHM7XG4gIHZhciBiYXNlICAgICAgICAgICAgPSBkZXNjLnN0YXRfZGVzYy5leHRyYV9iYXNlO1xuICB2YXIgbWF4X2xlbmd0aCAgICAgID0gZGVzYy5zdGF0X2Rlc2MubWF4X2xlbmd0aDtcbiAgdmFyIGg7ICAgICAgICAgICAgICAvKiBoZWFwIGluZGV4ICovXG4gIHZhciBuLCBtOyAgICAgICAgICAgLyogaXRlcmF0ZSBvdmVyIHRoZSB0cmVlIGVsZW1lbnRzICovXG4gIHZhciBiaXRzOyAgICAgICAgICAgLyogYml0IGxlbmd0aCAqL1xuICB2YXIgeGJpdHM7ICAgICAgICAgIC8qIGV4dHJhIGJpdHMgKi9cbiAgdmFyIGY7ICAgICAgICAgICAgICAvKiBmcmVxdWVuY3kgKi9cbiAgdmFyIG92ZXJmbG93ID0gMDsgICAvKiBudW1iZXIgb2YgZWxlbWVudHMgd2l0aCBiaXQgbGVuZ3RoIHRvbyBsYXJnZSAqL1xuXG4gIGZvciAoYml0cyA9IDA7IGJpdHMgPD0gTUFYX0JJVFM7IGJpdHMrKykge1xuICAgIHMuYmxfY291bnRbYml0c10gPSAwO1xuICB9XG5cbiAgLyogSW4gYSBmaXJzdCBwYXNzLCBjb21wdXRlIHRoZSBvcHRpbWFsIGJpdCBsZW5ndGhzICh3aGljaCBtYXlcbiAgICogb3ZlcmZsb3cgaW4gdGhlIGNhc2Ugb2YgdGhlIGJpdCBsZW5ndGggdHJlZSkuXG4gICAqL1xuICB0cmVlW3MuaGVhcFtzLmhlYXBfbWF4XSAqIDIgKyAxXS8qLkxlbiovID0gMDsgLyogcm9vdCBvZiB0aGUgaGVhcCAqL1xuXG4gIGZvciAoaCA9IHMuaGVhcF9tYXggKyAxOyBoIDwgSEVBUF9TSVpFOyBoKyspIHtcbiAgICBuID0gcy5oZWFwW2hdO1xuICAgIGJpdHMgPSB0cmVlW3RyZWVbbiAqIDIgKyAxXS8qLkRhZCovICogMiArIDFdLyouTGVuKi8gKyAxO1xuICAgIGlmIChiaXRzID4gbWF4X2xlbmd0aCkge1xuICAgICAgYml0cyA9IG1heF9sZW5ndGg7XG4gICAgICBvdmVyZmxvdysrO1xuICAgIH1cbiAgICB0cmVlW24gKiAyICsgMV0vKi5MZW4qLyA9IGJpdHM7XG4gICAgLyogV2Ugb3ZlcndyaXRlIHRyZWVbbl0uRGFkIHdoaWNoIGlzIG5vIGxvbmdlciBuZWVkZWQgKi9cblxuICAgIGlmIChuID4gbWF4X2NvZGUpIHsgY29udGludWU7IH0gLyogbm90IGEgbGVhZiBub2RlICovXG5cbiAgICBzLmJsX2NvdW50W2JpdHNdKys7XG4gICAgeGJpdHMgPSAwO1xuICAgIGlmIChuID49IGJhc2UpIHtcbiAgICAgIHhiaXRzID0gZXh0cmFbbiAtIGJhc2VdO1xuICAgIH1cbiAgICBmID0gdHJlZVtuICogMl0vKi5GcmVxKi87XG4gICAgcy5vcHRfbGVuICs9IGYgKiAoYml0cyArIHhiaXRzKTtcbiAgICBpZiAoaGFzX3N0cmVlKSB7XG4gICAgICBzLnN0YXRpY19sZW4gKz0gZiAqIChzdHJlZVtuICogMiArIDFdLyouTGVuKi8gKyB4Yml0cyk7XG4gICAgfVxuICB9XG4gIGlmIChvdmVyZmxvdyA9PT0gMCkgeyByZXR1cm47IH1cblxuICAvLyBUcmFjZSgoc3RkZXJyLFwiXFxuYml0IGxlbmd0aCBvdmVyZmxvd1xcblwiKSk7XG4gIC8qIFRoaXMgaGFwcGVucyBmb3IgZXhhbXBsZSBvbiBvYmoyIGFuZCBwaWMgb2YgdGhlIENhbGdhcnkgY29ycHVzICovXG5cbiAgLyogRmluZCB0aGUgZmlyc3QgYml0IGxlbmd0aCB3aGljaCBjb3VsZCBpbmNyZWFzZTogKi9cbiAgZG8ge1xuICAgIGJpdHMgPSBtYXhfbGVuZ3RoIC0gMTtcbiAgICB3aGlsZSAocy5ibF9jb3VudFtiaXRzXSA9PT0gMCkgeyBiaXRzLS07IH1cbiAgICBzLmJsX2NvdW50W2JpdHNdLS07ICAgICAgLyogbW92ZSBvbmUgbGVhZiBkb3duIHRoZSB0cmVlICovXG4gICAgcy5ibF9jb3VudFtiaXRzICsgMV0gKz0gMjsgLyogbW92ZSBvbmUgb3ZlcmZsb3cgaXRlbSBhcyBpdHMgYnJvdGhlciAqL1xuICAgIHMuYmxfY291bnRbbWF4X2xlbmd0aF0tLTtcbiAgICAvKiBUaGUgYnJvdGhlciBvZiB0aGUgb3ZlcmZsb3cgaXRlbSBhbHNvIG1vdmVzIG9uZSBzdGVwIHVwLFxuICAgICAqIGJ1dCB0aGlzIGRvZXMgbm90IGFmZmVjdCBibF9jb3VudFttYXhfbGVuZ3RoXVxuICAgICAqL1xuICAgIG92ZXJmbG93IC09IDI7XG4gIH0gd2hpbGUgKG92ZXJmbG93ID4gMCk7XG5cbiAgLyogTm93IHJlY29tcHV0ZSBhbGwgYml0IGxlbmd0aHMsIHNjYW5uaW5nIGluIGluY3JlYXNpbmcgZnJlcXVlbmN5LlxuICAgKiBoIGlzIHN0aWxsIGVxdWFsIHRvIEhFQVBfU0laRS4gKEl0IGlzIHNpbXBsZXIgdG8gcmVjb25zdHJ1Y3QgYWxsXG4gICAqIGxlbmd0aHMgaW5zdGVhZCBvZiBmaXhpbmcgb25seSB0aGUgd3Jvbmcgb25lcy4gVGhpcyBpZGVhIGlzIHRha2VuXG4gICAqIGZyb20gJ2FyJyB3cml0dGVuIGJ5IEhhcnVoaWtvIE9rdW11cmEuKVxuICAgKi9cbiAgZm9yIChiaXRzID0gbWF4X2xlbmd0aDsgYml0cyAhPT0gMDsgYml0cy0tKSB7XG4gICAgbiA9IHMuYmxfY291bnRbYml0c107XG4gICAgd2hpbGUgKG4gIT09IDApIHtcbiAgICAgIG0gPSBzLmhlYXBbLS1oXTtcbiAgICAgIGlmIChtID4gbWF4X2NvZGUpIHsgY29udGludWU7IH1cbiAgICAgIGlmICh0cmVlW20gKiAyICsgMV0vKi5MZW4qLyAhPT0gYml0cykge1xuICAgICAgICAvLyBUcmFjZSgoc3RkZXJyLFwiY29kZSAlZCBiaXRzICVkLT4lZFxcblwiLCBtLCB0cmVlW21dLkxlbiwgYml0cykpO1xuICAgICAgICBzLm9wdF9sZW4gKz0gKGJpdHMgLSB0cmVlW20gKiAyICsgMV0vKi5MZW4qLykgKiB0cmVlW20gKiAyXS8qLkZyZXEqLztcbiAgICAgICAgdHJlZVttICogMiArIDFdLyouTGVuKi8gPSBiaXRzO1xuICAgICAgfVxuICAgICAgbi0tO1xuICAgIH1cbiAgfVxufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogR2VuZXJhdGUgdGhlIGNvZGVzIGZvciBhIGdpdmVuIHRyZWUgYW5kIGJpdCBjb3VudHMgKHdoaWNoIG5lZWQgbm90IGJlXG4gKiBvcHRpbWFsKS5cbiAqIElOIGFzc2VydGlvbjogdGhlIGFycmF5IGJsX2NvdW50IGNvbnRhaW5zIHRoZSBiaXQgbGVuZ3RoIHN0YXRpc3RpY3MgZm9yXG4gKiB0aGUgZ2l2ZW4gdHJlZSBhbmQgdGhlIGZpZWxkIGxlbiBpcyBzZXQgZm9yIGFsbCB0cmVlIGVsZW1lbnRzLlxuICogT1VUIGFzc2VydGlvbjogdGhlIGZpZWxkIGNvZGUgaXMgc2V0IGZvciBhbGwgdHJlZSBlbGVtZW50cyBvZiBub25cbiAqICAgICB6ZXJvIGNvZGUgbGVuZ3RoLlxuICovXG5mdW5jdGlvbiBnZW5fY29kZXModHJlZSwgbWF4X2NvZGUsIGJsX2NvdW50KVxuLy8gICAgY3RfZGF0YSAqdHJlZTsgICAgICAgICAgICAgLyogdGhlIHRyZWUgdG8gZGVjb3JhdGUgKi9cbi8vICAgIGludCBtYXhfY29kZTsgICAgICAgICAgICAgIC8qIGxhcmdlc3QgY29kZSB3aXRoIG5vbiB6ZXJvIGZyZXF1ZW5jeSAqL1xuLy8gICAgdXNoZiAqYmxfY291bnQ7ICAgICAgICAgICAgLyogbnVtYmVyIG9mIGNvZGVzIGF0IGVhY2ggYml0IGxlbmd0aCAqL1xue1xuICB2YXIgbmV4dF9jb2RlID0gbmV3IEFycmF5KE1BWF9CSVRTICsgMSk7IC8qIG5leHQgY29kZSB2YWx1ZSBmb3IgZWFjaCBiaXQgbGVuZ3RoICovXG4gIHZhciBjb2RlID0gMDsgICAgICAgICAgICAgIC8qIHJ1bm5pbmcgY29kZSB2YWx1ZSAqL1xuICB2YXIgYml0czsgICAgICAgICAgICAgICAgICAvKiBiaXQgaW5kZXggKi9cbiAgdmFyIG47ICAgICAgICAgICAgICAgICAgICAgLyogY29kZSBpbmRleCAqL1xuXG4gIC8qIFRoZSBkaXN0cmlidXRpb24gY291bnRzIGFyZSBmaXJzdCB1c2VkIHRvIGdlbmVyYXRlIHRoZSBjb2RlIHZhbHVlc1xuICAgKiB3aXRob3V0IGJpdCByZXZlcnNhbC5cbiAgICovXG4gIGZvciAoYml0cyA9IDE7IGJpdHMgPD0gTUFYX0JJVFM7IGJpdHMrKykge1xuICAgIG5leHRfY29kZVtiaXRzXSA9IGNvZGUgPSAoY29kZSArIGJsX2NvdW50W2JpdHMgLSAxXSkgPDwgMTtcbiAgfVxuICAvKiBDaGVjayB0aGF0IHRoZSBiaXQgY291bnRzIGluIGJsX2NvdW50IGFyZSBjb25zaXN0ZW50LiBUaGUgbGFzdCBjb2RlXG4gICAqIG11c3QgYmUgYWxsIG9uZXMuXG4gICAqL1xuICAvL0Fzc2VydCAoY29kZSArIGJsX2NvdW50W01BWF9CSVRTXS0xID09ICgxPDxNQVhfQklUUyktMSxcbiAgLy8gICAgICAgIFwiaW5jb25zaXN0ZW50IGJpdCBjb3VudHNcIik7XG4gIC8vVHJhY2V2KChzdGRlcnIsXCJcXG5nZW5fY29kZXM6IG1heF9jb2RlICVkIFwiLCBtYXhfY29kZSkpO1xuXG4gIGZvciAobiA9IDA7ICBuIDw9IG1heF9jb2RlOyBuKyspIHtcbiAgICB2YXIgbGVuID0gdHJlZVtuICogMiArIDFdLyouTGVuKi87XG4gICAgaWYgKGxlbiA9PT0gMCkgeyBjb250aW51ZTsgfVxuICAgIC8qIE5vdyByZXZlcnNlIHRoZSBiaXRzICovXG4gICAgdHJlZVtuICogMl0vKi5Db2RlKi8gPSBiaV9yZXZlcnNlKG5leHRfY29kZVtsZW5dKyssIGxlbik7XG5cbiAgICAvL1RyYWNlY3YodHJlZSAhPSBzdGF0aWNfbHRyZWUsIChzdGRlcnIsXCJcXG5uICUzZCAlYyBsICUyZCBjICU0eCAoJXgpIFwiLFxuICAgIC8vICAgICBuLCAoaXNncmFwaChuKSA/IG4gOiAnICcpLCBsZW4sIHRyZWVbbl0uQ29kZSwgbmV4dF9jb2RlW2xlbl0tMSkpO1xuICB9XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBJbml0aWFsaXplIHRoZSB2YXJpb3VzICdjb25zdGFudCcgdGFibGVzLlxuICovXG5mdW5jdGlvbiB0cl9zdGF0aWNfaW5pdCgpIHtcbiAgdmFyIG47ICAgICAgICAvKiBpdGVyYXRlcyBvdmVyIHRyZWUgZWxlbWVudHMgKi9cbiAgdmFyIGJpdHM7ICAgICAvKiBiaXQgY291bnRlciAqL1xuICB2YXIgbGVuZ3RoOyAgIC8qIGxlbmd0aCB2YWx1ZSAqL1xuICB2YXIgY29kZTsgICAgIC8qIGNvZGUgdmFsdWUgKi9cbiAgdmFyIGRpc3Q7ICAgICAvKiBkaXN0YW5jZSBpbmRleCAqL1xuICB2YXIgYmxfY291bnQgPSBuZXcgQXJyYXkoTUFYX0JJVFMgKyAxKTtcbiAgLyogbnVtYmVyIG9mIGNvZGVzIGF0IGVhY2ggYml0IGxlbmd0aCBmb3IgYW4gb3B0aW1hbCB0cmVlICovXG5cbiAgLy8gZG8gY2hlY2sgaW4gX3RyX2luaXQoKVxuICAvL2lmIChzdGF0aWNfaW5pdF9kb25lKSByZXR1cm47XG5cbiAgLyogRm9yIHNvbWUgZW1iZWRkZWQgdGFyZ2V0cywgZ2xvYmFsIHZhcmlhYmxlcyBhcmUgbm90IGluaXRpYWxpemVkOiAqL1xuLyojaWZkZWYgTk9fSU5JVF9HTE9CQUxfUE9JTlRFUlNcbiAgc3RhdGljX2xfZGVzYy5zdGF0aWNfdHJlZSA9IHN0YXRpY19sdHJlZTtcbiAgc3RhdGljX2xfZGVzYy5leHRyYV9iaXRzID0gZXh0cmFfbGJpdHM7XG4gIHN0YXRpY19kX2Rlc2Muc3RhdGljX3RyZWUgPSBzdGF0aWNfZHRyZWU7XG4gIHN0YXRpY19kX2Rlc2MuZXh0cmFfYml0cyA9IGV4dHJhX2RiaXRzO1xuICBzdGF0aWNfYmxfZGVzYy5leHRyYV9iaXRzID0gZXh0cmFfYmxiaXRzO1xuI2VuZGlmKi9cblxuICAvKiBJbml0aWFsaXplIHRoZSBtYXBwaW5nIGxlbmd0aCAoMC4uMjU1KSAtPiBsZW5ndGggY29kZSAoMC4uMjgpICovXG4gIGxlbmd0aCA9IDA7XG4gIGZvciAoY29kZSA9IDA7IGNvZGUgPCBMRU5HVEhfQ09ERVMgLSAxOyBjb2RlKyspIHtcbiAgICBiYXNlX2xlbmd0aFtjb2RlXSA9IGxlbmd0aDtcbiAgICBmb3IgKG4gPSAwOyBuIDwgKDEgPDwgZXh0cmFfbGJpdHNbY29kZV0pOyBuKyspIHtcbiAgICAgIF9sZW5ndGhfY29kZVtsZW5ndGgrK10gPSBjb2RlO1xuICAgIH1cbiAgfVxuICAvL0Fzc2VydCAobGVuZ3RoID09IDI1NiwgXCJ0cl9zdGF0aWNfaW5pdDogbGVuZ3RoICE9IDI1NlwiKTtcbiAgLyogTm90ZSB0aGF0IHRoZSBsZW5ndGggMjU1IChtYXRjaCBsZW5ndGggMjU4KSBjYW4gYmUgcmVwcmVzZW50ZWRcbiAgICogaW4gdHdvIGRpZmZlcmVudCB3YXlzOiBjb2RlIDI4NCArIDUgYml0cyBvciBjb2RlIDI4NSwgc28gd2VcbiAgICogb3ZlcndyaXRlIGxlbmd0aF9jb2RlWzI1NV0gdG8gdXNlIHRoZSBiZXN0IGVuY29kaW5nOlxuICAgKi9cbiAgX2xlbmd0aF9jb2RlW2xlbmd0aCAtIDFdID0gY29kZTtcblxuICAvKiBJbml0aWFsaXplIHRoZSBtYXBwaW5nIGRpc3QgKDAuLjMySykgLT4gZGlzdCBjb2RlICgwLi4yOSkgKi9cbiAgZGlzdCA9IDA7XG4gIGZvciAoY29kZSA9IDA7IGNvZGUgPCAxNjsgY29kZSsrKSB7XG4gICAgYmFzZV9kaXN0W2NvZGVdID0gZGlzdDtcbiAgICBmb3IgKG4gPSAwOyBuIDwgKDEgPDwgZXh0cmFfZGJpdHNbY29kZV0pOyBuKyspIHtcbiAgICAgIF9kaXN0X2NvZGVbZGlzdCsrXSA9IGNvZGU7XG4gICAgfVxuICB9XG4gIC8vQXNzZXJ0IChkaXN0ID09IDI1NiwgXCJ0cl9zdGF0aWNfaW5pdDogZGlzdCAhPSAyNTZcIik7XG4gIGRpc3QgPj49IDc7IC8qIGZyb20gbm93IG9uLCBhbGwgZGlzdGFuY2VzIGFyZSBkaXZpZGVkIGJ5IDEyOCAqL1xuICBmb3IgKDsgY29kZSA8IERfQ09ERVM7IGNvZGUrKykge1xuICAgIGJhc2VfZGlzdFtjb2RlXSA9IGRpc3QgPDwgNztcbiAgICBmb3IgKG4gPSAwOyBuIDwgKDEgPDwgKGV4dHJhX2RiaXRzW2NvZGVdIC0gNykpOyBuKyspIHtcbiAgICAgIF9kaXN0X2NvZGVbMjU2ICsgZGlzdCsrXSA9IGNvZGU7XG4gICAgfVxuICB9XG4gIC8vQXNzZXJ0IChkaXN0ID09IDI1NiwgXCJ0cl9zdGF0aWNfaW5pdDogMjU2K2Rpc3QgIT0gNTEyXCIpO1xuXG4gIC8qIENvbnN0cnVjdCB0aGUgY29kZXMgb2YgdGhlIHN0YXRpYyBsaXRlcmFsIHRyZWUgKi9cbiAgZm9yIChiaXRzID0gMDsgYml0cyA8PSBNQVhfQklUUzsgYml0cysrKSB7XG4gICAgYmxfY291bnRbYml0c10gPSAwO1xuICB9XG5cbiAgbiA9IDA7XG4gIHdoaWxlIChuIDw9IDE0Mykge1xuICAgIHN0YXRpY19sdHJlZVtuICogMiArIDFdLyouTGVuKi8gPSA4O1xuICAgIG4rKztcbiAgICBibF9jb3VudFs4XSsrO1xuICB9XG4gIHdoaWxlIChuIDw9IDI1NSkge1xuICAgIHN0YXRpY19sdHJlZVtuICogMiArIDFdLyouTGVuKi8gPSA5O1xuICAgIG4rKztcbiAgICBibF9jb3VudFs5XSsrO1xuICB9XG4gIHdoaWxlIChuIDw9IDI3OSkge1xuICAgIHN0YXRpY19sdHJlZVtuICogMiArIDFdLyouTGVuKi8gPSA3O1xuICAgIG4rKztcbiAgICBibF9jb3VudFs3XSsrO1xuICB9XG4gIHdoaWxlIChuIDw9IDI4Nykge1xuICAgIHN0YXRpY19sdHJlZVtuICogMiArIDFdLyouTGVuKi8gPSA4O1xuICAgIG4rKztcbiAgICBibF9jb3VudFs4XSsrO1xuICB9XG4gIC8qIENvZGVzIDI4NiBhbmQgMjg3IGRvIG5vdCBleGlzdCwgYnV0IHdlIG11c3QgaW5jbHVkZSB0aGVtIGluIHRoZVxuICAgKiB0cmVlIGNvbnN0cnVjdGlvbiB0byBnZXQgYSBjYW5vbmljYWwgSHVmZm1hbiB0cmVlIChsb25nZXN0IGNvZGVcbiAgICogYWxsIG9uZXMpXG4gICAqL1xuICBnZW5fY29kZXMoc3RhdGljX2x0cmVlLCBMX0NPREVTICsgMSwgYmxfY291bnQpO1xuXG4gIC8qIFRoZSBzdGF0aWMgZGlzdGFuY2UgdHJlZSBpcyB0cml2aWFsOiAqL1xuICBmb3IgKG4gPSAwOyBuIDwgRF9DT0RFUzsgbisrKSB7XG4gICAgc3RhdGljX2R0cmVlW24gKiAyICsgMV0vKi5MZW4qLyA9IDU7XG4gICAgc3RhdGljX2R0cmVlW24gKiAyXS8qLkNvZGUqLyA9IGJpX3JldmVyc2UobiwgNSk7XG4gIH1cblxuICAvLyBOb3cgZGF0YSByZWFkeSBhbmQgd2UgY2FuIGluaXQgc3RhdGljIHRyZWVzXG4gIHN0YXRpY19sX2Rlc2MgPSBuZXcgU3RhdGljVHJlZURlc2Moc3RhdGljX2x0cmVlLCBleHRyYV9sYml0cywgTElURVJBTFMgKyAxLCBMX0NPREVTLCBNQVhfQklUUyk7XG4gIHN0YXRpY19kX2Rlc2MgPSBuZXcgU3RhdGljVHJlZURlc2Moc3RhdGljX2R0cmVlLCBleHRyYV9kYml0cywgMCwgICAgICAgICAgRF9DT0RFUywgTUFYX0JJVFMpO1xuICBzdGF0aWNfYmxfZGVzYyA9IG5ldyBTdGF0aWNUcmVlRGVzYyhuZXcgQXJyYXkoMCksIGV4dHJhX2JsYml0cywgMCwgICAgICAgICBCTF9DT0RFUywgTUFYX0JMX0JJVFMpO1xuXG4gIC8vc3RhdGljX2luaXRfZG9uZSA9IHRydWU7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBJbml0aWFsaXplIGEgbmV3IGJsb2NrLlxuICovXG5mdW5jdGlvbiBpbml0X2Jsb2NrKHMpIHtcbiAgdmFyIG47IC8qIGl0ZXJhdGVzIG92ZXIgdHJlZSBlbGVtZW50cyAqL1xuXG4gIC8qIEluaXRpYWxpemUgdGhlIHRyZWVzLiAqL1xuICBmb3IgKG4gPSAwOyBuIDwgTF9DT0RFUzsgIG4rKykgeyBzLmR5bl9sdHJlZVtuICogMl0vKi5GcmVxKi8gPSAwOyB9XG4gIGZvciAobiA9IDA7IG4gPCBEX0NPREVTOyAgbisrKSB7IHMuZHluX2R0cmVlW24gKiAyXS8qLkZyZXEqLyA9IDA7IH1cbiAgZm9yIChuID0gMDsgbiA8IEJMX0NPREVTOyBuKyspIHsgcy5ibF90cmVlW24gKiAyXS8qLkZyZXEqLyA9IDA7IH1cblxuICBzLmR5bl9sdHJlZVtFTkRfQkxPQ0sgKiAyXS8qLkZyZXEqLyA9IDE7XG4gIHMub3B0X2xlbiA9IHMuc3RhdGljX2xlbiA9IDA7XG4gIHMubGFzdF9saXQgPSBzLm1hdGNoZXMgPSAwO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogRmx1c2ggdGhlIGJpdCBidWZmZXIgYW5kIGFsaWduIHRoZSBvdXRwdXQgb24gYSBieXRlIGJvdW5kYXJ5XG4gKi9cbmZ1bmN0aW9uIGJpX3dpbmR1cChzKVxue1xuICBpZiAocy5iaV92YWxpZCA+IDgpIHtcbiAgICBwdXRfc2hvcnQocywgcy5iaV9idWYpO1xuICB9IGVsc2UgaWYgKHMuYmlfdmFsaWQgPiAwKSB7XG4gICAgLy9wdXRfYnl0ZShzLCAoQnl0ZSlzLT5iaV9idWYpO1xuICAgIHMucGVuZGluZ19idWZbcy5wZW5kaW5nKytdID0gcy5iaV9idWY7XG4gIH1cbiAgcy5iaV9idWYgPSAwO1xuICBzLmJpX3ZhbGlkID0gMDtcbn1cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDb3B5IGEgc3RvcmVkIGJsb2NrLCBzdG9yaW5nIGZpcnN0IHRoZSBsZW5ndGggYW5kIGl0c1xuICogb25lJ3MgY29tcGxlbWVudCBpZiByZXF1ZXN0ZWQuXG4gKi9cbmZ1bmN0aW9uIGNvcHlfYmxvY2socywgYnVmLCBsZW4sIGhlYWRlcilcbi8vRGVmbGF0ZVN0YXRlICpzO1xuLy9jaGFyZiAgICAqYnVmOyAgICAvKiB0aGUgaW5wdXQgZGF0YSAqL1xuLy91bnNpZ25lZCBsZW47ICAgICAvKiBpdHMgbGVuZ3RoICovXG4vL2ludCAgICAgIGhlYWRlcjsgIC8qIHRydWUgaWYgYmxvY2sgaGVhZGVyIG11c3QgYmUgd3JpdHRlbiAqL1xue1xuICBiaV93aW5kdXAocyk7ICAgICAgICAvKiBhbGlnbiBvbiBieXRlIGJvdW5kYXJ5ICovXG5cbiAgaWYgKGhlYWRlcikge1xuICAgIHB1dF9zaG9ydChzLCBsZW4pO1xuICAgIHB1dF9zaG9ydChzLCB+bGVuKTtcbiAgfVxuLy8gIHdoaWxlIChsZW4tLSkge1xuLy8gICAgcHV0X2J5dGUocywgKmJ1ZisrKTtcbi8vICB9XG4gIHV0aWxzLmFycmF5U2V0KHMucGVuZGluZ19idWYsIHMud2luZG93LCBidWYsIGxlbiwgcy5wZW5kaW5nKTtcbiAgcy5wZW5kaW5nICs9IGxlbjtcbn1cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDb21wYXJlcyB0byBzdWJ0cmVlcywgdXNpbmcgdGhlIHRyZWUgZGVwdGggYXMgdGllIGJyZWFrZXIgd2hlblxuICogdGhlIHN1YnRyZWVzIGhhdmUgZXF1YWwgZnJlcXVlbmN5LiBUaGlzIG1pbmltaXplcyB0aGUgd29yc3QgY2FzZSBsZW5ndGguXG4gKi9cbmZ1bmN0aW9uIHNtYWxsZXIodHJlZSwgbiwgbSwgZGVwdGgpIHtcbiAgdmFyIF9uMiA9IG4gKiAyO1xuICB2YXIgX20yID0gbSAqIDI7XG4gIHJldHVybiAodHJlZVtfbjJdLyouRnJlcSovIDwgdHJlZVtfbTJdLyouRnJlcSovIHx8XG4gICAgICAgICAodHJlZVtfbjJdLyouRnJlcSovID09PSB0cmVlW19tMl0vKi5GcmVxKi8gJiYgZGVwdGhbbl0gPD0gZGVwdGhbbV0pKTtcbn1cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBSZXN0b3JlIHRoZSBoZWFwIHByb3BlcnR5IGJ5IG1vdmluZyBkb3duIHRoZSB0cmVlIHN0YXJ0aW5nIGF0IG5vZGUgayxcbiAqIGV4Y2hhbmdpbmcgYSBub2RlIHdpdGggdGhlIHNtYWxsZXN0IG9mIGl0cyB0d28gc29ucyBpZiBuZWNlc3NhcnksIHN0b3BwaW5nXG4gKiB3aGVuIHRoZSBoZWFwIHByb3BlcnR5IGlzIHJlLWVzdGFibGlzaGVkIChlYWNoIGZhdGhlciBzbWFsbGVyIHRoYW4gaXRzXG4gKiB0d28gc29ucykuXG4gKi9cbmZ1bmN0aW9uIHBxZG93bmhlYXAocywgdHJlZSwgaylcbi8vICAgIGRlZmxhdGVfc3RhdGUgKnM7XG4vLyAgICBjdF9kYXRhICp0cmVlOyAgLyogdGhlIHRyZWUgdG8gcmVzdG9yZSAqL1xuLy8gICAgaW50IGs7ICAgICAgICAgICAgICAgLyogbm9kZSB0byBtb3ZlIGRvd24gKi9cbntcbiAgdmFyIHYgPSBzLmhlYXBba107XG4gIHZhciBqID0gayA8PCAxOyAgLyogbGVmdCBzb24gb2YgayAqL1xuICB3aGlsZSAoaiA8PSBzLmhlYXBfbGVuKSB7XG4gICAgLyogU2V0IGogdG8gdGhlIHNtYWxsZXN0IG9mIHRoZSB0d28gc29uczogKi9cbiAgICBpZiAoaiA8IHMuaGVhcF9sZW4gJiZcbiAgICAgIHNtYWxsZXIodHJlZSwgcy5oZWFwW2ogKyAxXSwgcy5oZWFwW2pdLCBzLmRlcHRoKSkge1xuICAgICAgaisrO1xuICAgIH1cbiAgICAvKiBFeGl0IGlmIHYgaXMgc21hbGxlciB0aGFuIGJvdGggc29ucyAqL1xuICAgIGlmIChzbWFsbGVyKHRyZWUsIHYsIHMuaGVhcFtqXSwgcy5kZXB0aCkpIHsgYnJlYWs7IH1cblxuICAgIC8qIEV4Y2hhbmdlIHYgd2l0aCB0aGUgc21hbGxlc3Qgc29uICovXG4gICAgcy5oZWFwW2tdID0gcy5oZWFwW2pdO1xuICAgIGsgPSBqO1xuXG4gICAgLyogQW5kIGNvbnRpbnVlIGRvd24gdGhlIHRyZWUsIHNldHRpbmcgaiB0byB0aGUgbGVmdCBzb24gb2YgayAqL1xuICAgIGogPDw9IDE7XG4gIH1cbiAgcy5oZWFwW2tdID0gdjtcbn1cblxuXG4vLyBpbmxpbmVkIG1hbnVhbGx5XG4vLyB2YXIgU01BTExFU1QgPSAxO1xuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFNlbmQgdGhlIGJsb2NrIGRhdGEgY29tcHJlc3NlZCB1c2luZyB0aGUgZ2l2ZW4gSHVmZm1hbiB0cmVlc1xuICovXG5mdW5jdGlvbiBjb21wcmVzc19ibG9jayhzLCBsdHJlZSwgZHRyZWUpXG4vLyAgICBkZWZsYXRlX3N0YXRlICpzO1xuLy8gICAgY29uc3QgY3RfZGF0YSAqbHRyZWU7IC8qIGxpdGVyYWwgdHJlZSAqL1xuLy8gICAgY29uc3QgY3RfZGF0YSAqZHRyZWU7IC8qIGRpc3RhbmNlIHRyZWUgKi9cbntcbiAgdmFyIGRpc3Q7ICAgICAgICAgICAvKiBkaXN0YW5jZSBvZiBtYXRjaGVkIHN0cmluZyAqL1xuICB2YXIgbGM7ICAgICAgICAgICAgIC8qIG1hdGNoIGxlbmd0aCBvciB1bm1hdGNoZWQgY2hhciAoaWYgZGlzdCA9PSAwKSAqL1xuICB2YXIgbHggPSAwOyAgICAgICAgIC8qIHJ1bm5pbmcgaW5kZXggaW4gbF9idWYgKi9cbiAgdmFyIGNvZGU7ICAgICAgICAgICAvKiB0aGUgY29kZSB0byBzZW5kICovXG4gIHZhciBleHRyYTsgICAgICAgICAgLyogbnVtYmVyIG9mIGV4dHJhIGJpdHMgdG8gc2VuZCAqL1xuXG4gIGlmIChzLmxhc3RfbGl0ICE9PSAwKSB7XG4gICAgZG8ge1xuICAgICAgZGlzdCA9IChzLnBlbmRpbmdfYnVmW3MuZF9idWYgKyBseCAqIDJdIDw8IDgpIHwgKHMucGVuZGluZ19idWZbcy5kX2J1ZiArIGx4ICogMiArIDFdKTtcbiAgICAgIGxjID0gcy5wZW5kaW5nX2J1ZltzLmxfYnVmICsgbHhdO1xuICAgICAgbHgrKztcblxuICAgICAgaWYgKGRpc3QgPT09IDApIHtcbiAgICAgICAgc2VuZF9jb2RlKHMsIGxjLCBsdHJlZSk7IC8qIHNlbmQgYSBsaXRlcmFsIGJ5dGUgKi9cbiAgICAgICAgLy9UcmFjZWN2KGlzZ3JhcGgobGMpLCAoc3RkZXJyLFwiICclYycgXCIsIGxjKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvKiBIZXJlLCBsYyBpcyB0aGUgbWF0Y2ggbGVuZ3RoIC0gTUlOX01BVENIICovXG4gICAgICAgIGNvZGUgPSBfbGVuZ3RoX2NvZGVbbGNdO1xuICAgICAgICBzZW5kX2NvZGUocywgY29kZSArIExJVEVSQUxTICsgMSwgbHRyZWUpOyAvKiBzZW5kIHRoZSBsZW5ndGggY29kZSAqL1xuICAgICAgICBleHRyYSA9IGV4dHJhX2xiaXRzW2NvZGVdO1xuICAgICAgICBpZiAoZXh0cmEgIT09IDApIHtcbiAgICAgICAgICBsYyAtPSBiYXNlX2xlbmd0aFtjb2RlXTtcbiAgICAgICAgICBzZW5kX2JpdHMocywgbGMsIGV4dHJhKTsgICAgICAgLyogc2VuZCB0aGUgZXh0cmEgbGVuZ3RoIGJpdHMgKi9cbiAgICAgICAgfVxuICAgICAgICBkaXN0LS07IC8qIGRpc3QgaXMgbm93IHRoZSBtYXRjaCBkaXN0YW5jZSAtIDEgKi9cbiAgICAgICAgY29kZSA9IGRfY29kZShkaXN0KTtcbiAgICAgICAgLy9Bc3NlcnQgKGNvZGUgPCBEX0NPREVTLCBcImJhZCBkX2NvZGVcIik7XG5cbiAgICAgICAgc2VuZF9jb2RlKHMsIGNvZGUsIGR0cmVlKTsgICAgICAgLyogc2VuZCB0aGUgZGlzdGFuY2UgY29kZSAqL1xuICAgICAgICBleHRyYSA9IGV4dHJhX2RiaXRzW2NvZGVdO1xuICAgICAgICBpZiAoZXh0cmEgIT09IDApIHtcbiAgICAgICAgICBkaXN0IC09IGJhc2VfZGlzdFtjb2RlXTtcbiAgICAgICAgICBzZW5kX2JpdHMocywgZGlzdCwgZXh0cmEpOyAgIC8qIHNlbmQgdGhlIGV4dHJhIGRpc3RhbmNlIGJpdHMgKi9cbiAgICAgICAgfVxuICAgICAgfSAvKiBsaXRlcmFsIG9yIG1hdGNoIHBhaXIgPyAqL1xuXG4gICAgICAvKiBDaGVjayB0aGF0IHRoZSBvdmVybGF5IGJldHdlZW4gcGVuZGluZ19idWYgYW5kIGRfYnVmK2xfYnVmIGlzIG9rOiAqL1xuICAgICAgLy9Bc3NlcnQoKHVJbnQpKHMtPnBlbmRpbmcpIDwgcy0+bGl0X2J1ZnNpemUgKyAyKmx4LFxuICAgICAgLy8gICAgICAgXCJwZW5kaW5nQnVmIG92ZXJmbG93XCIpO1xuXG4gICAgfSB3aGlsZSAobHggPCBzLmxhc3RfbGl0KTtcbiAgfVxuXG4gIHNlbmRfY29kZShzLCBFTkRfQkxPQ0ssIGx0cmVlKTtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENvbnN0cnVjdCBvbmUgSHVmZm1hbiB0cmVlIGFuZCBhc3NpZ25zIHRoZSBjb2RlIGJpdCBzdHJpbmdzIGFuZCBsZW5ndGhzLlxuICogVXBkYXRlIHRoZSB0b3RhbCBiaXQgbGVuZ3RoIGZvciB0aGUgY3VycmVudCBibG9jay5cbiAqIElOIGFzc2VydGlvbjogdGhlIGZpZWxkIGZyZXEgaXMgc2V0IGZvciBhbGwgdHJlZSBlbGVtZW50cy5cbiAqIE9VVCBhc3NlcnRpb25zOiB0aGUgZmllbGRzIGxlbiBhbmQgY29kZSBhcmUgc2V0IHRvIHRoZSBvcHRpbWFsIGJpdCBsZW5ndGhcbiAqICAgICBhbmQgY29ycmVzcG9uZGluZyBjb2RlLiBUaGUgbGVuZ3RoIG9wdF9sZW4gaXMgdXBkYXRlZDsgc3RhdGljX2xlbiBpc1xuICogICAgIGFsc28gdXBkYXRlZCBpZiBzdHJlZSBpcyBub3QgbnVsbC4gVGhlIGZpZWxkIG1heF9jb2RlIGlzIHNldC5cbiAqL1xuZnVuY3Rpb24gYnVpbGRfdHJlZShzLCBkZXNjKVxuLy8gICAgZGVmbGF0ZV9zdGF0ZSAqcztcbi8vICAgIHRyZWVfZGVzYyAqZGVzYzsgLyogdGhlIHRyZWUgZGVzY3JpcHRvciAqL1xue1xuICB2YXIgdHJlZSAgICAgPSBkZXNjLmR5bl90cmVlO1xuICB2YXIgc3RyZWUgICAgPSBkZXNjLnN0YXRfZGVzYy5zdGF0aWNfdHJlZTtcbiAgdmFyIGhhc19zdHJlZSA9IGRlc2Muc3RhdF9kZXNjLmhhc19zdHJlZTtcbiAgdmFyIGVsZW1zICAgID0gZGVzYy5zdGF0X2Rlc2MuZWxlbXM7XG4gIHZhciBuLCBtOyAgICAgICAgICAvKiBpdGVyYXRlIG92ZXIgaGVhcCBlbGVtZW50cyAqL1xuICB2YXIgbWF4X2NvZGUgPSAtMTsgLyogbGFyZ2VzdCBjb2RlIHdpdGggbm9uIHplcm8gZnJlcXVlbmN5ICovXG4gIHZhciBub2RlOyAgICAgICAgICAvKiBuZXcgbm9kZSBiZWluZyBjcmVhdGVkICovXG5cbiAgLyogQ29uc3RydWN0IHRoZSBpbml0aWFsIGhlYXAsIHdpdGggbGVhc3QgZnJlcXVlbnQgZWxlbWVudCBpblxuICAgKiBoZWFwW1NNQUxMRVNUXS4gVGhlIHNvbnMgb2YgaGVhcFtuXSBhcmUgaGVhcFsyKm5dIGFuZCBoZWFwWzIqbisxXS5cbiAgICogaGVhcFswXSBpcyBub3QgdXNlZC5cbiAgICovXG4gIHMuaGVhcF9sZW4gPSAwO1xuICBzLmhlYXBfbWF4ID0gSEVBUF9TSVpFO1xuXG4gIGZvciAobiA9IDA7IG4gPCBlbGVtczsgbisrKSB7XG4gICAgaWYgKHRyZWVbbiAqIDJdLyouRnJlcSovICE9PSAwKSB7XG4gICAgICBzLmhlYXBbKytzLmhlYXBfbGVuXSA9IG1heF9jb2RlID0gbjtcbiAgICAgIHMuZGVwdGhbbl0gPSAwO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgIHRyZWVbbiAqIDIgKyAxXS8qLkxlbiovID0gMDtcbiAgICB9XG4gIH1cblxuICAvKiBUaGUgcGt6aXAgZm9ybWF0IHJlcXVpcmVzIHRoYXQgYXQgbGVhc3Qgb25lIGRpc3RhbmNlIGNvZGUgZXhpc3RzLFxuICAgKiBhbmQgdGhhdCBhdCBsZWFzdCBvbmUgYml0IHNob3VsZCBiZSBzZW50IGV2ZW4gaWYgdGhlcmUgaXMgb25seSBvbmVcbiAgICogcG9zc2libGUgY29kZS4gU28gdG8gYXZvaWQgc3BlY2lhbCBjaGVja3MgbGF0ZXIgb24gd2UgZm9yY2UgYXQgbGVhc3RcbiAgICogdHdvIGNvZGVzIG9mIG5vbiB6ZXJvIGZyZXF1ZW5jeS5cbiAgICovXG4gIHdoaWxlIChzLmhlYXBfbGVuIDwgMikge1xuICAgIG5vZGUgPSBzLmhlYXBbKytzLmhlYXBfbGVuXSA9IChtYXhfY29kZSA8IDIgPyArK21heF9jb2RlIDogMCk7XG4gICAgdHJlZVtub2RlICogMl0vKi5GcmVxKi8gPSAxO1xuICAgIHMuZGVwdGhbbm9kZV0gPSAwO1xuICAgIHMub3B0X2xlbi0tO1xuXG4gICAgaWYgKGhhc19zdHJlZSkge1xuICAgICAgcy5zdGF0aWNfbGVuIC09IHN0cmVlW25vZGUgKiAyICsgMV0vKi5MZW4qLztcbiAgICB9XG4gICAgLyogbm9kZSBpcyAwIG9yIDEgc28gaXQgZG9lcyBub3QgaGF2ZSBleHRyYSBiaXRzICovXG4gIH1cbiAgZGVzYy5tYXhfY29kZSA9IG1heF9jb2RlO1xuXG4gIC8qIFRoZSBlbGVtZW50cyBoZWFwW2hlYXBfbGVuLzIrMSAuLiBoZWFwX2xlbl0gYXJlIGxlYXZlcyBvZiB0aGUgdHJlZSxcbiAgICogZXN0YWJsaXNoIHN1Yi1oZWFwcyBvZiBpbmNyZWFzaW5nIGxlbmd0aHM6XG4gICAqL1xuICBmb3IgKG4gPSAocy5oZWFwX2xlbiA+PiAxLyppbnQgLzIqLyk7IG4gPj0gMTsgbi0tKSB7IHBxZG93bmhlYXAocywgdHJlZSwgbik7IH1cblxuICAvKiBDb25zdHJ1Y3QgdGhlIEh1ZmZtYW4gdHJlZSBieSByZXBlYXRlZGx5IGNvbWJpbmluZyB0aGUgbGVhc3QgdHdvXG4gICAqIGZyZXF1ZW50IG5vZGVzLlxuICAgKi9cbiAgbm9kZSA9IGVsZW1zOyAgICAgICAgICAgICAgLyogbmV4dCBpbnRlcm5hbCBub2RlIG9mIHRoZSB0cmVlICovXG4gIGRvIHtcbiAgICAvL3BxcmVtb3ZlKHMsIHRyZWUsIG4pOyAgLyogbiA9IG5vZGUgb2YgbGVhc3QgZnJlcXVlbmN5ICovXG4gICAgLyoqKiBwcXJlbW92ZSAqKiovXG4gICAgbiA9IHMuaGVhcFsxLypTTUFMTEVTVCovXTtcbiAgICBzLmhlYXBbMS8qU01BTExFU1QqL10gPSBzLmhlYXBbcy5oZWFwX2xlbi0tXTtcbiAgICBwcWRvd25oZWFwKHMsIHRyZWUsIDEvKlNNQUxMRVNUKi8pO1xuICAgIC8qKiovXG5cbiAgICBtID0gcy5oZWFwWzEvKlNNQUxMRVNUKi9dOyAvKiBtID0gbm9kZSBvZiBuZXh0IGxlYXN0IGZyZXF1ZW5jeSAqL1xuXG4gICAgcy5oZWFwWy0tcy5oZWFwX21heF0gPSBuOyAvKiBrZWVwIHRoZSBub2RlcyBzb3J0ZWQgYnkgZnJlcXVlbmN5ICovXG4gICAgcy5oZWFwWy0tcy5oZWFwX21heF0gPSBtO1xuXG4gICAgLyogQ3JlYXRlIGEgbmV3IG5vZGUgZmF0aGVyIG9mIG4gYW5kIG0gKi9cbiAgICB0cmVlW25vZGUgKiAyXS8qLkZyZXEqLyA9IHRyZWVbbiAqIDJdLyouRnJlcSovICsgdHJlZVttICogMl0vKi5GcmVxKi87XG4gICAgcy5kZXB0aFtub2RlXSA9IChzLmRlcHRoW25dID49IHMuZGVwdGhbbV0gPyBzLmRlcHRoW25dIDogcy5kZXB0aFttXSkgKyAxO1xuICAgIHRyZWVbbiAqIDIgKyAxXS8qLkRhZCovID0gdHJlZVttICogMiArIDFdLyouRGFkKi8gPSBub2RlO1xuXG4gICAgLyogYW5kIGluc2VydCB0aGUgbmV3IG5vZGUgaW4gdGhlIGhlYXAgKi9cbiAgICBzLmhlYXBbMS8qU01BTExFU1QqL10gPSBub2RlKys7XG4gICAgcHFkb3duaGVhcChzLCB0cmVlLCAxLypTTUFMTEVTVCovKTtcblxuICB9IHdoaWxlIChzLmhlYXBfbGVuID49IDIpO1xuXG4gIHMuaGVhcFstLXMuaGVhcF9tYXhdID0gcy5oZWFwWzEvKlNNQUxMRVNUKi9dO1xuXG4gIC8qIEF0IHRoaXMgcG9pbnQsIHRoZSBmaWVsZHMgZnJlcSBhbmQgZGFkIGFyZSBzZXQuIFdlIGNhbiBub3dcbiAgICogZ2VuZXJhdGUgdGhlIGJpdCBsZW5ndGhzLlxuICAgKi9cbiAgZ2VuX2JpdGxlbihzLCBkZXNjKTtcblxuICAvKiBUaGUgZmllbGQgbGVuIGlzIG5vdyBzZXQsIHdlIGNhbiBnZW5lcmF0ZSB0aGUgYml0IGNvZGVzICovXG4gIGdlbl9jb2Rlcyh0cmVlLCBtYXhfY29kZSwgcy5ibF9jb3VudCk7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBTY2FuIGEgbGl0ZXJhbCBvciBkaXN0YW5jZSB0cmVlIHRvIGRldGVybWluZSB0aGUgZnJlcXVlbmNpZXMgb2YgdGhlIGNvZGVzXG4gKiBpbiB0aGUgYml0IGxlbmd0aCB0cmVlLlxuICovXG5mdW5jdGlvbiBzY2FuX3RyZWUocywgdHJlZSwgbWF4X2NvZGUpXG4vLyAgICBkZWZsYXRlX3N0YXRlICpzO1xuLy8gICAgY3RfZGF0YSAqdHJlZTsgICAvKiB0aGUgdHJlZSB0byBiZSBzY2FubmVkICovXG4vLyAgICBpbnQgbWF4X2NvZGU7ICAgIC8qIGFuZCBpdHMgbGFyZ2VzdCBjb2RlIG9mIG5vbiB6ZXJvIGZyZXF1ZW5jeSAqL1xue1xuICB2YXIgbjsgICAgICAgICAgICAgICAgICAgICAvKiBpdGVyYXRlcyBvdmVyIGFsbCB0cmVlIGVsZW1lbnRzICovXG4gIHZhciBwcmV2bGVuID0gLTE7ICAgICAgICAgIC8qIGxhc3QgZW1pdHRlZCBsZW5ndGggKi9cbiAgdmFyIGN1cmxlbjsgICAgICAgICAgICAgICAgLyogbGVuZ3RoIG9mIGN1cnJlbnQgY29kZSAqL1xuXG4gIHZhciBuZXh0bGVuID0gdHJlZVswICogMiArIDFdLyouTGVuKi87IC8qIGxlbmd0aCBvZiBuZXh0IGNvZGUgKi9cblxuICB2YXIgY291bnQgPSAwOyAgICAgICAgICAgICAvKiByZXBlYXQgY291bnQgb2YgdGhlIGN1cnJlbnQgY29kZSAqL1xuICB2YXIgbWF4X2NvdW50ID0gNzsgICAgICAgICAvKiBtYXggcmVwZWF0IGNvdW50ICovXG4gIHZhciBtaW5fY291bnQgPSA0OyAgICAgICAgIC8qIG1pbiByZXBlYXQgY291bnQgKi9cblxuICBpZiAobmV4dGxlbiA9PT0gMCkge1xuICAgIG1heF9jb3VudCA9IDEzODtcbiAgICBtaW5fY291bnQgPSAzO1xuICB9XG4gIHRyZWVbKG1heF9jb2RlICsgMSkgKiAyICsgMV0vKi5MZW4qLyA9IDB4ZmZmZjsgLyogZ3VhcmQgKi9cblxuICBmb3IgKG4gPSAwOyBuIDw9IG1heF9jb2RlOyBuKyspIHtcbiAgICBjdXJsZW4gPSBuZXh0bGVuO1xuICAgIG5leHRsZW4gPSB0cmVlWyhuICsgMSkgKiAyICsgMV0vKi5MZW4qLztcblxuICAgIGlmICgrK2NvdW50IDwgbWF4X2NvdW50ICYmIGN1cmxlbiA9PT0gbmV4dGxlbikge1xuICAgICAgY29udGludWU7XG5cbiAgICB9IGVsc2UgaWYgKGNvdW50IDwgbWluX2NvdW50KSB7XG4gICAgICBzLmJsX3RyZWVbY3VybGVuICogMl0vKi5GcmVxKi8gKz0gY291bnQ7XG5cbiAgICB9IGVsc2UgaWYgKGN1cmxlbiAhPT0gMCkge1xuXG4gICAgICBpZiAoY3VybGVuICE9PSBwcmV2bGVuKSB7IHMuYmxfdHJlZVtjdXJsZW4gKiAyXS8qLkZyZXEqLysrOyB9XG4gICAgICBzLmJsX3RyZWVbUkVQXzNfNiAqIDJdLyouRnJlcSovKys7XG5cbiAgICB9IGVsc2UgaWYgKGNvdW50IDw9IDEwKSB7XG4gICAgICBzLmJsX3RyZWVbUkVQWl8zXzEwICogMl0vKi5GcmVxKi8rKztcblxuICAgIH0gZWxzZSB7XG4gICAgICBzLmJsX3RyZWVbUkVQWl8xMV8xMzggKiAyXS8qLkZyZXEqLysrO1xuICAgIH1cblxuICAgIGNvdW50ID0gMDtcbiAgICBwcmV2bGVuID0gY3VybGVuO1xuXG4gICAgaWYgKG5leHRsZW4gPT09IDApIHtcbiAgICAgIG1heF9jb3VudCA9IDEzODtcbiAgICAgIG1pbl9jb3VudCA9IDM7XG5cbiAgICB9IGVsc2UgaWYgKGN1cmxlbiA9PT0gbmV4dGxlbikge1xuICAgICAgbWF4X2NvdW50ID0gNjtcbiAgICAgIG1pbl9jb3VudCA9IDM7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgbWF4X2NvdW50ID0gNztcbiAgICAgIG1pbl9jb3VudCA9IDQ7XG4gICAgfVxuICB9XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBTZW5kIGEgbGl0ZXJhbCBvciBkaXN0YW5jZSB0cmVlIGluIGNvbXByZXNzZWQgZm9ybSwgdXNpbmcgdGhlIGNvZGVzIGluXG4gKiBibF90cmVlLlxuICovXG5mdW5jdGlvbiBzZW5kX3RyZWUocywgdHJlZSwgbWF4X2NvZGUpXG4vLyAgICBkZWZsYXRlX3N0YXRlICpzO1xuLy8gICAgY3RfZGF0YSAqdHJlZTsgLyogdGhlIHRyZWUgdG8gYmUgc2Nhbm5lZCAqL1xuLy8gICAgaW50IG1heF9jb2RlOyAgICAgICAvKiBhbmQgaXRzIGxhcmdlc3QgY29kZSBvZiBub24gemVybyBmcmVxdWVuY3kgKi9cbntcbiAgdmFyIG47ICAgICAgICAgICAgICAgICAgICAgLyogaXRlcmF0ZXMgb3ZlciBhbGwgdHJlZSBlbGVtZW50cyAqL1xuICB2YXIgcHJldmxlbiA9IC0xOyAgICAgICAgICAvKiBsYXN0IGVtaXR0ZWQgbGVuZ3RoICovXG4gIHZhciBjdXJsZW47ICAgICAgICAgICAgICAgIC8qIGxlbmd0aCBvZiBjdXJyZW50IGNvZGUgKi9cblxuICB2YXIgbmV4dGxlbiA9IHRyZWVbMCAqIDIgKyAxXS8qLkxlbiovOyAvKiBsZW5ndGggb2YgbmV4dCBjb2RlICovXG5cbiAgdmFyIGNvdW50ID0gMDsgICAgICAgICAgICAgLyogcmVwZWF0IGNvdW50IG9mIHRoZSBjdXJyZW50IGNvZGUgKi9cbiAgdmFyIG1heF9jb3VudCA9IDc7ICAgICAgICAgLyogbWF4IHJlcGVhdCBjb3VudCAqL1xuICB2YXIgbWluX2NvdW50ID0gNDsgICAgICAgICAvKiBtaW4gcmVwZWF0IGNvdW50ICovXG5cbiAgLyogdHJlZVttYXhfY29kZSsxXS5MZW4gPSAtMTsgKi8gIC8qIGd1YXJkIGFscmVhZHkgc2V0ICovXG4gIGlmIChuZXh0bGVuID09PSAwKSB7XG4gICAgbWF4X2NvdW50ID0gMTM4O1xuICAgIG1pbl9jb3VudCA9IDM7XG4gIH1cblxuICBmb3IgKG4gPSAwOyBuIDw9IG1heF9jb2RlOyBuKyspIHtcbiAgICBjdXJsZW4gPSBuZXh0bGVuO1xuICAgIG5leHRsZW4gPSB0cmVlWyhuICsgMSkgKiAyICsgMV0vKi5MZW4qLztcblxuICAgIGlmICgrK2NvdW50IDwgbWF4X2NvdW50ICYmIGN1cmxlbiA9PT0gbmV4dGxlbikge1xuICAgICAgY29udGludWU7XG5cbiAgICB9IGVsc2UgaWYgKGNvdW50IDwgbWluX2NvdW50KSB7XG4gICAgICBkbyB7IHNlbmRfY29kZShzLCBjdXJsZW4sIHMuYmxfdHJlZSk7IH0gd2hpbGUgKC0tY291bnQgIT09IDApO1xuXG4gICAgfSBlbHNlIGlmIChjdXJsZW4gIT09IDApIHtcbiAgICAgIGlmIChjdXJsZW4gIT09IHByZXZsZW4pIHtcbiAgICAgICAgc2VuZF9jb2RlKHMsIGN1cmxlbiwgcy5ibF90cmVlKTtcbiAgICAgICAgY291bnQtLTtcbiAgICAgIH1cbiAgICAgIC8vQXNzZXJ0KGNvdW50ID49IDMgJiYgY291bnQgPD0gNiwgXCIgM182P1wiKTtcbiAgICAgIHNlbmRfY29kZShzLCBSRVBfM182LCBzLmJsX3RyZWUpO1xuICAgICAgc2VuZF9iaXRzKHMsIGNvdW50IC0gMywgMik7XG5cbiAgICB9IGVsc2UgaWYgKGNvdW50IDw9IDEwKSB7XG4gICAgICBzZW5kX2NvZGUocywgUkVQWl8zXzEwLCBzLmJsX3RyZWUpO1xuICAgICAgc2VuZF9iaXRzKHMsIGNvdW50IC0gMywgMyk7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgc2VuZF9jb2RlKHMsIFJFUFpfMTFfMTM4LCBzLmJsX3RyZWUpO1xuICAgICAgc2VuZF9iaXRzKHMsIGNvdW50IC0gMTEsIDcpO1xuICAgIH1cblxuICAgIGNvdW50ID0gMDtcbiAgICBwcmV2bGVuID0gY3VybGVuO1xuICAgIGlmIChuZXh0bGVuID09PSAwKSB7XG4gICAgICBtYXhfY291bnQgPSAxMzg7XG4gICAgICBtaW5fY291bnQgPSAzO1xuXG4gICAgfSBlbHNlIGlmIChjdXJsZW4gPT09IG5leHRsZW4pIHtcbiAgICAgIG1heF9jb3VudCA9IDY7XG4gICAgICBtaW5fY291bnQgPSAzO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgIG1heF9jb3VudCA9IDc7XG4gICAgICBtaW5fY291bnQgPSA0O1xuICAgIH1cbiAgfVxufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ29uc3RydWN0IHRoZSBIdWZmbWFuIHRyZWUgZm9yIHRoZSBiaXQgbGVuZ3RocyBhbmQgcmV0dXJuIHRoZSBpbmRleCBpblxuICogYmxfb3JkZXIgb2YgdGhlIGxhc3QgYml0IGxlbmd0aCBjb2RlIHRvIHNlbmQuXG4gKi9cbmZ1bmN0aW9uIGJ1aWxkX2JsX3RyZWUocykge1xuICB2YXIgbWF4X2JsaW5kZXg7ICAvKiBpbmRleCBvZiBsYXN0IGJpdCBsZW5ndGggY29kZSBvZiBub24gemVybyBmcmVxICovXG5cbiAgLyogRGV0ZXJtaW5lIHRoZSBiaXQgbGVuZ3RoIGZyZXF1ZW5jaWVzIGZvciBsaXRlcmFsIGFuZCBkaXN0YW5jZSB0cmVlcyAqL1xuICBzY2FuX3RyZWUocywgcy5keW5fbHRyZWUsIHMubF9kZXNjLm1heF9jb2RlKTtcbiAgc2Nhbl90cmVlKHMsIHMuZHluX2R0cmVlLCBzLmRfZGVzYy5tYXhfY29kZSk7XG5cbiAgLyogQnVpbGQgdGhlIGJpdCBsZW5ndGggdHJlZTogKi9cbiAgYnVpbGRfdHJlZShzLCBzLmJsX2Rlc2MpO1xuICAvKiBvcHRfbGVuIG5vdyBpbmNsdWRlcyB0aGUgbGVuZ3RoIG9mIHRoZSB0cmVlIHJlcHJlc2VudGF0aW9ucywgZXhjZXB0XG4gICAqIHRoZSBsZW5ndGhzIG9mIHRoZSBiaXQgbGVuZ3RocyBjb2RlcyBhbmQgdGhlIDUrNSs0IGJpdHMgZm9yIHRoZSBjb3VudHMuXG4gICAqL1xuXG4gIC8qIERldGVybWluZSB0aGUgbnVtYmVyIG9mIGJpdCBsZW5ndGggY29kZXMgdG8gc2VuZC4gVGhlIHBremlwIGZvcm1hdFxuICAgKiByZXF1aXJlcyB0aGF0IGF0IGxlYXN0IDQgYml0IGxlbmd0aCBjb2RlcyBiZSBzZW50LiAoYXBwbm90ZS50eHQgc2F5c1xuICAgKiAzIGJ1dCB0aGUgYWN0dWFsIHZhbHVlIHVzZWQgaXMgNC4pXG4gICAqL1xuICBmb3IgKG1heF9ibGluZGV4ID0gQkxfQ09ERVMgLSAxOyBtYXhfYmxpbmRleCA+PSAzOyBtYXhfYmxpbmRleC0tKSB7XG4gICAgaWYgKHMuYmxfdHJlZVtibF9vcmRlclttYXhfYmxpbmRleF0gKiAyICsgMV0vKi5MZW4qLyAhPT0gMCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIC8qIFVwZGF0ZSBvcHRfbGVuIHRvIGluY2x1ZGUgdGhlIGJpdCBsZW5ndGggdHJlZSBhbmQgY291bnRzICovXG4gIHMub3B0X2xlbiArPSAzICogKG1heF9ibGluZGV4ICsgMSkgKyA1ICsgNSArIDQ7XG4gIC8vVHJhY2V2KChzdGRlcnIsIFwiXFxuZHluIHRyZWVzOiBkeW4gJWxkLCBzdGF0ICVsZFwiLFxuICAvLyAgICAgICAgcy0+b3B0X2xlbiwgcy0+c3RhdGljX2xlbikpO1xuXG4gIHJldHVybiBtYXhfYmxpbmRleDtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFNlbmQgdGhlIGhlYWRlciBmb3IgYSBibG9jayB1c2luZyBkeW5hbWljIEh1ZmZtYW4gdHJlZXM6IHRoZSBjb3VudHMsIHRoZVxuICogbGVuZ3RocyBvZiB0aGUgYml0IGxlbmd0aCBjb2RlcywgdGhlIGxpdGVyYWwgdHJlZSBhbmQgdGhlIGRpc3RhbmNlIHRyZWUuXG4gKiBJTiBhc3NlcnRpb246IGxjb2RlcyA+PSAyNTcsIGRjb2RlcyA+PSAxLCBibGNvZGVzID49IDQuXG4gKi9cbmZ1bmN0aW9uIHNlbmRfYWxsX3RyZWVzKHMsIGxjb2RlcywgZGNvZGVzLCBibGNvZGVzKVxuLy8gICAgZGVmbGF0ZV9zdGF0ZSAqcztcbi8vICAgIGludCBsY29kZXMsIGRjb2RlcywgYmxjb2RlczsgLyogbnVtYmVyIG9mIGNvZGVzIGZvciBlYWNoIHRyZWUgKi9cbntcbiAgdmFyIHJhbms7ICAgICAgICAgICAgICAgICAgICAvKiBpbmRleCBpbiBibF9vcmRlciAqL1xuXG4gIC8vQXNzZXJ0IChsY29kZXMgPj0gMjU3ICYmIGRjb2RlcyA+PSAxICYmIGJsY29kZXMgPj0gNCwgXCJub3QgZW5vdWdoIGNvZGVzXCIpO1xuICAvL0Fzc2VydCAobGNvZGVzIDw9IExfQ09ERVMgJiYgZGNvZGVzIDw9IERfQ09ERVMgJiYgYmxjb2RlcyA8PSBCTF9DT0RFUyxcbiAgLy8gICAgICAgIFwidG9vIG1hbnkgY29kZXNcIik7XG4gIC8vVHJhY2V2KChzdGRlcnIsIFwiXFxuYmwgY291bnRzOiBcIikpO1xuICBzZW5kX2JpdHMocywgbGNvZGVzIC0gMjU3LCA1KTsgLyogbm90ICsyNTUgYXMgc3RhdGVkIGluIGFwcG5vdGUudHh0ICovXG4gIHNlbmRfYml0cyhzLCBkY29kZXMgLSAxLCAgIDUpO1xuICBzZW5kX2JpdHMocywgYmxjb2RlcyAtIDQsICA0KTsgLyogbm90IC0zIGFzIHN0YXRlZCBpbiBhcHBub3RlLnR4dCAqL1xuICBmb3IgKHJhbmsgPSAwOyByYW5rIDwgYmxjb2RlczsgcmFuaysrKSB7XG4gICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJcXG5ibCBjb2RlICUyZCBcIiwgYmxfb3JkZXJbcmFua10pKTtcbiAgICBzZW5kX2JpdHMocywgcy5ibF90cmVlW2JsX29yZGVyW3JhbmtdICogMiArIDFdLyouTGVuKi8sIDMpO1xuICB9XG4gIC8vVHJhY2V2KChzdGRlcnIsIFwiXFxuYmwgdHJlZTogc2VudCAlbGRcIiwgcy0+Yml0c19zZW50KSk7XG5cbiAgc2VuZF90cmVlKHMsIHMuZHluX2x0cmVlLCBsY29kZXMgLSAxKTsgLyogbGl0ZXJhbCB0cmVlICovXG4gIC8vVHJhY2V2KChzdGRlcnIsIFwiXFxubGl0IHRyZWU6IHNlbnQgJWxkXCIsIHMtPmJpdHNfc2VudCkpO1xuXG4gIHNlbmRfdHJlZShzLCBzLmR5bl9kdHJlZSwgZGNvZGVzIC0gMSk7IC8qIGRpc3RhbmNlIHRyZWUgKi9cbiAgLy9UcmFjZXYoKHN0ZGVyciwgXCJcXG5kaXN0IHRyZWU6IHNlbnQgJWxkXCIsIHMtPmJpdHNfc2VudCkpO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ2hlY2sgaWYgdGhlIGRhdGEgdHlwZSBpcyBURVhUIG9yIEJJTkFSWSwgdXNpbmcgdGhlIGZvbGxvd2luZyBhbGdvcml0aG06XG4gKiAtIFRFWFQgaWYgdGhlIHR3byBjb25kaXRpb25zIGJlbG93IGFyZSBzYXRpc2ZpZWQ6XG4gKiAgICBhKSBUaGVyZSBhcmUgbm8gbm9uLXBvcnRhYmxlIGNvbnRyb2wgY2hhcmFjdGVycyBiZWxvbmdpbmcgdG8gdGhlXG4gKiAgICAgICBcImJsYWNrIGxpc3RcIiAoMC4uNiwgMTQuLjI1LCAyOC4uMzEpLlxuICogICAgYikgVGhlcmUgaXMgYXQgbGVhc3Qgb25lIHByaW50YWJsZSBjaGFyYWN0ZXIgYmVsb25naW5nIHRvIHRoZVxuICogICAgICAgXCJ3aGl0ZSBsaXN0XCIgKDkge1RBQn0sIDEwIHtMRn0sIDEzIHtDUn0sIDMyLi4yNTUpLlxuICogLSBCSU5BUlkgb3RoZXJ3aXNlLlxuICogLSBUaGUgZm9sbG93aW5nIHBhcnRpYWxseS1wb3J0YWJsZSBjb250cm9sIGNoYXJhY3RlcnMgZm9ybSBhXG4gKiAgIFwiZ3JheSBsaXN0XCIgdGhhdCBpcyBpZ25vcmVkIGluIHRoaXMgZGV0ZWN0aW9uIGFsZ29yaXRobTpcbiAqICAgKDcge0JFTH0sIDgge0JTfSwgMTEge1ZUfSwgMTIge0ZGfSwgMjYge1NVQn0sIDI3IHtFU0N9KS5cbiAqIElOIGFzc2VydGlvbjogdGhlIGZpZWxkcyBGcmVxIG9mIGR5bl9sdHJlZSBhcmUgc2V0LlxuICovXG5mdW5jdGlvbiBkZXRlY3RfZGF0YV90eXBlKHMpIHtcbiAgLyogYmxhY2tfbWFzayBpcyB0aGUgYml0IG1hc2sgb2YgYmxhY2stbGlzdGVkIGJ5dGVzXG4gICAqIHNldCBiaXRzIDAuLjYsIDE0Li4yNSwgYW5kIDI4Li4zMVxuICAgKiAweGYzZmZjMDdmID0gYmluYXJ5IDExMTEwMDExMTExMTExMTExMTAwMDAwMDAxMTExMTExXG4gICAqL1xuICB2YXIgYmxhY2tfbWFzayA9IDB4ZjNmZmMwN2Y7XG4gIHZhciBuO1xuXG4gIC8qIENoZWNrIGZvciBub24tdGV4dHVhbCAoXCJibGFjay1saXN0ZWRcIikgYnl0ZXMuICovXG4gIGZvciAobiA9IDA7IG4gPD0gMzE7IG4rKywgYmxhY2tfbWFzayA+Pj49IDEpIHtcbiAgICBpZiAoKGJsYWNrX21hc2sgJiAxKSAmJiAocy5keW5fbHRyZWVbbiAqIDJdLyouRnJlcSovICE9PSAwKSkge1xuICAgICAgcmV0dXJuIFpfQklOQVJZO1xuICAgIH1cbiAgfVxuXG4gIC8qIENoZWNrIGZvciB0ZXh0dWFsIChcIndoaXRlLWxpc3RlZFwiKSBieXRlcy4gKi9cbiAgaWYgKHMuZHluX2x0cmVlWzkgKiAyXS8qLkZyZXEqLyAhPT0gMCB8fCBzLmR5bl9sdHJlZVsxMCAqIDJdLyouRnJlcSovICE9PSAwIHx8XG4gICAgICBzLmR5bl9sdHJlZVsxMyAqIDJdLyouRnJlcSovICE9PSAwKSB7XG4gICAgcmV0dXJuIFpfVEVYVDtcbiAgfVxuICBmb3IgKG4gPSAzMjsgbiA8IExJVEVSQUxTOyBuKyspIHtcbiAgICBpZiAocy5keW5fbHRyZWVbbiAqIDJdLyouRnJlcSovICE9PSAwKSB7XG4gICAgICByZXR1cm4gWl9URVhUO1xuICAgIH1cbiAgfVxuXG4gIC8qIFRoZXJlIGFyZSBubyBcImJsYWNrLWxpc3RlZFwiIG9yIFwid2hpdGUtbGlzdGVkXCIgYnl0ZXM6XG4gICAqIHRoaXMgc3RyZWFtIGVpdGhlciBpcyBlbXB0eSBvciBoYXMgdG9sZXJhdGVkIChcImdyYXktbGlzdGVkXCIpIGJ5dGVzIG9ubHkuXG4gICAqL1xuICByZXR1cm4gWl9CSU5BUlk7XG59XG5cblxudmFyIHN0YXRpY19pbml0X2RvbmUgPSBmYWxzZTtcblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBJbml0aWFsaXplIHRoZSB0cmVlIGRhdGEgc3RydWN0dXJlcyBmb3IgYSBuZXcgemxpYiBzdHJlYW0uXG4gKi9cbmZ1bmN0aW9uIF90cl9pbml0KHMpXG57XG5cbiAgaWYgKCFzdGF0aWNfaW5pdF9kb25lKSB7XG4gICAgdHJfc3RhdGljX2luaXQoKTtcbiAgICBzdGF0aWNfaW5pdF9kb25lID0gdHJ1ZTtcbiAgfVxuXG4gIHMubF9kZXNjICA9IG5ldyBUcmVlRGVzYyhzLmR5bl9sdHJlZSwgc3RhdGljX2xfZGVzYyk7XG4gIHMuZF9kZXNjICA9IG5ldyBUcmVlRGVzYyhzLmR5bl9kdHJlZSwgc3RhdGljX2RfZGVzYyk7XG4gIHMuYmxfZGVzYyA9IG5ldyBUcmVlRGVzYyhzLmJsX3RyZWUsIHN0YXRpY19ibF9kZXNjKTtcblxuICBzLmJpX2J1ZiA9IDA7XG4gIHMuYmlfdmFsaWQgPSAwO1xuXG4gIC8qIEluaXRpYWxpemUgdGhlIGZpcnN0IGJsb2NrIG9mIHRoZSBmaXJzdCBmaWxlOiAqL1xuICBpbml0X2Jsb2NrKHMpO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogU2VuZCBhIHN0b3JlZCBibG9ja1xuICovXG5mdW5jdGlvbiBfdHJfc3RvcmVkX2Jsb2NrKHMsIGJ1Ziwgc3RvcmVkX2xlbiwgbGFzdClcbi8vRGVmbGF0ZVN0YXRlICpzO1xuLy9jaGFyZiAqYnVmOyAgICAgICAvKiBpbnB1dCBibG9jayAqL1xuLy91bGcgc3RvcmVkX2xlbjsgICAvKiBsZW5ndGggb2YgaW5wdXQgYmxvY2sgKi9cbi8vaW50IGxhc3Q7ICAgICAgICAgLyogb25lIGlmIHRoaXMgaXMgdGhlIGxhc3QgYmxvY2sgZm9yIGEgZmlsZSAqL1xue1xuICBzZW5kX2JpdHMocywgKFNUT1JFRF9CTE9DSyA8PCAxKSArIChsYXN0ID8gMSA6IDApLCAzKTsgICAgLyogc2VuZCBibG9jayB0eXBlICovXG4gIGNvcHlfYmxvY2socywgYnVmLCBzdG9yZWRfbGVuLCB0cnVlKTsgLyogd2l0aCBoZWFkZXIgKi9cbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFNlbmQgb25lIGVtcHR5IHN0YXRpYyBibG9jayB0byBnaXZlIGVub3VnaCBsb29rYWhlYWQgZm9yIGluZmxhdGUuXG4gKiBUaGlzIHRha2VzIDEwIGJpdHMsIG9mIHdoaWNoIDcgbWF5IHJlbWFpbiBpbiB0aGUgYml0IGJ1ZmZlci5cbiAqL1xuZnVuY3Rpb24gX3RyX2FsaWduKHMpIHtcbiAgc2VuZF9iaXRzKHMsIFNUQVRJQ19UUkVFUyA8PCAxLCAzKTtcbiAgc2VuZF9jb2RlKHMsIEVORF9CTE9DSywgc3RhdGljX2x0cmVlKTtcbiAgYmlfZmx1c2gocyk7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBEZXRlcm1pbmUgdGhlIGJlc3QgZW5jb2RpbmcgZm9yIHRoZSBjdXJyZW50IGJsb2NrOiBkeW5hbWljIHRyZWVzLCBzdGF0aWNcbiAqIHRyZWVzIG9yIHN0b3JlLCBhbmQgb3V0cHV0IHRoZSBlbmNvZGVkIGJsb2NrIHRvIHRoZSB6aXAgZmlsZS5cbiAqL1xuZnVuY3Rpb24gX3RyX2ZsdXNoX2Jsb2NrKHMsIGJ1Ziwgc3RvcmVkX2xlbiwgbGFzdClcbi8vRGVmbGF0ZVN0YXRlICpzO1xuLy9jaGFyZiAqYnVmOyAgICAgICAvKiBpbnB1dCBibG9jaywgb3IgTlVMTCBpZiB0b28gb2xkICovXG4vL3VsZyBzdG9yZWRfbGVuOyAgIC8qIGxlbmd0aCBvZiBpbnB1dCBibG9jayAqL1xuLy9pbnQgbGFzdDsgICAgICAgICAvKiBvbmUgaWYgdGhpcyBpcyB0aGUgbGFzdCBibG9jayBmb3IgYSBmaWxlICovXG57XG4gIHZhciBvcHRfbGVuYiwgc3RhdGljX2xlbmI7ICAvKiBvcHRfbGVuIGFuZCBzdGF0aWNfbGVuIGluIGJ5dGVzICovXG4gIHZhciBtYXhfYmxpbmRleCA9IDA7ICAgICAgICAvKiBpbmRleCBvZiBsYXN0IGJpdCBsZW5ndGggY29kZSBvZiBub24gemVybyBmcmVxICovXG5cbiAgLyogQnVpbGQgdGhlIEh1ZmZtYW4gdHJlZXMgdW5sZXNzIGEgc3RvcmVkIGJsb2NrIGlzIGZvcmNlZCAqL1xuICBpZiAocy5sZXZlbCA+IDApIHtcblxuICAgIC8qIENoZWNrIGlmIHRoZSBmaWxlIGlzIGJpbmFyeSBvciB0ZXh0ICovXG4gICAgaWYgKHMuc3RybS5kYXRhX3R5cGUgPT09IFpfVU5LTk9XTikge1xuICAgICAgcy5zdHJtLmRhdGFfdHlwZSA9IGRldGVjdF9kYXRhX3R5cGUocyk7XG4gICAgfVxuXG4gICAgLyogQ29uc3RydWN0IHRoZSBsaXRlcmFsIGFuZCBkaXN0YW5jZSB0cmVlcyAqL1xuICAgIGJ1aWxkX3RyZWUocywgcy5sX2Rlc2MpO1xuICAgIC8vIFRyYWNldigoc3RkZXJyLCBcIlxcbmxpdCBkYXRhOiBkeW4gJWxkLCBzdGF0ICVsZFwiLCBzLT5vcHRfbGVuLFxuICAgIC8vICAgICAgICBzLT5zdGF0aWNfbGVuKSk7XG5cbiAgICBidWlsZF90cmVlKHMsIHMuZF9kZXNjKTtcbiAgICAvLyBUcmFjZXYoKHN0ZGVyciwgXCJcXG5kaXN0IGRhdGE6IGR5biAlbGQsIHN0YXQgJWxkXCIsIHMtPm9wdF9sZW4sXG4gICAgLy8gICAgICAgIHMtPnN0YXRpY19sZW4pKTtcbiAgICAvKiBBdCB0aGlzIHBvaW50LCBvcHRfbGVuIGFuZCBzdGF0aWNfbGVuIGFyZSB0aGUgdG90YWwgYml0IGxlbmd0aHMgb2ZcbiAgICAgKiB0aGUgY29tcHJlc3NlZCBibG9jayBkYXRhLCBleGNsdWRpbmcgdGhlIHRyZWUgcmVwcmVzZW50YXRpb25zLlxuICAgICAqL1xuXG4gICAgLyogQnVpbGQgdGhlIGJpdCBsZW5ndGggdHJlZSBmb3IgdGhlIGFib3ZlIHR3byB0cmVlcywgYW5kIGdldCB0aGUgaW5kZXhcbiAgICAgKiBpbiBibF9vcmRlciBvZiB0aGUgbGFzdCBiaXQgbGVuZ3RoIGNvZGUgdG8gc2VuZC5cbiAgICAgKi9cbiAgICBtYXhfYmxpbmRleCA9IGJ1aWxkX2JsX3RyZWUocyk7XG5cbiAgICAvKiBEZXRlcm1pbmUgdGhlIGJlc3QgZW5jb2RpbmcuIENvbXB1dGUgdGhlIGJsb2NrIGxlbmd0aHMgaW4gYnl0ZXMuICovXG4gICAgb3B0X2xlbmIgPSAocy5vcHRfbGVuICsgMyArIDcpID4+PiAzO1xuICAgIHN0YXRpY19sZW5iID0gKHMuc3RhdGljX2xlbiArIDMgKyA3KSA+Pj4gMztcblxuICAgIC8vIFRyYWNldigoc3RkZXJyLCBcIlxcbm9wdCAlbHUoJWx1KSBzdGF0ICVsdSglbHUpIHN0b3JlZCAlbHUgbGl0ICV1IFwiLFxuICAgIC8vICAgICAgICBvcHRfbGVuYiwgcy0+b3B0X2xlbiwgc3RhdGljX2xlbmIsIHMtPnN0YXRpY19sZW4sIHN0b3JlZF9sZW4sXG4gICAgLy8gICAgICAgIHMtPmxhc3RfbGl0KSk7XG5cbiAgICBpZiAoc3RhdGljX2xlbmIgPD0gb3B0X2xlbmIpIHsgb3B0X2xlbmIgPSBzdGF0aWNfbGVuYjsgfVxuXG4gIH0gZWxzZSB7XG4gICAgLy8gQXNzZXJ0KGJ1ZiAhPSAoY2hhciopMCwgXCJsb3N0IGJ1ZlwiKTtcbiAgICBvcHRfbGVuYiA9IHN0YXRpY19sZW5iID0gc3RvcmVkX2xlbiArIDU7IC8qIGZvcmNlIGEgc3RvcmVkIGJsb2NrICovXG4gIH1cblxuICBpZiAoKHN0b3JlZF9sZW4gKyA0IDw9IG9wdF9sZW5iKSAmJiAoYnVmICE9PSAtMSkpIHtcbiAgICAvKiA0OiB0d28gd29yZHMgZm9yIHRoZSBsZW5ndGhzICovXG5cbiAgICAvKiBUaGUgdGVzdCBidWYgIT0gTlVMTCBpcyBvbmx5IG5lY2Vzc2FyeSBpZiBMSVRfQlVGU0laRSA+IFdTSVpFLlxuICAgICAqIE90aGVyd2lzZSB3ZSBjYW4ndCBoYXZlIHByb2Nlc3NlZCBtb3JlIHRoYW4gV1NJWkUgaW5wdXQgYnl0ZXMgc2luY2VcbiAgICAgKiB0aGUgbGFzdCBibG9jayBmbHVzaCwgYmVjYXVzZSBjb21wcmVzc2lvbiB3b3VsZCBoYXZlIGJlZW5cbiAgICAgKiBzdWNjZXNzZnVsLiBJZiBMSVRfQlVGU0laRSA8PSBXU0laRSwgaXQgaXMgbmV2ZXIgdG9vIGxhdGUgdG9cbiAgICAgKiB0cmFuc2Zvcm0gYSBibG9jayBpbnRvIGEgc3RvcmVkIGJsb2NrLlxuICAgICAqL1xuICAgIF90cl9zdG9yZWRfYmxvY2socywgYnVmLCBzdG9yZWRfbGVuLCBsYXN0KTtcblxuICB9IGVsc2UgaWYgKHMuc3RyYXRlZ3kgPT09IFpfRklYRUQgfHwgc3RhdGljX2xlbmIgPT09IG9wdF9sZW5iKSB7XG5cbiAgICBzZW5kX2JpdHMocywgKFNUQVRJQ19UUkVFUyA8PCAxKSArIChsYXN0ID8gMSA6IDApLCAzKTtcbiAgICBjb21wcmVzc19ibG9jayhzLCBzdGF0aWNfbHRyZWUsIHN0YXRpY19kdHJlZSk7XG5cbiAgfSBlbHNlIHtcbiAgICBzZW5kX2JpdHMocywgKERZTl9UUkVFUyA8PCAxKSArIChsYXN0ID8gMSA6IDApLCAzKTtcbiAgICBzZW5kX2FsbF90cmVlcyhzLCBzLmxfZGVzYy5tYXhfY29kZSArIDEsIHMuZF9kZXNjLm1heF9jb2RlICsgMSwgbWF4X2JsaW5kZXggKyAxKTtcbiAgICBjb21wcmVzc19ibG9jayhzLCBzLmR5bl9sdHJlZSwgcy5keW5fZHRyZWUpO1xuICB9XG4gIC8vIEFzc2VydCAocy0+Y29tcHJlc3NlZF9sZW4gPT0gcy0+Yml0c19zZW50LCBcImJhZCBjb21wcmVzc2VkIHNpemVcIik7XG4gIC8qIFRoZSBhYm92ZSBjaGVjayBpcyBtYWRlIG1vZCAyXjMyLCBmb3IgZmlsZXMgbGFyZ2VyIHRoYW4gNTEyIE1CXG4gICAqIGFuZCB1TG9uZyBpbXBsZW1lbnRlZCBvbiAzMiBiaXRzLlxuICAgKi9cbiAgaW5pdF9ibG9jayhzKTtcblxuICBpZiAobGFzdCkge1xuICAgIGJpX3dpbmR1cChzKTtcbiAgfVxuICAvLyBUcmFjZXYoKHN0ZGVycixcIlxcbmNvbXBybGVuICVsdSglbHUpIFwiLCBzLT5jb21wcmVzc2VkX2xlbj4+MyxcbiAgLy8gICAgICAgcy0+Y29tcHJlc3NlZF9sZW4tNypsYXN0KSk7XG59XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogU2F2ZSB0aGUgbWF0Y2ggaW5mbyBhbmQgdGFsbHkgdGhlIGZyZXF1ZW5jeSBjb3VudHMuIFJldHVybiB0cnVlIGlmXG4gKiB0aGUgY3VycmVudCBibG9jayBtdXN0IGJlIGZsdXNoZWQuXG4gKi9cbmZ1bmN0aW9uIF90cl90YWxseShzLCBkaXN0LCBsYylcbi8vICAgIGRlZmxhdGVfc3RhdGUgKnM7XG4vLyAgICB1bnNpZ25lZCBkaXN0OyAgLyogZGlzdGFuY2Ugb2YgbWF0Y2hlZCBzdHJpbmcgKi9cbi8vICAgIHVuc2lnbmVkIGxjOyAgICAvKiBtYXRjaCBsZW5ndGgtTUlOX01BVENIIG9yIHVubWF0Y2hlZCBjaGFyIChpZiBkaXN0PT0wKSAqL1xue1xuICAvL3ZhciBvdXRfbGVuZ3RoLCBpbl9sZW5ndGgsIGRjb2RlO1xuXG4gIHMucGVuZGluZ19idWZbcy5kX2J1ZiArIHMubGFzdF9saXQgKiAyXSAgICAgPSAoZGlzdCA+Pj4gOCkgJiAweGZmO1xuICBzLnBlbmRpbmdfYnVmW3MuZF9idWYgKyBzLmxhc3RfbGl0ICogMiArIDFdID0gZGlzdCAmIDB4ZmY7XG5cbiAgcy5wZW5kaW5nX2J1ZltzLmxfYnVmICsgcy5sYXN0X2xpdF0gPSBsYyAmIDB4ZmY7XG4gIHMubGFzdF9saXQrKztcblxuICBpZiAoZGlzdCA9PT0gMCkge1xuICAgIC8qIGxjIGlzIHRoZSB1bm1hdGNoZWQgY2hhciAqL1xuICAgIHMuZHluX2x0cmVlW2xjICogMl0vKi5GcmVxKi8rKztcbiAgfSBlbHNlIHtcbiAgICBzLm1hdGNoZXMrKztcbiAgICAvKiBIZXJlLCBsYyBpcyB0aGUgbWF0Y2ggbGVuZ3RoIC0gTUlOX01BVENIICovXG4gICAgZGlzdC0tOyAgICAgICAgICAgICAvKiBkaXN0ID0gbWF0Y2ggZGlzdGFuY2UgLSAxICovXG4gICAgLy9Bc3NlcnQoKHVzaClkaXN0IDwgKHVzaClNQVhfRElTVChzKSAmJlxuICAgIC8vICAgICAgICh1c2gpbGMgPD0gKHVzaCkoTUFYX01BVENILU1JTl9NQVRDSCkgJiZcbiAgICAvLyAgICAgICAodXNoKWRfY29kZShkaXN0KSA8ICh1c2gpRF9DT0RFUywgIFwiX3RyX3RhbGx5OiBiYWQgbWF0Y2hcIik7XG5cbiAgICBzLmR5bl9sdHJlZVsoX2xlbmd0aF9jb2RlW2xjXSArIExJVEVSQUxTICsgMSkgKiAyXS8qLkZyZXEqLysrO1xuICAgIHMuZHluX2R0cmVlW2RfY29kZShkaXN0KSAqIDJdLyouRnJlcSovKys7XG4gIH1cblxuLy8gKCEpIFRoaXMgYmxvY2sgaXMgZGlzYWJsZWQgaW4gemxpYiBkZWZhaWx0cyxcbi8vIGRvbid0IGVuYWJsZSBpdCBmb3IgYmluYXJ5IGNvbXBhdGliaWxpdHlcblxuLy8jaWZkZWYgVFJVTkNBVEVfQkxPQ0tcbi8vICAvKiBUcnkgdG8gZ3Vlc3MgaWYgaXQgaXMgcHJvZml0YWJsZSB0byBzdG9wIHRoZSBjdXJyZW50IGJsb2NrIGhlcmUgKi9cbi8vICBpZiAoKHMubGFzdF9saXQgJiAweDFmZmYpID09PSAwICYmIHMubGV2ZWwgPiAyKSB7XG4vLyAgICAvKiBDb21wdXRlIGFuIHVwcGVyIGJvdW5kIGZvciB0aGUgY29tcHJlc3NlZCBsZW5ndGggKi9cbi8vICAgIG91dF9sZW5ndGggPSBzLmxhc3RfbGl0Kjg7XG4vLyAgICBpbl9sZW5ndGggPSBzLnN0cnN0YXJ0IC0gcy5ibG9ja19zdGFydDtcbi8vXG4vLyAgICBmb3IgKGRjb2RlID0gMDsgZGNvZGUgPCBEX0NPREVTOyBkY29kZSsrKSB7XG4vLyAgICAgIG91dF9sZW5ndGggKz0gcy5keW5fZHRyZWVbZGNvZGUqMl0vKi5GcmVxKi8gKiAoNSArIGV4dHJhX2RiaXRzW2Rjb2RlXSk7XG4vLyAgICB9XG4vLyAgICBvdXRfbGVuZ3RoID4+Pj0gMztcbi8vICAgIC8vVHJhY2V2KChzdGRlcnIsXCJcXG5sYXN0X2xpdCAldSwgaW4gJWxkLCBvdXQgfiVsZCglbGQlJSkgXCIsXG4vLyAgICAvLyAgICAgICBzLT5sYXN0X2xpdCwgaW5fbGVuZ3RoLCBvdXRfbGVuZ3RoLFxuLy8gICAgLy8gICAgICAgMTAwTCAtIG91dF9sZW5ndGgqMTAwTC9pbl9sZW5ndGgpKTtcbi8vICAgIGlmIChzLm1hdGNoZXMgPCAocy5sYXN0X2xpdD4+MSkvKmludCAvMiovICYmIG91dF9sZW5ndGggPCAoaW5fbGVuZ3RoPj4xKS8qaW50IC8yKi8pIHtcbi8vICAgICAgcmV0dXJuIHRydWU7XG4vLyAgICB9XG4vLyAgfVxuLy8jZW5kaWZcblxuICByZXR1cm4gKHMubGFzdF9saXQgPT09IHMubGl0X2J1ZnNpemUgLSAxKTtcbiAgLyogV2UgYXZvaWQgZXF1YWxpdHkgd2l0aCBsaXRfYnVmc2l6ZSBiZWNhdXNlIG9mIHdyYXBhcm91bmQgYXQgNjRLXG4gICAqIG9uIDE2IGJpdCBtYWNoaW5lcyBhbmQgYmVjYXVzZSBzdG9yZWQgYmxvY2tzIGFyZSByZXN0cmljdGVkIHRvXG4gICAqIDY0Sy0xIGJ5dGVzLlxuICAgKi9cbn1cblxuZXhwb3J0cy5fdHJfaW5pdCAgPSBfdHJfaW5pdDtcbmV4cG9ydHMuX3RyX3N0b3JlZF9ibG9jayA9IF90cl9zdG9yZWRfYmxvY2s7XG5leHBvcnRzLl90cl9mbHVzaF9ibG9jayAgPSBfdHJfZmx1c2hfYmxvY2s7XG5leHBvcnRzLl90cl90YWxseSA9IF90cl90YWxseTtcbmV4cG9ydHMuX3RyX2FsaWduID0gX3RyX2FsaWduO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5cbmZ1bmN0aW9uIFpTdHJlYW0oKSB7XG4gIC8qIG5leHQgaW5wdXQgYnl0ZSAqL1xuICB0aGlzLmlucHV0ID0gbnVsbDsgLy8gSlMgc3BlY2lmaWMsIGJlY2F1c2Ugd2UgaGF2ZSBubyBwb2ludGVyc1xuICB0aGlzLm5leHRfaW4gPSAwO1xuICAvKiBudW1iZXIgb2YgYnl0ZXMgYXZhaWxhYmxlIGF0IGlucHV0ICovXG4gIHRoaXMuYXZhaWxfaW4gPSAwO1xuICAvKiB0b3RhbCBudW1iZXIgb2YgaW5wdXQgYnl0ZXMgcmVhZCBzbyBmYXIgKi9cbiAgdGhpcy50b3RhbF9pbiA9IDA7XG4gIC8qIG5leHQgb3V0cHV0IGJ5dGUgc2hvdWxkIGJlIHB1dCB0aGVyZSAqL1xuICB0aGlzLm91dHB1dCA9IG51bGw7IC8vIEpTIHNwZWNpZmljLCBiZWNhdXNlIHdlIGhhdmUgbm8gcG9pbnRlcnNcbiAgdGhpcy5uZXh0X291dCA9IDA7XG4gIC8qIHJlbWFpbmluZyBmcmVlIHNwYWNlIGF0IG91dHB1dCAqL1xuICB0aGlzLmF2YWlsX291dCA9IDA7XG4gIC8qIHRvdGFsIG51bWJlciBvZiBieXRlcyBvdXRwdXQgc28gZmFyICovXG4gIHRoaXMudG90YWxfb3V0ID0gMDtcbiAgLyogbGFzdCBlcnJvciBtZXNzYWdlLCBOVUxMIGlmIG5vIGVycm9yICovXG4gIHRoaXMubXNnID0gJycvKlpfTlVMTCovO1xuICAvKiBub3QgdmlzaWJsZSBieSBhcHBsaWNhdGlvbnMgKi9cbiAgdGhpcy5zdGF0ZSA9IG51bGw7XG4gIC8qIGJlc3QgZ3Vlc3MgYWJvdXQgdGhlIGRhdGEgdHlwZTogYmluYXJ5IG9yIHRleHQgKi9cbiAgdGhpcy5kYXRhX3R5cGUgPSAyLypaX1VOS05PV04qLztcbiAgLyogYWRsZXIzMiB2YWx1ZSBvZiB0aGUgdW5jb21wcmVzc2VkIGRhdGEgKi9cbiAgdGhpcy5hZGxlciA9IDA7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gWlN0cmVhbTtcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4vLyByZXNvbHZlcyAuIGFuZCAuLiBlbGVtZW50cyBpbiBhIHBhdGggYXJyYXkgd2l0aCBkaXJlY3RvcnkgbmFtZXMgdGhlcmVcbi8vIG11c3QgYmUgbm8gc2xhc2hlcywgZW1wdHkgZWxlbWVudHMsIG9yIGRldmljZSBuYW1lcyAoYzpcXCkgaW4gdGhlIGFycmF5XG4vLyAoc28gYWxzbyBubyBsZWFkaW5nIGFuZCB0cmFpbGluZyBzbGFzaGVzIC0gaXQgZG9lcyBub3QgZGlzdGluZ3Vpc2hcbi8vIHJlbGF0aXZlIGFuZCBhYnNvbHV0ZSBwYXRocylcbmZ1bmN0aW9uIG5vcm1hbGl6ZUFycmF5KHBhcnRzLCBhbGxvd0Fib3ZlUm9vdCkge1xuICAvLyBpZiB0aGUgcGF0aCB0cmllcyB0byBnbyBhYm92ZSB0aGUgcm9vdCwgYHVwYCBlbmRzIHVwID4gMFxuICB2YXIgdXAgPSAwO1xuICBmb3IgKHZhciBpID0gcGFydHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICB2YXIgbGFzdCA9IHBhcnRzW2ldO1xuICAgIGlmIChsYXN0ID09PSAnLicpIHtcbiAgICAgIHBhcnRzLnNwbGljZShpLCAxKTtcbiAgICB9IGVsc2UgaWYgKGxhc3QgPT09ICcuLicpIHtcbiAgICAgIHBhcnRzLnNwbGljZShpLCAxKTtcbiAgICAgIHVwKys7XG4gICAgfSBlbHNlIGlmICh1cCkge1xuICAgICAgcGFydHMuc3BsaWNlKGksIDEpO1xuICAgICAgdXAtLTtcbiAgICB9XG4gIH1cblxuICAvLyBpZiB0aGUgcGF0aCBpcyBhbGxvd2VkIHRvIGdvIGFib3ZlIHRoZSByb290LCByZXN0b3JlIGxlYWRpbmcgLi5zXG4gIGlmIChhbGxvd0Fib3ZlUm9vdCkge1xuICAgIGZvciAoOyB1cC0tOyB1cCkge1xuICAgICAgcGFydHMudW5zaGlmdCgnLi4nKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcGFydHM7XG59XG5cbi8vIFNwbGl0IGEgZmlsZW5hbWUgaW50byBbcm9vdCwgZGlyLCBiYXNlbmFtZSwgZXh0XSwgdW5peCB2ZXJzaW9uXG4vLyAncm9vdCcgaXMganVzdCBhIHNsYXNoLCBvciBub3RoaW5nLlxudmFyIHNwbGl0UGF0aFJlID1cbiAgICAvXihcXC8/fCkoW1xcc1xcU10qPykoKD86XFwuezEsMn18W15cXC9dKz98KShcXC5bXi5cXC9dKnwpKSg/OltcXC9dKikkLztcbnZhciBzcGxpdFBhdGggPSBmdW5jdGlvbihmaWxlbmFtZSkge1xuICByZXR1cm4gc3BsaXRQYXRoUmUuZXhlYyhmaWxlbmFtZSkuc2xpY2UoMSk7XG59O1xuXG4vLyBwYXRoLnJlc29sdmUoW2Zyb20gLi4uXSwgdG8pXG4vLyBwb3NpeCB2ZXJzaW9uXG5leHBvcnRzLnJlc29sdmUgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHJlc29sdmVkUGF0aCA9ICcnLFxuICAgICAgcmVzb2x2ZWRBYnNvbHV0ZSA9IGZhbHNlO1xuXG4gIGZvciAodmFyIGkgPSBhcmd1bWVudHMubGVuZ3RoIC0gMTsgaSA+PSAtMSAmJiAhcmVzb2x2ZWRBYnNvbHV0ZTsgaS0tKSB7XG4gICAgdmFyIHBhdGggPSAoaSA+PSAwKSA/IGFyZ3VtZW50c1tpXSA6IHByb2Nlc3MuY3dkKCk7XG5cbiAgICAvLyBTa2lwIGVtcHR5IGFuZCBpbnZhbGlkIGVudHJpZXNcbiAgICBpZiAodHlwZW9mIHBhdGggIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudHMgdG8gcGF0aC5yZXNvbHZlIG11c3QgYmUgc3RyaW5ncycpO1xuICAgIH0gZWxzZSBpZiAoIXBhdGgpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHJlc29sdmVkUGF0aCA9IHBhdGggKyAnLycgKyByZXNvbHZlZFBhdGg7XG4gICAgcmVzb2x2ZWRBYnNvbHV0ZSA9IHBhdGguY2hhckF0KDApID09PSAnLyc7XG4gIH1cblxuICAvLyBBdCB0aGlzIHBvaW50IHRoZSBwYXRoIHNob3VsZCBiZSByZXNvbHZlZCB0byBhIGZ1bGwgYWJzb2x1dGUgcGF0aCwgYnV0XG4gIC8vIGhhbmRsZSByZWxhdGl2ZSBwYXRocyB0byBiZSBzYWZlIChtaWdodCBoYXBwZW4gd2hlbiBwcm9jZXNzLmN3ZCgpIGZhaWxzKVxuXG4gIC8vIE5vcm1hbGl6ZSB0aGUgcGF0aFxuICByZXNvbHZlZFBhdGggPSBub3JtYWxpemVBcnJheShmaWx0ZXIocmVzb2x2ZWRQYXRoLnNwbGl0KCcvJyksIGZ1bmN0aW9uKHApIHtcbiAgICByZXR1cm4gISFwO1xuICB9KSwgIXJlc29sdmVkQWJzb2x1dGUpLmpvaW4oJy8nKTtcblxuICByZXR1cm4gKChyZXNvbHZlZEFic29sdXRlID8gJy8nIDogJycpICsgcmVzb2x2ZWRQYXRoKSB8fCAnLic7XG59O1xuXG4vLyBwYXRoLm5vcm1hbGl6ZShwYXRoKVxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5ub3JtYWxpemUgPSBmdW5jdGlvbihwYXRoKSB7XG4gIHZhciBpc0Fic29sdXRlID0gZXhwb3J0cy5pc0Fic29sdXRlKHBhdGgpLFxuICAgICAgdHJhaWxpbmdTbGFzaCA9IHN1YnN0cihwYXRoLCAtMSkgPT09ICcvJztcblxuICAvLyBOb3JtYWxpemUgdGhlIHBhdGhcbiAgcGF0aCA9IG5vcm1hbGl6ZUFycmF5KGZpbHRlcihwYXRoLnNwbGl0KCcvJyksIGZ1bmN0aW9uKHApIHtcbiAgICByZXR1cm4gISFwO1xuICB9KSwgIWlzQWJzb2x1dGUpLmpvaW4oJy8nKTtcblxuICBpZiAoIXBhdGggJiYgIWlzQWJzb2x1dGUpIHtcbiAgICBwYXRoID0gJy4nO1xuICB9XG4gIGlmIChwYXRoICYmIHRyYWlsaW5nU2xhc2gpIHtcbiAgICBwYXRoICs9ICcvJztcbiAgfVxuXG4gIHJldHVybiAoaXNBYnNvbHV0ZSA/ICcvJyA6ICcnKSArIHBhdGg7XG59O1xuXG4vLyBwb3NpeCB2ZXJzaW9uXG5leHBvcnRzLmlzQWJzb2x1dGUgPSBmdW5jdGlvbihwYXRoKSB7XG4gIHJldHVybiBwYXRoLmNoYXJBdCgwKSA9PT0gJy8nO1xufTtcblxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5qb2luID0gZnVuY3Rpb24oKSB7XG4gIHZhciBwYXRocyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCk7XG4gIHJldHVybiBleHBvcnRzLm5vcm1hbGl6ZShmaWx0ZXIocGF0aHMsIGZ1bmN0aW9uKHAsIGluZGV4KSB7XG4gICAgaWYgKHR5cGVvZiBwICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnRzIHRvIHBhdGguam9pbiBtdXN0IGJlIHN0cmluZ3MnKTtcbiAgICB9XG4gICAgcmV0dXJuIHA7XG4gIH0pLmpvaW4oJy8nKSk7XG59O1xuXG5cbi8vIHBhdGgucmVsYXRpdmUoZnJvbSwgdG8pXG4vLyBwb3NpeCB2ZXJzaW9uXG5leHBvcnRzLnJlbGF0aXZlID0gZnVuY3Rpb24oZnJvbSwgdG8pIHtcbiAgZnJvbSA9IGV4cG9ydHMucmVzb2x2ZShmcm9tKS5zdWJzdHIoMSk7XG4gIHRvID0gZXhwb3J0cy5yZXNvbHZlKHRvKS5zdWJzdHIoMSk7XG5cbiAgZnVuY3Rpb24gdHJpbShhcnIpIHtcbiAgICB2YXIgc3RhcnQgPSAwO1xuICAgIGZvciAoOyBzdGFydCA8IGFyci5sZW5ndGg7IHN0YXJ0KyspIHtcbiAgICAgIGlmIChhcnJbc3RhcnRdICE9PSAnJykgYnJlYWs7XG4gICAgfVxuXG4gICAgdmFyIGVuZCA9IGFyci5sZW5ndGggLSAxO1xuICAgIGZvciAoOyBlbmQgPj0gMDsgZW5kLS0pIHtcbiAgICAgIGlmIChhcnJbZW5kXSAhPT0gJycpIGJyZWFrO1xuICAgIH1cblxuICAgIGlmIChzdGFydCA+IGVuZCkgcmV0dXJuIFtdO1xuICAgIHJldHVybiBhcnIuc2xpY2Uoc3RhcnQsIGVuZCAtIHN0YXJ0ICsgMSk7XG4gIH1cblxuICB2YXIgZnJvbVBhcnRzID0gdHJpbShmcm9tLnNwbGl0KCcvJykpO1xuICB2YXIgdG9QYXJ0cyA9IHRyaW0odG8uc3BsaXQoJy8nKSk7XG5cbiAgdmFyIGxlbmd0aCA9IE1hdGgubWluKGZyb21QYXJ0cy5sZW5ndGgsIHRvUGFydHMubGVuZ3RoKTtcbiAgdmFyIHNhbWVQYXJ0c0xlbmd0aCA9IGxlbmd0aDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIGlmIChmcm9tUGFydHNbaV0gIT09IHRvUGFydHNbaV0pIHtcbiAgICAgIHNhbWVQYXJ0c0xlbmd0aCA9IGk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICB2YXIgb3V0cHV0UGFydHMgPSBbXTtcbiAgZm9yICh2YXIgaSA9IHNhbWVQYXJ0c0xlbmd0aDsgaSA8IGZyb21QYXJ0cy5sZW5ndGg7IGkrKykge1xuICAgIG91dHB1dFBhcnRzLnB1c2goJy4uJyk7XG4gIH1cblxuICBvdXRwdXRQYXJ0cyA9IG91dHB1dFBhcnRzLmNvbmNhdCh0b1BhcnRzLnNsaWNlKHNhbWVQYXJ0c0xlbmd0aCkpO1xuXG4gIHJldHVybiBvdXRwdXRQYXJ0cy5qb2luKCcvJyk7XG59O1xuXG5leHBvcnRzLnNlcCA9ICcvJztcbmV4cG9ydHMuZGVsaW1pdGVyID0gJzonO1xuXG5leHBvcnRzLmRpcm5hbWUgPSBmdW5jdGlvbihwYXRoKSB7XG4gIHZhciByZXN1bHQgPSBzcGxpdFBhdGgocGF0aCksXG4gICAgICByb290ID0gcmVzdWx0WzBdLFxuICAgICAgZGlyID0gcmVzdWx0WzFdO1xuXG4gIGlmICghcm9vdCAmJiAhZGlyKSB7XG4gICAgLy8gTm8gZGlybmFtZSB3aGF0c29ldmVyXG4gICAgcmV0dXJuICcuJztcbiAgfVxuXG4gIGlmIChkaXIpIHtcbiAgICAvLyBJdCBoYXMgYSBkaXJuYW1lLCBzdHJpcCB0cmFpbGluZyBzbGFzaFxuICAgIGRpciA9IGRpci5zdWJzdHIoMCwgZGlyLmxlbmd0aCAtIDEpO1xuICB9XG5cbiAgcmV0dXJuIHJvb3QgKyBkaXI7XG59O1xuXG5cbmV4cG9ydHMuYmFzZW5hbWUgPSBmdW5jdGlvbihwYXRoLCBleHQpIHtcbiAgdmFyIGYgPSBzcGxpdFBhdGgocGF0aClbMl07XG4gIC8vIFRPRE86IG1ha2UgdGhpcyBjb21wYXJpc29uIGNhc2UtaW5zZW5zaXRpdmUgb24gd2luZG93cz9cbiAgaWYgKGV4dCAmJiBmLnN1YnN0cigtMSAqIGV4dC5sZW5ndGgpID09PSBleHQpIHtcbiAgICBmID0gZi5zdWJzdHIoMCwgZi5sZW5ndGggLSBleHQubGVuZ3RoKTtcbiAgfVxuICByZXR1cm4gZjtcbn07XG5cblxuZXhwb3J0cy5leHRuYW1lID0gZnVuY3Rpb24ocGF0aCkge1xuICByZXR1cm4gc3BsaXRQYXRoKHBhdGgpWzNdO1xufTtcblxuZnVuY3Rpb24gZmlsdGVyICh4cywgZikge1xuICAgIGlmICh4cy5maWx0ZXIpIHJldHVybiB4cy5maWx0ZXIoZik7XG4gICAgdmFyIHJlcyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgeHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGYoeHNbaV0sIGksIHhzKSkgcmVzLnB1c2goeHNbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuXG4vLyBTdHJpbmcucHJvdG90eXBlLnN1YnN0ciAtIG5lZ2F0aXZlIGluZGV4IGRvbid0IHdvcmsgaW4gSUU4XG52YXIgc3Vic3RyID0gJ2FiJy5zdWJzdHIoLTEpID09PSAnYidcbiAgICA/IGZ1bmN0aW9uIChzdHIsIHN0YXJ0LCBsZW4pIHsgcmV0dXJuIHN0ci5zdWJzdHIoc3RhcnQsIGxlbikgfVxuICAgIDogZnVuY3Rpb24gKHN0ciwgc3RhcnQsIGxlbikge1xuICAgICAgICBpZiAoc3RhcnQgPCAwKSBzdGFydCA9IHN0ci5sZW5ndGggKyBzdGFydDtcbiAgICAgICAgcmV0dXJuIHN0ci5zdWJzdHIoc3RhcnQsIGxlbik7XG4gICAgfVxuO1xuIiwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG5cbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLy8gY2FjaGVkIGZyb20gd2hhdGV2ZXIgZ2xvYmFsIGlzIHByZXNlbnQgc28gdGhhdCB0ZXN0IHJ1bm5lcnMgdGhhdCBzdHViIGl0XG4vLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXNcbi8vIHdyYXBwZWQgaW4gc3RyaWN0IG1vZGUgY29kZSB3aGljaCBkb2Vzbid0IGRlZmluZSBhbnkgZ2xvYmFscy4gIEl0J3MgaW5zaWRlIGFcbi8vIGZ1bmN0aW9uIGJlY2F1c2UgdHJ5L2NhdGNoZXMgZGVvcHRpbWl6ZSBpbiBjZXJ0YWluIGVuZ2luZXMuXG5cbnZhciBjYWNoZWRTZXRUaW1lb3V0O1xudmFyIGNhY2hlZENsZWFyVGltZW91dDtcblxuKGZ1bmN0aW9uICgpIHtcbiAgdHJ5IHtcbiAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGNhY2hlZFNldFRpbWVvdXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFRpbWVvdXQgaXMgbm90IGRlZmluZWQnKTtcbiAgICB9XG4gIH1cbiAgdHJ5IHtcbiAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBpcyBub3QgZGVmaW5lZCcpO1xuICAgIH1cbiAgfVxufSAoKSlcbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IGNhY2hlZFNldFRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGNhY2hlZENsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQoZHJhaW5RdWV1ZSwgMCk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG4iLCIvLyBwcm90b3R5cGUgY2xhc3MgZm9yIGhhc2ggZnVuY3Rpb25zXG5mdW5jdGlvbiBIYXNoIChibG9ja1NpemUsIGZpbmFsU2l6ZSkge1xuICB0aGlzLl9ibG9jayA9IG5ldyBCdWZmZXIoYmxvY2tTaXplKVxuICB0aGlzLl9maW5hbFNpemUgPSBmaW5hbFNpemVcbiAgdGhpcy5fYmxvY2tTaXplID0gYmxvY2tTaXplXG4gIHRoaXMuX2xlbiA9IDBcbiAgdGhpcy5fcyA9IDBcbn1cblxuSGFzaC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKGRhdGEsIGVuYykge1xuICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jID0gZW5jIHx8ICd1dGY4J1xuICAgIGRhdGEgPSBuZXcgQnVmZmVyKGRhdGEsIGVuYylcbiAgfVxuXG4gIHZhciBsID0gdGhpcy5fbGVuICs9IGRhdGEubGVuZ3RoXG4gIHZhciBzID0gdGhpcy5fcyB8fCAwXG4gIHZhciBmID0gMFxuICB2YXIgYnVmZmVyID0gdGhpcy5fYmxvY2tcblxuICB3aGlsZSAocyA8IGwpIHtcbiAgICB2YXIgdCA9IE1hdGgubWluKGRhdGEubGVuZ3RoLCBmICsgdGhpcy5fYmxvY2tTaXplIC0gKHMgJSB0aGlzLl9ibG9ja1NpemUpKVxuICAgIHZhciBjaCA9ICh0IC0gZilcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2g7IGkrKykge1xuICAgICAgYnVmZmVyWyhzICUgdGhpcy5fYmxvY2tTaXplKSArIGldID0gZGF0YVtpICsgZl1cbiAgICB9XG5cbiAgICBzICs9IGNoXG4gICAgZiArPSBjaFxuXG4gICAgaWYgKChzICUgdGhpcy5fYmxvY2tTaXplKSA9PT0gMCkge1xuICAgICAgdGhpcy5fdXBkYXRlKGJ1ZmZlcilcbiAgICB9XG4gIH1cbiAgdGhpcy5fcyA9IHNcblxuICByZXR1cm4gdGhpc1xufVxuXG5IYXNoLnByb3RvdHlwZS5kaWdlc3QgPSBmdW5jdGlvbiAoZW5jKSB7XG4gIC8vIFN1cHBvc2UgdGhlIGxlbmd0aCBvZiB0aGUgbWVzc2FnZSBNLCBpbiBiaXRzLCBpcyBsXG4gIHZhciBsID0gdGhpcy5fbGVuICogOFxuXG4gIC8vIEFwcGVuZCB0aGUgYml0IDEgdG8gdGhlIGVuZCBvZiB0aGUgbWVzc2FnZVxuICB0aGlzLl9ibG9ja1t0aGlzLl9sZW4gJSB0aGlzLl9ibG9ja1NpemVdID0gMHg4MFxuXG4gIC8vIGFuZCB0aGVuIGsgemVybyBiaXRzLCB3aGVyZSBrIGlzIHRoZSBzbWFsbGVzdCBub24tbmVnYXRpdmUgc29sdXRpb24gdG8gdGhlIGVxdWF0aW9uIChsICsgMSArIGspID09PSBmaW5hbFNpemUgbW9kIGJsb2NrU2l6ZVxuICB0aGlzLl9ibG9jay5maWxsKDAsIHRoaXMuX2xlbiAlIHRoaXMuX2Jsb2NrU2l6ZSArIDEpXG5cbiAgaWYgKGwgJSAodGhpcy5fYmxvY2tTaXplICogOCkgPj0gdGhpcy5fZmluYWxTaXplICogOCkge1xuICAgIHRoaXMuX3VwZGF0ZSh0aGlzLl9ibG9jaylcbiAgICB0aGlzLl9ibG9jay5maWxsKDApXG4gIH1cblxuICAvLyB0byB0aGlzIGFwcGVuZCB0aGUgYmxvY2sgd2hpY2ggaXMgZXF1YWwgdG8gdGhlIG51bWJlciBsIHdyaXR0ZW4gaW4gYmluYXJ5XG4gIC8vIFRPRE86IGhhbmRsZSBjYXNlIHdoZXJlIGwgaXMgPiBNYXRoLnBvdygyLCAyOSlcbiAgdGhpcy5fYmxvY2sud3JpdGVJbnQzMkJFKGwsIHRoaXMuX2Jsb2NrU2l6ZSAtIDQpXG5cbiAgdmFyIGhhc2ggPSB0aGlzLl91cGRhdGUodGhpcy5fYmxvY2spIHx8IHRoaXMuX2hhc2goKVxuXG4gIHJldHVybiBlbmMgPyBoYXNoLnRvU3RyaW5nKGVuYykgOiBoYXNoXG59XG5cbkhhc2gucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gIHRocm93IG5ldyBFcnJvcignX3VwZGF0ZSBtdXN0IGJlIGltcGxlbWVudGVkIGJ5IHN1YmNsYXNzJylcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBIYXNoXG4iLCJ2YXIgZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gU0hBIChhbGdvcml0aG0pIHtcbiAgYWxnb3JpdGhtID0gYWxnb3JpdGhtLnRvTG93ZXJDYXNlKClcblxuICB2YXIgQWxnb3JpdGhtID0gZXhwb3J0c1thbGdvcml0aG1dXG4gIGlmICghQWxnb3JpdGhtKSB0aHJvdyBuZXcgRXJyb3IoYWxnb3JpdGhtICsgJyBpcyBub3Qgc3VwcG9ydGVkICh3ZSBhY2NlcHQgcHVsbCByZXF1ZXN0cyknKVxuXG4gIHJldHVybiBuZXcgQWxnb3JpdGhtKClcbn1cblxuZXhwb3J0cy5zaGEgPSByZXF1aXJlKCcuL3NoYScpXG5leHBvcnRzLnNoYTEgPSByZXF1aXJlKCcuL3NoYTEnKVxuZXhwb3J0cy5zaGEyMjQgPSByZXF1aXJlKCcuL3NoYTIyNCcpXG5leHBvcnRzLnNoYTI1NiA9IHJlcXVpcmUoJy4vc2hhMjU2JylcbmV4cG9ydHMuc2hhMzg0ID0gcmVxdWlyZSgnLi9zaGEzODQnKVxuZXhwb3J0cy5zaGE1MTIgPSByZXF1aXJlKCcuL3NoYTUxMicpXG4iLCIvKlxuICogQSBKYXZhU2NyaXB0IGltcGxlbWVudGF0aW9uIG9mIHRoZSBTZWN1cmUgSGFzaCBBbGdvcml0aG0sIFNIQS0wLCBhcyBkZWZpbmVkXG4gKiBpbiBGSVBTIFBVQiAxODAtMVxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBkZXJpdmVkIGZyb20gc2hhMS5qcyBvZiB0aGUgc2FtZSByZXBvc2l0b3J5LlxuICogVGhlIGRpZmZlcmVuY2UgYmV0d2VlbiBTSEEtMCBhbmQgU0hBLTEgaXMganVzdCBhIGJpdHdpc2Ugcm90YXRlIGxlZnRcbiAqIG9wZXJhdGlvbiB3YXMgYWRkZWQuXG4gKi9cblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxudmFyIEhhc2ggPSByZXF1aXJlKCcuL2hhc2gnKVxuXG52YXIgSyA9IFtcbiAgMHg1YTgyNzk5OSwgMHg2ZWQ5ZWJhMSwgMHg4ZjFiYmNkYyB8IDAsIDB4Y2E2MmMxZDYgfCAwXG5dXG5cbnZhciBXID0gbmV3IEFycmF5KDgwKVxuXG5mdW5jdGlvbiBTaGEgKCkge1xuICB0aGlzLmluaXQoKVxuICB0aGlzLl93ID0gV1xuXG4gIEhhc2guY2FsbCh0aGlzLCA2NCwgNTYpXG59XG5cbmluaGVyaXRzKFNoYSwgSGFzaClcblxuU2hhLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLl9hID0gMHg2NzQ1MjMwMVxuICB0aGlzLl9iID0gMHhlZmNkYWI4OVxuICB0aGlzLl9jID0gMHg5OGJhZGNmZVxuICB0aGlzLl9kID0gMHgxMDMyNTQ3NlxuICB0aGlzLl9lID0gMHhjM2QyZTFmMFxuXG4gIHJldHVybiB0aGlzXG59XG5cbmZ1bmN0aW9uIHJvdGw1IChudW0pIHtcbiAgcmV0dXJuIChudW0gPDwgNSkgfCAobnVtID4+PiAyNylcbn1cblxuZnVuY3Rpb24gcm90bDMwIChudW0pIHtcbiAgcmV0dXJuIChudW0gPDwgMzApIHwgKG51bSA+Pj4gMilcbn1cblxuZnVuY3Rpb24gZnQgKHMsIGIsIGMsIGQpIHtcbiAgaWYgKHMgPT09IDApIHJldHVybiAoYiAmIGMpIHwgKCh+YikgJiBkKVxuICBpZiAocyA9PT0gMikgcmV0dXJuIChiICYgYykgfCAoYiAmIGQpIHwgKGMgJiBkKVxuICByZXR1cm4gYiBeIGMgXiBkXG59XG5cblNoYS5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uIChNKSB7XG4gIHZhciBXID0gdGhpcy5fd1xuXG4gIHZhciBhID0gdGhpcy5fYSB8IDBcbiAgdmFyIGIgPSB0aGlzLl9iIHwgMFxuICB2YXIgYyA9IHRoaXMuX2MgfCAwXG4gIHZhciBkID0gdGhpcy5fZCB8IDBcbiAgdmFyIGUgPSB0aGlzLl9lIHwgMFxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgMTY7ICsraSkgV1tpXSA9IE0ucmVhZEludDMyQkUoaSAqIDQpXG4gIGZvciAoOyBpIDwgODA7ICsraSkgV1tpXSA9IFdbaSAtIDNdIF4gV1tpIC0gOF0gXiBXW2kgLSAxNF0gXiBXW2kgLSAxNl1cblxuICBmb3IgKHZhciBqID0gMDsgaiA8IDgwOyArK2opIHtcbiAgICB2YXIgcyA9IH5+KGogLyAyMClcbiAgICB2YXIgdCA9IChyb3RsNShhKSArIGZ0KHMsIGIsIGMsIGQpICsgZSArIFdbal0gKyBLW3NdKSB8IDBcblxuICAgIGUgPSBkXG4gICAgZCA9IGNcbiAgICBjID0gcm90bDMwKGIpXG4gICAgYiA9IGFcbiAgICBhID0gdFxuICB9XG5cbiAgdGhpcy5fYSA9IChhICsgdGhpcy5fYSkgfCAwXG4gIHRoaXMuX2IgPSAoYiArIHRoaXMuX2IpIHwgMFxuICB0aGlzLl9jID0gKGMgKyB0aGlzLl9jKSB8IDBcbiAgdGhpcy5fZCA9IChkICsgdGhpcy5fZCkgfCAwXG4gIHRoaXMuX2UgPSAoZSArIHRoaXMuX2UpIHwgMFxufVxuXG5TaGEucHJvdG90eXBlLl9oYXNoID0gZnVuY3Rpb24gKCkge1xuICB2YXIgSCA9IG5ldyBCdWZmZXIoMjApXG5cbiAgSC53cml0ZUludDMyQkUodGhpcy5fYSB8IDAsIDApXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2IgfCAwLCA0KVxuICBILndyaXRlSW50MzJCRSh0aGlzLl9jIHwgMCwgOClcbiAgSC53cml0ZUludDMyQkUodGhpcy5fZCB8IDAsIDEyKVxuICBILndyaXRlSW50MzJCRSh0aGlzLl9lIHwgMCwgMTYpXG5cbiAgcmV0dXJuIEhcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBTaGFcbiIsIi8qXG4gKiBBIEphdmFTY3JpcHQgaW1wbGVtZW50YXRpb24gb2YgdGhlIFNlY3VyZSBIYXNoIEFsZ29yaXRobSwgU0hBLTEsIGFzIGRlZmluZWRcbiAqIGluIEZJUFMgUFVCIDE4MC0xXG4gKiBWZXJzaW9uIDIuMWEgQ29weXJpZ2h0IFBhdWwgSm9obnN0b24gMjAwMCAtIDIwMDIuXG4gKiBPdGhlciBjb250cmlidXRvcnM6IEdyZWcgSG9sdCwgQW5kcmV3IEtlcGVydCwgWWRuYXIsIExvc3RpbmV0XG4gKiBEaXN0cmlidXRlZCB1bmRlciB0aGUgQlNEIExpY2Vuc2VcbiAqIFNlZSBodHRwOi8vcGFqaG9tZS5vcmcudWsvY3J5cHQvbWQ1IGZvciBkZXRhaWxzLlxuICovXG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbnZhciBIYXNoID0gcmVxdWlyZSgnLi9oYXNoJylcblxudmFyIEsgPSBbXG4gIDB4NWE4Mjc5OTksIDB4NmVkOWViYTEsIDB4OGYxYmJjZGMgfCAwLCAweGNhNjJjMWQ2IHwgMFxuXVxuXG52YXIgVyA9IG5ldyBBcnJheSg4MClcblxuZnVuY3Rpb24gU2hhMSAoKSB7XG4gIHRoaXMuaW5pdCgpXG4gIHRoaXMuX3cgPSBXXG5cbiAgSGFzaC5jYWxsKHRoaXMsIDY0LCA1Nilcbn1cblxuaW5oZXJpdHMoU2hhMSwgSGFzaClcblxuU2hhMS5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5fYSA9IDB4Njc0NTIzMDFcbiAgdGhpcy5fYiA9IDB4ZWZjZGFiODlcbiAgdGhpcy5fYyA9IDB4OThiYWRjZmVcbiAgdGhpcy5fZCA9IDB4MTAzMjU0NzZcbiAgdGhpcy5fZSA9IDB4YzNkMmUxZjBcblxuICByZXR1cm4gdGhpc1xufVxuXG5mdW5jdGlvbiByb3RsMSAobnVtKSB7XG4gIHJldHVybiAobnVtIDw8IDEpIHwgKG51bSA+Pj4gMzEpXG59XG5cbmZ1bmN0aW9uIHJvdGw1IChudW0pIHtcbiAgcmV0dXJuIChudW0gPDwgNSkgfCAobnVtID4+PiAyNylcbn1cblxuZnVuY3Rpb24gcm90bDMwIChudW0pIHtcbiAgcmV0dXJuIChudW0gPDwgMzApIHwgKG51bSA+Pj4gMilcbn1cblxuZnVuY3Rpb24gZnQgKHMsIGIsIGMsIGQpIHtcbiAgaWYgKHMgPT09IDApIHJldHVybiAoYiAmIGMpIHwgKCh+YikgJiBkKVxuICBpZiAocyA9PT0gMikgcmV0dXJuIChiICYgYykgfCAoYiAmIGQpIHwgKGMgJiBkKVxuICByZXR1cm4gYiBeIGMgXiBkXG59XG5cblNoYTEucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbiAoTSkge1xuICB2YXIgVyA9IHRoaXMuX3dcblxuICB2YXIgYSA9IHRoaXMuX2EgfCAwXG4gIHZhciBiID0gdGhpcy5fYiB8IDBcbiAgdmFyIGMgPSB0aGlzLl9jIHwgMFxuICB2YXIgZCA9IHRoaXMuX2QgfCAwXG4gIHZhciBlID0gdGhpcy5fZSB8IDBcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IDE2OyArK2kpIFdbaV0gPSBNLnJlYWRJbnQzMkJFKGkgKiA0KVxuICBmb3IgKDsgaSA8IDgwOyArK2kpIFdbaV0gPSByb3RsMShXW2kgLSAzXSBeIFdbaSAtIDhdIF4gV1tpIC0gMTRdIF4gV1tpIC0gMTZdKVxuXG4gIGZvciAodmFyIGogPSAwOyBqIDwgODA7ICsraikge1xuICAgIHZhciBzID0gfn4oaiAvIDIwKVxuICAgIHZhciB0ID0gKHJvdGw1KGEpICsgZnQocywgYiwgYywgZCkgKyBlICsgV1tqXSArIEtbc10pIHwgMFxuXG4gICAgZSA9IGRcbiAgICBkID0gY1xuICAgIGMgPSByb3RsMzAoYilcbiAgICBiID0gYVxuICAgIGEgPSB0XG4gIH1cblxuICB0aGlzLl9hID0gKGEgKyB0aGlzLl9hKSB8IDBcbiAgdGhpcy5fYiA9IChiICsgdGhpcy5fYikgfCAwXG4gIHRoaXMuX2MgPSAoYyArIHRoaXMuX2MpIHwgMFxuICB0aGlzLl9kID0gKGQgKyB0aGlzLl9kKSB8IDBcbiAgdGhpcy5fZSA9IChlICsgdGhpcy5fZSkgfCAwXG59XG5cblNoYTEucHJvdG90eXBlLl9oYXNoID0gZnVuY3Rpb24gKCkge1xuICB2YXIgSCA9IG5ldyBCdWZmZXIoMjApXG5cbiAgSC53cml0ZUludDMyQkUodGhpcy5fYSB8IDAsIDApXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2IgfCAwLCA0KVxuICBILndyaXRlSW50MzJCRSh0aGlzLl9jIHwgMCwgOClcbiAgSC53cml0ZUludDMyQkUodGhpcy5fZCB8IDAsIDEyKVxuICBILndyaXRlSW50MzJCRSh0aGlzLl9lIHwgMCwgMTYpXG5cbiAgcmV0dXJuIEhcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBTaGExXG4iLCIvKipcbiAqIEEgSmF2YVNjcmlwdCBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgU2VjdXJlIEhhc2ggQWxnb3JpdGhtLCBTSEEtMjU2LCBhcyBkZWZpbmVkXG4gKiBpbiBGSVBTIDE4MC0yXG4gKiBWZXJzaW9uIDIuMi1iZXRhIENvcHlyaWdodCBBbmdlbCBNYXJpbiwgUGF1bCBKb2huc3RvbiAyMDAwIC0gMjAwOS5cbiAqIE90aGVyIGNvbnRyaWJ1dG9yczogR3JlZyBIb2x0LCBBbmRyZXcgS2VwZXJ0LCBZZG5hciwgTG9zdGluZXRcbiAqXG4gKi9cblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxudmFyIFNoYTI1NiA9IHJlcXVpcmUoJy4vc2hhMjU2JylcbnZhciBIYXNoID0gcmVxdWlyZSgnLi9oYXNoJylcblxudmFyIFcgPSBuZXcgQXJyYXkoNjQpXG5cbmZ1bmN0aW9uIFNoYTIyNCAoKSB7XG4gIHRoaXMuaW5pdCgpXG5cbiAgdGhpcy5fdyA9IFcgLy8gbmV3IEFycmF5KDY0KVxuXG4gIEhhc2guY2FsbCh0aGlzLCA2NCwgNTYpXG59XG5cbmluaGVyaXRzKFNoYTIyNCwgU2hhMjU2KVxuXG5TaGEyMjQucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuX2EgPSAweGMxMDU5ZWQ4XG4gIHRoaXMuX2IgPSAweDM2N2NkNTA3XG4gIHRoaXMuX2MgPSAweDMwNzBkZDE3XG4gIHRoaXMuX2QgPSAweGY3MGU1OTM5XG4gIHRoaXMuX2UgPSAweGZmYzAwYjMxXG4gIHRoaXMuX2YgPSAweDY4NTgxNTExXG4gIHRoaXMuX2cgPSAweDY0Zjk4ZmE3XG4gIHRoaXMuX2ggPSAweGJlZmE0ZmE0XG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuU2hhMjI0LnByb3RvdHlwZS5faGFzaCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIEggPSBuZXcgQnVmZmVyKDI4KVxuXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2EsIDApXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2IsIDQpXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2MsIDgpXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2QsIDEyKVxuICBILndyaXRlSW50MzJCRSh0aGlzLl9lLCAxNilcbiAgSC53cml0ZUludDMyQkUodGhpcy5fZiwgMjApXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2csIDI0KVxuXG4gIHJldHVybiBIXG59XG5cbm1vZHVsZS5leHBvcnRzID0gU2hhMjI0XG4iLCIvKipcbiAqIEEgSmF2YVNjcmlwdCBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgU2VjdXJlIEhhc2ggQWxnb3JpdGhtLCBTSEEtMjU2LCBhcyBkZWZpbmVkXG4gKiBpbiBGSVBTIDE4MC0yXG4gKiBWZXJzaW9uIDIuMi1iZXRhIENvcHlyaWdodCBBbmdlbCBNYXJpbiwgUGF1bCBKb2huc3RvbiAyMDAwIC0gMjAwOS5cbiAqIE90aGVyIGNvbnRyaWJ1dG9yczogR3JlZyBIb2x0LCBBbmRyZXcgS2VwZXJ0LCBZZG5hciwgTG9zdGluZXRcbiAqXG4gKi9cblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxudmFyIEhhc2ggPSByZXF1aXJlKCcuL2hhc2gnKVxuXG52YXIgSyA9IFtcbiAgMHg0MjhBMkY5OCwgMHg3MTM3NDQ5MSwgMHhCNUMwRkJDRiwgMHhFOUI1REJBNSxcbiAgMHgzOTU2QzI1QiwgMHg1OUYxMTFGMSwgMHg5MjNGODJBNCwgMHhBQjFDNUVENSxcbiAgMHhEODA3QUE5OCwgMHgxMjgzNUIwMSwgMHgyNDMxODVCRSwgMHg1NTBDN0RDMyxcbiAgMHg3MkJFNUQ3NCwgMHg4MERFQjFGRSwgMHg5QkRDMDZBNywgMHhDMTlCRjE3NCxcbiAgMHhFNDlCNjlDMSwgMHhFRkJFNDc4NiwgMHgwRkMxOURDNiwgMHgyNDBDQTFDQyxcbiAgMHgyREU5MkM2RiwgMHg0QTc0ODRBQSwgMHg1Q0IwQTlEQywgMHg3NkY5ODhEQSxcbiAgMHg5ODNFNTE1MiwgMHhBODMxQzY2RCwgMHhCMDAzMjdDOCwgMHhCRjU5N0ZDNyxcbiAgMHhDNkUwMEJGMywgMHhENUE3OTE0NywgMHgwNkNBNjM1MSwgMHgxNDI5Mjk2NyxcbiAgMHgyN0I3MEE4NSwgMHgyRTFCMjEzOCwgMHg0RDJDNkRGQywgMHg1MzM4MEQxMyxcbiAgMHg2NTBBNzM1NCwgMHg3NjZBMEFCQiwgMHg4MUMyQzkyRSwgMHg5MjcyMkM4NSxcbiAgMHhBMkJGRThBMSwgMHhBODFBNjY0QiwgMHhDMjRCOEI3MCwgMHhDNzZDNTFBMyxcbiAgMHhEMTkyRTgxOSwgMHhENjk5MDYyNCwgMHhGNDBFMzU4NSwgMHgxMDZBQTA3MCxcbiAgMHgxOUE0QzExNiwgMHgxRTM3NkMwOCwgMHgyNzQ4Nzc0QywgMHgzNEIwQkNCNSxcbiAgMHgzOTFDMENCMywgMHg0RUQ4QUE0QSwgMHg1QjlDQ0E0RiwgMHg2ODJFNkZGMyxcbiAgMHg3NDhGODJFRSwgMHg3OEE1NjM2RiwgMHg4NEM4NzgxNCwgMHg4Q0M3MDIwOCxcbiAgMHg5MEJFRkZGQSwgMHhBNDUwNkNFQiwgMHhCRUY5QTNGNywgMHhDNjcxNzhGMlxuXVxuXG52YXIgVyA9IG5ldyBBcnJheSg2NClcblxuZnVuY3Rpb24gU2hhMjU2ICgpIHtcbiAgdGhpcy5pbml0KClcblxuICB0aGlzLl93ID0gVyAvLyBuZXcgQXJyYXkoNjQpXG5cbiAgSGFzaC5jYWxsKHRoaXMsIDY0LCA1Nilcbn1cblxuaW5oZXJpdHMoU2hhMjU2LCBIYXNoKVxuXG5TaGEyNTYucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuX2EgPSAweDZhMDllNjY3XG4gIHRoaXMuX2IgPSAweGJiNjdhZTg1XG4gIHRoaXMuX2MgPSAweDNjNmVmMzcyXG4gIHRoaXMuX2QgPSAweGE1NGZmNTNhXG4gIHRoaXMuX2UgPSAweDUxMGU1MjdmXG4gIHRoaXMuX2YgPSAweDliMDU2ODhjXG4gIHRoaXMuX2cgPSAweDFmODNkOWFiXG4gIHRoaXMuX2ggPSAweDViZTBjZDE5XG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuZnVuY3Rpb24gY2ggKHgsIHksIHopIHtcbiAgcmV0dXJuIHogXiAoeCAmICh5IF4geikpXG59XG5cbmZ1bmN0aW9uIG1haiAoeCwgeSwgeikge1xuICByZXR1cm4gKHggJiB5KSB8ICh6ICYgKHggfCB5KSlcbn1cblxuZnVuY3Rpb24gc2lnbWEwICh4KSB7XG4gIHJldHVybiAoeCA+Pj4gMiB8IHggPDwgMzApIF4gKHggPj4+IDEzIHwgeCA8PCAxOSkgXiAoeCA+Pj4gMjIgfCB4IDw8IDEwKVxufVxuXG5mdW5jdGlvbiBzaWdtYTEgKHgpIHtcbiAgcmV0dXJuICh4ID4+PiA2IHwgeCA8PCAyNikgXiAoeCA+Pj4gMTEgfCB4IDw8IDIxKSBeICh4ID4+PiAyNSB8IHggPDwgNylcbn1cblxuZnVuY3Rpb24gZ2FtbWEwICh4KSB7XG4gIHJldHVybiAoeCA+Pj4gNyB8IHggPDwgMjUpIF4gKHggPj4+IDE4IHwgeCA8PCAxNCkgXiAoeCA+Pj4gMylcbn1cblxuZnVuY3Rpb24gZ2FtbWExICh4KSB7XG4gIHJldHVybiAoeCA+Pj4gMTcgfCB4IDw8IDE1KSBeICh4ID4+PiAxOSB8IHggPDwgMTMpIF4gKHggPj4+IDEwKVxufVxuXG5TaGEyNTYucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbiAoTSkge1xuICB2YXIgVyA9IHRoaXMuX3dcblxuICB2YXIgYSA9IHRoaXMuX2EgfCAwXG4gIHZhciBiID0gdGhpcy5fYiB8IDBcbiAgdmFyIGMgPSB0aGlzLl9jIHwgMFxuICB2YXIgZCA9IHRoaXMuX2QgfCAwXG4gIHZhciBlID0gdGhpcy5fZSB8IDBcbiAgdmFyIGYgPSB0aGlzLl9mIHwgMFxuICB2YXIgZyA9IHRoaXMuX2cgfCAwXG4gIHZhciBoID0gdGhpcy5faCB8IDBcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IDE2OyArK2kpIFdbaV0gPSBNLnJlYWRJbnQzMkJFKGkgKiA0KVxuICBmb3IgKDsgaSA8IDY0OyArK2kpIFdbaV0gPSAoZ2FtbWExKFdbaSAtIDJdKSArIFdbaSAtIDddICsgZ2FtbWEwKFdbaSAtIDE1XSkgKyBXW2kgLSAxNl0pIHwgMFxuXG4gIGZvciAodmFyIGogPSAwOyBqIDwgNjQ7ICsraikge1xuICAgIHZhciBUMSA9IChoICsgc2lnbWExKGUpICsgY2goZSwgZiwgZykgKyBLW2pdICsgV1tqXSkgfCAwXG4gICAgdmFyIFQyID0gKHNpZ21hMChhKSArIG1haihhLCBiLCBjKSkgfCAwXG5cbiAgICBoID0gZ1xuICAgIGcgPSBmXG4gICAgZiA9IGVcbiAgICBlID0gKGQgKyBUMSkgfCAwXG4gICAgZCA9IGNcbiAgICBjID0gYlxuICAgIGIgPSBhXG4gICAgYSA9IChUMSArIFQyKSB8IDBcbiAgfVxuXG4gIHRoaXMuX2EgPSAoYSArIHRoaXMuX2EpIHwgMFxuICB0aGlzLl9iID0gKGIgKyB0aGlzLl9iKSB8IDBcbiAgdGhpcy5fYyA9IChjICsgdGhpcy5fYykgfCAwXG4gIHRoaXMuX2QgPSAoZCArIHRoaXMuX2QpIHwgMFxuICB0aGlzLl9lID0gKGUgKyB0aGlzLl9lKSB8IDBcbiAgdGhpcy5fZiA9IChmICsgdGhpcy5fZikgfCAwXG4gIHRoaXMuX2cgPSAoZyArIHRoaXMuX2cpIHwgMFxuICB0aGlzLl9oID0gKGggKyB0aGlzLl9oKSB8IDBcbn1cblxuU2hhMjU2LnByb3RvdHlwZS5faGFzaCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIEggPSBuZXcgQnVmZmVyKDMyKVxuXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2EsIDApXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2IsIDQpXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2MsIDgpXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2QsIDEyKVxuICBILndyaXRlSW50MzJCRSh0aGlzLl9lLCAxNilcbiAgSC53cml0ZUludDMyQkUodGhpcy5fZiwgMjApXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2csIDI0KVxuICBILndyaXRlSW50MzJCRSh0aGlzLl9oLCAyOClcblxuICByZXR1cm4gSFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFNoYTI1NlxuIiwidmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxudmFyIFNIQTUxMiA9IHJlcXVpcmUoJy4vc2hhNTEyJylcbnZhciBIYXNoID0gcmVxdWlyZSgnLi9oYXNoJylcblxudmFyIFcgPSBuZXcgQXJyYXkoMTYwKVxuXG5mdW5jdGlvbiBTaGEzODQgKCkge1xuICB0aGlzLmluaXQoKVxuICB0aGlzLl93ID0gV1xuXG4gIEhhc2guY2FsbCh0aGlzLCAxMjgsIDExMilcbn1cblxuaW5oZXJpdHMoU2hhMzg0LCBTSEE1MTIpXG5cblNoYTM4NC5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5fYWggPSAweGNiYmI5ZDVkXG4gIHRoaXMuX2JoID0gMHg2MjlhMjkyYVxuICB0aGlzLl9jaCA9IDB4OTE1OTAxNWFcbiAgdGhpcy5fZGggPSAweDE1MmZlY2Q4XG4gIHRoaXMuX2VoID0gMHg2NzMzMjY2N1xuICB0aGlzLl9maCA9IDB4OGViNDRhODdcbiAgdGhpcy5fZ2ggPSAweGRiMGMyZTBkXG4gIHRoaXMuX2hoID0gMHg0N2I1NDgxZFxuXG4gIHRoaXMuX2FsID0gMHhjMTA1OWVkOFxuICB0aGlzLl9ibCA9IDB4MzY3Y2Q1MDdcbiAgdGhpcy5fY2wgPSAweDMwNzBkZDE3XG4gIHRoaXMuX2RsID0gMHhmNzBlNTkzOVxuICB0aGlzLl9lbCA9IDB4ZmZjMDBiMzFcbiAgdGhpcy5fZmwgPSAweDY4NTgxNTExXG4gIHRoaXMuX2dsID0gMHg2NGY5OGZhN1xuICB0aGlzLl9obCA9IDB4YmVmYTRmYTRcblxuICByZXR1cm4gdGhpc1xufVxuXG5TaGEzODQucHJvdG90eXBlLl9oYXNoID0gZnVuY3Rpb24gKCkge1xuICB2YXIgSCA9IG5ldyBCdWZmZXIoNDgpXG5cbiAgZnVuY3Rpb24gd3JpdGVJbnQ2NEJFIChoLCBsLCBvZmZzZXQpIHtcbiAgICBILndyaXRlSW50MzJCRShoLCBvZmZzZXQpXG4gICAgSC53cml0ZUludDMyQkUobCwgb2Zmc2V0ICsgNClcbiAgfVxuXG4gIHdyaXRlSW50NjRCRSh0aGlzLl9haCwgdGhpcy5fYWwsIDApXG4gIHdyaXRlSW50NjRCRSh0aGlzLl9iaCwgdGhpcy5fYmwsIDgpXG4gIHdyaXRlSW50NjRCRSh0aGlzLl9jaCwgdGhpcy5fY2wsIDE2KVxuICB3cml0ZUludDY0QkUodGhpcy5fZGgsIHRoaXMuX2RsLCAyNClcbiAgd3JpdGVJbnQ2NEJFKHRoaXMuX2VoLCB0aGlzLl9lbCwgMzIpXG4gIHdyaXRlSW50NjRCRSh0aGlzLl9maCwgdGhpcy5fZmwsIDQwKVxuXG4gIHJldHVybiBIXG59XG5cbm1vZHVsZS5leHBvcnRzID0gU2hhMzg0XG4iLCJ2YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG52YXIgSGFzaCA9IHJlcXVpcmUoJy4vaGFzaCcpXG5cbnZhciBLID0gW1xuICAweDQyOGEyZjk4LCAweGQ3MjhhZTIyLCAweDcxMzc0NDkxLCAweDIzZWY2NWNkLFxuICAweGI1YzBmYmNmLCAweGVjNGQzYjJmLCAweGU5YjVkYmE1LCAweDgxODlkYmJjLFxuICAweDM5NTZjMjViLCAweGYzNDhiNTM4LCAweDU5ZjExMWYxLCAweGI2MDVkMDE5LFxuICAweDkyM2Y4MmE0LCAweGFmMTk0ZjliLCAweGFiMWM1ZWQ1LCAweGRhNmQ4MTE4LFxuICAweGQ4MDdhYTk4LCAweGEzMDMwMjQyLCAweDEyODM1YjAxLCAweDQ1NzA2ZmJlLFxuICAweDI0MzE4NWJlLCAweDRlZTRiMjhjLCAweDU1MGM3ZGMzLCAweGQ1ZmZiNGUyLFxuICAweDcyYmU1ZDc0LCAweGYyN2I4OTZmLCAweDgwZGViMWZlLCAweDNiMTY5NmIxLFxuICAweDliZGMwNmE3LCAweDI1YzcxMjM1LCAweGMxOWJmMTc0LCAweGNmNjkyNjk0LFxuICAweGU0OWI2OWMxLCAweDllZjE0YWQyLCAweGVmYmU0Nzg2LCAweDM4NGYyNWUzLFxuICAweDBmYzE5ZGM2LCAweDhiOGNkNWI1LCAweDI0MGNhMWNjLCAweDc3YWM5YzY1LFxuICAweDJkZTkyYzZmLCAweDU5MmIwMjc1LCAweDRhNzQ4NGFhLCAweDZlYTZlNDgzLFxuICAweDVjYjBhOWRjLCAweGJkNDFmYmQ0LCAweDc2Zjk4OGRhLCAweDgzMTE1M2I1LFxuICAweDk4M2U1MTUyLCAweGVlNjZkZmFiLCAweGE4MzFjNjZkLCAweDJkYjQzMjEwLFxuICAweGIwMDMyN2M4LCAweDk4ZmIyMTNmLCAweGJmNTk3ZmM3LCAweGJlZWYwZWU0LFxuICAweGM2ZTAwYmYzLCAweDNkYTg4ZmMyLCAweGQ1YTc5MTQ3LCAweDkzMGFhNzI1LFxuICAweDA2Y2E2MzUxLCAweGUwMDM4MjZmLCAweDE0MjkyOTY3LCAweDBhMGU2ZTcwLFxuICAweDI3YjcwYTg1LCAweDQ2ZDIyZmZjLCAweDJlMWIyMTM4LCAweDVjMjZjOTI2LFxuICAweDRkMmM2ZGZjLCAweDVhYzQyYWVkLCAweDUzMzgwZDEzLCAweDlkOTViM2RmLFxuICAweDY1MGE3MzU0LCAweDhiYWY2M2RlLCAweDc2NmEwYWJiLCAweDNjNzdiMmE4LFxuICAweDgxYzJjOTJlLCAweDQ3ZWRhZWU2LCAweDkyNzIyYzg1LCAweDE0ODIzNTNiLFxuICAweGEyYmZlOGExLCAweDRjZjEwMzY0LCAweGE4MWE2NjRiLCAweGJjNDIzMDAxLFxuICAweGMyNGI4YjcwLCAweGQwZjg5NzkxLCAweGM3NmM1MWEzLCAweDA2NTRiZTMwLFxuICAweGQxOTJlODE5LCAweGQ2ZWY1MjE4LCAweGQ2OTkwNjI0LCAweDU1NjVhOTEwLFxuICAweGY0MGUzNTg1LCAweDU3NzEyMDJhLCAweDEwNmFhMDcwLCAweDMyYmJkMWI4LFxuICAweDE5YTRjMTE2LCAweGI4ZDJkMGM4LCAweDFlMzc2YzA4LCAweDUxNDFhYjUzLFxuICAweDI3NDg3NzRjLCAweGRmOGVlYjk5LCAweDM0YjBiY2I1LCAweGUxOWI0OGE4LFxuICAweDM5MWMwY2IzLCAweGM1Yzk1YTYzLCAweDRlZDhhYTRhLCAweGUzNDE4YWNiLFxuICAweDViOWNjYTRmLCAweDc3NjNlMzczLCAweDY4MmU2ZmYzLCAweGQ2YjJiOGEzLFxuICAweDc0OGY4MmVlLCAweDVkZWZiMmZjLCAweDc4YTU2MzZmLCAweDQzMTcyZjYwLFxuICAweDg0Yzg3ODE0LCAweGExZjBhYjcyLCAweDhjYzcwMjA4LCAweDFhNjQzOWVjLFxuICAweDkwYmVmZmZhLCAweDIzNjMxZTI4LCAweGE0NTA2Y2ViLCAweGRlODJiZGU5LFxuICAweGJlZjlhM2Y3LCAweGIyYzY3OTE1LCAweGM2NzE3OGYyLCAweGUzNzI1MzJiLFxuICAweGNhMjczZWNlLCAweGVhMjY2MTljLCAweGQxODZiOGM3LCAweDIxYzBjMjA3LFxuICAweGVhZGE3ZGQ2LCAweGNkZTBlYjFlLCAweGY1N2Q0ZjdmLCAweGVlNmVkMTc4LFxuICAweDA2ZjA2N2FhLCAweDcyMTc2ZmJhLCAweDBhNjM3ZGM1LCAweGEyYzg5OGE2LFxuICAweDExM2Y5ODA0LCAweGJlZjkwZGFlLCAweDFiNzEwYjM1LCAweDEzMWM0NzFiLFxuICAweDI4ZGI3N2Y1LCAweDIzMDQ3ZDg0LCAweDMyY2FhYjdiLCAweDQwYzcyNDkzLFxuICAweDNjOWViZTBhLCAweDE1YzliZWJjLCAweDQzMWQ2N2M0LCAweDljMTAwZDRjLFxuICAweDRjYzVkNGJlLCAweGNiM2U0MmI2LCAweDU5N2YyOTljLCAweGZjNjU3ZTJhLFxuICAweDVmY2I2ZmFiLCAweDNhZDZmYWVjLCAweDZjNDQxOThjLCAweDRhNDc1ODE3XG5dXG5cbnZhciBXID0gbmV3IEFycmF5KDE2MClcblxuZnVuY3Rpb24gU2hhNTEyICgpIHtcbiAgdGhpcy5pbml0KClcbiAgdGhpcy5fdyA9IFdcblxuICBIYXNoLmNhbGwodGhpcywgMTI4LCAxMTIpXG59XG5cbmluaGVyaXRzKFNoYTUxMiwgSGFzaClcblxuU2hhNTEyLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLl9haCA9IDB4NmEwOWU2NjdcbiAgdGhpcy5fYmggPSAweGJiNjdhZTg1XG4gIHRoaXMuX2NoID0gMHgzYzZlZjM3MlxuICB0aGlzLl9kaCA9IDB4YTU0ZmY1M2FcbiAgdGhpcy5fZWggPSAweDUxMGU1MjdmXG4gIHRoaXMuX2ZoID0gMHg5YjA1Njg4Y1xuICB0aGlzLl9naCA9IDB4MWY4M2Q5YWJcbiAgdGhpcy5faGggPSAweDViZTBjZDE5XG5cbiAgdGhpcy5fYWwgPSAweGYzYmNjOTA4XG4gIHRoaXMuX2JsID0gMHg4NGNhYTczYlxuICB0aGlzLl9jbCA9IDB4ZmU5NGY4MmJcbiAgdGhpcy5fZGwgPSAweDVmMWQzNmYxXG4gIHRoaXMuX2VsID0gMHhhZGU2ODJkMVxuICB0aGlzLl9mbCA9IDB4MmIzZTZjMWZcbiAgdGhpcy5fZ2wgPSAweGZiNDFiZDZiXG4gIHRoaXMuX2hsID0gMHgxMzdlMjE3OVxuXG4gIHJldHVybiB0aGlzXG59XG5cbmZ1bmN0aW9uIENoICh4LCB5LCB6KSB7XG4gIHJldHVybiB6IF4gKHggJiAoeSBeIHopKVxufVxuXG5mdW5jdGlvbiBtYWogKHgsIHksIHopIHtcbiAgcmV0dXJuICh4ICYgeSkgfCAoeiAmICh4IHwgeSkpXG59XG5cbmZ1bmN0aW9uIHNpZ21hMCAoeCwgeGwpIHtcbiAgcmV0dXJuICh4ID4+PiAyOCB8IHhsIDw8IDQpIF4gKHhsID4+PiAyIHwgeCA8PCAzMCkgXiAoeGwgPj4+IDcgfCB4IDw8IDI1KVxufVxuXG5mdW5jdGlvbiBzaWdtYTEgKHgsIHhsKSB7XG4gIHJldHVybiAoeCA+Pj4gMTQgfCB4bCA8PCAxOCkgXiAoeCA+Pj4gMTggfCB4bCA8PCAxNCkgXiAoeGwgPj4+IDkgfCB4IDw8IDIzKVxufVxuXG5mdW5jdGlvbiBHYW1tYTAgKHgsIHhsKSB7XG4gIHJldHVybiAoeCA+Pj4gMSB8IHhsIDw8IDMxKSBeICh4ID4+PiA4IHwgeGwgPDwgMjQpIF4gKHggPj4+IDcpXG59XG5cbmZ1bmN0aW9uIEdhbW1hMGwgKHgsIHhsKSB7XG4gIHJldHVybiAoeCA+Pj4gMSB8IHhsIDw8IDMxKSBeICh4ID4+PiA4IHwgeGwgPDwgMjQpIF4gKHggPj4+IDcgfCB4bCA8PCAyNSlcbn1cblxuZnVuY3Rpb24gR2FtbWExICh4LCB4bCkge1xuICByZXR1cm4gKHggPj4+IDE5IHwgeGwgPDwgMTMpIF4gKHhsID4+PiAyOSB8IHggPDwgMykgXiAoeCA+Pj4gNilcbn1cblxuZnVuY3Rpb24gR2FtbWExbCAoeCwgeGwpIHtcbiAgcmV0dXJuICh4ID4+PiAxOSB8IHhsIDw8IDEzKSBeICh4bCA+Pj4gMjkgfCB4IDw8IDMpIF4gKHggPj4+IDYgfCB4bCA8PCAyNilcbn1cblxuZnVuY3Rpb24gZ2V0Q2FycnkgKGEsIGIpIHtcbiAgcmV0dXJuIChhID4+PiAwKSA8IChiID4+PiAwKSA/IDEgOiAwXG59XG5cblNoYTUxMi5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uIChNKSB7XG4gIHZhciBXID0gdGhpcy5fd1xuXG4gIHZhciBhaCA9IHRoaXMuX2FoIHwgMFxuICB2YXIgYmggPSB0aGlzLl9iaCB8IDBcbiAgdmFyIGNoID0gdGhpcy5fY2ggfCAwXG4gIHZhciBkaCA9IHRoaXMuX2RoIHwgMFxuICB2YXIgZWggPSB0aGlzLl9laCB8IDBcbiAgdmFyIGZoID0gdGhpcy5fZmggfCAwXG4gIHZhciBnaCA9IHRoaXMuX2doIHwgMFxuICB2YXIgaGggPSB0aGlzLl9oaCB8IDBcblxuICB2YXIgYWwgPSB0aGlzLl9hbCB8IDBcbiAgdmFyIGJsID0gdGhpcy5fYmwgfCAwXG4gIHZhciBjbCA9IHRoaXMuX2NsIHwgMFxuICB2YXIgZGwgPSB0aGlzLl9kbCB8IDBcbiAgdmFyIGVsID0gdGhpcy5fZWwgfCAwXG4gIHZhciBmbCA9IHRoaXMuX2ZsIHwgMFxuICB2YXIgZ2wgPSB0aGlzLl9nbCB8IDBcbiAgdmFyIGhsID0gdGhpcy5faGwgfCAwXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCAzMjsgaSArPSAyKSB7XG4gICAgV1tpXSA9IE0ucmVhZEludDMyQkUoaSAqIDQpXG4gICAgV1tpICsgMV0gPSBNLnJlYWRJbnQzMkJFKGkgKiA0ICsgNClcbiAgfVxuICBmb3IgKDsgaSA8IDE2MDsgaSArPSAyKSB7XG4gICAgdmFyIHhoID0gV1tpIC0gMTUgKiAyXVxuICAgIHZhciB4bCA9IFdbaSAtIDE1ICogMiArIDFdXG4gICAgdmFyIGdhbW1hMCA9IEdhbW1hMCh4aCwgeGwpXG4gICAgdmFyIGdhbW1hMGwgPSBHYW1tYTBsKHhsLCB4aClcblxuICAgIHhoID0gV1tpIC0gMiAqIDJdXG4gICAgeGwgPSBXW2kgLSAyICogMiArIDFdXG4gICAgdmFyIGdhbW1hMSA9IEdhbW1hMSh4aCwgeGwpXG4gICAgdmFyIGdhbW1hMWwgPSBHYW1tYTFsKHhsLCB4aClcblxuICAgIC8vIFdbaV0gPSBnYW1tYTAgKyBXW2kgLSA3XSArIGdhbW1hMSArIFdbaSAtIDE2XVxuICAgIHZhciBXaTdoID0gV1tpIC0gNyAqIDJdXG4gICAgdmFyIFdpN2wgPSBXW2kgLSA3ICogMiArIDFdXG5cbiAgICB2YXIgV2kxNmggPSBXW2kgLSAxNiAqIDJdXG4gICAgdmFyIFdpMTZsID0gV1tpIC0gMTYgKiAyICsgMV1cblxuICAgIHZhciBXaWwgPSAoZ2FtbWEwbCArIFdpN2wpIHwgMFxuICAgIHZhciBXaWggPSAoZ2FtbWEwICsgV2k3aCArIGdldENhcnJ5KFdpbCwgZ2FtbWEwbCkpIHwgMFxuICAgIFdpbCA9IChXaWwgKyBnYW1tYTFsKSB8IDBcbiAgICBXaWggPSAoV2loICsgZ2FtbWExICsgZ2V0Q2FycnkoV2lsLCBnYW1tYTFsKSkgfCAwXG4gICAgV2lsID0gKFdpbCArIFdpMTZsKSB8IDBcbiAgICBXaWggPSAoV2loICsgV2kxNmggKyBnZXRDYXJyeShXaWwsIFdpMTZsKSkgfCAwXG5cbiAgICBXW2ldID0gV2loXG4gICAgV1tpICsgMV0gPSBXaWxcbiAgfVxuXG4gIGZvciAodmFyIGogPSAwOyBqIDwgMTYwOyBqICs9IDIpIHtcbiAgICBXaWggPSBXW2pdXG4gICAgV2lsID0gV1tqICsgMV1cblxuICAgIHZhciBtYWpoID0gbWFqKGFoLCBiaCwgY2gpXG4gICAgdmFyIG1hamwgPSBtYWooYWwsIGJsLCBjbClcblxuICAgIHZhciBzaWdtYTBoID0gc2lnbWEwKGFoLCBhbClcbiAgICB2YXIgc2lnbWEwbCA9IHNpZ21hMChhbCwgYWgpXG4gICAgdmFyIHNpZ21hMWggPSBzaWdtYTEoZWgsIGVsKVxuICAgIHZhciBzaWdtYTFsID0gc2lnbWExKGVsLCBlaClcblxuICAgIC8vIHQxID0gaCArIHNpZ21hMSArIGNoICsgS1tqXSArIFdbal1cbiAgICB2YXIgS2loID0gS1tqXVxuICAgIHZhciBLaWwgPSBLW2ogKyAxXVxuXG4gICAgdmFyIGNoaCA9IENoKGVoLCBmaCwgZ2gpXG4gICAgdmFyIGNobCA9IENoKGVsLCBmbCwgZ2wpXG5cbiAgICB2YXIgdDFsID0gKGhsICsgc2lnbWExbCkgfCAwXG4gICAgdmFyIHQxaCA9IChoaCArIHNpZ21hMWggKyBnZXRDYXJyeSh0MWwsIGhsKSkgfCAwXG4gICAgdDFsID0gKHQxbCArIGNobCkgfCAwXG4gICAgdDFoID0gKHQxaCArIGNoaCArIGdldENhcnJ5KHQxbCwgY2hsKSkgfCAwXG4gICAgdDFsID0gKHQxbCArIEtpbCkgfCAwXG4gICAgdDFoID0gKHQxaCArIEtpaCArIGdldENhcnJ5KHQxbCwgS2lsKSkgfCAwXG4gICAgdDFsID0gKHQxbCArIFdpbCkgfCAwXG4gICAgdDFoID0gKHQxaCArIFdpaCArIGdldENhcnJ5KHQxbCwgV2lsKSkgfCAwXG5cbiAgICAvLyB0MiA9IHNpZ21hMCArIG1halxuICAgIHZhciB0MmwgPSAoc2lnbWEwbCArIG1hamwpIHwgMFxuICAgIHZhciB0MmggPSAoc2lnbWEwaCArIG1hamggKyBnZXRDYXJyeSh0MmwsIHNpZ21hMGwpKSB8IDBcblxuICAgIGhoID0gZ2hcbiAgICBobCA9IGdsXG4gICAgZ2ggPSBmaFxuICAgIGdsID0gZmxcbiAgICBmaCA9IGVoXG4gICAgZmwgPSBlbFxuICAgIGVsID0gKGRsICsgdDFsKSB8IDBcbiAgICBlaCA9IChkaCArIHQxaCArIGdldENhcnJ5KGVsLCBkbCkpIHwgMFxuICAgIGRoID0gY2hcbiAgICBkbCA9IGNsXG4gICAgY2ggPSBiaFxuICAgIGNsID0gYmxcbiAgICBiaCA9IGFoXG4gICAgYmwgPSBhbFxuICAgIGFsID0gKHQxbCArIHQybCkgfCAwXG4gICAgYWggPSAodDFoICsgdDJoICsgZ2V0Q2FycnkoYWwsIHQxbCkpIHwgMFxuICB9XG5cbiAgdGhpcy5fYWwgPSAodGhpcy5fYWwgKyBhbCkgfCAwXG4gIHRoaXMuX2JsID0gKHRoaXMuX2JsICsgYmwpIHwgMFxuICB0aGlzLl9jbCA9ICh0aGlzLl9jbCArIGNsKSB8IDBcbiAgdGhpcy5fZGwgPSAodGhpcy5fZGwgKyBkbCkgfCAwXG4gIHRoaXMuX2VsID0gKHRoaXMuX2VsICsgZWwpIHwgMFxuICB0aGlzLl9mbCA9ICh0aGlzLl9mbCArIGZsKSB8IDBcbiAgdGhpcy5fZ2wgPSAodGhpcy5fZ2wgKyBnbCkgfCAwXG4gIHRoaXMuX2hsID0gKHRoaXMuX2hsICsgaGwpIHwgMFxuXG4gIHRoaXMuX2FoID0gKHRoaXMuX2FoICsgYWggKyBnZXRDYXJyeSh0aGlzLl9hbCwgYWwpKSB8IDBcbiAgdGhpcy5fYmggPSAodGhpcy5fYmggKyBiaCArIGdldENhcnJ5KHRoaXMuX2JsLCBibCkpIHwgMFxuICB0aGlzLl9jaCA9ICh0aGlzLl9jaCArIGNoICsgZ2V0Q2FycnkodGhpcy5fY2wsIGNsKSkgfCAwXG4gIHRoaXMuX2RoID0gKHRoaXMuX2RoICsgZGggKyBnZXRDYXJyeSh0aGlzLl9kbCwgZGwpKSB8IDBcbiAgdGhpcy5fZWggPSAodGhpcy5fZWggKyBlaCArIGdldENhcnJ5KHRoaXMuX2VsLCBlbCkpIHwgMFxuICB0aGlzLl9maCA9ICh0aGlzLl9maCArIGZoICsgZ2V0Q2FycnkodGhpcy5fZmwsIGZsKSkgfCAwXG4gIHRoaXMuX2doID0gKHRoaXMuX2doICsgZ2ggKyBnZXRDYXJyeSh0aGlzLl9nbCwgZ2wpKSB8IDBcbiAgdGhpcy5faGggPSAodGhpcy5faGggKyBoaCArIGdldENhcnJ5KHRoaXMuX2hsLCBobCkpIHwgMFxufVxuXG5TaGE1MTIucHJvdG90eXBlLl9oYXNoID0gZnVuY3Rpb24gKCkge1xuICB2YXIgSCA9IG5ldyBCdWZmZXIoNjQpXG5cbiAgZnVuY3Rpb24gd3JpdGVJbnQ2NEJFIChoLCBsLCBvZmZzZXQpIHtcbiAgICBILndyaXRlSW50MzJCRShoLCBvZmZzZXQpXG4gICAgSC53cml0ZUludDMyQkUobCwgb2Zmc2V0ICsgNClcbiAgfVxuXG4gIHdyaXRlSW50NjRCRSh0aGlzLl9haCwgdGhpcy5fYWwsIDApXG4gIHdyaXRlSW50NjRCRSh0aGlzLl9iaCwgdGhpcy5fYmwsIDgpXG4gIHdyaXRlSW50NjRCRSh0aGlzLl9jaCwgdGhpcy5fY2wsIDE2KVxuICB3cml0ZUludDY0QkUodGhpcy5fZGgsIHRoaXMuX2RsLCAyNClcbiAgd3JpdGVJbnQ2NEJFKHRoaXMuX2VoLCB0aGlzLl9lbCwgMzIpXG4gIHdyaXRlSW50NjRCRSh0aGlzLl9maCwgdGhpcy5fZmwsIDQwKVxuICB3cml0ZUludDY0QkUodGhpcy5fZ2gsIHRoaXMuX2dsLCA0OClcbiAgd3JpdGVJbnQ2NEJFKHRoaXMuX2hoLCB0aGlzLl9obCwgNTYpXG5cbiAgcmV0dXJuIEhcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBTaGE1MTJcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoc3RyLCBzZWFyY2gsIHBvcykge1xuXHRwb3MgPSB0eXBlb2YgcG9zID09PSAnbnVtYmVyJyA/IHBvcyA6IDA7XG5cblx0aWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgYSBzdHJpbmcnKTtcblx0fVxuXG5cdHJldHVybiBzdHIuaW5kZXhPZihzZWFyY2gsIHBvcykgIT09IC0xO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgZGF0ZVRpbWVSZWdleCA9IC9eKFxcZHs0fSk6KFxcZHsyfSk6KFxcZHsyfSkgKFxcZHsyfSk6KFxcZHsyfSk6KFxcZHsyfSkkLztcblxuY2xhc3MgSUZEIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5maWVsZHMgPSBuZXcgTWFwKCk7XG4gICAgfVxuXG4gICAgLy8gQ3VzdG9tIGZpZWxkc1xuICAgIGdldCBzaXplKCkge1xuICAgICAgICByZXR1cm4gdGhpcy53aWR0aCAqIHRoaXMuaGVpZ2h0O1xuICAgIH1cbiAgICBnZXQgd2lkdGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmltYWdlV2lkdGg7XG4gICAgfVxuICAgIGdldCBoZWlnaHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmltYWdlTGVuZ3RoO1xuICAgIH1cbiAgICBnZXQgY29tcG9uZW50cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2FtcGxlc1BlclBpeGVsO1xuICAgIH1cbiAgICBnZXQgZGF0ZSgpIHtcbiAgICAgICAgdmFyIGRhdGUgPSBuZXcgRGF0ZSgpO1xuICAgICAgICB2YXIgcmVzdWx0ID0gZGF0ZVRpbWVSZWdleC5leGVjKHRoaXMuZGF0ZVRpbWUpO1xuICAgICAgICBkYXRlLnNldEZ1bGxZZWFyKHJlc3VsdFsxXSwgcmVzdWx0WzJdIC0gMSwgcmVzdWx0WzNdKTtcbiAgICAgICAgZGF0ZS5zZXRIb3VycyhyZXN1bHRbNF0sIHJlc3VsdFs1XSwgcmVzdWx0WzZdKTtcbiAgICAgICAgcmV0dXJuIGRhdGU7XG4gICAgfVxuXG4gICAgLy8gSUZEIGZpZWxkc1xuICAgIGdldCBuZXdTdWJmaWxlVHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmllbGRzLmdldCgyNTQpXG4gICAgfVxuICAgIGdldCBpbWFnZVdpZHRoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5maWVsZHMuZ2V0KDI1Nik7XG4gICAgfVxuICAgIGdldCBpbWFnZUxlbmd0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmllbGRzLmdldCgyNTcpO1xuICAgIH1cbiAgICBnZXQgYml0c1BlclNhbXBsZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmllbGRzLmdldCgyNTgpO1xuICAgIH1cbiAgICBnZXQgY29tcHJlc3Npb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZpZWxkcy5nZXQoMjU5KSB8fCAxO1xuICAgIH1cbiAgICBnZXQgdHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmllbGRzLmdldCgyNjIpO1xuICAgIH1cbiAgICBnZXQgZmlsbE9yZGVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5maWVsZHMuZ2V0KDI2NikgfHwgMTtcbiAgICB9XG4gICAgZ2V0IGRvY3VtZW50TmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmllbGRzLmdldCgyNjkpO1xuICAgIH1cbiAgICBnZXQgaW1hZ2VEZXNjcmlwdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmllbGRzLmdldCgyNzApO1xuICAgIH1cbiAgICBnZXQgc3RyaXBPZmZzZXRzKCkge1xuICAgICAgICByZXR1cm4gYWx3YXlzQXJyYXkodGhpcy5maWVsZHMuZ2V0KDI3MykpO1xuICAgIH1cbiAgICBnZXQgb3JpZW50YXRpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZpZWxkcy5nZXQoMjc0KTtcbiAgICB9XG4gICAgZ2V0IHNhbXBsZXNQZXJQaXhlbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmllbGRzLmdldCgyNzcpO1xuICAgIH1cbiAgICBnZXQgcm93c1BlclN0cmlwKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5maWVsZHMuZ2V0KDI3OCk7XG4gICAgfVxuICAgIGdldCBzdHJpcEJ5dGVDb3VudHMoKSB7XG4gICAgICAgIHJldHVybiBhbHdheXNBcnJheSh0aGlzLmZpZWxkcy5nZXQoMjc5KSk7XG4gICAgfVxuICAgIGdldCBtaW5TYW1wbGVWYWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmllbGRzLmdldCgyODApIHx8IDA7XG4gICAgfVxuICAgIGdldCBtYXhTYW1wbGVWYWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmllbGRzLmdldCgyODEpIHx8IE1hdGgucG93KDIsIHRoaXMuYml0c1BlclNhbXBsZSkgLSAxO1xuICAgIH1cbiAgICBnZXQgeFJlc29sdXRpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZpZWxkcy5nZXQoMjgyKTtcbiAgICB9XG4gICAgZ2V0IHlSZXNvbHV0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5maWVsZHMuZ2V0KDI4Myk7XG4gICAgfVxuICAgIGdldCBwbGFuYXJDb25maWd1cmF0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5maWVsZHMuZ2V0KDI4NCkgfHwgMTtcbiAgICB9XG4gICAgZ2V0IHJlc29sdXRpb25Vbml0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5maWVsZHMuZ2V0KDI5NikgfHwgMjtcbiAgICB9XG4gICAgZ2V0IGRhdGVUaW1lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5maWVsZHMuZ2V0KDMwNik7XG4gICAgfVxuICAgIGdldCBwcmVkaWN0b3IoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZpZWxkcy5nZXQoMzE3KSB8fCAxO1xuICAgIH1cbiAgICBnZXQgc2FtcGxlRm9ybWF0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5maWVsZHMuZ2V0KDMzOSkgfHwgMTtcbiAgICB9XG4gICAgZ2V0IHNNaW5TYW1wbGVWYWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmllbGRzLmdldCgzNDApIHx8IHRoaXMubWluU2FtcGxlVmFsdWU7XG4gICAgfVxuICAgIGdldCBzTWF4U2FtcGxlVmFsdWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZpZWxkcy5nZXQoMzQxKSB8fCB0aGlzLm1heFNhbXBsZVZhbHVlO1xuICAgIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBJRkQ7XG5cbmZ1bmN0aW9uIGFsd2F5c0FycmF5KHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHJldHVybiBbdmFsdWVdO1xuICAgIHJldHVybiB2YWx1ZTtcbn0iLCIndXNlIHN0cmljdCc7XG5cbnZhciB0eXBlcyA9IG5ldyBNYXAoW1xuICAgIFsxICwgWzEsIHJlYWRCeXRlXV0sICAgICAgLy8gQllURVxuICAgIFsyICwgWzEsIHJlYWRBU0NJSV1dLCAgICAgLy8gQVNDSUlcbiAgICBbMyAsIFsyLCByZWFkU2hvcnRdXSwgICAgIC8vIFNIT1JUXG4gICAgWzQgLCBbNCwgcmVhZExvbmddXSwgICAgICAvLyBMT05HXG4gICAgWzUgLCBbOCwgcmVhZFJhdGlvbmFsXV0sICAvLyBSQVRJT05BTFxuICAgIFs2ICwgWzEsIHJlYWRTQnl0ZV1dLCAgICAgLy8gU0JZVEVcbiAgICBbNyAsIFsxLCByZWFkQnl0ZV1dLCAgICAgIC8vIFVOREVGSU5FRFxuICAgIFs4ICwgWzIsIHJlYWRTU2hvcnRdXSwgICAgLy8gU1NIT1JUXG4gICAgWzkgLCBbNCwgcmVhZFNMb25nXV0sICAgICAvLyBTTE9OR1xuICAgIFsxMCwgWzgsIHJlYWRTUmF0aW9uYWxdXSwgLy8gU1JBVElPTkFMXG4gICAgWzExLCBbNCwgcmVhZEZsb2F0XV0sICAgICAvLyBGTE9BVFxuICAgIFsxMiwgWzgsIHJlYWREb3VibGVdXSAgICAgLy8gRE9VQkxFXG5dKTtcblxuZXhwb3J0cy5nZXRCeXRlTGVuZ3RoID0gZnVuY3Rpb24gKHR5cGUsIGNvdW50KSB7XG4gICAgcmV0dXJuIHR5cGVzLmdldCh0eXBlKVswXSAqIGNvdW50O1xufTtcblxuZXhwb3J0cy5yZWFkRGF0YSA9IGZ1bmN0aW9uIChkZWNvZGVyLCB0eXBlLCBjb3VudCkge1xuICAgIHJldHVybiB0eXBlcy5nZXQodHlwZSlbMV0oZGVjb2RlciwgY291bnQpO1xufTtcblxuZnVuY3Rpb24gcmVhZEJ5dGUoZGVjb2RlciwgY291bnQpIHtcbiAgICBpZiAoY291bnQgPT09IDEpIHJldHVybiBkZWNvZGVyLnJlYWRVaW50OCgpO1xuICAgIHZhciBhcnJheSA9IG5ldyBVaW50OEFycmF5KGNvdW50KTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgICAgYXJyYXlbaV0gPSBkZWNvZGVyLnJlYWRVaW50OCgpO1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXk7XG59XG5cbmZ1bmN0aW9uIHJlYWRBU0NJSShkZWNvZGVyLCBjb3VudCkge1xuICAgIHZhciBzdHJpbmdzID0gW107XG4gICAgdmFyIGN1cnJlbnRTdHJpbmcgPSAnJztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgICAgdmFyIGNoYXIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGRlY29kZXIucmVhZFVpbnQ4KCkpO1xuICAgICAgICBpZiAoY2hhciA9PT0gJ1xcMCcpIHtcbiAgICAgICAgICAgIHN0cmluZ3MucHVzaChjdXJyZW50U3RyaW5nKTtcbiAgICAgICAgICAgIGN1cnJlbnRTdHJpbmcgPSAnJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGN1cnJlbnRTdHJpbmcgKz0gY2hhcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoc3RyaW5ncy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZ3NbMF07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZ3M7XG4gICAgfVxufVxuXG5mdW5jdGlvbiByZWFkU2hvcnQoZGVjb2RlciwgY291bnQpIHtcbiAgICBpZiAoY291bnQgPT09IDEpIHJldHVybiBkZWNvZGVyLnJlYWRVaW50MTYoKTtcbiAgICB2YXIgYXJyYXkgPSBuZXcgVWludDE2QXJyYXkoY291bnQpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICBhcnJheVtpXSA9IGRlY29kZXIucmVhZFVpbnQxNigpO1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXk7XG59XG5cbmZ1bmN0aW9uIHJlYWRMb25nKGRlY29kZXIsIGNvdW50KSB7XG4gICAgaWYgKGNvdW50ID09PSAxKSByZXR1cm4gZGVjb2Rlci5yZWFkVWludDMyKCk7XG4gICAgdmFyIGFycmF5ID0gbmV3IFVpbnQzMkFycmF5KGNvdW50KTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgICAgYXJyYXlbaV0gPSBkZWNvZGVyLnJlYWRVaW50MzIoKTtcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5O1xufVxuXG5mdW5jdGlvbiByZWFkUmF0aW9uYWwoZGVjb2RlciwgY291bnQpIHtcbiAgICBpZiAoY291bnQgPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIGRlY29kZXIucmVhZFVpbnQzMigpLFxuICAgICAgICAgICAgZGVjb2Rlci5yZWFkVWludDMyKClcbiAgICAgICAgXTtcbiAgICB9XG4gICAgdmFyIHJhdGlvbmFscyA9IG5ldyBBcnJheShjb3VudCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgIHJhdGlvbmFsc1tpXSA9IFtcbiAgICAgICAgICAgIGRlY29kZXIucmVhZFVpbnQzMigpLFxuICAgICAgICAgICAgZGVjb2Rlci5yZWFkVWludDMyKClcbiAgICAgICAgXTtcbiAgICB9XG4gICAgcmV0dXJuIHJhdGlvbmFscztcbn1cblxuZnVuY3Rpb24gcmVhZFNCeXRlKGRlY29kZXIsIGNvdW50KSB7XG4gICAgaWYgKGNvdW50ID09PSAxKSByZXR1cm4gZGVjb2Rlci5yZWFkSW50OCgpO1xuICAgIHZhciBhcnJheSA9IG5ldyBJbnQ4QXJyYXkoY291bnQpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICBhcnJheVtpXSA9IGRlY29kZXIucmVhZEludDgoKTtcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5O1xufVxuXG5mdW5jdGlvbiByZWFkU1Nob3J0KGRlY29kZXIsIGNvdW50KSB7XG4gICAgaWYgKGNvdW50ID09PSAxKSByZXR1cm4gZGVjb2Rlci5yZWFkSW50MTYoKTtcbiAgICB2YXIgYXJyYXkgPSBuZXcgSW50MTZBcnJheShjb3VudCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgIGFycmF5W2ldID0gZGVjb2Rlci5yZWFkSW50MTYoKTtcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5O1xufVxuXG5mdW5jdGlvbiByZWFkU0xvbmcoZGVjb2RlciwgY291bnQpIHtcbiAgICBpZiAoY291bnQgPT09IDEpIHJldHVybiBkZWNvZGVyLnJlYWRJbnQzMigpO1xuICAgIHZhciBhcnJheSA9IG5ldyBJbnQzMkFycmF5KGNvdW50KTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgICAgYXJyYXlbaV0gPSBkZWNvZGVyLnJlYWRJbnQzMigpO1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXk7XG59XG5cbmZ1bmN0aW9uIHJlYWRTUmF0aW9uYWwoZGVjb2RlciwgY291bnQpIHtcbiAgICBpZiAoY291bnQgPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIGRlY29kZXIucmVhZEludDMyKCksXG4gICAgICAgICAgICBkZWNvZGVyLnJlYWRJbnQzMigpXG4gICAgICAgIF07XG4gICAgfVxuICAgIHZhciByYXRpb25hbHMgPSBuZXcgQXJyYXkoY291bnQpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICByYXRpb25hbHNbaV0gPSBbXG4gICAgICAgICAgICBkZWNvZGVyLnJlYWRJbnQzMigpLFxuICAgICAgICAgICAgZGVjb2Rlci5yZWFkSW50MzIoKVxuICAgICAgICBdO1xuICAgIH1cbiAgICByZXR1cm4gcmF0aW9uYWxzO1xufVxuXG5mdW5jdGlvbiByZWFkRmxvYXQoZGVjb2RlciwgY291bnQpIHtcbiAgICBpZiAoY291bnQgPT09IDEpIHJldHVybiBkZWNvZGVyLnJlYWRGbG9hdDMyKCk7XG4gICAgdmFyIGFycmF5ID0gbmV3IEZsb2F0MzJBcnJheShjb3VudCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgIGFycmF5W2ldID0gZGVjb2Rlci5yZWFkRmxvYXQzMigpO1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXk7XG59XG5cbmZ1bmN0aW9uIHJlYWREb3VibGUoZGVjb2RlciwgY291bnQpIHtcbiAgICBpZiAoY291bnQgPT09IDEpIHJldHVybiBkZWNvZGVyLnJlYWRGbG9hdDY0KCk7XG4gICAgdmFyIGFycmF5ID0gbmV3IEZsb2F0NjRBcnJheShjb3VudCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgIGFycmF5W2ldID0gZGVjb2Rlci5yZWFkRmxvYXQ2NCgpO1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXk7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbmNsYXNzIFRJRkYge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmlmZCA9IFtdO1xuICAgIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBUSUZGO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBJT0J1ZmZlciA9IHJlcXVpcmUoJ2lvYnVmZmVyJyk7XG5jb25zdCBJRkQgPSByZXF1aXJlKCcuL0lGRCcpO1xuY29uc3QgSUZEVmFsdWUgPSByZXF1aXJlKCcuL0lGRFZhbHVlJyk7XG5jb25zdCBUSUZGID0gcmVxdWlyZSgnLi9USUZGJyk7XG5cbmNsYXNzIFRJRkZEZWNvZGVyIGV4dGVuZHMgSU9CdWZmZXIge1xuICAgIGNvbnN0cnVjdG9yKGRhdGEpIHtcbiAgICAgICAgc3VwZXIoZGF0YSk7XG4gICAgICAgIHRoaXMuX2RlY29kZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fdGlmZiA9IG51bGw7XG4gICAgICAgIHRoaXMuX25leHRJRkQgPSAwO1xuICAgIH1cblxuICAgIGRlY29kZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2RlY29kZWQpIHJldHVybiB0aGlzLl90aWZmO1xuICAgICAgICB0aGlzLl90aWZmID0gbmV3IFRJRkYoKTtcbiAgICAgICAgdGhpcy5kZWNvZGVIZWFkZXIoKTtcbiAgICAgICAgd2hpbGUgKHRoaXMuX25leHRJRkQpIHtcbiAgICAgICAgICAgIHRoaXMuZGVjb2RlSUZEKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3RpZmY7XG4gICAgfVxuXG4gICAgZGVjb2RlSGVhZGVyKCkge1xuICAgICAgICAvLyBCeXRlIG9mZnNldFxuICAgICAgICBsZXQgdmFsdWUgPSB0aGlzLnJlYWRVaW50MTYoKTtcbiAgICAgICAgaWYgKHZhbHVlID09PSAweDQ5NDkpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0TGl0dGxlRW5kaWFuKCk7XG4gICAgICAgIH0gZWxzZSBpZiAodmFsdWUgPT09IDB4NEQ0RCkge1xuICAgICAgICAgICAgdGhpcy5zZXRCaWdFbmRpYW4oKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBieXRlIG9yZGVyOiAweCcgKyB2YWx1ZS50b1N0cmluZygxNikpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gTWFnaWMgbnVtYmVyXG4gICAgICAgIHZhbHVlID0gdGhpcy5yZWFkVWludDE2KCk7XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gNDIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbm90IGEgVElGRiBmaWxlJyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBPZmZzZXQgb2YgdGhlIGZpcnN0IElGRFxuICAgICAgICB0aGlzLl9uZXh0SUZEID0gdGhpcy5yZWFkVWludDMyKCk7XG4gICAgfVxuXG4gICAgZGVjb2RlSUZEKCkge1xuICAgICAgICB0aGlzLnNlZWsodGhpcy5fbmV4dElGRCk7XG4gICAgICAgIHZhciBpZmQgPSBuZXcgSUZEKCk7XG4gICAgICAgIHRoaXMuX3RpZmYuaWZkLnB1c2goaWZkKTtcbiAgICAgICAgY29uc3QgbnVtRW50cmllcyA9IHRoaXMucmVhZFVpbnQxNigpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bUVudHJpZXM7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5kZWNvZGVJRkRFbnRyeShpZmQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGVjb2RlSW1hZ2VEYXRhKGlmZCk7XG4gICAgICAgIHRoaXMuX25leHRJRkQgPSB0aGlzLnJlYWRVaW50MzIoKTtcbiAgICB9XG5cbiAgICBkZWNvZGVJRkRFbnRyeShpZmQpIHtcbiAgICAgICAgdGhpcy5tYXJrKCk7XG4gICAgICAgIGxldCB0YWcgPSB0aGlzLnJlYWRVaW50MTYoKTtcbiAgICAgICAgbGV0IHR5cGUgPSB0aGlzLnJlYWRVaW50MTYoKTtcbiAgICAgICAgbGV0IG51bVZhbHVlcyA9IHRoaXMucmVhZFVpbnQzMigpO1xuXG4gICAgICAgIGlmICh0eXBlIDwgMSB8fCB0eXBlID4gMTIpIHtcbiAgICAgICAgICAgIHRoaXMuc2tpcCg0KTsgLy8gdW5rbm93biB0eXBlLCBza2lwIHRoaXMgdmFsdWVcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCB2YWx1ZUJ5dGVMZW5ndGggPSBJRkRWYWx1ZS5nZXRCeXRlTGVuZ3RoKHR5cGUsIG51bVZhbHVlcyk7XG4gICAgICAgIGlmICh2YWx1ZUJ5dGVMZW5ndGggPiA0KSB7XG4gICAgICAgICAgICB0aGlzLnNlZWsodGhpcy5yZWFkVWludDMyKCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHZhbHVlID0gSUZEVmFsdWUucmVhZERhdGEodGhpcywgdHlwZSwgbnVtVmFsdWVzKTtcbiAgICAgICAgaWZkLmZpZWxkcy5zZXQodGFnLCB2YWx1ZSk7XG5cbiAgICAgICAgLy8gZ28gdG8gdGhlIG5leHQgZW50cnlcbiAgICAgICAgdGhpcy5yZXNldCgpO1xuICAgICAgICB0aGlzLnNraXAoMTIpO1xuICAgIH1cblxuICAgIGRlY29kZUltYWdlRGF0YShpZmQpIHtcbiAgICAgICAgY29uc3Qgb3JpZW50YXRpb24gPSBpZmQub3JpZW50YXRpb247XG4gICAgICAgIGlmIChvcmllbnRhdGlvbiAmJiBvcmllbnRhdGlvbiAhPT0gMSkge1xuICAgICAgICAgICAgdW5zdXBwb3J0ZWQoJ29yaWVudGF0aW9uJywgb3JpZW50YXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaChpZmQudHlwZSkge1xuICAgICAgICAgICAgY2FzZSAxOiAvLyBCbGFja0lzWmVyb1xuICAgICAgICAgICAgICAgIHRoaXMuZGVjb2RlQmlsZXZlbE9yR3JleShpZmQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB1bnN1cHBvcnRlZCgnaW1hZ2UgdHlwZScsIGlmZC50eXBlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGRlY29kZUJpbGV2ZWxPckdyZXkoaWZkKSB7XG4gICAgICAgIGNvbnN0IHdpZHRoID0gaWZkLndpZHRoO1xuICAgICAgICBjb25zdCBoZWlnaHQgPSBpZmQuaGVpZ2h0O1xuXG4gICAgICAgIGNvbnN0IGJpdERlcHRoID0gaWZkLmJpdHNQZXJTYW1wbGU7XG4gICAgICAgIGNvbnN0IHNhbXBsZUZvcm1hdCA9IGlmZC5zYW1wbGVGb3JtYXQ7XG4gICAgICAgIGxldCBzaXplID0gd2lkdGggKiBoZWlnaHQ7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBnZXREYXRhQXJyYXkoc2l6ZSwgMSwgYml0RGVwdGgsIHNhbXBsZUZvcm1hdCk7XG5cbiAgICAgICAgY29uc3QgY29tcHJlc3Npb24gPSBpZmQuY29tcHJlc3Npb247XG4gICAgICAgIGNvbnN0IHJvd3NQZXJTdHJpcCA9IGlmZC5yb3dzUGVyU3RyaXA7XG4gICAgICAgIGNvbnN0IG1heFBpeGVscyA9IHJvd3NQZXJTdHJpcCAqIHdpZHRoO1xuICAgICAgICBjb25zdCBzdHJpcE9mZnNldHMgPSBpZmQuc3RyaXBPZmZzZXRzO1xuICAgICAgICBjb25zdCBzdHJpcEJ5dGVDb3VudHMgPSBpZmQuc3RyaXBCeXRlQ291bnRzO1xuXG4gICAgICAgIHZhciBwaXhlbCA9IDA7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyaXBPZmZzZXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgc3RyaXBEYXRhID0gdGhpcy5nZXRTdHJpcERhdGEoY29tcHJlc3Npb24sIHN0cmlwT2Zmc2V0c1tpXSwgc3RyaXBCeXRlQ291bnRzW2ldKTtcbiAgICAgICAgICAgIC8vIExhc3Qgc3RyaXAgY2FuIGJlIHNtYWxsZXJcbiAgICAgICAgICAgIHZhciBsZW5ndGggPSBzaXplID4gbWF4UGl4ZWxzID8gbWF4UGl4ZWxzIDogc2l6ZTtcbiAgICAgICAgICAgIHNpemUgLT0gbGVuZ3RoO1xuICAgICAgICAgICAgaWYgKGJpdERlcHRoID09PSA4KSB7XG4gICAgICAgICAgICAgICAgcGl4ZWwgPSBmaWxsOGJpdChkYXRhLCBzdHJpcERhdGEsIHBpeGVsLCBsZW5ndGgpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChiaXREZXB0aCA9PT0gMTYpIHtcbiAgICAgICAgICAgICAgICBwaXhlbCA9IGZpbGwxNmJpdChkYXRhLCBzdHJpcERhdGEsIHBpeGVsLCBsZW5ndGgsIHRoaXMuaXNMaXR0bGVFbmRpYW4oKSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGJpdERlcHRoID09PSAzMiAmJiBzYW1wbGVGb3JtYXQgPT09IDMpIHtcbiAgICAgICAgICAgICAgICBwaXhlbCA9IGZpbGxGbG9hdDMyKGRhdGEsIHN0cmlwRGF0YSwgcGl4ZWwsIGxlbmd0aCwgdGhpcy5pc0xpdHRsZUVuZGlhbigpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdW5zdXBwb3J0ZWQoJ2JpdERlcHRoJywgYml0RGVwdGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWZkLmRhdGEgPSBkYXRhO1xuICAgIH1cblxuICAgIGdldFN0cmlwRGF0YShjb21wcmVzc2lvbiwgb2Zmc2V0LCBieXRlQ291bnRzKSB7XG4gICAgICAgIHN3aXRjaCAoY29tcHJlc3Npb24pIHtcbiAgICAgICAgICAgIGNhc2UgMTogLy8gTm8gY29tcHJlc3Npb25cbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IERhdGFWaWV3KHRoaXMuYnVmZmVyLCBvZmZzZXQsIGJ5dGVDb3VudHMpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAyOiAvLyBDQ0lUVCBHcm91cCAzIDEtRGltZW5zaW9uYWwgTW9kaWZpZWQgSHVmZm1hbiBydW4gbGVuZ3RoIGVuY29kaW5nXG4gICAgICAgICAgICBjYXNlIDMyNzczOiAvLyBQYWNrQml0cyBjb21wcmVzc2lvblxuICAgICAgICAgICAgICAgIHVuc3VwcG9ydGVkKCdDb21wcmVzc2lvbicsIGNvbXByZXNzaW9uKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGNvbXByZXNzaW9uOiAnICsgY29tcHJlc3Npb24pO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFRJRkZEZWNvZGVyO1xuXG5mdW5jdGlvbiBnZXREYXRhQXJyYXkoc2l6ZSwgY2hhbm5lbHMsIGJpdERlcHRoLCBzYW1wbGVGb3JtYXQpIHtcbiAgICBpZiAoYml0RGVwdGggPT09IDgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KHNpemUgKiBjaGFubmVscyk7XG4gICAgfSBlbHNlIGlmIChiaXREZXB0aCA9PT0gMTYpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50MTZBcnJheShzaXplICogY2hhbm5lbHMpO1xuICAgIH0gZWxzZSBpZiAoYml0RGVwdGggPT09IDMyICYmIHNhbXBsZUZvcm1hdCA9PT0gMykge1xuICAgICAgICByZXR1cm4gbmV3IEZsb2F0MzJBcnJheShzaXplICogY2hhbm5lbHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHVuc3VwcG9ydGVkKCdiaXQgZGVwdGggLyBzYW1wbGUgZm9ybWF0JywgYml0RGVwdGggKyAnIC8gJyArIHNhbXBsZUZvcm1hdCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBmaWxsOGJpdChkYXRhVG8sIGRhdGFGcm9tLCBpbmRleCwgbGVuZ3RoKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBkYXRhVG9baW5kZXgrK10gPSBkYXRhRnJvbS5nZXRVaW50OChpKTtcbiAgICB9XG4gICAgcmV0dXJuIGluZGV4O1xufVxuXG5mdW5jdGlvbiBmaWxsMTZiaXQoZGF0YVRvLCBkYXRhRnJvbSwgaW5kZXgsIGxlbmd0aCwgbGl0dGxlRW5kaWFuKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGggKiAyOyBpICs9IDIpIHtcbiAgICAgICAgZGF0YVRvW2luZGV4KytdID0gZGF0YUZyb20uZ2V0VWludDE2KGksIGxpdHRsZUVuZGlhbik7XG4gICAgfVxuICAgIHJldHVybiBpbmRleDtcbn1cblxuZnVuY3Rpb24gZmlsbEZsb2F0MzIoZGF0YVRvLCBkYXRhRnJvbSwgaW5kZXgsIGxlbmd0aCwgbGl0dGxlRW5kaWFuKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGggKiA0OyBpICs9IDQpIHtcbiAgICAgICAgZGF0YVRvW2luZGV4KytdID0gZGF0YUZyb20uZ2V0RmxvYXQzMihpLCBsaXR0bGVFbmRpYW4pO1xuICAgIH1cbiAgICByZXR1cm4gaW5kZXg7XG59XG5cbmZ1bmN0aW9uIHVuc3VwcG9ydGVkKHR5cGUsIHZhbHVlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCAnICsgdHlwZSArICc6ICcgKyB2YWx1ZSk7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuVElGRkRlY29kZXIgPSByZXF1aXJlKCcuL1RJRkZEZWNvZGVyJyk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB3b3JrZXJUZW1wbGF0ZSA9IHJlcXVpcmUoJy4vd29ya2VyVGVtcGxhdGUnKTtcblxudmFyIENPUkVTID0gbmF2aWdhdG9yLmhhcmR3YXJlQ29uY3VycmVuY3kgfHwgMTtcblxudmFyIG5vb3AgPSBGdW5jdGlvbi5wcm90b3R5cGU7XG5cbmZ1bmN0aW9uIFdvcmtlck1hbmFnZXIoZnVuYywgb3B0aW9ucykge1xuICAgIC8vIENoZWNrIGFyZ3VtZW50c1xuICAgIGlmICh0eXBlb2YgZnVuYyAhPT0gJ3N0cmluZycgJiYgdHlwZW9mIGZ1bmMgIT09ICdmdW5jdGlvbicpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2Z1bmMgYXJndW1lbnQgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gICAgaWYgKG9wdGlvbnMgPT09IHVuZGVmaW5lZClcbiAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyAhPT0gJ29iamVjdCcgfHwgb3B0aW9ucyA9PT0gbnVsbClcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignb3B0aW9ucyBhcmd1bWVudCBtdXN0IGJlIGFuIG9iamVjdCcpO1xuXG4gICAgdGhpcy5fd29ya2VyQ29kZSA9IGZ1bmMudG9TdHJpbmcoKTtcblxuICAgIC8vIFBhcnNlIG9wdGlvbnNcbiAgICBpZiAob3B0aW9ucy5tYXhXb3JrZXJzID09PSB1bmRlZmluZWQgfHwgb3B0aW9ucy5tYXhXb3JrZXJzID09PSAnYXV0bycpIHtcbiAgICAgICAgdGhpcy5fbnVtV29ya2VycyA9IE1hdGgubWluKENPUkVTIC0gMSwgMSk7XG4gICAgfSBlbHNlIGlmIChvcHRpb25zLm1heFdvcmtlcnMgPiAwKSB7XG4gICAgICAgIHRoaXMuX251bVdvcmtlcnMgPSBNYXRoLm1pbihvcHRpb25zLm1heFdvcmtlcnMsIENPUkVTKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9udW1Xb3JrZXJzID0gQ09SRVM7XG4gICAgfVxuXG4gICAgdGhpcy5fd29ya2VycyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLl90aW1lb3V0ID0gb3B0aW9ucy50aW1lb3V0IHx8IDA7XG4gICAgdGhpcy5fdGVybWluYXRlT25FcnJvciA9ICEhb3B0aW9ucy50ZXJtaW5hdGVPbkVycm9yO1xuXG4gICAgdmFyIGRlcHMgPSBvcHRpb25zLmRlcHM7XG4gICAgaWYgKHR5cGVvZiBkZXBzID09PSAnc3RyaW5nJylcbiAgICAgICAgZGVwcyA9IFtkZXBzXTtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoZGVwcykpXG4gICAgICAgIGRlcHMgPSB1bmRlZmluZWQ7XG5cbiAgICB0aGlzLl9pZCA9IDA7XG4gICAgdGhpcy5fdGVybWluYXRlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3dvcmtpbmcgPSAwO1xuICAgIHRoaXMuX3dhaXRpbmcgPSBbXTtcblxuICAgIHRoaXMuX2luaXQoZGVwcyk7XG59XG5cbldvcmtlck1hbmFnZXIucHJvdG90eXBlLl9pbml0ID0gZnVuY3Rpb24gKGRlcHMpIHtcbiAgICB2YXIgd29ya2VyVVJMID0gd29ya2VyVGVtcGxhdGUubmV3V29ya2VyVVJMKHRoaXMuX3dvcmtlckNvZGUsIGRlcHMpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9udW1Xb3JrZXJzOyBpKyspIHtcbiAgICAgICAgdmFyIHdvcmtlciA9IG5ldyBXb3JrZXIod29ya2VyVVJMKTtcbiAgICAgICAgd29ya2VyLm9ubWVzc2FnZSA9IHRoaXMuX29ubWVzc2FnZS5iaW5kKHRoaXMsIHdvcmtlcik7XG4gICAgICAgIHdvcmtlci5vbmVycm9yID0gdGhpcy5fb25lcnJvci5iaW5kKHRoaXMsIHdvcmtlcik7XG4gICAgICAgIHdvcmtlci5ydW5uaW5nID0gZmFsc2U7XG4gICAgICAgIHdvcmtlci5pZCA9IGk7XG4gICAgICAgIHRoaXMuX3dvcmtlcnMuc2V0KHdvcmtlciwgbnVsbCk7XG4gICAgfVxuXG4gICAgVVJMLnJldm9rZU9iamVjdFVSTCh3b3JrZXJVUkwpO1xufTtcblxuV29ya2VyTWFuYWdlci5wcm90b3R5cGUuX29uZXJyb3IgPSBmdW5jdGlvbiAod29ya2VyLCBlcnJvcikge1xuICAgIGlmICh0aGlzLl90ZXJtaW5hdGVkKVxuICAgICAgICByZXR1cm47XG4gICAgdGhpcy5fd29ya2luZy0tO1xuICAgIHdvcmtlci5ydW5uaW5nID0gZmFsc2U7XG4gICAgdmFyIGNhbGxiYWNrID0gdGhpcy5fd29ya2Vycy5nZXQod29ya2VyKTtcbiAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgY2FsbGJhY2tbMV0oZXJyb3IubWVzc2FnZSk7XG4gICAgfVxuICAgIHRoaXMuX3dvcmtlcnMuc2V0KHdvcmtlciwgbnVsbCk7XG4gICAgaWYgKHRoaXMuX3Rlcm1pbmF0ZU9uRXJyb3IpIHtcbiAgICAgICAgdGhpcy50ZXJtaW5hdGUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9leGVjKCk7XG4gICAgfVxufTtcblxuV29ya2VyTWFuYWdlci5wcm90b3R5cGUuX29ubWVzc2FnZSA9IGZ1bmN0aW9uICh3b3JrZXIsIGV2ZW50KSB7XG4gICAgaWYgKHRoaXMuX3Rlcm1pbmF0ZWQpXG4gICAgICAgIHJldHVybjtcbiAgICB0aGlzLl93b3JraW5nLS07XG4gICAgd29ya2VyLnJ1bm5pbmcgPSBmYWxzZTtcbiAgICB2YXIgY2FsbGJhY2sgPSB0aGlzLl93b3JrZXJzLmdldCh3b3JrZXIpO1xuICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICBjYWxsYmFja1swXShldmVudC5kYXRhLmRhdGEpO1xuICAgIH1cbiAgICB0aGlzLl93b3JrZXJzLnNldCh3b3JrZXIsIG51bGwpO1xuICAgIHRoaXMuX2V4ZWMoKTtcbn07XG5cbldvcmtlck1hbmFnZXIucHJvdG90eXBlLl9leGVjID0gZnVuY3Rpb24gKCkge1xuICAgIGZvciAodmFyIHdvcmtlciBvZiB0aGlzLl93b3JrZXJzLmtleXMoKSkge1xuICAgICAgICBpZiAodGhpcy5fd29ya2luZyA9PT0gdGhpcy5fbnVtV29ya2VycyB8fFxuICAgICAgICAgICAgdGhpcy5fd2FpdGluZy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXdvcmtlci5ydW5uaW5nKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX3dhaXRpbmcubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgZXhlY0luZm8gPSB0aGlzLl93YWl0aW5nW2ldO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZXhlY0luZm9bNF0gPT09ICdudW1iZXInICYmIGV4ZWNJbmZvWzRdICE9PSB3b3JrZXIuaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyBtZXNzYWdlIGlzIGludGVuZGVkIHRvIGFub3RoZXIgd29ya2VyLCBsZXQncyBpZ25vcmUgaXRcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX3dhaXRpbmcuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgIHdvcmtlci5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbjogJ2V4ZWMnLFxuICAgICAgICAgICAgICAgICAgICBldmVudDogZXhlY0luZm9bMF0sXG4gICAgICAgICAgICAgICAgICAgIGFyZ3M6IGV4ZWNJbmZvWzFdXG4gICAgICAgICAgICAgICAgfSwgZXhlY0luZm9bMl0pO1xuICAgICAgICAgICAgICAgIHdvcmtlci5ydW5uaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB3b3JrZXIudGltZSA9IERhdGUubm93KCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fd29ya2Vycy5zZXQod29ya2VyLCBleGVjSW5mb1szXSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fd29ya2luZysrO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufTtcblxuV29ya2VyTWFuYWdlci5wcm90b3R5cGUudGVybWluYXRlID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLl90ZXJtaW5hdGVkKSByZXR1cm47XG4gICAgZm9yICh2YXIgZW50cnkgb2YgdGhpcy5fd29ya2Vycykge1xuICAgICAgICBlbnRyeVswXS50ZXJtaW5hdGUoKTtcbiAgICAgICAgaWYgKGVudHJ5WzFdKSB7XG4gICAgICAgICAgICBlbnRyeVsxXVsxXShuZXcgRXJyb3IoJ1Rlcm1pbmF0ZWQnKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5fd29ya2Vycy5jbGVhcigpO1xuICAgIHRoaXMuX3dhaXRpbmcgPSBbXTtcbiAgICB0aGlzLl93b3JraW5nID0gMDtcbiAgICB0aGlzLl90ZXJtaW5hdGVkID0gdHJ1ZTtcbn07XG5cbldvcmtlck1hbmFnZXIucHJvdG90eXBlLnBvc3RBbGwgPSBmdW5jdGlvbiAoZXZlbnQsIGFyZ3MpIHtcbiAgICBpZiAodGhpcy5fdGVybWluYXRlZClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgcG9zdCAodGVybWluYXRlZCknKTtcbiAgICB2YXIgcHJvbWlzZXMgPSBbXTtcbiAgICBmb3IgKHZhciB3b3JrZXIgb2YgdGhpcy5fd29ya2Vycy5rZXlzKCkpIHtcbiAgICAgICAgcHJvbWlzZXMucHVzaCh0aGlzLnBvc3QoZXZlbnQsIGFyZ3MsIFtdLCB3b3JrZXIuaWQpKTtcbiAgICB9XG4gICAgcmV0dXJuIFByb21pc2UuYWxsKHByb21pc2VzKTtcbn07XG5cbldvcmtlck1hbmFnZXIucHJvdG90eXBlLnBvc3QgPSBmdW5jdGlvbiAoZXZlbnQsIGFyZ3MsIHRyYW5zZmVyYWJsZSwgaWQpIHtcbiAgICBpZiAoYXJncyA9PT0gdW5kZWZpbmVkKSBhcmdzID0gW107XG4gICAgaWYgKHRyYW5zZmVyYWJsZSA9PT0gdW5kZWZpbmVkKSB0cmFuc2ZlcmFibGUgPSBbXTtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoYXJncykpIHtcbiAgICAgICAgYXJncyA9IFthcmdzXTtcbiAgICB9XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHRyYW5zZmVyYWJsZSkpIHtcbiAgICAgICAgdHJhbnNmZXJhYmxlID0gW3RyYW5zZmVyYWJsZV07XG4gICAgfVxuXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGlmIChzZWxmLl90ZXJtaW5hdGVkKSB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBwb3N0ICh0ZXJtaW5hdGVkKScpO1xuICAgICAgICBzZWxmLl93YWl0aW5nLnB1c2goW2V2ZW50LCBhcmdzLCB0cmFuc2ZlcmFibGUsIFtyZXNvbHZlLCByZWplY3RdLCBpZF0pO1xuICAgICAgICBzZWxmLl9leGVjKCk7XG4gICAgfSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFdvcmtlck1hbmFnZXI7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB3b3JrZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHdpbmRvdyA9IHNlbGYud2luZG93ID0gc2VsZjtcbiAgICBmdW5jdGlvbiBNYW5hZ2VkV29ya2VyKCkge1xuICAgICAgICB0aGlzLl9saXN0ZW5lcnMgPSB7fTtcbiAgICB9XG4gICAgTWFuYWdlZFdvcmtlci5wcm90b3R5cGUub24gPSBmdW5jdGlvbiAoZXZlbnQsIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICh0aGlzLl9saXN0ZW5lcnNbZXZlbnRdKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3RoZXJlIGlzIGFscmVhZHkgYSBsaXN0ZW5lciBmb3IgJyArIGV2ZW50KTtcbiAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2NhbGxiYWNrIGFyZ3VtZW50IG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICAgICAgICB0aGlzLl9saXN0ZW5lcnNbZXZlbnRdID0gY2FsbGJhY2s7XG4gICAgfTtcbiAgICBNYW5hZ2VkV29ya2VyLnByb3RvdHlwZS5fc2VuZCA9IGZ1bmN0aW9uIChpZCwgZGF0YSwgdHJhbnNmZXJhYmxlKSB7XG4gICAgICAgIGlmICh0cmFuc2ZlcmFibGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdHJhbnNmZXJhYmxlID0gW107XG4gICAgICAgIH0gZWxzZSBpZiAoIUFycmF5LmlzQXJyYXkodHJhbnNmZXJhYmxlKSkge1xuICAgICAgICAgICAgdHJhbnNmZXJhYmxlID0gW3RyYW5zZmVyYWJsZV07XG4gICAgICAgIH1cbiAgICAgICAgc2VsZi5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgICBkYXRhOiBkYXRhXG4gICAgICAgIH0sIHRyYW5zZmVyYWJsZSk7XG4gICAgfTtcbiAgICBNYW5hZ2VkV29ya2VyLnByb3RvdHlwZS5fdHJpZ2dlciA9IGZ1bmN0aW9uIChldmVudCwgYXJncykge1xuICAgICAgICBpZiAoIXRoaXMuX2xpc3RlbmVyc1tldmVudF0pXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2V2ZW50ICcgKyBldmVudCArICcgaXMgbm90IGRlZmluZWQnKTtcbiAgICAgICAgdGhpcy5fbGlzdGVuZXJzW2V2ZW50XS5hcHBseShudWxsLCBhcmdzKTtcbiAgICB9O1xuICAgIHZhciB3b3JrZXIgPSBuZXcgTWFuYWdlZFdvcmtlcigpO1xuICAgIHNlbGYub25tZXNzYWdlID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHN3aXRjaChldmVudC5kYXRhLmFjdGlvbikge1xuICAgICAgICAgICAgY2FzZSAnZXhlYyc6XG4gICAgICAgICAgICAgICAgZXZlbnQuZGF0YS5hcmdzLnVuc2hpZnQoZnVuY3Rpb24gKGRhdGEsIHRyYW5zZmVyYWJsZSkge1xuICAgICAgICAgICAgICAgICAgICB3b3JrZXIuX3NlbmQoZXZlbnQuZGF0YS5pZCwgZGF0YSwgdHJhbnNmZXJhYmxlKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB3b3JrZXIuX3RyaWdnZXIoZXZlbnQuZGF0YS5ldmVudCwgZXZlbnQuZGF0YS5hcmdzKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3BpbmcnOlxuICAgICAgICAgICAgICAgIHdvcmtlci5fc2VuZChldmVudC5kYXRhLmlkLCAncG9uZycpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VuZXhwZWN0ZWQgYWN0aW9uOiAnICsgZXZlbnQuZGF0YS5hY3Rpb24pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBcIkNPREVcIjtcbn07XG5cbnZhciB3b3JrZXJTdHIgPSB3b3JrZXIudG9TdHJpbmcoKS5zcGxpdCgnXCJDT0RFXCI7Jyk7XG5cbmV4cG9ydHMubmV3V29ya2VyVVJMID0gZnVuY3Rpb24gbmV3V29ya2VyVVJMKGNvZGUsIGRlcHMpIHtcbiAgICB2YXIgYmxvYiA9IG5ldyBCbG9iKFsnKCcsIHdvcmtlclN0clswXSwgJ2ltcG9ydFNjcmlwdHMuYXBwbHkoc2VsZiwgJyArIEpTT04uc3RyaW5naWZ5KGRlcHMpICsgJyk7XFxuJywgJygnLCBjb2RlLCAnKSgpOycsIHdvcmtlclN0clsxXSwgJykoKTsnXSwge3R5cGU6ICdhcHBsaWNhdGlvbi9qYXZhc2NyaXB0J30pO1xuICAgIHJldHVybiBVUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xufTtcbiIsIi8vIHRob3NlIG1ldGhvZHMgY2FuIG9ubHkgYXBwbHkgb24gYmluYXJ5IGltYWdlcy4uLiBidXQgd2Ugd2lsbCBub3QgbG9zZSB0aW1lIHRvIGNoZWNrIVxubGV0IGJpdE1ldGhvZHMgPSB7XG4gICAgc2V0Qml0WFkoeCwgeSkge1xuICAgICAgICBsZXQgdGFyZ2V0ID0geSAqIHRoaXMud2lkdGggKyB4O1xuICAgICAgICBsZXQgc2hpZnQgPSA3IC0gKHRhcmdldCAmIDBiMDAwMDAxMTEpO1xuICAgICAgICBsZXQgc2xvdCA9IHRhcmdldCA+PiAzO1xuICAgICAgICB0aGlzLmRhdGFbc2xvdF0gfD0gMSA8PCBzaGlmdDtcbiAgICB9LFxuXG4gICAgY2xlYXJCaXRYWSh4LCB5KSB7XG4gICAgICAgIGxldCB0YXJnZXQgPSB5ICogdGhpcy53aWR0aCArIHg7XG4gICAgICAgIGxldCBzaGlmdCA9IDcgLSAodGFyZ2V0ICYgMGIwMDAwMDExMSk7XG4gICAgICAgIGxldCBzbG90ID0gdGFyZ2V0ID4+IDM7XG4gICAgICAgIHRoaXMuZGF0YVtzbG90XSAmPSB+KDEgPDwgc2hpZnQpO1xuICAgIH0sXG5cbiAgICB0b2dnbGVCaXRYWSh4LCB5KSB7XG4gICAgICAgIGxldCB0YXJnZXQgPSB5ICogdGhpcy53aWR0aCArIHg7XG4gICAgICAgIGxldCBzaGlmdCA9IDcgLSAodGFyZ2V0ICYgMGIwMDAwMDExMSk7XG4gICAgICAgIGxldCBzbG90ID0gdGFyZ2V0ID4+IDM7XG4gICAgICAgIHRoaXMuZGF0YVtzbG90XSBePSAxIDw8IHNoaWZ0O1xuICAgIH0sXG5cbiAgICBnZXRCaXRYWSh4LCB5KSB7XG4gICAgICAgIGxldCB0YXJnZXQgPSB5ICogdGhpcy53aWR0aCArIHg7XG4gICAgICAgIGxldCBzaGlmdCA9IDcgLSAodGFyZ2V0ICYgMGIwMDAwMDExMSk7XG4gICAgICAgIGxldCBzbG90ID0gdGFyZ2V0ID4+IDM7XG4gICAgICAgIHJldHVybiAodGhpcy5kYXRhW3Nsb3RdICYgKDEgPDwgc2hpZnQpKSA/IDEgOiAwO1xuICAgIH0sXG5cbiAgICBzZXRCaXQocGl4ZWwpIHtcbiAgICAgICAgbGV0IHNoaWZ0ID0gNyAtIChwaXhlbCAmIDBiMDAwMDAxMTEpO1xuICAgICAgICBsZXQgc2xvdCA9IHBpeGVsID4+IDM7XG4gICAgICAgIHRoaXMuZGF0YVtzbG90XSB8PSAxIDw8IHNoaWZ0O1xuICAgIH0sXG5cbiAgICBjbGVhckJpdChwaXhlbCkge1xuICAgICAgICBsZXQgc2hpZnQgPSA3IC0gKHBpeGVsICYgMGIwMDAwMDExMSk7XG4gICAgICAgIGxldCBzbG90ID0gcGl4ZWwgPj4gMztcbiAgICAgICAgdGhpcy5kYXRhW3Nsb3RdICY9IH4oMSA8PCBzaGlmdCk7XG4gICAgfSxcblxuICAgIHRvZ2dsZUJpdChwaXhlbCkge1xuICAgICAgICBsZXQgc2hpZnQgPSA3IC0gKHBpeGVsICYgMGIwMDAwMDExMSk7XG4gICAgICAgIGxldCBzbG90ID0gcGl4ZWwgPj4gMztcbiAgICAgICAgdGhpcy5kYXRhW3Nsb3RdIF49IDEgPDwgc2hpZnQ7XG4gICAgfSxcblxuICAgIGdldEJpdChwaXhlbCkge1xuICAgICAgICBsZXQgc2hpZnQgPSA3IC0gKHBpeGVsICYgMGIwMDAwMDExMSk7XG4gICAgICAgIGxldCBzbG90ID0gcGl4ZWwgPj4gMztcbiAgICAgICAgcmV0dXJuICh0aGlzLmRhdGFbc2xvdF0gJiAoMSA8PCBzaGlmdCkpID8gMSA6IDA7XG4gICAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gKEltYWdlKSB7XG4gICAgZm9yIChsZXQgaSBpbiBiaXRNZXRob2RzKSB7XG4gICAgICAgIEltYWdlLnByb3RvdHlwZVtpXSA9IGJpdE1ldGhvZHNbaV07XG4gICAgfVxufVxuIiwiaW1wb3J0IG5ld0FycmF5IGZyb20gJ25ldy1hcnJheSc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldENvbG9ySGlzdG9ncmFtKHtcbiAgICB1c2VBbHBoYSA9IHRydWUsXG4gICAgbmJTbG90cyA9IDUxMlxuICAgIH0gPSB7fSkge1xuICAgIHRoaXMuY2hlY2tQcm9jZXNzYWJsZSgnZ2V0Q29sb3JIaXN0b2dyYW0nLCB7XG4gICAgICAgIGJpdERlcHRoOiBbOCwgMTZdLFxuICAgICAgICBjb21wb25lbnRzOiBbM11cbiAgICB9KTtcblxuICAgIGxldCBuYlNsb3RzQ2hlY2sgPSBNYXRoLmxvZyhuYlNsb3RzKSAvIE1hdGgubG9nKDgpO1xuICAgIGlmIChuYlNsb3RzQ2hlY2sgIT09IE1hdGguZmxvb3IobmJTbG90c0NoZWNrKSkge1xuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignbmJTbG90cyBtdXN0IGJlIGEgcG93ZXIgb2YgOC4gVXN1YWxseSA4LCA2NCwgNTEyIG9yIDQwOTYnKTtcbiAgICB9XG5cbiAgICBsZXQgYml0U2hpZnQgPSB0aGlzLmJpdERlcHRoIC0gbmJTbG90c0NoZWNrO1xuXG4gICAgbGV0IGRhdGEgPSB0aGlzLmRhdGE7XG4gICAgbGV0IHJlc3VsdCA9IG5ld0FycmF5KE1hdGgucG93KDgsIG5iU2xvdHNDaGVjayksMCk7XG4gICAgbGV0IGZhY3RvcjIgPSBNYXRoLnBvdygyLCBuYlNsb3RzQ2hlY2sgKiAyKTtcbiAgICBsZXQgZmFjdG9yMSA9IE1hdGgucG93KDIsIG5iU2xvdHNDaGVjayk7XG5cblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkgKz0gdGhpcy5jaGFubmVscykge1xuICAgICAgICBsZXQgc2xvdCA9ICgoZGF0YVtpXSkgPj4gYml0U2hpZnQpICogZmFjdG9yMiArXG4gICAgICAgICAgICAoKGRhdGFbaSArIDFdKSA+PiBiaXRTaGlmdCkgKiBmYWN0b3IxICtcbiAgICAgICAgICAgICgoZGF0YVtpICsgMl0pID4+IGJpdFNoaWZ0KTtcbiAgICAgICAgaWYgKHVzZUFscGhhICYmIHRoaXMuYWxwaGEpIHtcbiAgICAgICAgICAgIHJlc3VsdFtzbG90XSArPSBkYXRhW2kgKyB0aGlzLmNoYW5uZWxzIC0gMV0gLyB0aGlzLm1heFZhbHVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0W3Nsb3RdKys7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuIiwiXG4vLyByZXR1cm5zIHRoZSBudW1iZXIgb2YgdHJhbnNwYXJlbnRcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY291bnRBbHBoYVBpeGVscyh7XG4gICAgYWxwaGFcbiAgICB9ID0ge30pIHtcbiAgICB0aGlzLmNoZWNrUHJvY2Vzc2FibGUoJ2NvdW50QWxwaGFQaXhlbHMnLCB7XG4gICAgICAgIGJpdERlcHRoOiBbOCwgMTZdLFxuICAgICAgICBhbHBoYTogMVxuICAgIH0pO1xuXG4gICAgbGV0IGNvdW50ID0gMDtcblxuICAgIGlmIChhbHBoYSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLmNvbXBvbmVudHM7IGkgPCB0aGlzLmRhdGEubGVuZ3RoOyBpICs9IHRoaXMuY2hhbm5lbHMpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmRhdGFbaV0gPT09IGFscGhhKSBjb3VudCsrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb3VudDtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBiZWNhdXNlIHRoZXJlIGlzIGFuIGFscGhhIGNoYW5uZWwgYWxsIHRoZSBwaXhlbHMgaGF2ZSBhbiBhbHBoYVxuICAgICAgICByZXR1cm4gdGhpcy5zaXplO1xuICAgIH1cbn1cbiIsImltcG9ydCBuZXdBcnJheSBmcm9tICduZXctYXJyYXknO1xuaW1wb3J0IGlzSW50ZWdlciBmcm9tICdpcy1pbnRlZ2VyJztcblxuZXhwb3J0IGZ1bmN0aW9uIGdldEhpc3RvZ3JhbSh7bWF4U2xvdHMgPSAyNTYsIGNoYW5uZWwsIHVzZUFscGhhID0gdHJ1ZX0gPSB7fSkge1xuICAgIHRoaXMuY2hlY2tQcm9jZXNzYWJsZSgnZ2V0SGlzdG9ncmFtJywge1xuICAgICAgICBiaXREZXB0aDogWzgsIDE2XVxuICAgIH0pO1xuICAgIGlmIChjaGFubmVsID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKHRoaXMuY29tcG9uZW50cyA+IDEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdZb3UgbmVlZCB0byBkZWZpbmUgdGhlIGNoYW5uZWwgZm9yIGFuIGltYWdlIHRoYXQgY29udGFpbnMgbW9yZSB0aGFuIG9uZSBjaGFubmVsJyk7XG4gICAgICAgIH1cbiAgICAgICAgY2hhbm5lbCA9IDA7XG4gICAgfVxuICAgIHJldHVybiBnZXRDaGFubmVsSGlzdG9ncmFtLmNhbGwodGhpcywgY2hhbm5lbCwgdXNlQWxwaGEsIG1heFNsb3RzKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldEhpc3RvZ3JhbXMoe21heFNsb3RzID0gMjU2LCB1c2VBbHBoYSA9IHRydWV9ID0ge30pIHtcbiAgICB0aGlzLmNoZWNrUHJvY2Vzc2FibGUoJ2dldEhpc3RvZ3JhbXMnLCB7XG4gICAgICAgIGJpdERlcHRoOiBbOCwgMTZdXG4gICAgfSk7XG4gICAgbGV0IHJlc3VsdHMgPSBuZXcgQXJyYXkoKHVzZUFscGhhKSA/IHRoaXMuY29tcG9uZW50cyA6IHRoaXMuY2hhbm5lbHMpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVzdWx0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICByZXN1bHRzW2ldID0gZ2V0Q2hhbm5lbEhpc3RvZ3JhbS5jYWxsKHRoaXMsIGksIHVzZUFscGhhLCBtYXhTbG90cyk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHRzO1xufVxuXG5cbmZ1bmN0aW9uIGdldENoYW5uZWxIaXN0b2dyYW0oY2hhbm5lbCwgdXNlQWxwaGEsIG1heFNsb3RzKSB7XG4gICAgbGV0IGJpdFNsb3RzID0gTWF0aC5sb2cyKG1heFNsb3RzKTtcbiAgICBpZiAoIWlzSW50ZWdlcihiaXRTbG90cykpIHtcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ21heFNsb3RzIG11c3QgYmUgYSBwb3dlciBvZiAyLCBmb3IgZXhhbXBsZTogNjQsIDI1NiwgMTAyNCcpO1xuICAgIH1cbiAgICAvLyB3ZSB3aWxsIGNvbXBhcmUgdGhlIGJpdFNsb3RzIHRvIHRoZSBiaXREZXB0aCBvZiB0aGUgaW1hZ2VcbiAgICAvLyBiYXNlZCBvbiB0aGlzIHdlIHdpbGwgc2hpZnQgdGhlIHZhbHVlcy4gVGhpcyBhbGxvd3MgdG8gZ2VuZXJhdGUgYSBoaXN0b2dyYW1cbiAgICAvLyBvZiAxNiBncmV5IGV2ZW4gaWYgdGhlIGltYWdlcyBoYXMgMjU2IHNoYWRlIG9mIGdyZXlcblxuICAgIGxldCBiaXRTaGlmdCA9IDA7XG4gICAgaWYgKHRoaXMuYml0RGVwdGggPiBiaXRTbG90cykgYml0U2hpZnQgPSB0aGlzLmJpdERlcHRoIC0gYml0U2xvdHM7XG5cbiAgICBsZXQgZGF0YSA9IHRoaXMuZGF0YTtcbiAgICBsZXQgcmVzdWx0ID0gbmV3QXJyYXkoTWF0aC5wb3coMiwgTWF0aC5taW4odGhpcy5iaXREZXB0aCwgYml0U2xvdHMpKSwwKTtcbiAgICBpZiAodXNlQWxwaGEgJiYgdGhpcy5hbHBoYSkge1xuICAgICAgICBsZXQgYWxwaGFDaGFubmVsRGlmZiA9IHRoaXMuY2hhbm5lbHMgLSBjaGFubmVsIC0gMTtcblxuICAgICAgICBmb3IgKGxldCBpID0gY2hhbm5lbDsgaSA8IGRhdGEubGVuZ3RoOyBpICs9IHRoaXMuY2hhbm5lbHMpIHtcbiAgICAgICAgICAgIHJlc3VsdFtkYXRhW2ldID4+IGJpdFNoaWZ0XSArPSBkYXRhW2kgKyBhbHBoYUNoYW5uZWxEaWZmXSAvIHRoaXMubWF4VmFsdWU7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKGxldCBpID0gY2hhbm5lbDsgaSA8IGRhdGEubGVuZ3RoOyBpICs9IHRoaXMuY2hhbm5lbHMpIHtcbiAgICAgICAgICAgIHJlc3VsdFtkYXRhW2ldID4+IGJpdFNoaWZ0XSsrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbiIsImltcG9ydCBuZXdBcnJheSBmcm9tICduZXctYXJyYXknO1xuXG4vLyByZXR1cm5zIGFuIGFycmF5IHdpdGggdGhlIG1heGltYWwgdmFsdWUgb2YgZWFjaCBjaGFubmVsXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIG1heCgpIHtcbiAgICB0aGlzLmNoZWNrUHJvY2Vzc2FibGUoJ21heCcsIHtcbiAgICAgICAgYml0RGVwdGg6IFs4LCAxNl1cbiAgICB9KTtcblxuICAgIGxldCByZXN1bHQgPSBuZXdBcnJheSh0aGlzLmNoYW5uZWxzLC1JbmZpbml0eSk7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuZGF0YS5sZW5ndGg7IGkgKz0gdGhpcy5jaGFubmVscykge1xuICAgICAgICBmb3IgKGxldCBjID0gMDsgYyA8IHRoaXMuY2hhbm5lbHM7IGMrKykge1xuICAgICAgICAgICAgaWYgKHRoaXMuZGF0YVtpICsgY10gPiByZXN1bHRbY10pIHJlc3VsdFtjXSA9IHRoaXMuZGF0YVtpICsgY107XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcblxufVxuIiwiaW1wb3J0IHttZWFuIGFzIGhpc3RvZ3JhbU1lYW59IGZyb20gJy4uLy4uL3V0aWwvaGlzdG9ncmFtJztcblxuLy8gcmV0dXJucyBhbiBhcnJheSB3aXRoIHRoZSBhdmVyYWdlIHZhbHVlIG9mIGVhY2ggY29tcG9uZW50XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIG1lYW4oKSB7XG4gICAgbGV0IGhpc3RvZ3JhbXMgPSB0aGlzLmdldEhpc3RvZ3JhbXMoe21heFNsb3RzOnRoaXMubWF4VmFsdWUgKyAxfSk7XG4gICAgbGV0IHJlc3VsdCA9IG5ldyBBcnJheShoaXN0b2dyYW1zLmxlbmd0aCk7XG4gICAgZm9yIChsZXQgYyA9IDA7IGMgPCBoaXN0b2dyYW1zLmxlbmd0aDsgYysrKSB7XG4gICAgICAgIGxldCBoaXN0b2dyYW0gPSBoaXN0b2dyYW1zW2NdO1xuICAgICAgICByZXN1bHRbY10gPSBoaXN0b2dyYW1NZWFuKGhpc3RvZ3JhbSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG4iLCJpbXBvcnQge21lZGlhbiBhcyBoaXN0b2dyYW1NZWRpYW59IGZyb20gJy4uLy4uL3V0aWwvaGlzdG9ncmFtJztcbi8vIHJldHVybnMgYW4gYXJyYXkgd2l0aCB0aGUgbWVkaWFuIHZhbHVlIG9mIGVhY2ggY29tcG9uZW50XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIG1lZGlhbigpIHtcbiAgICBsZXQgaGlzdG9ncmFtcyA9IHRoaXMuZ2V0SGlzdG9ncmFtcyh7bWF4U2xvdHM6dGhpcy5tYXhWYWx1ZSArIDF9KTtcbiAgICBsZXQgcmVzdWx0ID0gbmV3IEFycmF5KGhpc3RvZ3JhbXMubGVuZ3RoKTtcbiAgICBmb3IgKGxldCBjID0gMDsgYyA8IGhpc3RvZ3JhbXMubGVuZ3RoOyBjKyspIHtcbiAgICAgICAgbGV0IGhpc3RvZ3JhbSA9IGhpc3RvZ3JhbXNbY107XG4gICAgICAgIHJlc3VsdFtjXSA9IGhpc3RvZ3JhbU1lZGlhbihoaXN0b2dyYW0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuIiwiaW1wb3J0IG5ld0FycmF5IGZyb20gJ25ldy1hcnJheSc7XG5cbi8vIHJldHVybnMgYW4gYXJyYXkgd2l0aCB0aGUgbWluaW1hbCB2YWx1ZSBvZiBlYWNoIGNoYW5uZWxcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gbWluKCkge1xuICAgIHRoaXMuY2hlY2tQcm9jZXNzYWJsZSgnbWluJywge1xuICAgICAgICBiaXREZXB0aDogWzgsIDE2XVxuICAgIH0pO1xuXG4gICAgbGV0IHJlc3VsdCA9IG5ld0FycmF5KHRoaXMuY2hhbm5lbHMsK0luZmluaXR5KTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5kYXRhLmxlbmd0aDsgaSArPSB0aGlzLmNoYW5uZWxzKSB7XG4gICAgICAgIGZvciAobGV0IGMgPSAwOyBjIDwgdGhpcy5jaGFubmVsczsgYysrKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5kYXRhW2kgKyBjXSA8IHJlc3VsdFtjXSkgcmVzdWx0W2NdID0gdGhpcy5kYXRhW2kgKyBjXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuXG59XG4iLCIvLyB0aGlzIGZ1bmN0aW9uIHdpbGwgcmV0dXJuIGFuIGFycmF5IGNvbnRhaW5pbmcgYW4gYXJyYXkgb2YgWFlcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0UGl4ZWxzQXJyYXkoKSB7XG4gICAgdGhpcy5jaGVja1Byb2Nlc3NhYmxlKCdnZXRQaXhlbHNBcnJheScsIHtcbiAgICAgICAgYml0RGVwdGg6IFsxXVxuICAgIH0pO1xuXG4gICAgaWYgKHRoaXMuYml0RGVwdGggPT09IDEpIHtcbiAgICAgICAgbGV0IHBpeGVscyA9IG5ldyBBcnJheSh0aGlzLnNpemUpO1xuICAgICAgICBsZXQgY291bnRlciA9IDA7XG4gICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgdGhpcy53aWR0aDsgeCsrKSB7XG4gICAgICAgICAgICBmb3IgKGxldCB5ID0gMDsgeSA8IHRoaXMuaGVpZ2h0OyB5KyspIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5nZXRCaXRYWSh4LCB5KSA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICBwaXhlbHNbY291bnRlcisrXSA9IFt4LCB5XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcGl4ZWxzLmxlbmd0aCA9IGNvdW50ZXI7XG4gICAgICAgIHJldHVybiBwaXhlbHM7XG4gICAgfVxufVxuXG4iLCIvKlxuIEFuIGltYWdlIG1heSBiZSBkZXJpdmVkIGZyb20gYW5vdGhlciBpbWFnZSBlaXRoZXIgYnkgYSBjcm9wXG4gb3IgYmVjYXVzZSBpdCBpcyBhIFJPSSAocmVnaW9uIG9mIGludGVyZXN0KVxuIEFsc28gYSByZWdpb24gb2YgaW50ZXJlc3QgY2FuIGJlIHJlcHJvY2Vzc2VkIHRvIGdlbmVyYXRlZCBhbm90aGVyXG4gc2V0IG9mIHJlZ2lvbiBvZiBpbnRlcmVzdHMuXG4gSXQgaXMgdGhlcmVmb3JlIGltcG9ydGFudCB0byBrZWVwIHRoZSBoaWVyYXJjaHkgb2YgaW1hZ2VzIHRvIGtub3dcbiB3aGljaCBpbWFnZSBpcyBkZXJpdmVkIGZyb20gd2hpY2ggb25lIGFuZCBiZSBhYmxlIHRvIGdldCB0aGVcbiByZWxhdGl2ZSBwb3NpdGlvbiBvZiBvbmUgaW1hZ2UgaW4gYW5vdGhlclxuIFRoaXMgbWV0aG9kcyB0YWtlcyBjYXJlIG9mIHRoaXMuXG4gKi9cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0UmVsYXRpdmVQb3NpdGlvbih0YXJnZXRJbWFnZSkge1xuICAgIGlmICh0aGlzID09PSB0YXJnZXRJbWFnZSkgcmV0dXJuIFswLDBdO1xuICAgIGxldCBwb3NpdGlvbiA9IFswLDBdO1xuXG4gICAgbGV0IGN1cnJlbnRJbWFnZSA9IHRoaXM7XG4gICAgd2hpbGUgKGN1cnJlbnRJbWFnZSkge1xuICAgICAgICBpZiAoY3VycmVudEltYWdlID09PSB0YXJnZXRJbWFnZSkgcmV0dXJuIHBvc2l0aW9uO1xuICAgICAgICBpZiAoY3VycmVudEltYWdlLnBvc2l0aW9uKSB7XG4gICAgICAgICAgICBwb3NpdGlvblswXSArPSBjdXJyZW50SW1hZ2UucG9zaXRpb25bMF07XG4gICAgICAgICAgICBwb3NpdGlvblsxXSArPSBjdXJyZW50SW1hZ2UucG9zaXRpb25bMV07XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudEltYWdlID0gY3VycmVudEltYWdlLnBhcmVudDtcbiAgICB9XG4gICAgLy8gd2Ugc2hvdWxkIG5ldmVyIHJlYWNoIHRoaXMgcGxhY2UsIHRoaXMgbWVhbnMgd2UgY291bGQgbm90IGZpbmQgdGhlIHBhcmVudFxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgLy8gdGhyb3cgRXJyb3IoJ1BhcmVudCBpbWFnZSB3YXMgbm90IGZvdW5kLCBjYW4gbm90IGdldCByZWxhdGl2ZSBwb3NpdGlvbi4nKVxufVxuIiwiaW1wb3J0IG5ld0FycmF5IGZyb20gJ25ldy1hcnJheSc7XG5cbi8vIHJldHVybnMgYW4gYXJyYXkgd2l0aCB0aGUgc3VtIHZhbHVlcyBvZiBlYWNoIGNoYW5uZWxcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gc3VtKCkge1xuICAgIHRoaXMuY2hlY2tQcm9jZXNzYWJsZSgnc3VtJywge1xuICAgICAgICBiaXREZXB0aDogWzgsIDE2XVxuICAgIH0pO1xuXG4gICAgbGV0IHJlc3VsdCA9IG5ld0FycmF5KHRoaXMuY2hhbm5lbHMsMCk7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuZGF0YS5sZW5ndGg7IGkgKz0gdGhpcy5jaGFubmVscykge1xuICAgICAgICBmb3IgKGxldCBjID0gMDsgYyA8IHRoaXMuY2hhbm5lbHM7IGMrKykge1xuICAgICAgICAgICAgcmVzdWx0W2NdICs9IHRoaXMuZGF0YVtpICsgY107XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcblxufVxuIiwibGV0IE1hdHJpeCA9IHJlcXVpcmUoJ21sLW1hdHJpeCcpO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRTVkQoKSB7XG4gICAgdGhpcy5jaGVja1Byb2Nlc3NhYmxlKCdnZXRTVkQnLCB7XG4gICAgICAgIGJpdERlcHRoOiBbMV1cbiAgICB9KTtcblxuICAgIHJldHVybiBNYXRyaXguREMuU1ZEKHRoaXMucGl4ZWxzQXJyYXkpO1xufVxuIiwibGV0IGxvYWRCaW5hcnksIERPTUltYWdlLCBDYW52YXMsIEltYWdlRGF0YSwgaXNEaWZmZXJlbnRPcmlnaW4sIGVudjtcblxuaWYgKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJykgeyAvLyBCcm93c2VyXG4gICAgZW52ID0gJ2Jyb3dzZXInO1xuICAgIGNvbnN0IG9yaWdpbiA9IHNlbGYubG9jYXRpb24ub3JpZ2luO1xuICAgIGlzRGlmZmVyZW50T3JpZ2luID0gZnVuY3Rpb24gKHVybCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbGV0IHBhcnNlZFVSTCA9IG5ldyBzZWxmLlVSTCh1cmwpO1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlZFVSTC5vcmlnaW4gIT09IG9yaWdpbjtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgLy8gbWF5IGJlIGEgcmVsYXRpdmUgVVJMLiBJbiB0aGlzIGNhc2UsIGl0IGNhbm5vdCBiZSBwYXJzZWQgYnV0IGlzIGVmZmVjdGl2ZWx5IGZyb20gc2FtZSBvcmlnaW5cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBJbWFnZURhdGEgPSBzZWxmLkltYWdlRGF0YTtcblxuICAgIERPTUltYWdlID0gc2VsZi5JbWFnZTtcbiAgICBDYW52YXMgPSBmdW5jdGlvbiBDYW52YXMod2lkdGgsIGhlaWdodCkge1xuICAgICAgICBsZXQgY2FudmFzID0gc2VsZi5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgICAgY2FudmFzLndpZHRoID0gd2lkdGg7XG4gICAgICAgIGNhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgIHJldHVybiBjYW52YXM7XG4gICAgfTtcblxuICAgIGxvYWRCaW5hcnkgPSBmdW5jdGlvbiAodXJsKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICBsZXQgeGhyID0gbmV3IHNlbGYuWE1MSHR0cFJlcXVlc3QoKTtcbiAgICAgICAgICAgIHhoci5vcGVuKCdHRVQnLCB1cmwsIHRydWUpO1xuICAgICAgICAgICAgeGhyLnJlc3BvbnNlVHlwZSA9ICdhcnJheWJ1ZmZlcic7XG5cbiAgICAgICAgICAgIHhoci5vbmxvYWQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdHVzID09PSAyMDAgPyByZXNvbHZlKHRoaXMucmVzcG9uc2UpIDogcmVqZWN0KCd3cm9uZyBzdGF0dXMnLCBlKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB4aHIub25lcnJvciA9IHJlamVjdDtcbiAgICAgICAgICAgIHhoci5zZW5kKCk7XG4gICAgICAgIH0pO1xuICAgIH07XG59IGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKSB7IC8vIE5vZGUuanNcbiAgICBlbnYgPSAnbm9kZSc7XG4gICAgaXNEaWZmZXJlbnRPcmlnaW4gPSBmdW5jdGlvbiAodXJsKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuXG4gICAgY29uc3QgY2FudmFzID0gcmVxdWlyZSgnY2FudmFzJyk7XG4gICAgRE9NSW1hZ2UgPSBjYW52YXMuSW1hZ2U7XG4gICAgQ2FudmFzID0gY2FudmFzO1xuICAgIEltYWdlRGF0YSA9IGNhbnZhcy5JbWFnZURhdGE7XG5cbiAgICBjb25zdCBmcyA9IHJlcXVpcmUoJ2ZzJyk7XG4gICAgbG9hZEJpbmFyeSA9IGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICBmcy5yZWFkRmlsZShwYXRoLCBmdW5jdGlvbiAoZXJyLCBkYXRhKSB7XG4gICAgICAgICAgICAgICAgZXJyID8gcmVqZWN0KGVycikgOiByZXNvbHZlKGRhdGEuYnVmZmVyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xufVxuXG5leHBvcnQge2xvYWRCaW5hcnksIERPTUltYWdlLCBDYW52YXMsIEltYWdlRGF0YSwgaXNEaWZmZXJlbnRPcmlnaW4sIGVudn07XG4iLCIvLyBmaWx0ZXJzXG5pbXBvcnQgaW52ZXJ0R2V0U2V0IGZyb20gJy4vZmlsdGVyL2ludmVydEdldFNldCc7XG5pbXBvcnQgaW52ZXJ0SXRlcmF0b3IgZnJvbSAnLi9maWx0ZXIvaW52ZXJ0SXRlcmF0b3InO1xuaW1wb3J0IGludmVydE9uZUxvb3AgZnJvbSAnLi9maWx0ZXIvaW52ZXJ0T25lTG9vcCc7XG5pbXBvcnQgaW52ZXJ0UGl4ZWwgZnJvbSAnLi9maWx0ZXIvaW52ZXJ0UGl4ZWwnO1xuaW1wb3J0IGludmVydEFwcGx5IGZyb20gJy4vZmlsdGVyL2ludmVydEFwcGx5JztcbmltcG9ydCBpbnZlcnRCaW5hcnlMb29wIGZyb20gJy4vZmlsdGVyL2ludmVydEJpbmFyeUxvb3AnO1xuaW1wb3J0IGludmVydCBmcm9tICcuL2ZpbHRlci9pbnZlcnQnO1xuaW1wb3J0IG1lYW5GaWx0ZXIgZnJvbSAnLi9maWx0ZXIvYmx1cic7XG5pbXBvcnQgbWVkaWFuRmlsdGVyIGZyb20gJy4vZmlsdGVyL21lZGlhbic7XG5pbXBvcnQgZ2F1c3NpYW5GaWx0ZXIgZnJvbSAnLi9maWx0ZXIvZ2F1c3NpYW4nO1xuaW1wb3J0IHNvYmVsRmlsdGVyIGZyb20gJy4vZmlsdGVyL3NvYmVsJztcbmltcG9ydCBsZXZlbCBmcm9tICcuL2ZpbHRlci9sZXZlbCc7XG5pbXBvcnQgYWRkIGZyb20gJy4vZmlsdGVyL2FkZCc7XG5pbXBvcnQgc3VidHJhY3QgZnJvbSAnLi9maWx0ZXIvc3VidHJhY3QnO1xuaW1wb3J0IGh5cG90ZW51c2UgZnJvbSAnLi9maWx0ZXIvaHlwb3RlbnVzZSc7XG5pbXBvcnQgbXVsdGlwbHkgZnJvbSAnLi9maWx0ZXIvbXVsdGlwbHknO1xuaW1wb3J0IGRpdmlkZSBmcm9tICcuL2ZpbHRlci9kaXZpZGUnO1xuaW1wb3J0IGdldEJhY2tncm91bmQgZnJvbSAnLi9maWx0ZXIvZ2V0QmFja2dyb3VuZCc7XG5cbi8vIHRyYW5zZm9ybWVyc1xuaW1wb3J0IGNyb3AgZnJvbSAnLi90cmFuc2Zvcm0vY3JvcCc7XG5pbXBvcnQgc2NhbGUgZnJvbSAnLi90cmFuc2Zvcm0vc2NhbGUvc2NhbGUnO1xuaW1wb3J0IGhzdiBmcm9tICcuL3RyYW5zZm9ybS9oc3YnO1xuaW1wb3J0IGhzbCBmcm9tICcuL3RyYW5zZm9ybS9oc2wnO1xuaW1wb3J0IHJnYmE4IGZyb20gJy4vdHJhbnNmb3JtL3JnYmE4JztcbmltcG9ydCBncmV5IGZyb20gJy4vdHJhbnNmb3JtL2dyZXkvZ3JleSc7XG5pbXBvcnQgbWFzayBmcm9tICcuL3RyYW5zZm9ybS9tYXNrL21hc2snO1xuaW1wb3J0IHBhZCBmcm9tICcuL3RyYW5zZm9ybS9wYWQnO1xuaW1wb3J0IHJlc2l6ZUJpbmFyeSBmcm9tICcuL3RyYW5zZm9ybS9yZXNpemVCaW5hcnknO1xuaW1wb3J0IGNvbG9yRGVwdGggZnJvbSAnLi90cmFuc2Zvcm0vY29sb3JEZXB0aCc7XG5cblxuaW1wb3J0IHNldEJvcmRlciBmcm9tICcuL3V0aWxpdHkvc2V0Qm9yZGVyJztcbmltcG9ydCBzcGxpdCBmcm9tICcuL3V0aWxpdHkvc3BsaXQnO1xuaW1wb3J0IGdldENoYW5uZWwgZnJvbSAnLi91dGlsaXR5L2dldENoYW5uZWwnO1xuaW1wb3J0IHNldENoYW5uZWwgZnJvbSAnLi91dGlsaXR5L3NldENoYW5uZWwnO1xuaW1wb3J0IGdldFNpbWlsYXJpdHkgZnJvbSAnLi91dGlsaXR5L2dldFNpbWlsYXJpdHknO1xuaW1wb3J0IGdldFBpeGVsc0dyaWQgZnJvbSAnLi91dGlsaXR5L2dldFBpeGVsc0dyaWQnO1xuaW1wb3J0IGdldEJlc3RNYXRjaCBmcm9tICcuL3V0aWxpdHkvZ2V0QmVzdE1hdGNoJztcbmltcG9ydCBnZXRSb3cgZnJvbSAnLi91dGlsaXR5L2dldFJvdyc7XG5pbXBvcnQgZ2V0Q29sdW1uIGZyb20gJy4vdXRpbGl0eS9nZXRDb2x1bW4nO1xuaW1wb3J0IHBhaW50TWFza3MgZnJvbSAnLi9vcGVyYXRvci9wYWludE1hc2tzJztcbmltcG9ydCBwYWludFBpeGVscyBmcm9tICcuL29wZXJhdG9yL3BhaW50UGl4ZWxzJztcbmltcG9ydCBleHRyYWN0IGZyb20gJy4vb3BlcmF0b3IvZXh0cmFjdCc7XG5pbXBvcnQgY29udm9sdXRpb24gZnJvbSAnLi9vcGVyYXRvci9jb252b2x1dGlvbic7XG5cbi8vIGNvbXB1dGVyc1xuaW1wb3J0IHtnZXRIaXN0b2dyYW0sIGdldEhpc3RvZ3JhbXN9IGZyb20gJy4vY29tcHV0ZS9oaXN0b2dyYW0nO1xuaW1wb3J0IGdldENvbG9ySGlzdG9ncmFtIGZyb20gJy4vY29tcHV0ZS9jb2xvckhpc3RvZ3JhbSc7XG5pbXBvcnQgZ2V0TWluIGZyb20gJy4vY29tcHV0ZS9taW4nO1xuaW1wb3J0IGdldE1heCBmcm9tICcuL2NvbXB1dGUvbWF4JztcbmltcG9ydCBnZXRTdW0gZnJvbSAnLi9jb21wdXRlL3N1bSc7XG5pbXBvcnQgZ2V0TWVhbiBmcm9tICcuL2NvbXB1dGUvbWVhbic7XG5pbXBvcnQgZ2V0TWVkaWFuIGZyb20gJy4vY29tcHV0ZS9tZWRpYW4nO1xuaW1wb3J0IGdldFBpeGVsc0FycmF5IGZyb20gJy4vY29tcHV0ZS9waXhlbHNBcnJheSc7XG5pbXBvcnQgZ2V0UmVsYXRpdmVQb3NpdGlvbiBmcm9tICcuL2NvbXB1dGUvcmVsYXRpdmVQb3NpdGlvbic7XG5pbXBvcnQgZ2V0U1ZEIGZyb20gJy4vY29tcHV0ZS9zdmQnO1xuaW1wb3J0IGNvdW50QWxwaGFQaXhlbHMgZnJvbSAnLi9jb21wdXRlL2NvdW50QWxwaGFQaXhlbHMnO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBleHRlbmQoSW1hZ2UpIHtcbiAgICBsZXQgaW5QbGFjZSA9IHtpblBsYWNlOiB0cnVlfTtcbiAgICBsZXQgaW5QbGFjZVN0YWNrID0ge2luUGxhY2U6IHRydWUsIHN0YWNrOiB0cnVlfTtcbiAgICBsZXQgc3RhY2sgPSB7c3RhY2s6IHRydWV9O1xuXG4gICAgSW1hZ2UuZXh0ZW5kTWV0aG9kKCdpbnZlcnRHZXRTZXQnLCBpbnZlcnRHZXRTZXQsIGluUGxhY2UpO1xuICAgIEltYWdlLmV4dGVuZE1ldGhvZCgnaW52ZXJ0SXRlcmF0b3InLCBpbnZlcnRJdGVyYXRvciwgaW5QbGFjZSk7XG4gICAgSW1hZ2UuZXh0ZW5kTWV0aG9kKCdpbnZlcnRQaXhlbCcsIGludmVydFBpeGVsLCBpblBsYWNlKTtcbiAgICBJbWFnZS5leHRlbmRNZXRob2QoJ2ludmVydE9uZUxvb3AnLCBpbnZlcnRPbmVMb29wLCBpblBsYWNlKTtcbiAgICBJbWFnZS5leHRlbmRNZXRob2QoJ2ludmVydEFwcGx5JywgaW52ZXJ0QXBwbHksIGluUGxhY2UpO1xuICAgIEltYWdlLmV4dGVuZE1ldGhvZCgnaW52ZXJ0JywgaW52ZXJ0LCBpblBsYWNlU3RhY2spO1xuICAgIEltYWdlLmV4dGVuZE1ldGhvZCgnaW52ZXJ0QmluYXJ5TG9vcCcsIGludmVydEJpbmFyeUxvb3AsIGluUGxhY2UpO1xuICAgIEltYWdlLmV4dGVuZE1ldGhvZCgnbGV2ZWwnLCBsZXZlbCwgaW5QbGFjZSk7XG4gICAgSW1hZ2UuZXh0ZW5kTWV0aG9kKCdhZGQnLCBhZGQsIGluUGxhY2UpO1xuICAgIEltYWdlLmV4dGVuZE1ldGhvZCgnc3VidHJhY3QnLCBzdWJ0cmFjdCwgaW5QbGFjZSk7XG4gICAgSW1hZ2UuZXh0ZW5kTWV0aG9kKCdtdWx0aXBseScsIG11bHRpcGx5LCBpblBsYWNlKTtcbiAgICBJbWFnZS5leHRlbmRNZXRob2QoJ2RpdmlkZScsIGRpdmlkZSwgaW5QbGFjZSk7XG4gICAgSW1hZ2UuZXh0ZW5kTWV0aG9kKCdoeXBvdGVudXNlJywgaHlwb3RlbnVzZSk7XG4gICAgSW1hZ2UuZXh0ZW5kTWV0aG9kKCdnZXRCYWNrZ3JvdW5kJywgZ2V0QmFja2dyb3VuZCk7XG5cbiAgICBJbWFnZS5leHRlbmRNZXRob2QoJ21lYW5GaWx0ZXInLCBtZWFuRmlsdGVyKTtcbiAgICBJbWFnZS5leHRlbmRNZXRob2QoJ21lZGlhbkZpbHRlcicsIG1lZGlhbkZpbHRlcik7XG4gICAgSW1hZ2UuZXh0ZW5kTWV0aG9kKCdnYXVzc2lhbkZpbHRlcicsIGdhdXNzaWFuRmlsdGVyKTtcbiAgICBJbWFnZS5leHRlbmRNZXRob2QoJ3NvYmVsRmlsdGVyJywgc29iZWxGaWx0ZXIpO1xuXG4gICAgSW1hZ2UuZXh0ZW5kTWV0aG9kKCdjcm9wJywgY3JvcCwgc3RhY2spO1xuICAgIEltYWdlLmV4dGVuZE1ldGhvZCgnc2NhbGUnLCBzY2FsZSwgc3RhY2spO1xuICAgIEltYWdlLmV4dGVuZE1ldGhvZCgnaHN2JywgaHN2KTtcbiAgICBJbWFnZS5leHRlbmRNZXRob2QoJ2hzbCcsIGhzbCk7XG4gICAgSW1hZ2UuZXh0ZW5kTWV0aG9kKCdyZ2JhOCcsIHJnYmE4KTtcbiAgICBJbWFnZS5leHRlbmRNZXRob2QoJ2dyZXknLCBncmV5KS5leHRlbmRNZXRob2QoJ2dyYXknLCBncmV5KTtcbiAgICBJbWFnZS5leHRlbmRNZXRob2QoJ21hc2snLCBtYXNrKTtcbiAgICBJbWFnZS5leHRlbmRNZXRob2QoJ3BhZCcsIHBhZCk7XG4gICAgSW1hZ2UuZXh0ZW5kTWV0aG9kKCdyZXNpemVCaW5hcnknLCByZXNpemVCaW5hcnkpO1xuICAgIEltYWdlLmV4dGVuZE1ldGhvZCgnY29sb3JEZXB0aCcsIGNvbG9yRGVwdGgpO1xuICAgIEltYWdlLmV4dGVuZE1ldGhvZCgnc2V0Qm9yZGVyJywgc2V0Qm9yZGVyLCBpblBsYWNlKTtcblxuICAgIEltYWdlLmV4dGVuZE1ldGhvZCgnZ2V0Um93JywgZ2V0Um93KTtcbiAgICBJbWFnZS5leHRlbmRNZXRob2QoJ2dldENvbHVtbicsIGdldENvbHVtbik7XG5cbiAgICBJbWFnZS5leHRlbmRNZXRob2QoJ3NwbGl0Jywgc3BsaXQpO1xuICAgIEltYWdlLmV4dGVuZE1ldGhvZCgnZ2V0Q2hhbm5lbCcsIGdldENoYW5uZWwpO1xuICAgIEltYWdlLmV4dGVuZE1ldGhvZCgnc2V0Q2hhbm5lbCcsIHNldENoYW5uZWwpO1xuICAgIEltYWdlLmV4dGVuZE1ldGhvZCgnZ2V0U2ltaWxhcml0eScsIGdldFNpbWlsYXJpdHkpO1xuICAgIEltYWdlLmV4dGVuZE1ldGhvZCgnZ2V0UGl4ZWxzR3JpZCcsIGdldFBpeGVsc0dyaWQpO1xuICAgIEltYWdlLmV4dGVuZE1ldGhvZCgnZ2V0QmVzdE1hdGNoJywgZ2V0QmVzdE1hdGNoKTtcblxuICAgIEltYWdlLmV4dGVuZE1ldGhvZCgncGFpbnRNYXNrcycsIHBhaW50TWFza3MsIGluUGxhY2UpO1xuICAgIEltYWdlLmV4dGVuZE1ldGhvZCgncGFpbnRQaXhlbHMnLCBwYWludFBpeGVscywgaW5QbGFjZSk7XG4gICAgSW1hZ2UuZXh0ZW5kTWV0aG9kKCdleHRyYWN0JywgZXh0cmFjdCk7XG4gICAgSW1hZ2UuZXh0ZW5kTWV0aG9kKCdjb252b2x1dGlvbicsIGNvbnZvbHV0aW9uKTtcblxuICAgIEltYWdlLmV4dGVuZE1ldGhvZCgnY291bnRBbHBoYVBpeGVscycsIGNvdW50QWxwaGFQaXhlbHMpO1xuICAgIEltYWdlLmV4dGVuZE1ldGhvZCgnZ2V0SGlzdG9ncmFtJywgZ2V0SGlzdG9ncmFtKS5leHRlbmRQcm9wZXJ0eSgnaGlzdG9ncmFtJywgZ2V0SGlzdG9ncmFtKTtcbiAgICBJbWFnZS5leHRlbmRNZXRob2QoJ2dldEhpc3RvZ3JhbXMnLCBnZXRIaXN0b2dyYW1zKS5leHRlbmRQcm9wZXJ0eSgnaGlzdG9ncmFtcycsIGdldEhpc3RvZ3JhbXMpO1xuICAgIEltYWdlLmV4dGVuZE1ldGhvZCgnZ2V0Q29sb3JIaXN0b2dyYW0nLCBnZXRDb2xvckhpc3RvZ3JhbSkuZXh0ZW5kUHJvcGVydHkoJ2NvbG9ySGlzdG9ncmFtJywgZ2V0Q29sb3JIaXN0b2dyYW0pO1xuICAgIEltYWdlLmV4dGVuZE1ldGhvZCgnZ2V0TWluJywgZ2V0TWluKS5leHRlbmRQcm9wZXJ0eSgnbWluJywgZ2V0TWluKTtcbiAgICBJbWFnZS5leHRlbmRNZXRob2QoJ2dldE1heCcsIGdldE1heCkuZXh0ZW5kUHJvcGVydHkoJ21heCcsIGdldE1heCk7XG4gICAgSW1hZ2UuZXh0ZW5kTWV0aG9kKCdnZXRTdW0nLCBnZXRTdW0pLmV4dGVuZFByb3BlcnR5KCdzdW0nLCBnZXRTdW0pO1xuICAgIEltYWdlLmV4dGVuZE1ldGhvZCgnZ2V0TWVkaWFuJywgZ2V0U3VtKS5leHRlbmRQcm9wZXJ0eSgnbWVkaWFuJywgZ2V0TWVkaWFuKTtcbiAgICBJbWFnZS5leHRlbmRNZXRob2QoJ2dldE1lYW4nLCBnZXRNZWFuKS5leHRlbmRQcm9wZXJ0eSgnbWVhbicsIGdldE1lYW4pO1xuICAgIEltYWdlLmV4dGVuZE1ldGhvZCgnZ2V0UGl4ZWxzQXJyYXknLCBnZXRQaXhlbHNBcnJheSkuZXh0ZW5kUHJvcGVydHkoJ3BpeGVsc0FycmF5JywgZ2V0UGl4ZWxzQXJyYXkpO1xuICAgIEltYWdlLmV4dGVuZE1ldGhvZCgnZ2V0UmVsYXRpdmVQb3NpdGlvbicsIGdldFJlbGF0aXZlUG9zaXRpb24pO1xuICAgIEltYWdlLmV4dGVuZE1ldGhvZCgnZ2V0U1ZEJywgZ2V0U1ZEKS5leHRlbmRQcm9wZXJ0eSgnc3ZkJywgZ2V0U1ZEKTtcbn1cbiIsImltcG9ydCB7dmFsaWRhdGVBcnJheU9mQ2hhbm5lbHN9IGZyb20gJy4uLy4uL3V0aWwvY2hhbm5lbCc7XG5pbXBvcnQgSW1hZ2UgZnJvbSAnLi4vaW1hZ2UnO1xuaW1wb3J0IHtjaGVja051bWJlckFycmF5fSBmcm9tICcuLi8uLi91dGlsL3ZhbHVlJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gYWRkKHZhbHVlLCB7Y2hhbm5lbHN9ID0ge30pIHtcbiAgICB0aGlzLmNoZWNrUHJvY2Vzc2FibGUoJ2FkZCcsIHtcbiAgICAgICAgYml0RGVwdGg6IFs4LCAxNl1cbiAgICB9KTtcblxuICAgIGNoYW5uZWxzID0gdmFsaWRhdGVBcnJheU9mQ2hhbm5lbHModGhpcywge2NoYW5uZWxzOmNoYW5uZWxzfSk7XG4gICAgdmFsdWUgPSBjaGVja051bWJlckFycmF5KHZhbHVlKTtcblxuLy8gd2UgYWxsb3cgMyBjYXNlcywgdGhlIHZhbHVlIG1heSBiZSBhbiBhcnJheSAoMUQpLCBhbiBpbWFnZSBvciBhIHNpbmdsZSB2YWx1ZVxuICAgIGlmICghaXNOYU4odmFsdWUpKSB7XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgY2hhbm5lbHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGxldCBjID0gY2hhbm5lbHNbal07XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuZGF0YS5sZW5ndGg7IGkgKz0gdGhpcy5jaGFubmVscykge1xuICAgICAgICAgICAgICAgIHRoaXMuZGF0YVtpICsgY10gPSBNYXRoLm1pbih0aGlzLm1heFZhbHVlLCAodGhpcy5kYXRhW2kgKyBjXSArIHZhbHVlKSA+PiAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh0aGlzLmRhdGEubGVuZ3RoICE9PSB2YWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYWRkOiB0aGUgZGF0YSBzaXplIGlzIGRpZmZlcmVudCcpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgY2hhbm5lbHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGxldCBjID0gY2hhbm5lbHNbal07XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuZGF0YS5sZW5ndGg7IGkgKz0gdGhpcy5jaGFubmVscykge1xuICAgICAgICAgICAgICAgIHRoaXMuZGF0YVtpICsgY10gPSBNYXRoLm1heCgwLE1hdGgubWluKHRoaXMubWF4VmFsdWUsICh0aGlzLmRhdGFbaSArIGNdICsgdmFsdWVbaSArIGNdKSA+PiAwKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG4iLCJpbXBvcnQgSW1hZ2UgZnJvbSAnLi4vaW1hZ2UnO1xuaW1wb3J0IGNvbnZvbHV0aW9uIGZyb20gJy4uL29wZXJhdG9yL2NvbnZvbHV0aW9uJztcblxuLy8gZmlyc3QgcmVsZWFzZSBvZiBtZWFuIGZpbHRlclxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gbWVhbkZpbHRlcihrKSB7XG5cbiAgICB0aGlzLmNoZWNrUHJvY2Vzc2FibGUoJ21lYW5GaWx0ZXInLCB7XG4gICAgICAgIGNvbXBvbmVudHM6WzFdLFxuICAgICAgICBiaXREZXB0aDpbOCwxNl1cbiAgICB9KTtcblxuICAgIGlmIChrIDwgMSkge3Rocm93IG5ldyBFcnJvcignTnVtYmVyIG9mIG5laWdoYm9ycyBzaG91bGQgYmUgZ3JhdGVyIHRoYW4gMCcpO31cblxuICAgIGxldCBuID0gMiAqIGsgKyAxO1xuICAgIGxldCBzaXplID0gbiAqIG47XG4gICAgbGV0IGtlcm5lbCA9IG5ldyBBcnJheShzaXplKTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwga2VybmVsLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGtlcm5lbFtpXSA9IDE7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbnZvbHV0aW9uLmNhbGwodGhpcywga2VybmVsKTtcbn1cbiIsImltcG9ydCB7dmFsaWRhdGVBcnJheU9mQ2hhbm5lbHN9IGZyb20gJy4uLy4uL3V0aWwvY2hhbm5lbCc7XG5pbXBvcnQgSW1hZ2UgZnJvbSAnLi4vaW1hZ2UnO1xuaW1wb3J0IHtjaGVja051bWJlckFycmF5fSBmcm9tICcuLi8uLi91dGlsL3ZhbHVlJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gYWRkKHZhbHVlLCB7Y2hhbm5lbHN9ID0ge30pIHtcbiAgICB0aGlzLmNoZWNrUHJvY2Vzc2FibGUoJ2RpdmlkZScsIHtcbiAgICAgICAgYml0RGVwdGg6IFs4LCAxNl1cbiAgICB9KTtcblxuICAgIGNoYW5uZWxzID0gdmFsaWRhdGVBcnJheU9mQ2hhbm5lbHModGhpcywge2NoYW5uZWxzOmNoYW5uZWxzfSk7XG4gICAgdmFsdWUgPSBjaGVja051bWJlckFycmF5KHZhbHVlKTtcblxuICAgIGlmICghaXNOYU4odmFsdWUpKSB7XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgY2hhbm5lbHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGxldCBjID0gY2hhbm5lbHNbal07XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuZGF0YS5sZW5ndGg7IGkgKz0gdGhpcy5jaGFubmVscykge1xuICAgICAgICAgICAgICAgIHRoaXMuZGF0YVtpICsgY10gPSBNYXRoLm1pbih0aGlzLm1heFZhbHVlLCAodGhpcy5kYXRhW2kgKyBjXSAvIHZhbHVlKSA+PiAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh0aGlzLmRhdGEubGVuZ3RoICE9PSB2YWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZGl2aWRlOiB0aGU6IHRoZSBkYXRhIHNpemUgaXMgZGlmZmVyZW50Jyk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBjaGFubmVscy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgbGV0IGMgPSBjaGFubmVsc1tqXTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5kYXRhLmxlbmd0aDsgaSArPSB0aGlzLmNoYW5uZWxzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kYXRhW2kgKyBjXSA9IE1hdGgubWF4KDAsIE1hdGgubWluKHRoaXMubWF4VmFsdWUsICh0aGlzLmRhdGFbaSArIGNdIC8gdmFsdWVbaSArIGNdKSA+PiAwKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG4iLCJpbXBvcnQgSW1hZ2UgZnJvbSAnLi4vaW1hZ2UnO1xuaW1wb3J0IGNvbnZvbHV0aW9uIGZyb20gJy4uL29wZXJhdG9yL2NvbnZvbHV0aW9uJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2F1c3NpYW5GaWx0ZXIoe1xuXHRyYWRpdXMgPSAxLFxuXHRzaWdtYSxcblx0Y2hhbm5lbHMsXG5cdGJvcmRlciA9ICdjb3B5J1xuXHR9ID0ge30pIHtcblxuXHR0aGlzLmNoZWNrUHJvY2Vzc2FibGUoJ2dhdXNzaWFuRmlsdGVyJywge1xuXHRcdGJpdERlcHRoOiBbOCwgMTZdXG5cdH0pO1xuXG5cdGxldCBrZXJuZWw7XG5cdGlmIChzaWdtYSkge1xuXHRcdGtlcm5lbCA9IGdldFNpZ21hS2VybmVsKHNpZ21hKTtcblx0fSBlbHNlIHtcblx0XHQvLyBzaWdtYSBhcHByb3hpbWF0aW9uIHVzaW5nIHJhZGl1c1xuXHRcdHNpZ21hID0gMC4zICogKHJhZGl1cyAtIDEpICsgMC44O1xuXHRcdGtlcm5lbCA9IGdldEtlcm5lbChyYWRpdXMsIHNpZ21hKTtcblx0fVxuXG5cdHJldHVybiBjb252b2x1dGlvbi5jYWxsKHRoaXMsIGtlcm5lbCwge1xuXHRcdGJvcmRlcjogYm9yZGVyLFxuXHRcdGNoYW5uZWxzOiBjaGFubmVsc1xuXHR9KTtcbn1cblxuZnVuY3Rpb24gZ2V0S2VybmVsKHJhZGl1cywgc2lnbWEpIHtcblx0aWYgKHJhZGl1cyA8IDEpIHtcblx0XHR0aHJvdyBuZXcgUmFuZ2VFcnJvcignUmFkaXVzIHNob3VsZCBiZSBncmF0ZXIgdGhhbiAwJyk7XG5cdH1cblx0bGV0IG4gPSAyICogcmFkaXVzICsgMTtcblxuXHRsZXQga2VybmVsID0gbmV3IEFycmF5KG4gKiBuKTtcblxuXHQvL2dhdXNzaWFuIGtlcm5lbCBpcyBjYWxjdWxhdGVkXG5cdGxldCBzaWdtYTIgPSAyICogKHNpZ21hICogc2lnbWEpOyAvLzIqc2lnbWFeMlxuXHRsZXQgUEkyc2lnbWEyID0gTWF0aC5QSSAqIHNpZ21hMjsgLy8yKlBJKnNpZ21hXjJcblxuXHRmb3IgKGxldCBpID0gMDsgaSA8PSByYWRpdXM7IGkrKykge1xuXHRcdGZvciAobGV0IGogPSBpOyBqIDw9IHJhZGl1czsgaisrKSB7XG5cdFx0XHRsZXQgdmFsdWUgPSBNYXRoLmV4cCgtKChpICogaSkgKyAoaiAqIGopKSAvIHNpZ21hMikgLyBQSTJzaWdtYTI7XG5cdFx0XHRrZXJuZWxbKGkgKyByYWRpdXMpICogbiArIChqICsgcmFkaXVzKV0gPSB2YWx1ZTtcblx0XHRcdGtlcm5lbFsoaSArIHJhZGl1cykgKiBuICsgKC1qICsgcmFkaXVzKV0gPSB2YWx1ZTtcblx0XHRcdGtlcm5lbFsoLWkgKyByYWRpdXMpICogbiArIChqICsgcmFkaXVzKV0gPSB2YWx1ZTtcblx0XHRcdGtlcm5lbFsoLWkgKyByYWRpdXMpICogbiArICgtaiArIHJhZGl1cyldID0gdmFsdWU7XG5cdFx0XHRrZXJuZWxbKGogKyByYWRpdXMpICogbiArIChpICsgcmFkaXVzKV0gPSB2YWx1ZTtcblx0XHRcdGtlcm5lbFsoaiArIHJhZGl1cykgKiBuICsgKC1pICsgcmFkaXVzKV0gPSB2YWx1ZTtcblx0XHRcdGtlcm5lbFsoLWogKyByYWRpdXMpICogbiArIChpICsgcmFkaXVzKV0gPSB2YWx1ZTtcblx0XHRcdGtlcm5lbFsoLWogKyByYWRpdXMpICogbiArICgtaSArIHJhZGl1cyldID0gdmFsdWU7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBrZXJuZWw7XG59XG5cbmZ1bmN0aW9uIGdldFNpZ21hS2VybmVsKHNpZ21hKSB7XG5cdGlmIChzaWdtYSA8PSAwKSB7XG5cdFx0dGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1NpZ21hIHNob3VsZCBiZSBncmF0ZXIgdGhhbiAwJyk7XG5cdH1cblx0bGV0IHNpZ21hMiA9IDIgKiAoc2lnbWEgKiBzaWdtYSk7IC8vMipzaWdtYV4yXG5cdGxldCBQSTJzaWdtYTIgPSBNYXRoLlBJICogc2lnbWEyOyAvLzIqUEkqc2lnbWFeMlxuXHRsZXQgdmFsdWUgPSAxIC8gUEkyc2lnbWEyO1xuXHRsZXQgc3VtID0gdmFsdWU7XG5cdGxldCBuZWlnaGJvcnMgPSAwO1xuXG5cdHdoaWxlIChzdW0gPCAwLjk5KSB7XG5cdFx0bmVpZ2hib3JzKys7XG5cdFx0dmFsdWUgPSBNYXRoLmV4cCgtKG5laWdoYm9ycyAqIG5laWdoYm9ycykgLyBzaWdtYTIpIC8gUEkyc2lnbWEyO1xuXHRcdHN1bSArPSA0ICogdmFsdWU7XG5cdFx0Zm9yIChsZXQgaSA9IDE7IGkgPCBuZWlnaGJvcnM7IGkrKykge1xuXHRcdFx0dmFsdWUgPSBNYXRoLmV4cCgtKChpICogaSkgKyAobmVpZ2hib3JzICogbmVpZ2hib3JzKSkgLyBzaWdtYTIpIC8gUEkyc2lnbWEyO1xuXHRcdFx0c3VtICs9IDggKiB2YWx1ZTtcblx0XHR9XG5cdFx0dmFsdWUgPSA0ICogTWF0aC5leHAoLSgyICogbmVpZ2hib3JzICogbmVpZ2hib3JzKSAvIHNpZ21hMikgLyBQSTJzaWdtYTI7XG5cdFx0c3VtICs9ICB2YWx1ZTtcblx0fVxuXG5cdC8vIFdoYXQgZG9lcyB0aGlzIGNhc2UgbWVhbiA/XG5cdGlmIChzdW0gPiAxKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKCd1bmV4cGVjdGVkIHN1bSBvdmVyIDEnKTtcblx0fVxuXG5cdHJldHVybiBnZXRLZXJuZWwobmVpZ2hib3JzLCBzaWdtYSk7XG59XG4iLCJpbXBvcnQge0tlcm5lbFJpZGdlUmVncmVzc2lvbn0gZnJvbSAnbWwtcmVncmVzc2lvbic7XG5pbXBvcnQgSW1hZ2UgZnJvbSAnLi4vaW1hZ2UnO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRCYWNrZ3JvdW5kKGNvb3JkaW5hdGVzLCB2YWx1ZXMsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBtb2RlbCA9IG5ldyBLZXJuZWxSaWRnZVJlZ3Jlc3Npb24oY29vcmRpbmF0ZXMsIHZhbHVlcywgb3B0aW9ucyk7XG4gICAgY29uc3QgYWxsQ29vcmRpbmF0ZXMgPSBuZXcgQXJyYXkodGhpcy5zaXplKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMud2lkdGg7IGkrKykge1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHRoaXMuaGVpZ2h0OyBqKyspIHtcbiAgICAgICAgICAgIGFsbENvb3JkaW5hdGVzW2ogKiB0aGlzLndpZHRoICsgaV0gPSBbaSwgal07XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gbW9kZWwucHJlZGljdChhbGxDb29yZGluYXRlcyk7XG4gICAgY29uc3QgYmFja2dyb3VuZCA9IEltYWdlLmNyZWF0ZUZyb20odGhpcyk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnNpemU7IGkrKykge1xuICAgICAgICBiYWNrZ3JvdW5kLmRhdGFbaV0gPSBNYXRoLm1pbih0aGlzLm1heFZhbHVlLCBNYXRoLm1heCgwLCByZXN1bHRbaV1bMF0pKTtcbiAgICB9XG4gICAgcmV0dXJuIGJhY2tncm91bmQ7XG59XG4iLCJpbXBvcnQge3ZhbGlkYXRlQXJyYXlPZkNoYW5uZWxzfSBmcm9tICcuLi8uLi91dGlsL2NoYW5uZWwnO1xuaW1wb3J0IEltYWdlIGZyb20gJy4uL2ltYWdlJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gaHlwb3RlbnVzZShvdGhlckltYWdlLCB7Yml0RGVwdGgsIGNoYW5uZWxzfSA9IHt9KSB7XG4gICAgdGhpcy5jaGVja1Byb2Nlc3NhYmxlKCdoeXBvdGVudXNlJywge1xuICAgICAgICBiaXREZXB0aDogWzgsIDE2LCAzMl1cbiAgICB9KTtcbiAgICBpZiAodGhpcy53aWR0aCAhPT0gb3RoZXJJbWFnZS53aWR0aCB8fCB0aGlzLmhlaWdodCAhPT0gb3RoZXJJbWFnZS5oZWlnaHQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdoeXBvdGVudXNlOiBib3RoIGltYWdlcyBtdXN0IGhhdmUgdGhlIHNhbWUgc2l6ZScpO1xuICAgIH1cbiAgICBpZiAodGhpcy5hbHBoYSAhPT0gb3RoZXJJbWFnZS5hbHBoYSB8fCB0aGlzLmJpdERlcHRoICE9PSBvdGhlckltYWdlLmJpdERlcHRoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaHlwb3RlbnVzZTogYm90aCBpbWFnZXMgbXVzdCBoYXZlIHRoZSBzYW1lIGFscGhhIGFuZCBiaXREZXB0aCcpO1xuICAgIH1cbiAgICBpZiAodGhpcy5jaGFubmVscyAhPT0gb3RoZXJJbWFnZS5jaGFubmVscykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2h5cG90ZW51c2U6IGJvdGggaW1hZ2VzIG11c3QgaGF2ZSB0aGUgc2FtZSBudW1iZXIgb2YgY2hhbm5lbHMnKTtcbiAgICB9XG5cbiAgICBsZXQgbmV3SW1hZ2UgPSBJbWFnZS5jcmVhdGVGcm9tKHRoaXMsIHtiaXREZXB0aDpiaXREZXB0aH0pO1xuXG4gICAgY2hhbm5lbHMgPSB2YWxpZGF0ZUFycmF5T2ZDaGFubmVscyh0aGlzLCB7Y2hhbm5lbHM6Y2hhbm5lbHN9KTtcblxuICAgIGxldCBjbGFtcGVkID0gbmV3SW1hZ2UuaXNDbGFtcGVkO1xuXG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCBjaGFubmVscy5sZW5ndGg7IGorKykge1xuICAgICAgICBsZXQgYyA9IGNoYW5uZWxzW2pdO1xuICAgICAgICBmb3IgKGxldCBpID0gYzsgaSA8IHRoaXMuZGF0YS5sZW5ndGg7IGkgKz0gdGhpcy5jaGFubmVscykge1xuICAgICAgICAgICAgbGV0IHZhbHVlID0gTWF0aC5zcXJ0KHRoaXMuZGF0YVtpXSAqIHRoaXMuZGF0YVtpXSArIG90aGVySW1hZ2UuZGF0YVtpXSAqIG90aGVySW1hZ2UuZGF0YVtpXSk7XG4gICAgICAgICAgICBpZiAoY2xhbXBlZCkgeyAvLyB3ZSBjYWxjdWxhdGUgdGhlIGNsYW1wZWQgcmVzdWx0XG4gICAgICAgICAgICAgICAgbmV3SW1hZ2UuZGF0YVtpXSA9IE1hdGgubWluKE1hdGgubWF4KE1hdGgucm91bmQodmFsdWUpLDApLG5ld0ltYWdlLm1heFZhbHVlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbmV3SW1hZ2UuZGF0YVtpXSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ld0ltYWdlO1xufVxuIiwiLy8gd2UgdHJ5IHRoZSBmYXN0ZXIgbWV0aG9kc1xuXG5pbXBvcnQge3ZhbGlkYXRlQXJyYXlPZkNoYW5uZWxzfSBmcm9tICcuLi8uLi91dGlsL2NoYW5uZWwnO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBpbnZlcnQoe2NoYW5uZWxzfSA9IHt9KSB7XG4gICAgdGhpcy5jaGVja1Byb2Nlc3NhYmxlKCdpbnZlcnRPbmVMb29wJywge1xuICAgICAgICBiaXREZXB0aDogWzEsIDgsIDE2XVxuICAgIH0pO1xuXG4gICAgaWYgKHRoaXMuYml0RGVwdGggPT09IDEpIHtcbiAgICAgICAgLy8gd2Ugc2ltcGx5IGludmVydCBhbGwgdGhlIGludGVnZXJzIHZhbHVlXG4gICAgICAgIC8vIHRoZXJlIGNvdWxkIGJlIGEgc21hbGwgbWlzdGFrZSBpZiB0aGUgbnVtYmVyIG9mIHBvaW50c1xuICAgICAgICAvLyBpcyBub3QgYSBtdWx0aXBsZSBvZiA4IGJ1dCBpdCBpcyBub3QgaW1wb3J0YW50XG4gICAgICAgIGxldCBkYXRhID0gdGhpcy5kYXRhO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGRhdGFbaV0gPSB+ZGF0YVtpXTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGNoYW5uZWxzID0gdmFsaWRhdGVBcnJheU9mQ2hhbm5lbHModGhpcywgY2hhbm5lbHMsIHRydWUpO1xuXG4gICAgICAgIGxldCBkYXRhID0gdGhpcy5kYXRhO1xuXG4gICAgICAgIC8vIGZvciAobGV0IGogb2YgY2hhbm5lbHMpIHsgV09VTEQgU0xPVyBETyBPRiBBIEZBQ1RPUiAxMCAhXG5cbiAgICAgICAgZm9yIChsZXQgYyA9IDA7IGMgPCBjaGFubmVscy5sZW5ndGg7IGMrKykge1xuICAgICAgICAgICAgbGV0IGogPSBjaGFubmVsc1tjXTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSBqOyBpIDwgZGF0YS5sZW5ndGg7IGkgKz0gdGhpcy5jaGFubmVscykge1xuICAgICAgICAgICAgICAgIGRhdGFbaV0gPSB0aGlzLm1heFZhbHVlIC0gZGF0YVtpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbiIsIi8vIHRoaXMgY29kZSBnaXZlcyB0aGUgc2FtZSByZXN1bHQgYXMgaW52ZXJ0KClcbi8vIGJ1dCBpcyBiYXNlZCBvbiBhIG1hdHJpeCBvZiBwaXhlbHNcbi8vIG1heSBiZSBlYXNpZXIgdG8gaW1wbGVtZW50IHNvbWUgYWxnb3JpdGhtXG4vLyBidXQgaXQgd2lsbCBsaWtlbHkgYmUgbXVjaCBzbG93ZXJcblxuLy8gdGhpcyBtZXRob2QgaXMgNTAgdGltZXMgU0xPV0VSIHRoYW4gaW52ZXJ0ICEhISEhIVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBpbnZlcnRBcHBseSgpIHtcblxuXG5cbiAgICBpZiAodGhpcy5iaXREZXB0aCA9PT0gMSkge1xuICAgICAgICAvLyB3ZSBzaW1wbHkgaW52ZXJ0IGFsbCB0aGUgaW50ZWdlcnMgdmFsdWVcbiAgICAgICAgLy8gdGhlcmUgY291bGQgYmUgYSBzbWFsbCBtaXN0YWtlIGlmIHRoZSBudW1iZXIgb2YgcG9pbnRzXG4gICAgICAgIC8vIGlzIG5vdCBhIG11bHRpcGxlIG9mIDggYnV0IGl0IGlzIG5vdCBpbXBvcnRhbnRcbiAgICAgICAgbGV0IGRhdGEgPSB0aGlzLmRhdGE7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgZGF0YVtpXSA9IH5kYXRhW2ldO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5jaGVja1Byb2Nlc3NhYmxlKCdpbnZlcnRBcHBseScsIHtcbiAgICAgICAgICAgIGJpdERlcHRoOiBbOCwgMTZdXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmFwcGx5KGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCB0aGlzLmNvbXBvbmVudHM7IGsrKykge1xuICAgICAgICAgICAgICAgIHRoaXMuZGF0YVtpbmRleCArIGtdID0gdGhpcy5tYXhWYWx1ZSAtIHRoaXMuZGF0YVtpbmRleCArIGtdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBpbnZlcnRCaW5hcnlMb29wKCkge1xuICAgIHRoaXMuY2hlY2tQcm9jZXNzYWJsZSgnaW52ZXJ0QmluYXJ5TG9vcCcsIHtcbiAgICAgICAgYml0RGVwdGg6IFsxXVxuICAgIH0pO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnNpemU7IGkrKykge1xuICAgICAgICB0aGlzLnRvZ2dsZUJpdChpKTtcbiAgICB9XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBpbnZlcnQoKSB7XG4gICAgdGhpcy5jaGVja1Byb2Nlc3NhYmxlKCdpbnZlcnQnLCB7XG4gICAgICAgIGJpdERlcHRoOiBbMSwgOCwgMTZdXG4gICAgfSk7XG5cbiAgICBpZiAodGhpcy5iaXREZXB0aCA9PT0gMSkge1xuICAgICAgICAvLyB3ZSBzaW1wbHkgaW52ZXJ0IGFsbCB0aGUgaW50ZWdlcnMgdmFsdWVcbiAgICAgICAgLy8gdGhlcmUgY291bGQgYmUgYSBzbWFsbCBtaXN0YWtlIGlmIHRoZSBudW1iZXIgb2YgcG9pbnRzXG4gICAgICAgIC8vIGlzIG5vdCBhIG11bHRpcGxlIG9mIDggYnV0IGl0IGlzIG5vdCBpbXBvcnRhbnRcbiAgICAgICAgbGV0IGRhdGEgPSB0aGlzLmRhdGE7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgZGF0YVtpXSA9IH5kYXRhW2ldO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCB0aGlzLndpZHRoOyB4KyspIHtcbiAgICAgICAgICAgIGZvciAobGV0IHkgPSAwOyB5IDwgdGhpcy5oZWlnaHQ7IHkrKykge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgdGhpcy5jb21wb25lbnRzOyBrKyspIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHZhbHVlID0gdGhpcy5nZXRWYWx1ZVhZKHgsIHksIGspO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFZhbHVlWFkoeCwgeSwgaywgdGhpcy5tYXhWYWx1ZSAtIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBpbnZlcnRJdGVyYXRvcigpIHtcbiAgICB0aGlzLmNoZWNrUHJvY2Vzc2FibGUoJ2ludmVydCcsIHtcbiAgICAgICAgYml0RGVwdGg6IFsxLCA4LCAxNl1cbiAgICB9KTtcblxuICAgIGlmICh0aGlzLmJpdERlcHRoID09PSAxKSB7XG4gICAgICAgIC8vIHdlIHNpbXBseSBpbnZlcnQgYWxsIHRoZSBpbnRlZ2VycyB2YWx1ZVxuICAgICAgICAvLyB0aGVyZSBjb3VsZCBiZSBhIHNtYWxsIG1pc3Rha2UgaWYgdGhlIG51bWJlciBvZiBwb2ludHNcbiAgICAgICAgLy8gaXMgbm90IGEgbXVsdGlwbGUgb2YgOCBidXQgaXQgaXMgbm90IGltcG9ydGFudFxuICAgICAgICBsZXQgZGF0YSA9IHRoaXMuZGF0YTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBkYXRhW2ldID0gfmRhdGFbaV07XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKGxldCB7aW5kZXgsIHBpeGVsfSBvZiB0aGlzLnBpeGVscygpKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IHRoaXMuY29tcG9uZW50czsgaysrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRWYWx1ZShpbmRleCwgaywgdGhpcy5tYXhWYWx1ZSAtIHBpeGVsW2tdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGludmVydE9uZUxvb3AoKSB7XG4gICAgdGhpcy5jaGVja1Byb2Nlc3NhYmxlKCdpbnZlcnRPbmVMb29wJywge1xuICAgICAgICBiaXREZXB0aDogWzgsIDE2XVxuICAgIH0pO1xuXG4gICAgbGV0IGRhdGEgPSB0aGlzLmRhdGE7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSArPSB0aGlzLmNoYW5uZWxzKSB7XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdGhpcy5jb21wb25lbnRzOyBqKyspIHtcbiAgICAgICAgICAgIGRhdGFbaSArIGpdID0gdGhpcy5tYXhWYWx1ZSAtIGRhdGFbaSArIGpdO1xuICAgICAgICB9XG4gICAgfVxufVxuIiwiLy8gdGhpcyBjb2RlIGdpdmVzIHRoZSBzYW1lIHJlc3VsdCBhcyBpbnZlcnQoKVxuLy8gYnV0IGlzIGJhc2VkIG9uIGEgbWF0cml4IG9mIHBpeGVsc1xuLy8gbWF5IGJlIGVhc2llciB0byBpbXBsZW1lbnQgc29tZSBhbGdvcml0aG1cbi8vIGJ1dCBpdCB3aWxsIGxpa2VseSBiZSBtdWNoIHNsb3dlclxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBpbnZlcnRQaXhlbCgpIHtcbiAgICB0aGlzLmNoZWNrUHJvY2Vzc2FibGUoJ2ludmVydFBpeGVsJywge1xuICAgICAgICBiaXREZXB0aDogWzgsIDE2XVxuICAgIH0pO1xuXG5cbiAgICBmb3IgKGxldCB4ID0gMDsgeCA8IHRoaXMud2lkdGg7IHgrKykge1xuICAgICAgICBmb3IgKGxldCB5ID0gMDsgeSA8IHRoaXMuaGVpZ2h0OyB5KyspIHtcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IHRoaXMuZ2V0UGl4ZWxYWSh4LCB5KTtcbiAgICAgICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgdGhpcy5jb21wb25lbnRzOyBrKyspIHtcbiAgICAgICAgICAgICAgICB2YWx1ZVtrXSA9IHRoaXMubWF4VmFsdWUgLSB2YWx1ZVtrXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc2V0UGl4ZWxYWSh4LCB5LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbn1cbiIsImltcG9ydCBuZXdBcnJheSBmcm9tICduZXctYXJyYXknO1xuXG5pbXBvcnQge3ZhbGlkYXRlQXJyYXlPZkNoYW5uZWxzfSBmcm9tICcuLi8uLi91dGlsL2NoYW5uZWwnO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBsZXZlbCh7XG4gICAgYWxnb3JpdGhtID0gJ3JhbmdlJyxcbiAgICBjaGFubmVscyxcbiAgICBtaW4gPSB0aGlzLm1pbixcbiAgICBtYXggPSB0aGlzLm1heFxuICAgIH0gPSB7fSkge1xuICAgIHRoaXMuY2hlY2tQcm9jZXNzYWJsZSgnbGV2ZWwnLCB7XG4gICAgICAgIGJpdERlcHRoOiBbOCwgMTZdXG4gICAgfSk7XG5cbiAgICBjaGFubmVscyA9IHZhbGlkYXRlQXJyYXlPZkNoYW5uZWxzKHRoaXMsIHtjaGFubmVsczpjaGFubmVsc30pO1xuXG4gICAgc3dpdGNoIChhbGdvcml0aG0pIHtcblxuICAgICAgICBjYXNlICdyYW5nZSc6XG4gICAgICAgICAgICBpZiAobWluIDwgMCkgbWluID0gMDtcbiAgICAgICAgICAgIGlmIChtYXggPiB0aGlzLm1heFZhbHVlKSBtYXggPSB0aGlzLm1heFZhbHVlO1xuXG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkobWluKSkgbWluID0gbmV3QXJyYXkoY2hhbm5lbHMubGVuZ3RoLCBtaW4pO1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG1heCkpIG1heCA9IG5ld0FycmF5KGNoYW5uZWxzLmxlbmd0aCwgbWF4KTtcblxuICAgICAgICAgICAgcHJvY2Vzc0ltYWdlKHRoaXMsIG1pbiwgbWF4LCBjaGFubmVscyk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdsZXZlbDogYWxnb3JpdGhtIG5vdCBpbXBsZW1lbnQ6ICcgKyBhbGdvcml0aG0pO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gcHJvY2Vzc0ltYWdlKGltYWdlLCBtaW4sIG1heCwgY2hhbm5lbHMpIHtcbiAgICBsZXQgZGVsdGEgPSAxZS01OyAvLyBzb3JyeSBubyBiZXR0ZXIgdmFsdWUgdGhhdCB0aGlzIFwiYmVzdCBndWVzc1wiXG4gICAgbGV0IGZhY3RvciA9IG5ldyBBcnJheShpbWFnZS5jaGFubmVscyk7XG5cbiAgICBmb3IgKGxldCBjIG9mIGNoYW5uZWxzKSB7XG4gICAgICAgIGlmIChtaW5bY10gPT09IDAgJiYgbWF4W2NdID09PSBpbWFnZS5tYXhWYWx1ZSkge1xuICAgICAgICAgICAgZmFjdG9yW2NdID0gMDtcbiAgICAgICAgfSBlbHNlIGlmIChtYXhbY10gPT09IG1pbltjXSkge1xuICAgICAgICAgICAgZmFjdG9yW2NdID0gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZhY3RvcltjXSA9IChpbWFnZS5tYXhWYWx1ZSArIDEgLSBkZWx0YSkgLyAobWF4W2NdIC0gbWluW2NdKTtcbiAgICAgICAgfVxuICAgICAgICBtaW5bY10gKz0gKCgwLjUgLSBkZWx0YSAvIDIpIC8gZmFjdG9yW2NdKTtcbiAgICB9XG5cbiAgICAvKlxuICAgICBOb3RlIG9uIGJvcmRlciBlZmZlY3RcbiAgICAgRm9yIDggYml0cyBpbWFnZXMgd2Ugc2hvdWxkIGNhbGN1bGF0ZSBmb3IgdGhlIHNwYWNlIGJldHdlZW4gLTAuNSBhbmQgMjU1LjVcbiAgICAgc28gdGhhdCBhZnRlciByb25kaW5nIHRoZSBmaXJzdCBhbmQgbGFzdCBwb2ludHMgc3RpbGwgaGF2ZSB0aGUgc2FtZSBwb3B1bGF0aW9uXG4gICAgIEJ1dCBkb2luZyB0aGlzIHdlIG5lZWQgdG8gZGVhbCB3aXRoIE1hdGgucm91bmQgdGhhdCBnaXZlcyAyNTYgaWYgdGhlIHZhbHVlIGlzIDI1NS41XG4gICAgICovXG5cblxuICAgIGZvciAobGV0IGogPSAwOyBqIDwgY2hhbm5lbHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgbGV0IGMgPSBjaGFubmVsc1tqXTtcbiAgICAgICAgaWYgKGZhY3RvcltjXSAhPT0gMCkge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbWFnZS5kYXRhLmxlbmd0aDsgaSArPSBpbWFnZS5jaGFubmVscykge1xuICAgICAgICAgICAgICAgIGltYWdlLmRhdGFbaSArIGNdID0gTWF0aC5taW4oTWF0aC5tYXgoMCwgKChpbWFnZS5kYXRhW2kgKyBjXSAtIG1pbltjXSkgKiBmYWN0b3JbY10gKyAwLjUpIHwgMCksIGltYWdlLm1heFZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cblxuXG4iLCIvKipcbiAqIENyZWF0ZWQgYnkgQ3Jpc3RpYW4gb24gMTgvMDcvMjAxNS5cbiAqL1xuaW1wb3J0IHt2YWxpZGF0ZUFycmF5T2ZDaGFubmVsc30gZnJvbSAnLi4vLi4vdXRpbC9jaGFubmVsJztcbmltcG9ydCBJbWFnZSBmcm9tICcuLi9pbWFnZSc7XG5cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gbWVkaWFuRmlsdGVyKHJhZGl1cywgY2hhbm5lbHMsIGJvcmRlciA9ICdjb3B5Jykge1xuICAgIHRoaXMuY2hlY2tQcm9jZXNzYWJsZSgnbWVkaWFuRmlsdGVyJywge1xuICAgICAgICBiaXREZXB0aDpbOCwxNl1cbiAgICB9KTtcblxuICAgIGlmIChyYWRpdXMgPCAxKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignS2VybmVsIHJhZGl1cyBzaG91bGQgYmUgZ3JlYXRlciB0aGFuIDAnKTtcbiAgICB9XG5cbiAgICBjaGFubmVscyA9IHZhbGlkYXRlQXJyYXlPZkNoYW5uZWxzKHRoaXMsIGNoYW5uZWxzLCB0cnVlKTtcblxuICAgIGxldCBrV2lkdGggPSByYWRpdXM7XG4gICAgbGV0IGtIZWlnaHQgPSByYWRpdXM7XG4gICAgbGV0IG5ld0ltYWdlID0gSW1hZ2UuY3JlYXRlRnJvbSh0aGlzKTtcblxuICAgIGxldCBzaXplID0gKGtXaWR0aCAqIDIgKyAxKSAqIChrSGVpZ2h0ICogMiArIDEpO1xuICAgIGxldCBtaWRkbGUgPSBNYXRoLmZsb29yKHNpemUgLyAyKTtcbiAgICBsZXQga2VybmVsID0gbmV3IEFycmF5KHNpemUpO1xuXG4gICAgZm9yIChsZXQgY2hhbm5lbCA9IDA7IGNoYW5uZWwgPCBjaGFubmVscy5sZW5ndGg7IGNoYW5uZWwrKykge1xuICAgICAgICBsZXQgYyA9IGNoYW5uZWxzW2NoYW5uZWxdO1xuICAgICAgICBmb3IgKGxldCB5ID0ga0hlaWdodDsgeSA8IHRoaXMuaGVpZ2h0IC0ga0hlaWdodDsgeSsrKSB7XG4gICAgICAgICAgICBmb3IgKGxldCB4ID0ga1dpZHRoOyB4IDwgdGhpcy53aWR0aCAtIGtXaWR0aDsgeCsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IG4gPSAwO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAta0hlaWdodDsgaiA8PSBrSGVpZ2h0OyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IC1rV2lkdGg7IGkgPD0ga1dpZHRoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBpbmRleCA9ICgoeSArIGopICogdGhpcy53aWR0aCArIHggKyBpKSAqIHRoaXMuY2hhbm5lbHMgKyBjO1xuICAgICAgICAgICAgICAgICAgICAgICAga2VybmVsW24rK10gPSB0aGlzLmRhdGFbaW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBpbmRleCA9ICh5ICogdGhpcy53aWR0aCArIHgpICogdGhpcy5jaGFubmVscyArIGM7XG4gICAgICAgICAgICAgICAgbGV0IG5ld1ZhbHVlID0ga2VybmVsLnNvcnQoKVttaWRkbGVdO1xuICAgICAgICAgICAgICAgIG5ld0ltYWdlLmRhdGFbaW5kZXhdID0gbmV3VmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5hbHBoYSAmJiBjaGFubmVscy5pbmRleE9mKHRoaXMuY2hhbm5lbHMpID09PSAtMSkge1xuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5jb21wb25lbnRzOyBpIDwgdGhpcy5kYXRhLmxlbmd0aDsgaSA9IGkgKyB0aGlzLmNoYW5uZWxzKSB7XG4gICAgICAgICAgICBuZXdJbWFnZS5kYXRhW2ldID0gdGhpcy5kYXRhW2ldO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbmV3SW1hZ2Uuc2V0Qm9yZGVyKHtzaXplOltrV2lkdGgsIGtIZWlnaHRdLCBhbGdvcml0aG06IGJvcmRlcn0pO1xuXG4gICAgcmV0dXJuIG5ld0ltYWdlO1xuXG59Ly9FbmQgbWVkaWFuRmlsdGVyIGZ1bmN0aW9uXG5cbiIsImltcG9ydCB7dmFsaWRhdGVBcnJheU9mQ2hhbm5lbHN9IGZyb20gJy4uLy4uL3V0aWwvY2hhbm5lbCc7XG5pbXBvcnQgSW1hZ2UgZnJvbSAnLi4vaW1hZ2UnO1xuaW1wb3J0IHtjaGVja051bWJlckFycmF5fSBmcm9tICcuLi8uLi91dGlsL3ZhbHVlJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gYWRkKHZhbHVlLCB7Y2hhbm5lbHN9ID0ge30pIHtcbiAgICB0aGlzLmNoZWNrUHJvY2Vzc2FibGUoJ211bHRpcGx5Jywge1xuICAgICAgICBiaXREZXB0aDogWzgsIDE2XVxuICAgIH0pO1xuICAgIGlmICh2YWx1ZSA8PSAwKSB0aHJvdyBuZXcgRXJyb3IoJ211bHRpcGx5OiB0aGUgdmFsdWUgbXVzdCBiZSBncmVhdGVyIHRoYW4gMCcpO1xuXG4gICAgY2hhbm5lbHMgPSB2YWxpZGF0ZUFycmF5T2ZDaGFubmVscyh0aGlzLCB7Y2hhbm5lbHM6Y2hhbm5lbHN9KTtcbiAgICB2YWx1ZSA9IGNoZWNrTnVtYmVyQXJyYXkodmFsdWUpO1xuXG4gICAgaWYgKCFpc05hTih2YWx1ZSkpIHtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBjaGFubmVscy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgbGV0IGMgPSBjaGFubmVsc1tqXTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5kYXRhLmxlbmd0aDsgaSArPSB0aGlzLmNoYW5uZWxzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kYXRhW2kgKyBjXSA9IE1hdGgubWluKHRoaXMubWF4VmFsdWUsICh0aGlzLmRhdGFbaSArIGNdICogdmFsdWUpID4+IDApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHRoaXMuZGF0YS5sZW5ndGggIT09IHZhbHVlLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtdWx0aXBseTogdGhlIGRhdGEgc2l6ZSBpcyBkaWZmZXJlbnQnKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGNoYW5uZWxzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBsZXQgYyA9IGNoYW5uZWxzW2pdO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmRhdGEubGVuZ3RoOyBpICs9IHRoaXMuY2hhbm5lbHMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRhdGFbaSArIGNdID0gTWF0aC5tYXgoMCwgTWF0aC5taW4odGhpcy5tYXhWYWx1ZSwgKHRoaXMuZGF0YVtpICsgY10gKiB2YWx1ZVtpICsgY10pID4+IDApKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbiIsImltcG9ydCBJbWFnZSBmcm9tICcuLi9pbWFnZSc7XG5pbXBvcnQgY29udm9sdXRpb24gZnJvbSAnLi4vb3BlcmF0b3IvY29udm9sdXRpb24nO1xuaW1wb3J0IHtHUkFESUVOVF9YLCBHUkFESUVOVF9ZfSBmcm9tICcuLi8uLi91dGlsL2tlcm5lbHMnO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBzb2JlbEZpbHRlcih7XG5cdGtlcm5lbFggPSBHUkFESUVOVF9YLFxuXHRrZXJuZWxZID0gR1JBRElFTlRfWSxcblx0Ym9yZGVyID0gJ2NvcHknLFxuXHRjaGFubmVsc1xuXHR9ID0ge30pIHtcblxuXHR0aGlzLmNoZWNrUHJvY2Vzc2FibGUoJ3NvYmVsRmlsdGVyJywge1xuXHRcdGJpdERlcHRoOiBbOCwgMTZdXG5cdH0pO1xuXG5cdGxldCBnWCA9IGNvbnZvbHV0aW9uLmNhbGwodGhpcywga2VybmVsWCwge1xuXHRcdGNoYW5uZWxzOiBjaGFubmVscyxcblx0XHRib3JkZXI6IGJvcmRlcixcblx0XHRiaXREZXB0aDogMzJcblx0fSk7XG5cblx0bGV0IGdZID0gY29udm9sdXRpb24uY2FsbCh0aGlzLCBrZXJuZWxZLCB7XG5cdFx0Y2hhbm5lbHM6IGNoYW5uZWxzLFxuXHRcdGJvcmRlcjogYm9yZGVyLFxuXHRcdGJpdERlcHRoOiAzMlxuXHR9KTtcblxuXHRyZXR1cm4gZ1guaHlwb3RlbnVzZShnWSwge2JpdERlcHRoOiB0aGlzLmJpdERlcHRoLCBjaGFubmVsczogY2hhbm5lbHN9KTtcbn1cbiIsImltcG9ydCB7dmFsaWRhdGVBcnJheU9mQ2hhbm5lbHN9IGZyb20gJy4uLy4uL3V0aWwvY2hhbm5lbCc7XG5pbXBvcnQgSW1hZ2UgZnJvbSAnLi4vaW1hZ2UnO1xuaW1wb3J0IHtjaGVja051bWJlckFycmF5fSBmcm9tICcuLi8uLi91dGlsL3ZhbHVlJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gc3VidHJhY3QodmFsdWUsIHtjaGFubmVsc30gPSB7fSkge1xuICAgIHRoaXMuY2hlY2tQcm9jZXNzYWJsZSgnc3VidHJhY3QnLCB7XG4gICAgICAgIGJpdERlcHRoOiBbOCwgMTZdXG4gICAgfSk7XG5cbiAgICBjaGFubmVscyA9IHZhbGlkYXRlQXJyYXlPZkNoYW5uZWxzKHRoaXMsIHtjaGFubmVsczpjaGFubmVsc30pO1xuICAgIHZhbHVlID0gY2hlY2tOdW1iZXJBcnJheSh2YWx1ZSk7XG5cbiAgICBpZiAoIWlzTmFOKHZhbHVlKSkge1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGNoYW5uZWxzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBsZXQgYyA9IGNoYW5uZWxzW2pdO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmRhdGEubGVuZ3RoOyBpICs9IHRoaXMuY2hhbm5lbHMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRhdGFbaSArIGNdID0gTWF0aC5tYXgoMCwgKHRoaXMuZGF0YVtpICsgY10gLSB2YWx1ZSkgPj4gMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodGhpcy5kYXRhLmxlbmd0aCAhPT0gdmFsdWUubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3N1YnN0cmFjdDogdGhlIGRhdGEgc2l6ZSBpcyBkaWZmZXJlbnQnKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGNoYW5uZWxzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBsZXQgYyA9IGNoYW5uZWxzW2pdO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmRhdGEubGVuZ3RoOyBpICs9IHRoaXMuY2hhbm5lbHMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRhdGFbaSArIGNdID0gTWF0aC5tYXgoMCwgTWF0aC5taW4odGhpcy5tYXhWYWx1ZSwgKHRoaXMuZGF0YVtpICsgY10gLSB2YWx1ZVtpICsgY10pID4+IDApKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbiIsImltcG9ydCB7Z2V0S2luZCwgY3JlYXRlUGl4ZWxBcnJheSwgZ2V0VGhlb3JldGljYWxQaXhlbEFycmF5U2l6ZX0gZnJvbSAnLi9raW5kJztcbmltcG9ydCB7UkdCQX0gZnJvbSAnLi9raW5kTmFtZXMnO1xuaW1wb3J0IHtJbWFnZURhdGEsIENhbnZhc30gZnJvbSAnLi9lbnZpcm9ubWVudCc7XG5pbXBvcnQgZXh0ZW5kIGZyb20gJy4vZXh0ZW5kJztcbmltcG9ydCBiaXRNZXRob2RzIGZyb20gJy4vYml0TWV0aG9kcyc7XG5pbXBvcnQge2NyZWF0ZVdyaXRlU3RyZWFtfSBmcm9tICdmcyc7XG5pbXBvcnQge1JHQn0gZnJvbSAnLi9tb2RlbC9tb2RlbCc7XG5pbXBvcnQgUk9JTWFuYWdlciBmcm9tICcuL3JvaS9tYW5hZ2VyJztcbmltcG9ydCB7Z2V0VHlwZSwgY2FuV3JpdGV9IGZyb20gJy4vbWVkaWFUeXBlcyc7XG5pbXBvcnQgZXh0ZW5kT2JqZWN0IGZyb20gJ2V4dGVuZCc7XG5pbXBvcnQge2xvYWRVUkx9IGZyb20gJy4vbG9hZCc7XG5pbXBvcnQgU3RhY2sgZnJvbSAnLi4vc3RhY2svc3RhY2snO1xuXG5sZXQgY29tcHV0ZWRQcm9wZXJ0eURlc2NyaXB0b3IgPSB7XG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGdldDogdW5kZWZpbmVkXG59O1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBJbWFnZSB7XG4gICAgY29uc3RydWN0b3Iod2lkdGgsIGhlaWdodCwgZGF0YSwgb3B0aW9ucykge1xuICAgICAgICBpZiAod2lkdGggPT09IHVuZGVmaW5lZCkgd2lkdGggPSAxO1xuICAgICAgICBpZiAoaGVpZ2h0ID09PSB1bmRlZmluZWQpIGhlaWdodCA9IDE7XG5cbiAgICAgICAgLy8gY29weSBhbm90aGVyIGltYWdlXG4gICAgICAgIGlmICh0eXBlb2Ygd2lkdGggPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBjb25zdCBvdGhlckltYWdlID0gd2lkdGg7XG4gICAgICAgICAgICBjb25zdCBjbG9uZURhdGEgPSBoZWlnaHQgPT09IHRydWU7XG4gICAgICAgICAgICB3aWR0aCA9IG90aGVySW1hZ2Uud2lkdGg7XG4gICAgICAgICAgICBoZWlnaHQgPSBvdGhlckltYWdlLmhlaWdodDtcbiAgICAgICAgICAgIGRhdGEgPSBjbG9uZURhdGEgPyBvdGhlckltYWdlLmRhdGEuc2xpY2UoKSA6IG90aGVySW1hZ2UuZGF0YTtcbiAgICAgICAgICAgIG9wdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgcG9zaXRpb246IG90aGVySW1hZ2UucG9zaXRpb24sXG4gICAgICAgICAgICAgICAgY29tcG9uZW50czogb3RoZXJJbWFnZS5jb21wb25lbnRzLFxuICAgICAgICAgICAgICAgIGFscGhhOiBvdGhlckltYWdlLmFscGhhLFxuICAgICAgICAgICAgICAgIGJpdERlcHRoOiBvdGhlckltYWdlLmJpdERlcHRoLFxuICAgICAgICAgICAgICAgIGNvbG9yTW9kZWw6IG90aGVySW1hZ2UuY29sb3JNb2RlbFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkYXRhICYmICFkYXRhLmxlbmd0aCkge1xuICAgICAgICAgICAgb3B0aW9ucyA9IGRhdGE7XG4gICAgICAgICAgICBkYXRhID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdW5kZWZpbmVkKSBvcHRpb25zID0ge307XG5cbiAgICAgICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgICAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcblxuICAgICAgICBpZiAodGhpcy53aWR0aCA8PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignd2lkdGggbXVzdCBiZSBncmVhdGVyIHRoYW4gMCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmhlaWdodCA8PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignaGVpZ2h0IG11c3QgYmUgZ3JlYXRlciB0aGFuIDAnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFdlIHdpbGwgc2V0IHRoZSBwYXJlbnQgaW1hZ2UgZm9yIHJlbGF0aXZlIHBvc2l0aW9uXG5cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdwYXJlbnQnLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnBhcmVudCA9IG9wdGlvbnMucGFyZW50O1xuICAgICAgICB0aGlzLnBvc2l0aW9uID0gb3B0aW9ucy5wb3NpdGlvbiB8fCBbMCwgMF07XG5cbiAgICAgICAgbGV0IHRoZUtpbmQ7XG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5raW5kID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGhlS2luZCA9IGdldEtpbmQob3B0aW9ucy5raW5kKTtcbiAgICAgICAgICAgIGlmICghdGhlS2luZCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ2ludmFsaWQgaW1hZ2Uga2luZDogJyArIG9wdGlvbnMua2luZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGVLaW5kID0gZ2V0S2luZChSR0JBKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBraW5kRGVmaW5pdGlvbiA9IGV4dGVuZE9iamVjdCh7fSwgdGhlS2luZCwgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMuY29tcG9uZW50cyA9IGtpbmREZWZpbml0aW9uLmNvbXBvbmVudHM7XG4gICAgICAgIHRoaXMuYWxwaGEgPSBraW5kRGVmaW5pdGlvbi5hbHBoYSArIDA7XG4gICAgICAgIHRoaXMuYml0RGVwdGggPSBraW5kRGVmaW5pdGlvbi5iaXREZXB0aDtcbiAgICAgICAgdGhpcy5jb2xvck1vZGVsID0ga2luZERlZmluaXRpb24uY29sb3JNb2RlbDtcblxuICAgICAgICB0aGlzLmNvbXB1dGVkID0gbnVsbDtcblxuICAgICAgICB0aGlzLmluaXRpYWxpemUoKTtcblxuICAgICAgICBpZiAoIWRhdGEpXG4gICAgICAgICAgICBjcmVhdGVQaXhlbEFycmF5KHRoaXMpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBsZW5ndGggPSBnZXRUaGVvcmV0aWNhbFBpeGVsQXJyYXlTaXplKHRoaXMpO1xuICAgICAgICAgICAgaWYgKGxlbmd0aCAhPT0gZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgaW5jb3JyZWN0IGRhdGEgc2l6ZS4gU2hvdWxkIGJlICR7bGVuZ3RofSBhbmQgZm91bmQgJHtkYXRhLmxlbmd0aH1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpbml0aWFsaXplKCkge1xuICAgICAgICB0aGlzLnNpemUgPSB0aGlzLndpZHRoICogdGhpcy5oZWlnaHQ7XG4gICAgICAgIHRoaXMuc2l6ZXMgPSBbdGhpcy53aWR0aCwgdGhpcy5oZWlnaHRdO1xuICAgICAgICB0aGlzLmNoYW5uZWxzID0gdGhpcy5jb21wb25lbnRzICsgdGhpcy5hbHBoYTtcbiAgICAgICAgaWYgKHRoaXMuYml0RGVwdGggPT09IDMyKSB7XG4gICAgICAgICAgICB0aGlzLm1heFZhbHVlID0gTnVtYmVyLk1BWF9WQUxVRTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubWF4VmFsdWUgPSBNYXRoLnBvdygyLCB0aGlzLmJpdERlcHRoKSAtIDE7ICAvLyB3ZSBtYXkgbm90IHVzZSAxIDw8IHRoaXMuYml0RGVwdGggZm9yIDMyIGJpdHMgaW1hZ2VzXG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm11bHRpcGxpZXJYID0gdGhpcy5jaGFubmVscztcbiAgICAgICAgdGhpcy5tdWx0aXBsaWVyWSA9IHRoaXMuY2hhbm5lbHMgKiB0aGlzLndpZHRoO1xuICAgICAgICB0aGlzLmlzQ2xhbXBlZCA9IHRoaXMuYml0RGVwdGggPCAzMjtcbiAgICAgICAgdGhpcy5ib3JkZXJTaXplcyA9IFswLDBdOyAvLyB3aGVuIGEgZmlsdGVyIGNyZWF0ZSBhIGJvcmRlciBpdCBtYXkgaGF2ZSBpbXBhY3Qgb24gZnV0dXJlIHByb2Nlc3NpbmcgbGlrZSBST0lcbiAgICB9XG5cblxuICAgIHN0YXRpYyBsb2FkKHVybCkge1xuICAgICAgICByZXR1cm4gbG9hZFVSTCh1cmwpO1xuICAgIH1cblxuICAgIHN0YXRpYyBleHRlbmRNZXRob2QobmFtZSwgbWV0aG9kLCB7aW5QbGFjZSA9IGZhbHNlLCByZXR1cm5UaGlzID0gdHJ1ZSwgcGFydGlhbEFyZ3MgPSBbXSwgc3RhY2sgPSBmYWxzZX0gPSB7fSkge1xuICAgICAgICBpZiAoaW5QbGFjZSkge1xuICAgICAgICAgICAgSW1hZ2UucHJvdG90eXBlW25hbWVdID0gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgICAgICAgICAgICAvLyByZW1vdmUgY29tcHV0ZWQgcHJvcGVydGllc1xuICAgICAgICAgICAgICAgIHRoaXMuY29tcHV0ZWQgPSBudWxsO1xuICAgICAgICAgICAgICAgIGxldCByZXN1bHQgPSBtZXRob2QuYXBwbHkodGhpcywgWy4uLnBhcnRpYWxBcmdzLCAuLi5hcmdzXSk7XG4gICAgICAgICAgICAgICAgaWYgKHJldHVyblRoaXMpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKHN0YWNrKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RhY2tOYW1lID0gdHlwZW9mIHN0YWNrID09PSAnc3RyaW5nJyA/IHN0YWNrIDogbmFtZTtcbiAgICAgICAgICAgICAgICBpZiAocmV0dXJuVGhpcykge1xuICAgICAgICAgICAgICAgICAgICBTdGFjay5wcm90b3R5cGVbc3RhY2tOYW1lXSA9IGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpbWFnZSBvZiB0aGlzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2VbbmFtZV0oLi4uYXJncyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBTdGFjay5wcm90b3R5cGVbc3RhY2tOYW1lXSA9IGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgcmVzdWx0ID0gbmV3IFN0YWNrKHRoaXMubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFtpXSA9IHRoaXNbaV1bbmFtZV0oLi4uYXJncyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIEltYWdlLnByb3RvdHlwZVtuYW1lXSA9IGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1ldGhvZC5hcHBseSh0aGlzLCBbLi4ucGFydGlhbEFyZ3MsIC4uLmFyZ3NdKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoc3RhY2spIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzdGFja05hbWUgPSB0eXBlb2Ygc3RhY2sgPT09ICdzdHJpbmcnID8gc3RhY2sgOiBuYW1lO1xuICAgICAgICAgICAgICAgIFN0YWNrLnByb3RvdHlwZVtzdGFja05hbWVdID0gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHJlc3VsdCA9IG5ldyBTdGFjayh0aGlzLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2ldID0gdGhpc1tpXVtuYW1lXSguLi5hcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEltYWdlO1xuICAgIH1cblxuICAgIHN0YXRpYyBleHRlbmRQcm9wZXJ0eShuYW1lLCBtZXRob2QsIHtwYXJ0aWFsQXJncyA9IFtdfSA9IHt9KSB7XG4gICAgICAgIGNvbXB1dGVkUHJvcGVydHlEZXNjcmlwdG9yLmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbXB1dGVkID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb21wdXRlZCA9IHt9O1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmNvbXB1dGVkLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29tcHV0ZWRbbmFtZV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gbWV0aG9kLmFwcGx5KHRoaXMsIHBhcnRpYWxBcmdzKTtcbiAgICAgICAgICAgIHRoaXMuY29tcHV0ZWRbbmFtZV0gPSByZXN1bHQ7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9O1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSW1hZ2UucHJvdG90eXBlLCBuYW1lLCBjb21wdXRlZFByb3BlcnR5RGVzY3JpcHRvcik7XG4gICAgICAgIHJldHVybiBJbWFnZTtcbiAgICB9XG5cblxuICAgIHN0YXRpYyBjcmVhdGVGcm9tKG90aGVyLCBvcHRpb25zKSB7XG4gICAgICAgIGxldCBuZXdPcHRpb25zID0ge1xuICAgICAgICAgICAgd2lkdGg6IG90aGVyLndpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0OiBvdGhlci5oZWlnaHQsXG4gICAgICAgICAgICBwb3NpdGlvbjogb3RoZXIucG9zaXRpb24sXG4gICAgICAgICAgICBjb21wb25lbnRzOiBvdGhlci5jb21wb25lbnRzLFxuICAgICAgICAgICAgYWxwaGE6IG90aGVyLmFscGhhLFxuICAgICAgICAgICAgY29sb3JNb2RlbDogb3RoZXIuY29sb3JNb2RlbCxcbiAgICAgICAgICAgIGJpdERlcHRoOiBvdGhlci5iaXREZXB0aCxcbiAgICAgICAgICAgIHBhcmVudDogb3RoZXJcbiAgICAgICAgfTtcbiAgICAgICAgZXh0ZW5kT2JqZWN0KG5ld09wdGlvbnMsIG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gbmV3IEltYWdlKG5ld09wdGlvbnMud2lkdGgsIG5ld09wdGlvbnMuaGVpZ2h0LCBuZXdPcHRpb25zKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgaXNUeXBlU3VwcG9ydGVkKHR5cGUsIG9wZXJhdGlvbiA9ICd3cml0ZScpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0eXBlICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigndHlwZSBhcmd1bWVudCBtdXN0IGJlIGEgc3RyaW5nJyk7XG4gICAgICAgIH1cbiAgICAgICAgdHlwZSA9IGdldFR5cGUodHlwZSk7XG4gICAgICAgIGlmIChvcGVyYXRpb24gPT09ICd3cml0ZScpIHtcbiAgICAgICAgICAgIHJldHVybiBjYW5Xcml0ZSh0eXBlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3Vua25vd24gb3BlcmF0aW9uOiAnICsgb3BlcmF0aW9uKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldFBpeGVsSW5kZXgoaW5kaWNlcykge1xuICAgICAgICBsZXQgc2hpZnQgPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGluZGljZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHNoaWZ0ICs9IHRoaXMubXVsdGlwbGllcnNbaV0gKiBpbmRpY2VzW2ldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzaGlmdDtcbiAgICB9XG5cbiAgICBzZXRWYWx1ZVhZKHgsIHksIGNoYW5uZWwsIHZhbHVlKSB7XG4gICAgICAgIHRoaXMuZGF0YVsoeSAqIHRoaXMud2lkdGggKyB4KSAqIHRoaXMuY2hhbm5lbHMgKyBjaGFubmVsXSA9IHZhbHVlO1xuICAgICAgICB0aGlzLmNvbXB1dGVkID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZ2V0VmFsdWVYWSh4LCB5LCBjaGFubmVsKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFbKHkgKiB0aGlzLndpZHRoICsgeCkgKiB0aGlzLmNoYW5uZWxzICsgY2hhbm5lbF07XG4gICAgfVxuXG4gICAgc2V0VmFsdWUocGl4ZWwsIGNoYW5uZWwsIHZhbHVlKSB7XG4gICAgICAgIHRoaXMuZGF0YVtwaXhlbCAqIHRoaXMuY2hhbm5lbHMgKyBjaGFubmVsXSA9IHZhbHVlO1xuICAgICAgICB0aGlzLmNvbXB1dGVkID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZ2V0VmFsdWUocGl4ZWwsIGNoYW5uZWwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVtwaXhlbCAqIHRoaXMuY2hhbm5lbHMgKyBjaGFubmVsXTtcbiAgICB9XG5cbiAgICBzZXRQaXhlbFhZKHgsIHksIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNldFBpeGVsKHkgKiB0aGlzLndpZHRoICsgeCwgdmFsdWUpO1xuICAgIH1cblxuICAgIGdldFBpeGVsWFkoeCwgeSkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRQaXhlbCh5ICogdGhpcy53aWR0aCArIHgpO1xuICAgIH1cblxuICAgIHNldFBpeGVsKHBpeGVsLCB2YWx1ZSkge1xuICAgICAgICBsZXQgdGFyZ2V0ID0gcGl4ZWwgKiB0aGlzLmNoYW5uZWxzO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLmRhdGFbdGFyZ2V0ICsgaV0gPSB2YWx1ZVtpXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNvbXB1dGVkID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZ2V0UGl4ZWwocGl4ZWwpIHtcbiAgICAgICAgbGV0IHZhbHVlID0gbmV3IEFycmF5KHRoaXMuY2hhbm5lbHMpO1xuICAgICAgICBsZXQgdGFyZ2V0ID0gcGl4ZWwgKiB0aGlzLmNoYW5uZWxzO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuY2hhbm5lbHM7IGkrKykge1xuICAgICAgICAgICAgdmFsdWVbaV0gPSB0aGlzLmRhdGFbdGFyZ2V0ICsgaV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIHRvRGF0YVVSTCh0eXBlID0gJ2ltYWdlL3BuZycpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q2FudmFzKCkudG9EYXRhVVJMKGdldFR5cGUodHlwZSkpO1xuICAgIH1cblxuICAgIGdldENhbnZhcygpIHtcbiAgICAgICAgbGV0IGRhdGEgPSBuZXcgSW1hZ2VEYXRhKHRoaXMuZ2V0UkdCQURhdGEoKSwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuICAgICAgICBsZXQgY2FudmFzID0gbmV3IENhbnZhcyh0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG4gICAgICAgIGxldCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgY3R4LnB1dEltYWdlRGF0YShkYXRhLCAwLCAwKTtcbiAgICAgICAgcmV0dXJuIGNhbnZhcztcbiAgICB9XG5cbiAgICBnZXRSR0JBRGF0YSgpIHtcbiAgICAgICAgdGhpcy5jaGVja1Byb2Nlc3NhYmxlKCdnZXRSR0JBRGF0YScsIHtcbiAgICAgICAgICAgIGNvbXBvbmVudHM6IFsxLCAzXSxcbiAgICAgICAgICAgIGJpdERlcHRoOiBbMSwgOCwgMTZdXG4gICAgICAgIH0pO1xuICAgICAgICBsZXQgc2l6ZSA9IHRoaXMuc2l6ZTtcbiAgICAgICAgbGV0IG5ld0RhdGEgPSBuZXcgVWludDhDbGFtcGVkQXJyYXkodGhpcy53aWR0aCAqIHRoaXMuaGVpZ2h0ICogNCk7XG4gICAgICAgIGlmICh0aGlzLmJpdERlcHRoID09PSAxKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNpemU7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCB2YWx1ZSA9IHRoaXMuZ2V0Qml0KGkpO1xuICAgICAgICAgICAgICAgIG5ld0RhdGFbaSAqIDRdID0gdmFsdWUgKiAyNTU7XG4gICAgICAgICAgICAgICAgbmV3RGF0YVtpICogNCArIDFdID0gdmFsdWUgKiAyNTU7XG4gICAgICAgICAgICAgICAgbmV3RGF0YVtpICogNCArIDJdID0gdmFsdWUgKiAyNTU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jb21wb25lbnRzID09PSAxKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzaXplOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3RGF0YVtpICogNF0gPSB0aGlzLmRhdGFbaSAqIHRoaXMuY2hhbm5lbHNdID4+PiAodGhpcy5iaXREZXB0aCAtIDgpO1xuICAgICAgICAgICAgICAgICAgICBuZXdEYXRhW2kgKiA0ICsgMV0gPSB0aGlzLmRhdGFbaSAqIHRoaXMuY2hhbm5lbHNdID4+PiAodGhpcy5iaXREZXB0aCAtIDgpO1xuICAgICAgICAgICAgICAgICAgICBuZXdEYXRhW2kgKiA0ICsgMl0gPSB0aGlzLmRhdGFbaSAqIHRoaXMuY2hhbm5lbHNdID4+PiAodGhpcy5iaXREZXB0aCAtIDgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5jb21wb25lbnRzID09PSAzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGVja1Byb2Nlc3NhYmxlKCdnZXRSR0JBRGF0YScsIHtjb2xvck1vZGVsOiBbUkdCXX0pO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNvbG9yTW9kZWwgPT09IFJHQikge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNpemU7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3RGF0YVtpICogNF0gPSB0aGlzLmRhdGFbaSAqIHRoaXMuY2hhbm5lbHNdID4+PiAodGhpcy5iaXREZXB0aCAtIDgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3RGF0YVtpICogNCArIDFdID0gdGhpcy5kYXRhW2kgKiB0aGlzLmNoYW5uZWxzICsgMV0gPj4+ICh0aGlzLmJpdERlcHRoIC0gOCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdEYXRhW2kgKiA0ICsgMl0gPSB0aGlzLmRhdGFbaSAqIHRoaXMuY2hhbm5lbHMgKyAyXSA+Pj4gKHRoaXMuYml0RGVwdGggLSA4KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5hbHBoYSkge1xuICAgICAgICAgICAgdGhpcy5jaGVja1Byb2Nlc3NhYmxlKCdnZXRSR0JBRGF0YScsIHtiaXREZXB0aDogWzgsIDE2XX0pO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzaXplOyBpKyspIHtcbiAgICAgICAgICAgICAgICBuZXdEYXRhW2kgKiA0ICsgM10gPSB0aGlzLmRhdGFbaSAqIHRoaXMuY2hhbm5lbHMgKyB0aGlzLmNvbXBvbmVudHNdID4+ICh0aGlzLmJpdERlcHRoIC0gOCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNpemU7IGkrKykge1xuICAgICAgICAgICAgICAgIG5ld0RhdGFbaSAqIDQgKyAzXSA9IDI1NTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3RGF0YTtcbiAgICB9XG5cbiAgICBnZXRST0lNYW5hZ2VyKG1hc2ssIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBST0lNYW5hZ2VyKHRoaXMsIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIGNsb25lKHtjb3B5RGF0YSA9IHRydWV9ID0ge30pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBJbWFnZSh0aGlzLCBjb3B5RGF0YSk7XG4gICAgfVxuXG4gICAgc2F2ZShwYXRoLCB7Zm9ybWF0ID0gJ3BuZyd9ID0ge30pIHsgLy8gTm9kZS5KUyBvbmx5XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBsZXQgb3V0ID0gY3JlYXRlV3JpdGVTdHJlYW0ocGF0aCk7XG4gICAgICAgICAgICBsZXQgY2FudmFzID0gdGhpcy5nZXRDYW52YXMoKTtcbiAgICAgICAgICAgIGxldCBzdHJlYW07XG4gICAgICAgICAgICBzd2l0Y2ggKGZvcm1hdC50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAncG5nJzpcbiAgICAgICAgICAgICAgICAgICAgc3RyZWFtID0gY2FudmFzLnBuZ1N0cmVhbSgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdqcGcnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2pwZWcnOlxuICAgICAgICAgICAgICAgICAgICBzdHJlYW0gPSBjYW52YXMuanBlZ1N0cmVhbSgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KG5ldyBSYW5nZUVycm9yKCdpbnZhbGlkIG91dHB1dCBmb3JtYXQ6ICcgKyBmb3JtYXQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG91dC5vbignZmluaXNoJywgcmVzb2x2ZSk7XG4gICAgICAgICAgICBvdXQub24oJ2Vycm9yJywgcmVqZWN0KTtcbiAgICAgICAgICAgIHN0cmVhbS5waXBlKG91dCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIHRoaXMgbWV0aG9kIGNoZWNrIGlmIGEgcHJvY2VzcyBjYW4gYmUgYXBwbGllZCBvbiB0aGUgY3VycmVudCBpbWFnZVxuICAgIGNoZWNrUHJvY2Vzc2FibGUocHJvY2Vzc05hbWUsIHtiaXREZXB0aCwgYWxwaGEsIGNvbG9yTW9kZWwsIGNvbXBvbmVudHN9ID0ge30pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBwcm9jZXNzTmFtZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2NoZWNrUHJvY2Vzc2FibGUgcmVxdWlyZXMgYXMgZmlyc3QgcGFyYW1ldGVyIHRoZSBwcm9jZXNzTmFtZSAoYSBzdHJpbmcpJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJpdERlcHRoKSB7XG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoYml0RGVwdGgpKSBiaXREZXB0aCA9IFtiaXREZXB0aF07XG4gICAgICAgICAgICBpZiAoYml0RGVwdGguaW5kZXhPZih0aGlzLmJpdERlcHRoKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgcHJvY2VzczogJyArIHByb2Nlc3NOYW1lICsgJyBjYW4gb25seSBiZSBhcHBsaWVkIGlmIGJpdCBkZXB0aCBpcyBpbjogJyArIGJpdERlcHRoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoYWxwaGEpIHtcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShhbHBoYSkpIGFscGhhID0gW2FscGhhXTtcbiAgICAgICAgICAgIGlmIChhbHBoYS5pbmRleE9mKHRoaXMuYWxwaGEpID09PSAtMSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBwcm9jZXNzOiAnICsgcHJvY2Vzc05hbWUgKyAnIGNhbiBvbmx5IGJlIGFwcGxpZWQgaWYgYWxwaGEgaXMgaW46ICcgKyBhbHBoYSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbG9yTW9kZWwpIHtcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShjb2xvck1vZGVsKSkgY29sb3JNb2RlbCA9IFtjb2xvck1vZGVsXTtcbiAgICAgICAgICAgIGlmIChjb2xvck1vZGVsLmluZGV4T2YodGhpcy5jb2xvck1vZGVsKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgcHJvY2VzczogJyArIHByb2Nlc3NOYW1lICsgJyBjYW4gb25seSBiZSBhcHBsaWVkIGlmIGNvbG9yIG1vZGVsIGlzIGluOiAnICsgY29sb3JNb2RlbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbXBvbmVudHMpIHtcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShjb21wb25lbnRzKSkgY29tcG9uZW50cyA9IFtjb21wb25lbnRzXTtcbiAgICAgICAgICAgIGlmIChjb21wb25lbnRzLmluZGV4T2YodGhpcy5jb21wb25lbnRzKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgcHJvY2VzczogJyArIHByb2Nlc3NOYW1lICsgJyBjYW4gb25seSBiZSBhcHBsaWVkIGlmIHRoZSBudW1iZXIgb2YgY2hhbm5lbHMgaXMgaW46ICcgKyBjb21wb25lbnRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNoZWNrQ29sdW1uKGNvbHVtbikge1xuICAgICAgICBpZiAoKGNvbHVtbiA8IDApIHx8IChjb2x1bW4gPj0gdGhpcy53aWR0aCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBjaGVja0NvbHVtbjogY29sdW1uIHNob3VsZCBiZSBpbmNsdWRlZCBiZXR3ZWVuIDAgYW5kICR7dGhpcy53aWR0aCAtIDF9LiBDdXJyZW50IHZhbHVlOiAke2NvbHVtbn1gKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNoZWNrUm93KHJvdykge1xuICAgICAgICBpZiAoKHJvdyA8IDApIHx8IChyb3cgPj0gdGhpcy5oZWlnaHQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgY2hlY2tSb3c6IHJvdyBzaG91bGQgYmUgaW5jbHVkZWQgYmV0d2VlbiAwIGFuZCAke3RoaXMuaGVpZ2h0IC0gMX0uIEN1cnJlbnQgdmFsdWU6ICR7cm93fWApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY2hlY2tDaGFubmVsKGNoYW5uZWwpIHtcbiAgICAgICAgaWYgKChjaGFubmVsIDwgMCkgfHwgKGNoYW5uZWwgPj0gdGhpcy5jaGFubmVscykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBjaGVja0NoYW5uZWw6IGNoYW5uZWwgc2hvdWxkIGJlIGluY2x1ZGVkIGJldHdlZW4gMCBhbmQgJHt0aGlzLmNoYW5uZWxzIC0gMX0uIEN1cnJlbnQgdmFsdWU6ICR7Y2hhbm5lbH1gKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgYXBwbHkoZmlsdGVyKSB7XG4gICAgICAgIGZvciAobGV0IHkgPSAwOyB5IDwgdGhpcy5oZWlnaHQ7IHkrKykge1xuICAgICAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCB0aGlzLndpZHRoOyB4KyspIHtcbiAgICAgICAgICAgICAgICBsZXQgaW5kZXggPSAoeSAqIHRoaXMud2lkdGggKyB4KSAqIHRoaXMuY2hhbm5lbHM7XG4gICAgICAgICAgICAgICAgZmlsdGVyLmNhbGwodGhpcywgaW5kZXgpO1xuXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4dGVuZChJbWFnZSk7XG5iaXRNZXRob2RzKEltYWdlKTtcbiIsImltcG9ydCAqIGFzIEtpbmQgZnJvbSAnLi9raW5kTmFtZXMnO1xuaW1wb3J0IHtSR0J9IGZyb20gJy4vbW9kZWwvbW9kZWwnO1xuXG5jb25zdCBraW5kcyA9IHt9O1xuXG5raW5kc1tLaW5kLkJJTkFSWV0gPSB7XG4gICAgY29tcG9uZW50czogMSxcbiAgICBhbHBoYTogMCxcbiAgICBiaXREZXB0aDogMVxufTtcblxua2luZHNbS2luZC5HUkVZQV0gPSB7XG4gICAgY29tcG9uZW50czogMSxcbiAgICBhbHBoYTogMSxcbiAgICBiaXREZXB0aDogOFxufTtcblxua2luZHNbS2luZC5HUkVZXSA9IHtcbiAgICBjb21wb25lbnRzOiAxLFxuICAgIGFscGhhOiAwLFxuICAgIGJpdERlcHRoOiA4XG59O1xuXG5raW5kc1tLaW5kLlJHQkFdID0ge1xuICAgIGNvbXBvbmVudHM6IDMsXG4gICAgYWxwaGE6IDEsXG4gICAgYml0RGVwdGg6IDgsXG4gICAgY29sb3JNb2RlbDogUkdCXG59O1xuXG5raW5kc1tLaW5kLlJHQl0gPSB7XG4gICAgY29tcG9uZW50czogMyxcbiAgICBhbHBoYTogMCxcbiAgICBiaXREZXB0aDogOCxcbiAgICBjb2xvck1vZGVsOiBSR0Jcbn07XG5cblxuZXhwb3J0IGZ1bmN0aW9uIGdldEtpbmQoa2luZCkge1xuICAgIHJldHVybiBraW5kc1traW5kXTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFRoZW9yZXRpY2FsUGl4ZWxBcnJheVNpemUoaW1hZ2UpIHtcbiAgICBsZXQgbGVuZ3RoID0gaW1hZ2UuY2hhbm5lbHMgKiBpbWFnZS5zaXplO1xuICAgIGlmIChpbWFnZS5iaXREZXB0aCA9PT0gMSkge1xuICAgICAgICBsZW5ndGggPSBNYXRoLmNlaWwobGVuZ3RoIC8gOCk7XG4gICAgfVxuICAgIHJldHVybiBsZW5ndGg7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVQaXhlbEFycmF5KGltYWdlKSB7XG4gICAgbGV0IGxlbmd0aCA9IGltYWdlLmNoYW5uZWxzICogaW1hZ2Uuc2l6ZTtcbiAgICBsZXQgYXJyO1xuICAgIHN3aXRjaCAoaW1hZ2UuYml0RGVwdGgpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgYXJyID0gbmV3IFVpbnQ4QXJyYXkoTWF0aC5jZWlsKGxlbmd0aCAvIDgpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICBhcnIgPSBuZXcgVWludDhDbGFtcGVkQXJyYXkobGVuZ3RoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDE2OlxuICAgICAgICAgICAgYXJyID0gbmV3IFVpbnQxNkFycmF5KGxlbmd0aCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzMjpcbiAgICAgICAgICAgIGFyciA9IG5ldyBGbG9hdDMyQXJyYXkobGVuZ3RoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgY3JlYXRlIHBpeGVsIGFycmF5IGZvciBiaXQgZGVwdGggJyArIGltYWdlLmJpdERlcHRoKTtcbiAgICB9XG5cbiAgICAvLyBhbHBoYSBjaGFubmVsIGlzIDEwMCUgYnkgZGVmYXVsdFxuICAgIGlmIChpbWFnZS5hbHBoYSkge1xuICAgICAgICBmb3IgKGxldCBpID0gaW1hZ2UuY29tcG9uZW50czsgaSA8IGFyci5sZW5ndGg7IGkgKz0gaW1hZ2UuY2hhbm5lbHMpIHtcbiAgICAgICAgICAgIGFycltpXSA9IGltYWdlLm1heFZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGltYWdlLmRhdGEgPSBhcnI7XG59XG4iLCIvLyBTaG9ydGN1dHMgZm9yIGNvbW1vbiBpbWFnZSBraW5kc1xuXG5leHBvcnQgY29uc3QgQklOQVJZID0gJ0JJTkFSWSc7XG5leHBvcnQgY29uc3QgR1JFWUEgPSAnR1JFWUEnO1xuZXhwb3J0IGNvbnN0IFJHQkEgPSAnUkdCQSc7XG5leHBvcnQgY29uc3QgUkdCID0gJ1JHQic7XG5leHBvcnQgY29uc3QgR1JFWSA9ICdHUkVZJztcblxuIiwiaW1wb3J0IEltYWdlIGZyb20gJy4vaW1hZ2UnO1xuaW1wb3J0IFN0YWNrIGZyb20gJy4uL3N0YWNrL3N0YWNrJztcbmltcG9ydCB7ZW52LCBsb2FkQmluYXJ5LCBET01JbWFnZSwgSW1hZ2VEYXRhLCBDYW52YXMsIGlzRGlmZmVyZW50T3JpZ2lufSBmcm9tICcuL2Vudmlyb25tZW50JztcbmltcG9ydCB7UE5HRGVjb2Rlcn0gZnJvbSAnZmFzdC1wbmcnO1xuaW1wb3J0IHtUSUZGRGVjb2Rlcn0gZnJvbSAndGlmZic7XG5pbXBvcnQgYXRvYiBmcm9tICdhdG9iLWxpdGUnO1xuXG5jb25zdCBpc0RhdGFVUkwgPSAvXmRhdGE6W2Etel0rXFwvKFthLXpdKyk7YmFzZTY0LC87XG5jb25zdCBpc1BORyA9IC9cXC5wbmckL2k7XG5jb25zdCBpc1RJRkYgPSAvXFwudGlmZj8kL2k7XG5cbmZ1bmN0aW9uIHN0cjJhYihzdHIpIHtcbiAgICBjb25zdCBhcnIgPSBuZXcgVWludDhBcnJheShzdHIubGVuZ3RoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgICAgICBhcnJbaV0gPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICB9XG4gICAgcmV0dXJuIGFycjtcbn1cblxuZnVuY3Rpb24gc3dhcDE2KHZhbCkge1xuICAgIHJldHVybiAoKHZhbCAmIDB4RkYpIDw8IDgpIHwgKCh2YWwgPj4gOCkgJiAweEZGKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGxvYWRVUkwodXJsKSB7XG4gICAgY29uc3QgZGF0YVVSTCA9IHVybC5zbGljZSgwLCA2NCkubWF0Y2goaXNEYXRhVVJMKTtcbiAgICBpZiAoZGF0YVVSTCkge1xuICAgICAgICBjb25zdCBtaW1ldHlwZSA9IGRhdGFVUkxbMV07XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IGRhdGFVUkxbMF0ubGVuZ3RoO1xuICAgICAgICBpZiAobWltZXR5cGUgPT09ICdwbmcnKSB7XG4gICAgICAgICAgICBsZXQgc2xpY2UgPSB1cmwuc2xpY2Uob2Zmc2V0KTtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoc3RyMmFiKGF0b2Ioc2xpY2UpKSkudGhlbihsb2FkUE5HKTtcbiAgICAgICAgfSBlbHNlIGlmIChtaW1ldHlwZSA9PT0gJ3RpZmYnKSB7XG4gICAgICAgICAgICBsZXQgc2xpY2UgPSB1cmwuc2xpY2Uob2Zmc2V0KTtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoc3RyMmFiKGF0b2Ioc2xpY2UpKSkudGhlbihsb2FkVElGRik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaXNQTkcudGVzdCh1cmwpKSB7XG4gICAgICAgIHJldHVybiBsb2FkQmluYXJ5KHVybCkudGhlbihsb2FkUE5HKTtcbiAgICB9IGVsc2UgaWYgKGlzVElGRi50ZXN0KHVybCkpIHtcbiAgICAgICAgcmV0dXJuIGxvYWRCaW5hcnkodXJsKS50aGVuKGxvYWRUSUZGKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbG9hZEdlbmVyaWModXJsKTtcbn1cblxuZnVuY3Rpb24gbG9hZFBORyhkYXRhKSB7XG4gICAgY29uc3QgZGVjb2RlciA9IG5ldyBQTkdEZWNvZGVyKGRhdGEpO1xuICAgIGNvbnN0IHBuZyA9IGRlY29kZXIuZGVjb2RlKCk7XG4gICAgY29uc3QgYml0RGVwdGggPSBwbmcuYml0RGVwdGg7XG4gICAgY29uc3QgYnVmZmVyID0gcG5nLmRhdGEuYnVmZmVyO1xuICAgIGxldCBiaXRtYXA7XG4gICAgaWYgKGJpdERlcHRoID09PSA4KSB7XG4gICAgICAgIGJpdG1hcCA9IG5ldyBVaW50OENsYW1wZWRBcnJheShidWZmZXIpO1xuICAgIH0gZWxzZSBpZiAoYml0RGVwdGggPT09IDE2KSB7XG4gICAgICAgIGJpdG1hcCA9IG5ldyBVaW50MTZBcnJheShidWZmZXIpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJpdG1hcC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYml0bWFwW2ldID0gc3dhcDE2KGJpdG1hcFtpXSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCB0eXBlID0gcG5nLmNvbG91clR5cGU7XG4gICAgbGV0IGNvbXBvbmVudHMsIGFscGhhID0gMDtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSAwOiBjb21wb25lbnRzID0gMTsgYnJlYWs7XG4gICAgICAgIGNhc2UgMjogY29tcG9uZW50cyA9IDM7IGJyZWFrO1xuICAgICAgICBjYXNlIDQ6IGNvbXBvbmVudHMgPSAxOyBhbHBoYSA9IDE7IGJyZWFrO1xuICAgICAgICBjYXNlIDY6IGNvbXBvbmVudHMgPSAzOyBhbHBoYSA9IDE7IGJyZWFrO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgSW1hZ2UocG5nLndpZHRoLCBwbmcuaGVpZ2h0LCBiaXRtYXAsIHtjb21wb25lbnRzLCBhbHBoYSwgYml0RGVwdGh9KTtcbn1cblxuZnVuY3Rpb24gbG9hZFRJRkYoZGF0YSkge1xuICAgIGxldCBkZWNvZGVyID0gbmV3IFRJRkZEZWNvZGVyKGRhdGEpO1xuICAgIGxldCByZXN1bHQgPSBkZWNvZGVyLmRlY29kZSgpO1xuICAgIGlmIChyZXN1bHQuaWZkLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICByZXR1cm4gZ2V0SW1hZ2VGcm9tSUZEKHJlc3VsdC5pZmRbMF0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBuZXcgU3RhY2socmVzdWx0LmlmZC5tYXAoZ2V0SW1hZ2VGcm9tSUZEKSk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBnZXRJbWFnZUZyb21JRkQoaW1hZ2UpIHtcbiAgICByZXR1cm4gbmV3IEltYWdlKGltYWdlLndpZHRoLCBpbWFnZS5oZWlnaHQsIGltYWdlLmRhdGEsIHtcbiAgICAgICAgY29tcG9uZW50czogMSxcbiAgICAgICAgYWxwaGE6IDAsXG4gICAgICAgIGNvbG9yTW9kZWw6IG51bGwsXG4gICAgICAgIGJpdERlcHRoOiBpbWFnZS5iaXRzUGVyU2FtcGxlXG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIGxvYWRHZW5lcmljKHVybCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGxldCBpbWFnZSA9IG5ldyBET01JbWFnZSgpO1xuXG4gICAgICAgIGlmIChpc0RpZmZlcmVudE9yaWdpbih1cmwpKSB7XG4gICAgICAgICAgICAvLyBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRNTC9DT1JTX2VuYWJsZWRfaW1hZ2VcbiAgICAgICAgICAgIGltYWdlLmNyb3NzT3JpZ2luID0gJ0Fub255bW91cyc7XG4gICAgICAgIH1cblxuICAgICAgICBpbWFnZS5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBsZXQgdyA9IGltYWdlLndpZHRoLCBoID0gaW1hZ2UuaGVpZ2h0O1xuICAgICAgICAgICAgbGV0IGNhbnZhcyA9IG5ldyBDYW52YXModywgaCk7XG4gICAgICAgICAgICBsZXQgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgICAgICBjdHguZHJhd0ltYWdlKGltYWdlLCAwLCAwLCB3LCBoKTtcbiAgICAgICAgICAgIGxldCBkYXRhID0gY3R4LmdldEltYWdlRGF0YSgwLCAwLCB3LCBoKS5kYXRhO1xuICAgICAgICAgICAgcmVzb2x2ZShuZXcgSW1hZ2UodywgaCwgZGF0YSkpO1xuICAgICAgICB9O1xuICAgICAgICBpbWFnZS5vbmVycm9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignQ291bGQgbm90IGxvYWQgJyArIHVybCkpO1xuICAgICAgICB9O1xuICAgICAgICBpbWFnZS5zcmMgPSB1cmw7XG4gICAgfSk7XG59XG4iLCJpbXBvcnQgSW1hZ2UgZnJvbSAnLi9pbWFnZSc7XG5pbXBvcnQge2Vudn0gZnJvbSAnLi9lbnZpcm9ubWVudCc7XG5pbXBvcnQgaW5jbHVkZXMgZnJvbSAnc3RyaW5nLWluY2x1ZGVzJztcblxubGV0IHR5cGVzID0gbmV3IE1hcCgpO1xubGV0IGltYWdlO1xuXG5mdW5jdGlvbiBnZXRNZWRpYVR5cGUodHlwZSkge1xuICAgIGlmICghaW1hZ2UpIHtcbiAgICAgICAgaW1hZ2UgPSBuZXcgSW1hZ2UoMSwgMSk7XG4gICAgfVxuICAgIGxldCB0aGVUeXBlID0gdHlwZXMuZ2V0KHR5cGUpO1xuICAgIGlmICghdGhlVHlwZSkge1xuICAgICAgICB0aGVUeXBlID0gbmV3IE1lZGlhVHlwZSh0eXBlKTtcbiAgICAgICAgdHlwZXMuc2V0KHR5cGUsIHRoZVR5cGUpO1xuICAgIH1cbiAgICByZXR1cm4gdGhlVHlwZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNhbldyaXRlKHR5cGUpIHtcbiAgICBpZiAoZW52ID09PSAnbm9kZScgJiYgdHlwZSAhPT0gJ2ltYWdlL3BuZycpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBub2RlLWNhbnZhcyB0aHJvd3MgZm9yIG90aGVyIHR5cGVzXG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGdldE1lZGlhVHlwZSh0eXBlKS5jYW5Xcml0ZSgpO1xuICAgIH1cbn1cblxuY2xhc3MgTWVkaWFUeXBlIHtcbiAgICBjb25zdHJ1Y3Rvcih0eXBlKSB7XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgIHRoaXMuX2NhbldyaXRlID0gbnVsbDtcbiAgICB9XG5cbiAgICBjYW5Xcml0ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2NhbldyaXRlID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9jYW5Xcml0ZSA9IGltYWdlLnRvRGF0YVVSTCh0aGlzLnR5cGUpLnN0YXJ0c1dpdGgoJ2RhdGE6JyArIHRoaXMudHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2NhbldyaXRlO1xuICAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFR5cGUodHlwZSkge1xuICAgIGlmICghaW5jbHVkZXModHlwZSwgJy8nKSkge1xuICAgICAgICB0eXBlID0gJ2ltYWdlLycgKyB0eXBlO1xuICAgIH1cbiAgICByZXR1cm4gdHlwZTtcbn1cbiIsImV4cG9ydCBjb25zdCBSR0IgPSAnUkdCJztcbmV4cG9ydCBjb25zdCBIU0wgPSAnSFNMJztcbmV4cG9ydCBjb25zdCBIU1YgPSAnSFNWJztcbiIsIlxuaW1wb3J0IEltYWdlIGZyb20gJy4uL2ltYWdlJztcbmltcG9ydCB7dmFsaWRhdGVBcnJheU9mQ2hhbm5lbHN9IGZyb20gJy4uLy4uL3V0aWwvY2hhbm5lbCc7XG5pbXBvcnQge3ZhbGlkYXRlS2VybmVsfSBmcm9tICcuLi8uLi91dGlsL2tlcm5lbCc7XG4vKipcbiAqXG4gKiBAcGFyYW0ga2VybmVsXG4gKiBAcGFyYW0gYml0RGVwdGggOiBXZSBjYW4gc3BlY2lmeSBhIG5ldyBiaXREZXB0aCBmb3IgdGhlIGltYWdlLiBUaGlzIGFsbG93IHRvIHNwZWNpZnkgMzIgYml0cyBpbiBvcmRlciBubyB0byBjbGFtcFxuICogQHBhcmFtIG5vcm1hbGl6ZVxuICogQHBhcmFtIGRpdmlzb3JcbiAqIEBwYXJhbSBib3JkZXJcbiAqIEByZXR1cm5zIHsqfVxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjb252b2x1dGlvbihrZXJuZWwsIHtjaGFubmVscywgYml0RGVwdGgsIG5vcm1hbGl6ZSA9IGZhbHNlLCBkaXZpc29yID0gMSwgYm9yZGVyID0gJ2NvcHknfSA9IHt9KSB7XG5cbiAgICBsZXQgbmV3SW1hZ2UgPSBJbWFnZS5jcmVhdGVGcm9tKHRoaXMsIHtiaXREZXB0aDogYml0RGVwdGh9KTtcblxuICAgIGNoYW5uZWxzID0gdmFsaWRhdGVBcnJheU9mQ2hhbm5lbHModGhpcywgY2hhbm5lbHMsIHRydWUpO1xuXG4gICAgbGV0IGtXaWR0aCwga0hlaWdodDtcbiAgICAoe2tXaWR0aCwga0hlaWdodCwga2VybmVsfSA9IHZhbGlkYXRlS2VybmVsKGtlcm5lbCkpO1xuXG4gICAgLy9jYWxjdWxhdGUgZGl2aXNvclxuICAgIGlmIChub3JtYWxpemUpIHtcbiAgICAgICAgZGl2aXNvciA9IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwga2VybmVsLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBrZXJuZWxbMF0ubGVuZ3RoOyBqKyspXG4gICAgICAgICAgICAgICAgZGl2aXNvciArPSBrZXJuZWxbaV1bal07XG4gICAgfVxuXG4gICAgaWYgKGRpdmlzb3IgPT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ2NvbnZvbHV0aW9uOiBUaGUgZGl2aXNvciBpcyBlcXVhbCB0byB6ZXJvJyk7XG4gICAgfVxuXG5cbiAgICBsZXQgY2xhbXBlZCA9IG5ld0ltYWdlLmlzQ2xhbXBlZDtcblxuICAgIGZvciAobGV0IGNoYW5uZWwgPSAwOyBjaGFubmVsIDwgY2hhbm5lbHMubGVuZ3RoOyBjaGFubmVsKyspIHtcbiAgICAgICAgbGV0IGMgPSBjaGFubmVsc1tjaGFubmVsXTtcbiAgICAgICAgZm9yIChsZXQgeSA9IGtIZWlnaHQ7IHkgPCB0aGlzLmhlaWdodCAtIGtIZWlnaHQ7IHkrKykge1xuICAgICAgICAgICAgZm9yIChsZXQgeCA9IGtXaWR0aDsgeCA8IHRoaXMud2lkdGggLSBrV2lkdGg7IHgrKykge1xuICAgICAgICAgICAgICAgIGxldCBzdW0gPSAwO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAta0hlaWdodDsgaiA8PSBrSGVpZ2h0OyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IC1rV2lkdGg7IGkgPD0ga1dpZHRoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBrVmFsID0ga2VybmVsW2tIZWlnaHQgKyBqXVtrV2lkdGggKyBpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBpbmRleCA9ICgoeSArIGopICogdGhpcy53aWR0aCArIHggKyBpKSAqIHRoaXMuY2hhbm5lbHMgKyBjO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3VtICs9IHRoaXMuZGF0YVtpbmRleF0gKiBrVmFsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbGV0IGluZGV4ID0gKHkgKiB0aGlzLndpZHRoICsgeCkgKiB0aGlzLmNoYW5uZWxzICsgYztcbiAgICAgICAgICAgICAgICBpZiAoY2xhbXBlZCkgeyAvLyB3ZSBjYWxjdWxhdGUgdGhlIGNsYW1wZWQgcmVzdWx0XG4gICAgICAgICAgICAgICAgICAgIG5ld0ltYWdlLmRhdGFbaW5kZXhdID0gTWF0aC5taW4oTWF0aC5tYXgoTWF0aC5yb3VuZChzdW0gLyBkaXZpc29yKSwgMCksIG5ld0ltYWdlLm1heFZhbHVlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBuZXdJbWFnZS5kYXRhW2luZGV4XSA9IHN1bSAvIGRpdmlzb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGlmIHRoZSBrZXJuZWwgd2FzIG5vdCBhcHBsaWVkIG9uIHRoZSBhbHBoYSBjaGFubmVsIHdlIGp1c3QgY29weSBpdFxuICAgIC8vIFRPRE86IGluIGdlbmVyYWwgd2Ugc2hvdWxkIGNvcHkgdGhlIGNoYW5uZWxzIHRoYXQgd2hlcmUgbm90IGNoYW5nZWRcbiAgICAvLyBUT0RPOiBwcm9iYWJseSB3ZSBzaG91bGQganVzdCBjb3B5IHRoZSBpbWFnZSBhdCB0aGUgYmVnaW5uaW5nID9cblxuICAgIGlmICh0aGlzLmFscGhhICYmIGNoYW5uZWxzLmluZGV4T2YodGhpcy5jaGFubmVscykgPT09IC0xKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLmNvbXBvbmVudHM7IGkgPCB0aGlzLmRhdGEubGVuZ3RoOyBpID0gaSArIHRoaXMuY2hhbm5lbHMpIHtcbiAgICAgICAgICAgIG5ld0ltYWdlLmRhdGFbaV0gPSB0aGlzLmRhdGFbaV07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBuZXdJbWFnZS5zZXRCb3JkZXIoe3NpemU6W2tXaWR0aCwga0hlaWdodF0sIGFsZ29yaXRobTogYm9yZGVyfSk7XG5cbiAgICByZXR1cm4gbmV3SW1hZ2U7XG59XG4iLCIvLyB3ZSB3aWxsIGNyZWF0ZSBhIHNtYWxsIGltYWdlIGZyb20gYSBtYXNrXG5cblxuaW1wb3J0IEltYWdlIGZyb20gJy4uL2ltYWdlJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZXh0cmFjdChtYXNrLCB7XG4gICAgc2NhbGUgPSAxLFxuICAgIHBvc2l0aW9ufSA9IHt9KSB7XG5cbiAgICB0aGlzLmNoZWNrUHJvY2Vzc2FibGUoJ2V4dHJhY3QnLCB7XG4gICAgICAgIGJpdERlcHRoOiBbOCwgMTZdXG4gICAgfSk7XG5cbiAgICAvLyB3ZSBuZWVkIHRvIGZpbmQgdGhlIHJlbGF0aXZlIHBvc2l0aW9uIHRvIHRoZSBwYXJlbnRcbiAgICBpZiAoIXBvc2l0aW9uKSB7XG4gICAgICAgIHBvc2l0aW9uID0gbWFzay5nZXRSZWxhdGl2ZVBvc2l0aW9uKHRoaXMpO1xuICAgICAgICBpZiAoIXBvc2l0aW9uKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4dHJhY3QgOiBjYW4gbm90IGV4dHJhY3QgYW4gaW1hZ2UgYmVjYXVzZSB0aGUgcmVsYXRpdmUgcG9zaXRpb24gY2FuIG5vdCBiZSAnICtcbiAgICAgICAgICAgICAgICAnZGV0ZXJtaW5lZCwgdHJ5IHRvIHNwZWNpZnkgbWFudWFseSB0aGUgcG9zaXRpb24gYXMgYW4gYXJyYXkgb2YgMiBlbGVtZW50cyBbeCx5XS4nKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBsZXQgZXh0cmFjdCA9IEltYWdlLmNyZWF0ZUZyb20odGhpcywge1xuICAgICAgICB3aWR0aDogbWFzay53aWR0aCxcbiAgICAgICAgaGVpZ2h0OiBtYXNrLmhlaWdodCxcbiAgICAgICAgYWxwaGE6IDEsICAgLy8gd2UgZm9yY2UgdGhlIGFscGhhLCBvdGhlcndpc2UgZGlmaWN1bHQgdG8gZXh0cmFjdCBhIG1hc2sgLi4uXG4gICAgICAgIHBvc2l0aW9uOiBwb3NpdGlvbixcbiAgICAgICAgcGFyZW50OiB0aGlzXG4gICAgfSk7XG5cblxuXG4gICAgZm9yIChsZXQgeCA9IDA7IHggPCBtYXNrLndpZHRoOyB4KyspIHtcbiAgICAgICAgZm9yIChsZXQgeSA9IDA7IHkgPCBtYXNrLmhlaWdodDsgeSsrKSB7XG4gICAgICAgICAgICAvLyB3ZSBjb3B5IHRoZSBwb2ludFxuICAgICAgICAgICAgZm9yIChsZXQgY2hhbm5lbCA9IDA7IGNoYW5uZWwgPCB0aGlzLmNoYW5uZWxzOyBjaGFubmVsKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgdmFsdWUgPSB0aGlzLmdldFZhbHVlWFkoeCArIHBvc2l0aW9uWzBdLCB5ICsgcG9zaXRpb25bMV0sIGNoYW5uZWwpO1xuICAgICAgICAgICAgICAgIGV4dHJhY3Quc2V0VmFsdWVYWSh4LCB5LCBjaGFubmVsLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB3ZSBtYWtlIGl0IHRyYW5zcGFyZW50IGluIGNhc2UgaXQgaXMgbm90IGluIHRoZSBtYXNrXG4gICAgICAgICAgICBpZiAoIW1hc2suZ2V0Qml0WFkoeCwgeSkpIHtcbiAgICAgICAgICAgICAgICBleHRyYWN0LnNldFZhbHVlWFkoeCwgeSwgdGhpcy5jb21wb25lbnRzLCAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBleHRyYWN0O1xufVxuIiwiaW1wb3J0IHtSR0J9IGZyb20gJy4uL21vZGVsL21vZGVsJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcGFpbnRNYXNrcyhtYXNrcywge1xuICAgIGNvbG9yID0gW3RoaXMubWF4VmFsdWUsIDAsIDBdXG4gICAgfSA9IHt9KSB7XG5cbiAgICB0aGlzLmNoZWNrUHJvY2Vzc2FibGUoJ3BhaW50TWFza3MnLCB7XG4gICAgICAgIGNvbXBvbmVudHM6IDMsXG4gICAgICAgIGJpdERlcHRoOiBbOCwgMTZdLFxuICAgICAgICBjb2xvck1vZGVsOiBSR0JcbiAgICB9KTtcblxuICAgIGlmICghQXJyYXkuaXNBcnJheShtYXNrcykpIG1hc2tzID0gW21hc2tzXTtcblxuICAgIGxldCBudW1iZXJDaGFubmVscyA9IE1hdGgubWluKHRoaXMuY2hhbm5lbHMsIGNvbG9yLmxlbmd0aCk7XG5cblxuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgcm9pID0gbWFza3NbaV07XG4gICAgICAgIC8vIHdlIG5lZWQgdG8gZmluZCB0aGUgcGFyZW50IGltYWdlIHRvIGNhbGN1bGF0ZSB0aGUgcmVsYXRpdmUgcG9zaXRpb25cblxuICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IHJvaS53aWR0aDsgeCsrKSB7XG4gICAgICAgICAgICBmb3IgKGxldCB5ID0gMDsgeSA8IHJvaS5oZWlnaHQ7IHkrKykge1xuICAgICAgICAgICAgICAgIGlmIChyb2kuZ2V0Qml0WFkoeCwgeSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgY2hhbm5lbCA9IDA7IGNoYW5uZWwgPCBudW1iZXJDaGFubmVsczsgY2hhbm5lbCsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFZhbHVlWFkoeCArIHJvaS5wb3NpdGlvblswXSwgeSArIHJvaS5wb3NpdGlvblsxXSwgY2hhbm5lbCwgY29sb3JbY2hhbm5lbF0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuIiwiaW1wb3J0IHtSR0J9IGZyb20gJy4uL21vZGVsL21vZGVsJztcbmltcG9ydCBTaGFwZSBmcm9tICcuLi8uLi91dGlsL3NoYXBlJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcGFpbnRQaXhlbHMocGl4ZWxzLCB7XG4gICAgY29sb3IgPSBbdGhpcy5tYXhWYWx1ZSwgMCwgMF0sXG4gICAgc2hhcGV9ID0ge30pIHtcblxuICAgIHRoaXMuY2hlY2tQcm9jZXNzYWJsZSgncGFpbnRQaXhlbHMnLCB7XG4gICAgICAgIGNvbXBvbmVudHM6IDMsXG4gICAgICAgIGJpdERlcHRoOiBbOCwgMTZdLFxuICAgICAgICBjb2xvck1vZGVsOiBSR0JcbiAgICB9KTtcblxuICAgIGxldCBzaGFwZVBpeGVscyA9IChuZXcgU2hhcGUoc2hhcGUpKS5nZXRQaXhlbHMoKTtcblxuICAgIGxldCBudW1iZXJDaGFubmVscyA9IE1hdGgubWluKHRoaXMuY2hhbm5lbHMsIGNvbG9yLmxlbmd0aCk7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBpeGVscy5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgeFAgPSBwaXhlbHNbaV1bMF07XG4gICAgICAgIGxldCB5UCA9IHBpeGVsc1tpXVsxXTtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBzaGFwZVBpeGVscy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgbGV0IHhTID0gc2hhcGVQaXhlbHNbal1bMF07XG4gICAgICAgICAgICBsZXQgeVMgPSBzaGFwZVBpeGVsc1tqXVsxXTtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAoKHhQICsgeFMpID49IDApICYmXG4gICAgICAgICAgICAgICAgKCh5UCArIHlTKSA+PSAwKSAmJlxuICAgICAgICAgICAgICAgICgoeFAgKyB4UykgPCB0aGlzLndpZHRoKSAmJlxuICAgICAgICAgICAgICAgICgoeVAgKyB5UykgPCB0aGlzLmhlaWdodClcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIGxldCBwb3NpdGlvbiA9ICh4UCArIHhTICsgKHlQICsgeVMpICogdGhpcy53aWR0aCkgKiB0aGlzLmNoYW5uZWxzO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGNoYW5uZWwgPSAwOyBjaGFubmVsIDwgbnVtYmVyQ2hhbm5lbHM7IGNoYW5uZWwrKykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRhdGFbcG9zaXRpb24gKyBjaGFubmVsXSA9IGNvbG9yW2NoYW5uZWxdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cblxuXG5cblxuIiwiZXhwb3J0IGRlZmF1bHQgY2xhc3MgUk9JTWFwIHtcbiAgICBjb25zdHJ1Y3RvcihwYXJlbnQsIHBpeGVscywgbmVnYXRpdmVJRCwgcG9zaXRpdmVJRCkge1xuICAgICAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgICAgICAgdGhpcy53aWR0aCA9IHBhcmVudC53aWR0aDtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBwYXJlbnQuaGVpZ2h0O1xuICAgICAgICB0aGlzLnBpeGVscyA9IHBpeGVsczsgLy8gcGl4ZWxzIGNvbnRhaW5pbmcgdGhlIGFubm90YXRpb25zXG4gICAgICAgIHRoaXMubmVnYXRpdmUgPSAtbmVnYXRpdmVJRDsgLy8gbnVtYmVyIG9mIG5lZ2F0aXZlIHpvbmVzXG4gICAgICAgIHRoaXMucG9zaXRpdmUgPSBwb3NpdGl2ZUlEOyAvLyBudW1iZXIgb2YgcG9zaXRpdmllIHpvbmVzXG4gICAgICAgIHRoaXMudG90YWwgPSBwb3NpdGl2ZUlEIC0gbmVnYXRpdmVJRDsgLy8gdG90YWwgbnVtYmVyIG9mIHpvbmVzXG4gICAgfVxufVxuIiwiaW1wb3J0IFJPSSBmcm9tICcuL3JvaSc7XG5cblxuLypcblJPSSBhcmUgY3JlYXRlZCBmcm9tIGEgcm9pTWFwXG5UaGUgcm9pTWFwIGNvbnRhaW5zIG1haW50eSBhbiBhcnJheSBvZiBpZGVudGlmaWVycyB0aGF0IGRlZmluZVxuZm9yIGVhY2ggcGl4ZWxzIHRvIHdoaWNoIFJPSSBpdCBiZWxvbmdzXG4gKi9cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY3JlYXRlUk9JKHJvaU1hcCkge1xuXG4gICAgbGV0IHNpemUgPSByb2lNYXAudG90YWw7XG4gICAgbGV0IHJvaXMgPSBuZXcgQXJyYXkoc2l6ZSk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzaXplOyBpKyspIHtcbiAgICAgICAgbGV0IG1hcElEID0gLXJvaU1hcC5uZWdhdGl2ZSArIGk7XG4gICAgICAgIGlmIChpID49IHJvaU1hcC5uZWdhdGl2ZSkgbWFwSUQrKztcbiAgICAgICAgcm9pc1tpXSA9IG5ldyBST0kocm9pTWFwLCBtYXBJRCk7XG4gICAgfVxuICAgIGxldCBwaXhlbHMgPSByb2lNYXAucGl4ZWxzO1xuXG4gICAgbGV0IHdpZHRoID0gcm9pTWFwLnBhcmVudC53aWR0aDtcbiAgICBsZXQgaGVpZ2h0ID0gcm9pTWFwLnBhcmVudC5oZWlnaHQ7XG5cbiAgICBmb3IgKGxldCB4ID0gMDsgeCA8IHdpZHRoOyB4KyspIHtcbiAgICAgICAgZm9yIChsZXQgeSA9IDA7IHkgPCBoZWlnaHQ7IHkrKykge1xuICAgICAgICAgICAgbGV0IHRhcmdldCA9IHkgKiB3aWR0aCArIHg7XG4gICAgICAgICAgICBpZiAocGl4ZWxzW3RhcmdldF0gIT09IDApIHtcbiAgICAgICAgICAgICAgICBsZXQgbWFwSUQgPSBwaXhlbHNbdGFyZ2V0XSArIHJvaU1hcC5uZWdhdGl2ZTtcbiAgICAgICAgICAgICAgICBpZiAobWFwSUQgPiByb2lNYXAubmVnYXRpdmUpIG1hcElELS07XG4gICAgICAgICAgICAgICAgaWYgKHggPCByb2lzW21hcElEXS5taW5YKSByb2lzW21hcElEXS5taW5YID0geDtcbiAgICAgICAgICAgICAgICBpZiAoeCA+IHJvaXNbbWFwSURdLm1heFgpIHJvaXNbbWFwSURdLm1heFggPSB4O1xuICAgICAgICAgICAgICAgIGlmICh5IDwgcm9pc1ttYXBJRF0ubWluWSkgcm9pc1ttYXBJRF0ubWluWSA9IHk7XG4gICAgICAgICAgICAgICAgaWYgKHkgPiByb2lzW21hcElEXS5tYXhZKSByb2lzW21hcElEXS5tYXhZID0geTtcbiAgICAgICAgICAgICAgICByb2lzW21hcElEXS5tZWFuWCArPSB4O1xuICAgICAgICAgICAgICAgIHJvaXNbbWFwSURdLm1lYW5ZICs9IHk7XG4gICAgICAgICAgICAgICAgcm9pc1ttYXBJRF0uc3VyZmFjZSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2l6ZTsgaSsrKSB7XG4gICAgICAgIGxldCBtYXBJRCA9IC1yb2lNYXAubmVnYXRpdmUgKyBpO1xuICAgICAgICBpZiAoaSA+PSByb2lNYXAubmVnYXRpdmUpIG1hcElEKys7XG4gICAgICAgIHJvaXNbaV0ubWVhblggLz0gcm9pc1tpXS5zdXJmYWNlO1xuICAgICAgICByb2lzW2ldLm1lYW5ZIC89IHJvaXNbaV0uc3VyZmFjZTtcbiAgICB9XG4gICAgcmV0dXJuIHJvaXM7XG59XG4iLCJpbXBvcnQgUk9JTWFwIGZyb20gJy4vLi4vUk9JTWFwJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY3JlYXRlUk9JTWFwRnJvbUV4dHJlbWEoXG4gICAge1xuICAgICAgICBhbGxvd0Nvcm5lciA9IHRydWUsXG4gICAgICAgIG9ubHlUb3AsXG4gICAgICAgIGludmVydCA9IGZhbHNlfSA9IHt9XG4pIHtcblxuICAgIGxldCBpbWFnZSA9IHRoaXM7XG4gICAgaW1hZ2UuY2hlY2tQcm9jZXNzYWJsZSgnY3JlYXRlUk9JTWFwRnJvbUV4dHJlbWEnLHtjb21wb25lbnRzOlsxXX0pO1xuXG5cbiAgICBjb25zdCBQUk9DRVNTX1RPUCA9IDE7XG4gICAgY29uc3QgUFJPQ0VTU19OT1JNQUwgPSAyO1xuXG4gICAgLy8gc3BsaXQgd2lsbCBhbHdheXMgcmV0dXJuIGFuIGFycmF5IG9mIGltYWdlc1xuICAgIGxldCBwb3NpdGl2ZUlEID0gMDtcbiAgICBsZXQgbmVnYXRpdmVJRCA9IDA7XG5cbiAgICBsZXQgTUlOX1ZBTFVFID0gLTMyNzY4O1xuXG4gICAgbGV0IHBpeGVscyA9IG5ldyBJbnQxNkFycmF5KGltYWdlLnNpemUpOyAvLyBtYXhWYWx1ZTogMzI3NjcsIG1pblZhbHVlOiAtMzI3NjhcbiAgICBsZXQgcHJvY2Vzc2VkID0gbmV3IEludDhBcnJheShpbWFnZS5zaXplKTtcbiAgICBsZXQgdmFyaWF0aW9ucyA9IG5ldyBGbG9hdDMyQXJyYXkoaW1hZ2Uuc2l6ZSk7XG5cblxuICAgIGxldCBNQVhfQVJSQVkgPSAweDBmZmZmZjsgLy8gc2hvdWxkIGJlIGVub3VnaCBmb3IgbW9zdCBvZiB0aGUgY2FzZXNcbiAgICBsZXQgeFRvUHJvY2VzcyA9IG5ldyBVaW50MTZBcnJheShNQVhfQVJSQVkgKyAxKTsgLy8gYXNzaWduIGR5bmFtaWNhbGx5ID8/Pz9cbiAgICBsZXQgeVRvUHJvY2VzcyA9IG5ldyBVaW50MTZBcnJheShNQVhfQVJSQVkgKyAxKTsgLy8gbWFzayArMSBpcyBvZiBjb3Vyc2UgbWFuZGF0b3J5ICEhIVxuXG5cbiAgICBsZXQgZnJvbSA9IDA7XG4gICAgbGV0IHRvID0gMDtcblxuXG4gICAgbGV0IHhUb1Byb2Nlc3NUb3AgPSBuZXcgVWludDE2QXJyYXkoTUFYX0FSUkFZICsgMSk7IC8vIGFzc2lnbiBkeW5hbWljYWxseSA/Pz8/XG4gICAgbGV0IHlUb1Byb2Nlc3NUb3AgPSBuZXcgVWludDE2QXJyYXkoTUFYX0FSUkFZICsgMSk7IC8vIG1hc2sgKzEgaXMgb2YgY291cnNlIG1hbmRhdG9yeSAhISFcblxuICAgIGxldCBmcm9tVG9wID0gMDtcbiAgICBsZXQgdG9Ub3AgPSAwO1xuXG4gICAgYXBwZW5kRXh0cmVtYShpbWFnZSwge21heGltYTohaW52ZXJ0fSk7XG5cbiAgICB3aGlsZSAoZnJvbSA8IHRvKSB7XG4gICAgICAgIGxldCBjdXJyZW50WCA9IHhUb1Byb2Nlc3NbZnJvbSAmIE1BWF9BUlJBWV07XG4gICAgICAgIGxldCBjdXJyZW50WSA9IHlUb1Byb2Nlc3NbZnJvbSAmIE1BWF9BUlJBWV07XG4gICAgICAgIHByb2Nlc3MoY3VycmVudFgsIGN1cnJlbnRZLCBQUk9DRVNTX05PUk1BTCk7XG4gICAgICAgIGZyb20rKztcbiAgICB9XG5cblxuICAgIHJldHVybiBuZXcgUk9JTWFwKGltYWdlLCBwaXhlbHMsIG5lZ2F0aXZlSUQsIHBvc2l0aXZlSUQpO1xuXG4gICAgLy8gd2Ugd2lsbCBsb29rIGZvciB0aGUgbWF4aW1hIChvciBtaW5pbWEpIHRoYXQgaXMgcHJlc2VudCBpbiB0aGUgcGljdHVyZVxuICAgIC8vIGEgbWF4aW1hIGlzIGEgcG9pbnQgdGhhdCBpcyBzdXJyb3VuZGVkIGJ5IGxvd2VyIHZhbHVlc1xuICAgIC8vIHNob3VsZCBkZWFsIHdpdGggYWxsb3dDb3JuZXIgYW5kIGludmVydFxuICAgIGZ1bmN0aW9uIGFwcGVuZEV4dHJlbWEoe21heGltYSA9IHRydWV9KSB7XG4gICAgICAgIGZvciAobGV0IHkgPSAxOyB5IDwgaW1hZ2UuaGVpZ2h0IC0gMTsgeSsrKSB7XG4gICAgICAgICAgICBmb3IgKGxldCB4ID0gMTsgeCA8IGltYWdlLndpZHRoIC0gMTsgeCsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IGluZGV4ID0geCArIHkgKiBpbWFnZS53aWR0aDtcbiAgICAgICAgICAgICAgICBpZiAocHJvY2Vzc2VkW2luZGV4XSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgY3VycmVudFZhbHVlID0gKG1heGltYSkgPyBpbWFnZS5kYXRhW2luZGV4XSA6IC1pbWFnZS5kYXRhW3ggKyB5ICogaW1hZ2Uud2lkdGhdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW1hZ2UuZGF0YVt5ICogaW1hZ2Uud2lkdGggKyB4IC0gMV0gPiBjdXJyZW50VmFsdWUpIHsgLy8gTEVGVFxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGltYWdlLmRhdGFbeSAqIGltYWdlLndpZHRoICsgeCArIDFdID4gY3VycmVudFZhbHVlKSB7IC8vIFJJR0hUXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoaW1hZ2UuZGF0YVsoeSAtIDEpICogaW1hZ2Uud2lkdGggKyB4XSA+IGN1cnJlbnRWYWx1ZSkgeyAvLyBUT1BcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbWFnZS5kYXRhWyh5ICsgMSkgKiBpbWFnZS53aWR0aCArIHhdID4gY3VycmVudFZhbHVlKSB7IC8vIEJPVFRPTVxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGFsbG93Q29ybmVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW1hZ2UuZGF0YVsoeSAtIDEpICogaW1hZ2Uud2lkdGggKyB4IC0gMV0gPiBjdXJyZW50VmFsdWUpIHsgLy8gTEVGVCBUT1BcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbWFnZS5kYXRhWyh5IC0gMSkgKiBpbWFnZS53aWR0aCArIHggKyAxXSA+IGN1cnJlbnRWYWx1ZSkgeyAvLyBSSUdIVCBUT1BcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbWFnZS5kYXRhWyh5ICsgMSkgKiBpbWFnZS53aWR0aCArIHggLSAxXSA+IGN1cnJlbnRWYWx1ZSkgeyAvLyBMRUZUIEJPVFRPTVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGltYWdlLmRhdGFbKHkgKyAxKSAqIGltYWdlLndpZHRoICsgeCArIDFdID4gY3VycmVudFZhbHVlKSB7IC8vIFJJR0hUIEJPVFRPTVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgcGl4ZWxzW2luZGV4XSA9IChtYXhpbWEpID8gKytwb3NpdGl2ZUlEIDogLS1uZWdhdGl2ZUlEO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCctLS0nLHBpeGVsc1tpbmRleF0pO1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWxpZD1wcm9jZXNzVG9wKHgsIHksIFBST0NFU1NfVE9QKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEgdmFsaWQpIChtYXhpbWEpID8gLS1wb3NpdGl2ZUlEIDogKytuZWdhdGl2ZUlEO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIHdlIHdpbGwgdHJ5IHRvIGdldCBhbGwgdGhlIHBvaW50cyBvZiB0aGUgdG9wIChzYW1lIHZhbHVlKVxuICAgIC8vIGFuZCB0byBjaGVjayBpZiB0aGUgd2hvbGUgZ3JvdXAgaXMgc3Vycm91bmRlZCBieSBsb3dlciB2YWx1ZVxuICAgIC8vIGFzIHNvb24gYXMgb25lIG9mIHRoZW0gaWYgbm90IHBhcnQgd2UgbmVlZCB0byByZXZlcnNlIHRoZSBwcm9jZXNzXG4gICAgLy8gYW5kIGp1c3QgZm9yIGdldCB0aG9zZSBwb2ludHNcbiAgICBmdW5jdGlvbiBwcm9jZXNzVG9wKHhUb1Byb2Nlc3MsIHlUb1Byb2Nlc3MpIHtcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ3Byb2Nlc3MgdG9wJyk7XG4gICAgICAgIGxldCBjdXJyZW50VG8gPSB0bzsgLy8gaW4gY2FzZSBpZiBmYWlscyB3ZSBjb21lIGJhY2tcbiAgICAgICAgZnJvbVRvcCA9IDA7XG4gICAgICAgIHRvVG9wID0gMTtcbiAgICAgICAgeFRvUHJvY2Vzc1RvcFswXSA9IHhUb1Byb2Nlc3M7XG4gICAgICAgIHlUb1Byb2Nlc3NUb3BbMF0gPSB5VG9Qcm9jZXNzO1xuICAgICAgICBsZXQgdmFsaWQgPSB0cnVlO1xuICAgICAgICB3aGlsZSAoZnJvbVRvcCA8IHRvVG9wKSB7XG4gICAgICAgICAgICBsZXQgY3VycmVudFggPSB4VG9Qcm9jZXNzVG9wW2Zyb21Ub3AgJiBNQVhfQVJSQVldO1xuICAgICAgICAgICAgbGV0IGN1cnJlbnRZID0geVRvUHJvY2Vzc1RvcFtmcm9tVG9wICYgTUFYX0FSUkFZXTtcbiAgICAgICAgICAgIHZhbGlkICY9IHByb2Nlc3MoY3VycmVudFgsIGN1cnJlbnRZLCBQUk9DRVNTX1RPUCk7XG4gICAgICAgICAgICBmcm9tVG9wKys7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF2YWxpZCkge1xuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ1JFVkVSVCcpO1xuICAgICAgICAgICAgLy8gbmVlZCB0byBjbGVhciBhbGwgdGhlIGNhbGN1bGF0ZWQgcGl4ZWxzIGJlY2F1c2UgdGhlIHRvcCBpcyBub3Qgc3Vycm91bmRlZCBieSBuZWdhdGl2ZSB2YWx1ZXNcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdG9Ub3A7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBjdXJyZW50WCA9IHhUb1Byb2Nlc3NUb3BbaSAmIE1BWF9BUlJBWV07XG4gICAgICAgICAgICAgICAgbGV0IGN1cnJlbnRZID0geVRvUHJvY2Vzc1RvcFtpICYgTUFYX0FSUkFZXTtcbiAgICAgICAgICAgICAgICBsZXQgaW5kZXggPSBjdXJyZW50WSAqIGltYWdlLndpZHRoICsgY3VycmVudFg7XG4gICAgICAgICAgICAgICAgcGl4ZWxzW2luZGV4XSA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0byA9IGN1cnJlbnRUbztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsaWQ7XG4gICAgfVxuXG4gICAgLypcbiAgICAgRm9yIGEgc3BlY2lmaWMgcG9pbnQgd2Ugd2lsbCBjaGVjayB0aGUgcG9pbnRzIGFyb3VuZCwgaW5jcmVhc2UgdGhlIGFyZWEgb2YgaW50ZXJlc3RzIGFuZCBhZGRcbiAgICAgdGhlbSB0byB0aGUgcHJvY2Vzc2luZyBsaXN0XG4gICAgIHR5cGU9MCA6IHRvcFxuICAgICB0eXBlPTEgOiBub3JtYWxcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwcm9jZXNzKHhDZW50ZXIsIHlDZW50ZXIsIHR5cGUpIHtcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ1BST0NFU1MnLCB4Q2VudGVyLCB5Q2VudGVyKTtcbiAgICAgICAgbGV0IGN1cnJlbnRJRCA9IHBpeGVsc1t5Q2VudGVyICogaW1hZ2Uud2lkdGggKyB4Q2VudGVyXTtcbiAgICAgICAgbGV0IGN1cnJlbnRWYWx1ZSA9IGltYWdlLmRhdGFbeUNlbnRlciAqIGltYWdlLndpZHRoICsgeENlbnRlcl07XG4gICAgICAgIGxldCBjdXJyZW50VmFyaWF0aW9uID0gdmFyaWF0aW9uc1t5Q2VudGVyICogaW1hZ2Uud2lkdGggKyB4Q2VudGVyXTtcbiAgICAgICAgZm9yIChsZXQgeSA9IHlDZW50ZXIgLSAxOyB5IDw9IHlDZW50ZXIgKyAxOyB5KyspIHtcbiAgICAgICAgICAgIGZvciAobGV0IHggPSB4Q2VudGVyIC0gMTsgeCA8PSB4Q2VudGVyICsgMTsgeCsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IGluZGV4ID0geSAqIGltYWdlLndpZHRoICsgeDtcbiAgICAgICAgICAgICAgICBpZiAocHJvY2Vzc2VkW2luZGV4XSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBwcm9jZXNzZWRbaW5kZXhdID0gMTtcbiAgICAgICAgICAgICAgICAgICAgLy8gd2Ugc3RvcmUgdGhlIHZhcmlhdGlvbiBjb21wYXJlIHRvIHRoZSBwYXJlbnQgcGl4ZWxcbiAgICAgICAgICAgICAgICAgICAgdmFyaWF0aW9uc1tpbmRleF0gPSBpbWFnZS5kYXRhW2luZGV4XSAtIGN1cnJlbnRWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFBST0NFU1NfVE9QOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKHgsIHksIHZhcmlhdGlvbnNbaW5kZXhdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFyaWF0aW9uc1tpbmRleF0gPT09IDApIHsgLy8gd2UgbG9vayBmb3IgbWF4aW1hXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdaRVJPJywgY3VycmVudElELCB4LCB5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgd2UgYXJlIG5leHQgdG8gYSBib3JkZXIgLi4uIGl0IGlzIG5vdCBzdXJyb3VuZGVkICFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHggPT09IDAgfHwgeSA9PT0gMCB8fCB4ID09PSAoaW1hZ2Uud2lkdGggLSAxKSB8fCB5ID09PSAoaW1hZ2UuaGVpZ2h0IC0gMSkpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGl4ZWxzW2luZGV4XSA9IGN1cnJlbnRJRDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeFRvUHJvY2Vzc1RvcFt0b1RvcCAmIE1BWF9BUlJBWV0gPSB4O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5VG9Qcm9jZXNzVG9wW3RvVG9wICYgTUFYX0FSUkFZXSA9IHk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvVG9wKys7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh2YXJpYXRpb25zW2luZGV4XSA+IDApIHsgLy8gbm90IGEgZ2xvYmFsIG1heGltdW1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ0xBUkdFUicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsgLy8gYSBwb2ludCB3ZSB3aWxsIGhhdmUgdG8gcHJvY2Vzc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW9ubHlUb3ApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBpeGVsc1tpbmRleF0gPSBjdXJyZW50SUQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4VG9Qcm9jZXNzW3RvICYgTUFYX0FSUkFZXSA9IHg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5VG9Qcm9jZXNzW3RvICYgTUFYX0FSUkFZXSA9IHk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0bysrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBQUk9DRVNTX05PUk1BTDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFyaWF0aW9uc1tpbmRleF0gPD0gMCkgeyAvLyB3ZSBsb29rIGZvciBtYXhpbWFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGl4ZWxzW2luZGV4XSA9IGN1cnJlbnRJRDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeFRvUHJvY2Vzc1t0byAmIE1BWF9BUlJBWV0gPSB4O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5VG9Qcm9jZXNzW3RvICYgTUFYX0FSUkFZXSA9IHk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvKys7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxufVxuXG4iLCIvKlxuV2Ugd2lsbCBhbm5vdGF0ZSBlYWNoIHBvaW50IHRvIGRlZmluZSB0byB3aGljaCBhcmVhIGl0IGJlbG9uZ3NcbiAqL1xuXG5pbXBvcnQgUk9JTWFwIGZyb20gJy4vLi4vUk9JTWFwJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY3JlYXRlUk9JTWFwRnJvbU1hc2sobWFzaywge2FsbG93Q29ybmVyID0gZmFsc2V9ID0ge30pIHtcblxuICAgIC8vIGJhc2VkIG9uIGEgYmluYXJ5IGltYWdlIHdlIHdpbGwgY3JlYXRlIHBsZW50eSBvZiBzbWFsbCBpbWFnZXNcbiAgICBsZXQgcGl4ZWxzID0gbmV3IEludDE2QXJyYXkobWFzay5zaXplKTsgLy8gbWF4VmFsdWU6IDMyNzY3LCBtaW5WYWx1ZTogLTMyNzY4XG5cbiAgICAvLyBzcGxpdCB3aWxsIGFsd2F5cyByZXR1cm4gYW4gYXJyYXkgb2YgaW1hZ2VzXG4gICAgbGV0IHBvc2l0aXZlSUQgPSAwO1xuICAgIGxldCBuZWdhdGl2ZUlEID0gMDtcblxuICAgIGxldCBNQVhfQVJSQVkgPSAweDAwZmZmZjsgLy8gc2hvdWxkIGJlIGVub3VnaCBmb3IgbW9zdCBvZiB0aGUgY2FzZXNcbiAgICBsZXQgeFRvUHJvY2VzcyA9IG5ldyBVaW50MTZBcnJheShNQVhfQVJSQVkgKyAxKTsgLy8gYXNzaWduIGR5bmFtaWNhbGx5ID8/Pz9cbiAgICBsZXQgeVRvUHJvY2VzcyA9IG5ldyBVaW50MTZBcnJheShNQVhfQVJSQVkgKyAxKTsgLy8gbWFzayArMSBpcyBvZiBjb3Vyc2UgbWFuZGF0b3J5ICEhIVxuXG5cbiAgICBmb3IgKGxldCB4ID0gMDsgeCA8IG1hc2sud2lkdGg7IHgrKykge1xuICAgICAgICBmb3IgKGxldCB5ID0gMDsgeSA8IG1hc2suaGVpZ2h0OyB5KyspIHtcbiAgICAgICAgICAgIGlmIChwaXhlbHNbeSAqIG1hc2sud2lkdGggKyB4XSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIC8vIG5lZWQgdG8gcHJvY2VzcyB0aGUgd2hvbGUgc3VyZmFjZVxuICAgICAgICAgICAgICAgIGFuYWx5c2VTdXJmYWNlKHgsIHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYW5hbHlzZVN1cmZhY2UoeCwgeSkge1xuICAgICAgICBsZXQgZnJvbSA9IDA7XG4gICAgICAgIGxldCB0byA9IDA7XG4gICAgICAgIGxldCB0YXJnZXRTdGF0ZSA9IG1hc2suZ2V0Qml0WFkoeCwgeSk7XG4gICAgICAgIGxldCBpZCA9IHRhcmdldFN0YXRlID8gKytwb3NpdGl2ZUlEIDogLS1uZWdhdGl2ZUlEO1xuICAgICAgICB4VG9Qcm9jZXNzWzBdID0geDtcbiAgICAgICAgeVRvUHJvY2Vzc1swXSA9IHk7XG4gICAgICAgIHdoaWxlIChmcm9tIDw9IHRvKSB7XG4gICAgICAgICAgICBsZXQgY3VycmVudFggPSB4VG9Qcm9jZXNzW2Zyb20gJiBNQVhfQVJSQVldO1xuICAgICAgICAgICAgbGV0IGN1cnJlbnRZID0geVRvUHJvY2Vzc1tmcm9tICYgTUFYX0FSUkFZXTtcbiAgICAgICAgICAgIHBpeGVsc1tjdXJyZW50WSAqIG1hc2sud2lkdGggKyBjdXJyZW50WF0gPSBpZDtcbiAgICAgICAgICAgIC8vIG5lZWQgdG8gY2hlY2sgYWxsIGFyb3VuZCBtYXNrIHBpeGVsXG4gICAgICAgICAgICBpZiAoY3VycmVudFggPiAwICYmIHBpeGVsc1tjdXJyZW50WSAqIG1hc2sud2lkdGggKyBjdXJyZW50WCAtIDFdID09PSAwICYmXG4gICAgICAgICAgICAgICAgbWFzay5nZXRCaXRYWShjdXJyZW50WCAtIDEsIGN1cnJlbnRZKSA9PT0gdGFyZ2V0U3RhdGUpIHtcbiAgICAgICAgICAgICAgICAvLyBMRUZUXG4gICAgICAgICAgICAgICAgdG8rKztcbiAgICAgICAgICAgICAgICB4VG9Qcm9jZXNzW3RvICYgTUFYX0FSUkFZXSA9IGN1cnJlbnRYIC0gMTtcbiAgICAgICAgICAgICAgICB5VG9Qcm9jZXNzW3RvICYgTUFYX0FSUkFZXSA9IGN1cnJlbnRZO1xuICAgICAgICAgICAgICAgIHBpeGVsc1tjdXJyZW50WSAqIG1hc2sud2lkdGggKyBjdXJyZW50WCAtIDFdID0gLTMyNzY4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGN1cnJlbnRZID4gMCAmJiBwaXhlbHNbKGN1cnJlbnRZIC0gMSkgKiBtYXNrLndpZHRoICsgY3VycmVudFhdID09PSAwICYmXG4gICAgICAgICAgICAgICAgbWFzay5nZXRCaXRYWShjdXJyZW50WCwgY3VycmVudFkgLSAxKSA9PT0gdGFyZ2V0U3RhdGUpIHtcbiAgICAgICAgICAgICAgICAvLyBUT1BcbiAgICAgICAgICAgICAgICB0bysrO1xuICAgICAgICAgICAgICAgIHhUb1Byb2Nlc3NbdG8gJiBNQVhfQVJSQVldID0gY3VycmVudFg7XG4gICAgICAgICAgICAgICAgeVRvUHJvY2Vzc1t0byAmIE1BWF9BUlJBWV0gPSBjdXJyZW50WSAtIDE7XG4gICAgICAgICAgICAgICAgcGl4ZWxzWyhjdXJyZW50WSAtIDEpICogbWFzay53aWR0aCArIGN1cnJlbnRYXSA9IC0zMjc2ODtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjdXJyZW50WCA8IG1hc2sud2lkdGggLSAxICYmIHBpeGVsc1tjdXJyZW50WSAqIG1hc2sud2lkdGggKyBjdXJyZW50WCArIDFdID09PSAwICYmXG4gICAgICAgICAgICAgICAgbWFzay5nZXRCaXRYWShjdXJyZW50WCArIDEsIGN1cnJlbnRZKSA9PT0gdGFyZ2V0U3RhdGUpIHtcbiAgICAgICAgICAgICAgICAvLyBSSUdIVFxuICAgICAgICAgICAgICAgIHRvKys7XG4gICAgICAgICAgICAgICAgeFRvUHJvY2Vzc1t0byAmIE1BWF9BUlJBWV0gPSBjdXJyZW50WCArIDE7XG4gICAgICAgICAgICAgICAgeVRvUHJvY2Vzc1t0byAmIE1BWF9BUlJBWV0gPSBjdXJyZW50WTtcbiAgICAgICAgICAgICAgICBwaXhlbHNbY3VycmVudFkgKiBtYXNrLndpZHRoICsgY3VycmVudFggKyAxXSA9IC0zMjc2ODtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjdXJyZW50WSA8IG1hc2suaGVpZ2h0IC0gMSAmJiBwaXhlbHNbKGN1cnJlbnRZICsgMSkgKiBtYXNrLndpZHRoICsgY3VycmVudFhdID09PSAwICYmXG4gICAgICAgICAgICAgICAgbWFzay5nZXRCaXRYWShjdXJyZW50WCwgY3VycmVudFkgKyAxKSA9PT0gdGFyZ2V0U3RhdGUpIHtcbiAgICAgICAgICAgICAgICAvLyBCT1RUT01cbiAgICAgICAgICAgICAgICB0bysrO1xuICAgICAgICAgICAgICAgIHhUb1Byb2Nlc3NbdG8gJiBNQVhfQVJSQVldID0gY3VycmVudFg7XG4gICAgICAgICAgICAgICAgeVRvUHJvY2Vzc1t0byAmIE1BWF9BUlJBWV0gPSBjdXJyZW50WSArIDE7XG4gICAgICAgICAgICAgICAgcGl4ZWxzWyhjdXJyZW50WSArIDEpICogbWFzay53aWR0aCArIGN1cnJlbnRYXSA9IC0zMjc2ODtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhbGxvd0Nvcm5lcikge1xuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50WCA+IDAgJiYgY3VycmVudFkgPiAwICYmIHBpeGVsc1soY3VycmVudFkgLSAxKSAqIG1hc2sud2lkdGggKyBjdXJyZW50WCAtIDFdID09PSAwICYmXG4gICAgICAgICAgICAgICAgICAgIG1hc2suZ2V0Qml0WFkoY3VycmVudFggLSAxLCBjdXJyZW50WSAtIDEpID09PSB0YXJnZXRTdGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBUT1AgTEVGVFxuICAgICAgICAgICAgICAgICAgICB0bysrO1xuICAgICAgICAgICAgICAgICAgICB4VG9Qcm9jZXNzW3RvICYgTUFYX0FSUkFZXSA9IGN1cnJlbnRYIC0gMTtcbiAgICAgICAgICAgICAgICAgICAgeVRvUHJvY2Vzc1t0byAmIE1BWF9BUlJBWV0gPSBjdXJyZW50WSAtIDE7XG4gICAgICAgICAgICAgICAgICAgIHBpeGVsc1soY3VycmVudFkgLSAxKSAqIG1hc2sud2lkdGggKyBjdXJyZW50WCAtIDFdID0gLTMyNzY4O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudFggPCBtYXNrLndpZHRoIC0gMSAmJiBjdXJyZW50WSA+IDAgJiYgcGl4ZWxzWyhjdXJyZW50WSAtIDEpICogbWFzay53aWR0aCArIGN1cnJlbnRYICsgMV0gPT09IDAgJiZcbiAgICAgICAgICAgICAgICAgICAgbWFzay5nZXRCaXRYWShjdXJyZW50WCArIDEsIGN1cnJlbnRZIC0gMSkgPT09IHRhcmdldFN0YXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRPUCBSSUdIVFxuICAgICAgICAgICAgICAgICAgICB0bysrO1xuICAgICAgICAgICAgICAgICAgICB4VG9Qcm9jZXNzW3RvICYgTUFYX0FSUkFZXSA9IGN1cnJlbnRYICsgMTtcbiAgICAgICAgICAgICAgICAgICAgeVRvUHJvY2Vzc1t0byAmIE1BWF9BUlJBWV0gPSBjdXJyZW50WSAtIDE7XG4gICAgICAgICAgICAgICAgICAgIHBpeGVsc1soY3VycmVudFkgLSAxKSAqIG1hc2sud2lkdGggKyBjdXJyZW50WCArIDFdID0gLTMyNzY4O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudFggPiAwICYmIGN1cnJlbnRZIDwgbWFzay5oZWlnaHQgLSAxICYmIHBpeGVsc1soY3VycmVudFkgKyAxKSAqIG1hc2sud2lkdGggKyBjdXJyZW50WCAtIDFdID09PSAwICYmXG4gICAgICAgICAgICAgICAgICAgIG1hc2suZ2V0Qml0WFkoY3VycmVudFggLSAxLCBjdXJyZW50WSArIDEpID09PSB0YXJnZXRTdGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBCT1RUT00gTEVGVFxuICAgICAgICAgICAgICAgICAgICB0bysrO1xuICAgICAgICAgICAgICAgICAgICB4VG9Qcm9jZXNzW3RvICYgTUFYX0FSUkFZXSA9IGN1cnJlbnRYIC0gMTtcbiAgICAgICAgICAgICAgICAgICAgeVRvUHJvY2Vzc1t0byAmIE1BWF9BUlJBWV0gPSBjdXJyZW50WSArIDE7XG4gICAgICAgICAgICAgICAgICAgIHBpeGVsc1soY3VycmVudFkgKyAxKSAqIG1hc2sud2lkdGggKyBjdXJyZW50WCAtIDFdID0gLTMyNzY4O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudFggPCBtYXNrLndpZHRoIC0gMSAmJiBjdXJyZW50WSA8IG1hc2suaGVpZ2h0IC0gMSAmJiBwaXhlbHNbKGN1cnJlbnRZICsgMSkgKiBtYXNrLndpZHRoICsgY3VycmVudFggKyAxXSA9PT0gMCAmJlxuICAgICAgICAgICAgICAgICAgICBtYXNrLmdldEJpdFhZKGN1cnJlbnRYICsgMSwgY3VycmVudFkgKyAxKSA9PT0gdGFyZ2V0U3RhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQk9UVE9NIFJJR0hUXG4gICAgICAgICAgICAgICAgICAgIHRvKys7XG4gICAgICAgICAgICAgICAgICAgIHhUb1Byb2Nlc3NbdG8gJiBNQVhfQVJSQVldID0gY3VycmVudFggKyAxO1xuICAgICAgICAgICAgICAgICAgICB5VG9Qcm9jZXNzW3RvICYgTUFYX0FSUkFZXSA9IGN1cnJlbnRZICsgMTtcbiAgICAgICAgICAgICAgICAgICAgcGl4ZWxzWyhjdXJyZW50WSArIDEpICogbWFzay53aWR0aCArIGN1cnJlbnRYICsgMV0gPSAtMzI3Njg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG5cbiAgICAgICAgICAgIGZyb20rKztcblxuICAgICAgICAgICAgaWYgKCh0byAtIGZyb20pID4gTUFYX0FSUkFZKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhbmFseXNlTWFzayBjYW4gbm90IGZpbmlzaCwgdGhlIGFycmF5IHRvIG1hbmFnZSBpbnRlcm5hbCBkYXRhIGlzIG5vdCBiaWcgZW5vdWdoLicgK1xuICAgICAgICAgICAgICAgICAgICAnWW91IGNvdWxkIGltcHJvdmUgbWFzayBieSBjaGFuZ2luZyBNQVhfQVJSQVknKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBuZXcgUk9JTWFwKG1hc2ssIHBpeGVscywgbmVnYXRpdmVJRCwgcG9zaXRpdmVJRCk7XG5cbn1cbiIsIi8qXG5XZSB3aWxsIGFubm90YXRlIGVhY2ggcG9pbnQgdG8gZGVmaW5lIHRvIHdoaWNoIGFyZWEgaXQgYmVsb25nc1xuICovXG5cbmltcG9ydCBST0lNYXAgZnJvbSAnLi8uLi9ST0lNYXAnO1xuaW1wb3J0IFNoYXBlIGZyb20gJy4vLi4vLi4vLi4vdXRpbC9zaGFwZSc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGZyb21Db29yZGluYXRlcyhwaXhlbHNUb1BhaW50LCBvcHRpb25zID0ge30pIHtcbiAgICBsZXQgc2hhcGUgPSBuZXcgU2hhcGUob3B0aW9ucyk7XG5cbiAgICAvLyBiYXNlZCBvbiBhIGJpbmFyeSBpbWFnZSB3ZSB3aWxsIGNyZWF0ZSBwbGVudHkgb2Ygc21hbGwgaW1hZ2VzXG4gICAgbGV0IG1hcFBpeGVscyA9IG5ldyBJbnQxNkFycmF5KHRoaXMuc2l6ZSk7IC8vIG1heFZhbHVlOiAzMjc2NywgbWluVmFsdWU6IC0zMjc2OFxuICAgIGxldCBwb3NpdGl2ZUlEID0gMDtcbiAgICBsZXQgc2hhcGVQaXhlbHMgPSBzaGFwZS5nZXRQaXhlbHMoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBpeGVsc1RvUGFpbnQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcG9zaXRpdmVJRCsrO1xuICAgICAgICBsZXQgeFAgPSBwaXhlbHNUb1BhaW50W2ldWzBdO1xuICAgICAgICBsZXQgeVAgPSBwaXhlbHNUb1BhaW50W2ldWzFdO1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHNoYXBlUGl4ZWxzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBsZXQgeFMgPSBzaGFwZVBpeGVsc1tqXVswXTtcbiAgICAgICAgICAgIGxldCB5UyA9IHNoYXBlUGl4ZWxzW2pdWzFdO1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICgoeFAgKyB4UykgPj0gMCkgJiZcbiAgICAgICAgICAgICAgICAoKHlQICsgeVMpID49IDApICYmXG4gICAgICAgICAgICAgICAgKCh4UCArIHhTKSA8IHRoaXMud2lkdGgpICYmXG4gICAgICAgICAgICAgICAgKCh5UCArIHlTKSA8IHRoaXMuaGVpZ2h0KVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgbWFwUGl4ZWxzW3hQICsgeFMgKyAoeVAgKyB5UykgKiB0aGlzLndpZHRoXSA9IHBvc2l0aXZlSUQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5ldyBST0lNYXAodGhpcywgbWFwUGl4ZWxzLCAwLCBwb3NpdGl2ZUlEKTtcbn1cbiIsImltcG9ydCBmcm9tTWFzayBmcm9tICcuL2NyZWF0b3IvZnJvbU1hc2snO1xuaW1wb3J0IGZyb21FeHRyZW1hIGZyb20gJy4vY3JlYXRvci9mcm9tRXh0cmVtYSc7XG5pbXBvcnQgZnJvbUNvb3JkaW5hdGVzIGZyb20gJy4vY3JlYXRvci9mcm9tUGl4ZWxzJztcbmltcG9ydCBjcmVhdGVST0kgZnJvbSAnLi9jcmVhdGVST0knO1xuaW1wb3J0IGV4dGVuZE9iamVjdCBmcm9tICdleHRlbmQnO1xuaW1wb3J0IEltYWdlIGZyb20gJy4uL2ltYWdlJztcblxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBST0lNYW5hZ2VyIHtcblxuICAgIGNvbnN0cnVjdG9yKGltYWdlLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgdGhpcy5faW1hZ2UgPSBpbWFnZTtcbiAgICAgICAgdGhpcy5fb3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIGlmICghdGhpcy5fb3B0aW9ucy5sZWJlbCkgdGhpcy5fb3B0aW9ucy5sYWJlbCA9ICdkZWZhdWx0JztcbiAgICAgICAgdGhpcy5fbGF5ZXJzID0ge307XG4gICAgICAgIHRoaXMuX3BhaW50ZWQgPSBudWxsO1xuICAgIH1cblxuICAgIGdlbmVyYXRlUk9JRnJvbUV4dHJlbWEob3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGxldCBvcHQgPSBleHRlbmRPYmplY3Qoe30sIHRoaXMuX29wdGlvbnMsIG9wdGlvbnMpO1xuICAgICAgICBsZXQgcm9pTWFwID0gZnJvbUV4dHJlbWEuY2FsbCh0aGlzLl9pbWFnZSwgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMuX2xheWVyc1tvcHQubGFiZWxdID0gbmV3IFJPSUxheWVyKHJvaU1hcCwgb3B0KTtcbiAgICB9XG5cbiAgICBwdXRQaXhlbHMocGl4ZWxzLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgbGV0IG9wdCA9IGV4dGVuZE9iamVjdCh7fSwgdGhpcy5fb3B0aW9ucywgb3B0aW9ucyk7XG4gICAgICAgIGxldCByb2lNYXAgPSBmcm9tQ29vcmRpbmF0ZXMuY2FsbCh0aGlzLl9pbWFnZSwgcGl4ZWxzLCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy5fbGF5ZXJzW29wdC5sYWJlbF0gPSBuZXcgUk9JTGF5ZXIocm9pTWFwLCBvcHQpO1xuICAgIH1cblxuICAgIHB1dE1hcChyb2lNYXAsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBsZXQgb3B0ID0gZXh0ZW5kT2JqZWN0KHt9LCB0aGlzLl9vcHRpb25zLCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy5fbGF5ZXJzW29wdC5sYWJlbF0gPSBuZXcgUk9JTGF5ZXIocm9pTWFwLCBvcHQpO1xuICAgIH1cblxuICAgIHB1dE1hc2sobWFzaywgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGxldCBvcHQgPSBleHRlbmRPYmplY3Qoe30sIHRoaXMuX29wdGlvbnMsIG9wdGlvbnMpO1xuICAgICAgICBsZXQgcm9pTWFwID0gZnJvbU1hc2suY2FsbCh0aGlzLl9pbWFnZSwgbWFzaywgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMuX2xheWVyc1tvcHQubGFiZWxdID0gbmV3IFJPSUxheWVyKHJvaU1hcCwgb3B0KTtcbiAgICB9XG5cbiAgICBnZXRNYXAob3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGxldCBvcHQgPSBleHRlbmRPYmplY3Qoe30sIHRoaXMuX29wdGlvbnMsIG9wdGlvbnMpO1xuICAgICAgICBpZiAoIXRoaXMuX2xheWVyc1tvcHQubGFiZWxdKSByZXR1cm47XG4gICAgICAgIHJldHVybiB0aGlzLl9sYXllcnNbb3B0LmxhYmVsXS5yb2lNYXA7XG4gICAgfVxuXG4gICAgZ2V0Uk9JSURzKG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBsZXQgcm9pcyA9IHRoaXMuZ2V0Uk9JKG9wdGlvbnMpO1xuICAgICAgICBpZiAoIXJvaXMpIHJldHVybjtcbiAgICAgICAgbGV0IGlkcyA9IG5ldyBBcnJheShyb2lzLmxlbmd0aCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcm9pcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWRzW2ldID0gcm9pc1tpXS5pZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaWRzO1xuICAgIH1cblxuICAgIGdldFJPSSh7XG4gICAgICAgIGxhYmVsID0gdGhpcy5fb3B0aW9ucy5sYWJlbCxcbiAgICAgICAgcG9zaXRpdmUgPSB0cnVlLFxuICAgICAgICBuZWdhdGl2ZSA9IHRydWUsXG4gICAgICAgIG1pblN1cmZhY2UgPSAwLFxuICAgICAgICBtYXhTdXJmYWNlID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZXG4gICAgICAgIH0gPSB7fSkge1xuXG4gICAgICAgIGxldCBhbGxST0lzID0gdGhpcy5fbGF5ZXJzW2xhYmVsXS5yb2k7XG4gICAgICAgIGxldCByb2lzID0gbmV3IEFycmF5KGFsbFJPSXMubGVuZ3RoKTtcbiAgICAgICAgbGV0IHB0ciA9IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYWxsUk9Jcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHJvaSA9IGFsbFJPSXNbaV07XG4gICAgICAgICAgICBpZiAoKChyb2kuaWQgPCAwICYmIG5lZ2F0aXZlKSB8fCByb2kuaWQgPiAwICYmIHBvc2l0aXZlKVxuICAgICAgICAgICAgICAgICYmIHJvaS5zdXJmYWNlID49IG1pblN1cmZhY2VcbiAgICAgICAgICAgICAgICAmJiByb2kuc3VyZmFjZSA8PSBtYXhTdXJmYWNlKSB7XG4gICAgICAgICAgICAgICAgcm9pc1twdHIrK10gPSByb2k7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcm9pcy5sZW5ndGggPSBwdHI7XG4gICAgICAgIHJldHVybiByb2lzO1xuICAgIH1cblxuICAgIGdldFJPSU1hc2tzKG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBsZXQgcm9pcyA9IHRoaXMuZ2V0Uk9JKG9wdGlvbnMpO1xuICAgICAgICBsZXQgbWFza3MgPSBuZXcgQXJyYXkocm9pcy5sZW5ndGgpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJvaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIG1hc2tzW2ldID0gcm9pc1tpXS5tYXNrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYXNrcztcbiAgICB9XG5cbiAgICBnZXRQaXhlbHMob3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGxldCBvcHQgPSBleHRlbmRPYmplY3Qoe30sIHRoaXMuX29wdGlvbnMsIG9wdGlvbnMpO1xuICAgICAgICBpZiAodGhpcy5fbGF5ZXJzW29wdC5sYWJlbF0pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9sYXllcnNbb3B0LmxhYmVsXS5yb2lNYXAucGl4ZWxzO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcGFpbnQob3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGlmICghdGhpcy5fcGFpbnRlZCkgdGhpcy5fcGFpbnRlZCA9IHRoaXMuX2ltYWdlLnJnYmE4KCk7XG4gICAgICAgIGxldCBtYXNrcyA9IHRoaXMuZ2V0Uk9JTWFza3Mob3B0aW9ucyk7XG4gICAgICAgIHRoaXMuX3BhaW50ZWQucGFpbnRNYXNrcyhtYXNrcywgb3B0aW9ucyk7XG4gICAgICAgIHJldHVybiB0aGlzLl9wYWludGVkO1xuICAgIH1cblxuICAgIC8vIHJldHVybiBhIG1hc2sgY29ycmVzcG9uZGluZyB0byBhbGwgdGhlIHNlbGVjdGVkIG1hc2tzXG4gICAgZ2V0TWFzayhvcHRpb25zID0ge30pIHtcbiAgICAgICAgbGV0IG1hc2sgPSBuZXcgSW1hZ2UodGhpcy5faW1hZ2Uud2lkdGgsIHRoaXMuX2ltYWdlLmhlaWdodCwge2tpbmQ6J0JJTkFSWSd9KTtcbiAgICAgICAgbGV0IG1hc2tzID0gdGhpcy5nZXRST0lNYXNrcyhvcHRpb25zKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHJvaSA9IG1hc2tzW2ldO1xuICAgICAgICAgICAgLy8gd2UgbmVlZCB0byBmaW5kIHRoZSBwYXJlbnQgaW1hZ2UgdG8gY2FsY3VsYXRlIHRoZSByZWxhdGl2ZSBwb3NpdGlvblxuXG4gICAgICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IHJvaS53aWR0aDsgeCsrKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgeSA9IDA7IHkgPCByb2kuaGVpZ2h0OyB5KyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJvaS5nZXRCaXRYWSh4LCB5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWFzay5zZXRCaXRYWSh4ICsgcm9pLnBvc2l0aW9uWzBdLCB5ICsgcm9pLnBvc2l0aW9uWzFdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWFzaztcbiAgICB9XG5cblxuICAgIHJlc2V0UGFpbnRlZChpbWFnZSkge1xuICAgICAgICB0aGlzLl9wYWludGVkID0gaW1hZ2U7XG4gICAgfVxufVxuXG5jbGFzcyBST0lMYXllciB7XG4gICAgY29uc3RydWN0b3Iocm9pTWFwLCBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMucm9pTWFwID0gcm9pTWFwO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB0aGlzLnJvaSA9IGNyZWF0ZVJPSSh0aGlzLnJvaU1hcCk7XG4gICAgfVxufVxuIiwiaW1wb3J0IEltYWdlIGZyb20gJy4uL2ltYWdlJztcbmltcG9ydCAqIGFzIEtpbmROYW1lcyBmcm9tICcuLi9raW5kTmFtZXMnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBST0kge1xuXG4gICAgY29uc3RydWN0b3IobWFwLCBpZCkge1xuICAgICAgICB0aGlzLm1hcCA9IG1hcDtcbiAgICAgICAgdGhpcy5pZCA9IGlkO1xuICAgICAgICB0aGlzLm1pblggPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gICAgICAgIHRoaXMubWF4WCA9IE51bWJlci5ORUdBVElWRV9JTkZJTklUWTtcbiAgICAgICAgdGhpcy5taW5ZID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICAgICAgICB0aGlzLm1heFkgPSBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFk7XG4gICAgICAgIHRoaXMubWVhblggPSAwO1xuICAgICAgICB0aGlzLm1lYW5ZID0gMDtcbiAgICAgICAgdGhpcy5zdXJmYWNlID0gMDtcbiAgICAgICAgdGhpcy5jb21wdXRlZCA9IHt9O1xuICAgIH1cblxuICAgIGdldE1hc2soe2ZpbGwgPSBmYWxzZSwgc2NhbGUgPSAxfSA9IHt9KSB7XG4gICAgICAgIGxldCBtYXNrO1xuICAgICAgICBpZiAoZmlsbCkge1xuICAgICAgICAgICAgbWFzayA9IHRoaXMuZmlsbGVkTWFzaztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1hc2sgPSB0aGlzLm1hc2s7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2NhbGUgPCAxKSB7XG4gICAgICAgICAgICBtYXNrID0gbWFzay5yZXNpemVCaW5hcnkoc2NhbGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG1hc2s7XG4gICAgfVxuXG4gICAgZ2V0IHdpZHRoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tYXhYIC0gdGhpcy5taW5YICsgMTtcbiAgICB9XG5cbiAgICBnZXQgaGVpZ2h0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tYXhZIC0gdGhpcy5taW5ZICsgMTtcbiAgICB9XG5cbiAgICBnZXQgc3Vycm91bmQoKSB7XG4gICAgICAgIGlmICh0aGlzLmNvbXB1dGVkLnN1cnJvdW5kKSByZXR1cm4gdGhpcy5jb21wdXRlZC5zdXJyb3VuZDtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcHV0ZWQuc3Vycm91bmQgPSBnZXRTdXJyb3VuZGluZ0lEcyh0aGlzKTtcbiAgICB9XG5cbiAgICBnZXQgaW50ZXJuYWxNYXBJRHMoKSB7XG4gICAgICAgIGlmICh0aGlzLmNvbXB1dGVkLmludGVybmFsTWFwSURzKSByZXR1cm4gdGhpcy5jb21wdXRlZC5pbnRlcm5hbE1hcElEcztcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcHV0ZWQuaW50ZXJuYWxNYXBJRHMgPSBnZXRJbnRlcm5hbE1hcElEcyh0aGlzKTtcbiAgICB9XG5cbiAgICBnZXQgZXh0ZXJuYWwoKSB7IC8vIHBvaW50cyBvZiB0aGUgUk9JIHRoYXQgdG91Y2ggdGhlIHJlY3Rhbmd1bGFyIHNoYXBlXG4gICAgICAgIGlmICh0aGlzLmNvbXB1dGVkLmV4dGVybmFsKSByZXR1cm4gdGhpcy5jb21wdXRlZC5leHRlcm5hbDtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcHV0ZWQuZXh0ZXJuYWwgPSBnZXRFeHRlcm5hbCh0aGlzKTtcbiAgICB9XG5cbiAgICBnZXQgY29udG91cigpIHtcbiAgICAgICAgaWYgKHRoaXMuY29tcHV0ZWQuY29udG91cikgcmV0dXJuIHRoaXMuY29tcHV0ZWQuY29udG91cjtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcHV0ZWQuY29udG91ciA9IGdldENvbnRvdXIodGhpcyk7XG4gICAgfVxuXG4gICAgZ2V0IGJvcmRlcigpIHtcbiAgICAgICAgaWYgKHRoaXMuY29tcHV0ZWQuYm9yZGVyKSByZXR1cm4gdGhpcy5jb21wdXRlZC5ib3JkZXI7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXB1dGVkLmJvcmRlciA9IGdldEJvcmRlcih0aGlzKTtcbiAgICB9XG5cbiAgICBnZXQgbWFzaygpIHtcbiAgICAgICAgaWYgKHRoaXMuY29tcHV0ZWQubWFzaykgcmV0dXJuIHRoaXMuY29tcHV0ZWQubWFzaztcblxuICAgICAgICBsZXQgaW1nID0gbmV3IEltYWdlKHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0LCB7XG4gICAgICAgICAgICBraW5kOiBLaW5kTmFtZXMuQklOQVJZLFxuICAgICAgICAgICAgcG9zaXRpb246IFt0aGlzLm1pblgsIHRoaXMubWluWV0sXG4gICAgICAgICAgICBwYXJlbnQ6IHRoaXMubWFwLnBhcmVudFxuICAgICAgICB9KTtcblxuICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IHRoaXMud2lkdGg7IHgrKykge1xuICAgICAgICAgICAgZm9yIChsZXQgeSA9IDA7IHkgPCB0aGlzLmhlaWdodDsgeSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubWFwLnBpeGVsc1t4ICsgdGhpcy5taW5YICsgKHkgKyB0aGlzLm1pblkpICogdGhpcy5tYXAud2lkdGhdID09PSB0aGlzLmlkKSB7XG4gICAgICAgICAgICAgICAgICAgIGltZy5zZXRCaXRYWSh4LCB5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcHV0ZWQubWFzayA9IGltZztcbiAgICB9XG5cbiAgICBnZXQgZmlsbGVkTWFzaygpIHtcbiAgICAgICAgaWYgKHRoaXMuY29tcHV0ZWQuZmlsbGVkTWFzaykgcmV0dXJuIHRoaXMuY29tcHV0ZWQuZmlsbGVkTWFzaztcblxuICAgICAgICBsZXQgaW1nID0gbmV3IEltYWdlKHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0LCB7XG4gICAgICAgICAgICBraW5kOiBLaW5kTmFtZXMuQklOQVJZLFxuICAgICAgICAgICAgcG9zaXRpb246IFt0aGlzLm1pblgsIHRoaXMubWluWV0sXG4gICAgICAgICAgICBwYXJlbnQ6IHRoaXMubWFwLnBhcmVudFxuICAgICAgICB9KTtcblxuICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IHRoaXMud2lkdGg7IHgrKykge1xuICAgICAgICAgICAgZm9yIChsZXQgeSA9IDA7IHkgPCB0aGlzLmhlaWdodDsgeSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IHRhcmdldCA9IHggKyB0aGlzLm1pblggKyAoeSArIHRoaXMubWluWSkgKiB0aGlzLm1hcC53aWR0aDtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pbnRlcm5hbE1hcElEcy5pbmRleE9mKHRoaXMubWFwLnBpeGVsc1t0YXJnZXRdKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGltZy5zZXRCaXRYWSh4LCB5KTtcbiAgICAgICAgICAgICAgICB9IC8vIGJ5IGRlZmF1bHQgYSBwaXhlbCBpcyB0byAwIHNvIG5vIHByb2JsZW1zLCBpdCB3aWxsIGJlIHRyYW5zcGFyZW50XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5jb21wdXRlZC5maWxsZWRNYXNrID0gaW1nO1xuICAgIH1cbn1cblxuXG4vKiBpdCBzaG91bGQgcmVhbGx5IGJlIGFuIGFycmF5IHRvIHNvbHZlIGNvbXBsZXggY2FzZXMgcmVsYXRlZCB0byBib3JkZXIgZWZmZWN0XG4gTGlrZSB0aGUgaW1hZ2VcbiAwMDAwXG4gMTExMVxuIDAwMDBcbiAxMTExXG5cbiBUaGUgZmlyc3Qgcm93IG9mIDEgd2lsbCBiZSBzdXJyb3VuZWQgYnkgMiBkaWZmZXJlbnRzIHpvbmVzXG5cbiBPciBldmVuIHdvcnNlXG4gMDEwXG4gMTExXG4gMDEwXG4gVGhlIGNyb3NzIHdpbGwgYmUgc3Vycm91bmVkIGJ5IDQgZGlmZmVyZW50cyB6b25lc1xuXG4gSG93ZXZlciBpbiBtb3N0IG9mIHRoZSBjYXNlcyBpdCB3aWxsIGJlIGFuIGFycmF5IG9mIG9uZSBlbGVtZW50XG4gKi9cblxuZnVuY3Rpb24gZ2V0U3Vycm91bmRpbmdJRHMocm9pKSB7XG4gICAgbGV0IHN1cnJvdW5kaW5nID0gbmV3IEFycmF5KDEpO1xuXG4gICAgbGV0IHB0ciA9IDA7XG4gICAgbGV0IHJvaU1hcCA9IHJvaS5tYXA7XG4gICAgbGV0IHBpeGVscyA9IHJvaU1hcC5waXhlbHM7XG4gICAgLy8gd2UgY2hlY2sgdGhlIGZpcnN0IGxpbmUgYW5kIHRoZSBsYXN0IGxpbmVcbiAgICBsZXQgZnJvbVggPSBNYXRoLm1heChyb2kubWluWCwgMSk7XG4gICAgbGV0IHRvWCA9IE1hdGgubWluKHJvaS53aWR0aCwgcm9pTWFwLndpZHRoIC0gMik7XG5cbiAgICAvLyBub3Qgb3B0aW1pemVkICBpZiBoZWlnaHQ9MSAhXG4gICAgZm9yIChsZXQgeSBvZiBbMCwgcm9pLmhlaWdodCAtIDFdKSB7XG4gICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgcm9pLndpZHRoOyB4KyspIHtcbiAgICAgICAgICAgIGxldCB0YXJnZXQgPSAoeSArIHJvaS5taW5ZKSAqIHJvaU1hcC53aWR0aCArIHggKyByb2kubWluWDtcbiAgICAgICAgICAgIGlmICgoeCAtIHJvaS5taW5YKSA+IDAgJiYgcGl4ZWxzW3RhcmdldF0gPT09IHJvaS5pZCAmJiBwaXhlbHNbdGFyZ2V0IC0gMV0gIT09IHJvaS5pZCkge1xuICAgICAgICAgICAgICAgIGxldCB2YWx1ZSA9IHBpeGVsc1t0YXJnZXQgLSAxXTtcbiAgICAgICAgICAgICAgICBpZiAoc3Vycm91bmRpbmcuaW5kZXhPZih2YWx1ZSkgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1cnJvdW5kaW5nW3B0cisrXSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgocm9pTWFwLndpZHRoIC0geCAtIHJvaS5taW5YKSA+IDEgJiYgcGl4ZWxzW3RhcmdldF0gPT09IHJvaS5pZCAmJiBwaXhlbHNbdGFyZ2V0ICsgMV0gIT09IHJvaS5pZCkge1xuICAgICAgICAgICAgICAgIGxldCB2YWx1ZSA9IHBpeGVsc1t0YXJnZXQgKyAxXTtcbiAgICAgICAgICAgICAgICBpZiAoc3Vycm91bmRpbmcuaW5kZXhPZih2YWx1ZSkgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1cnJvdW5kaW5nW3B0cisrXSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgLy8gd2UgY2hlY2sgdGhlIGZpcnN0IGNvbHVtbiBhbmQgdGhlIGxhc3QgY29sdW1uXG4gICAgbGV0IGZyb21ZID0gTWF0aC5tYXgocm9pLm1pblksIDEpO1xuICAgIGxldCB0b1kgPSBNYXRoLm1pbihyb2kuaGVpZ2h0LCByb2lNYXAuaGVpZ2h0IC0gMik7XG4gICAgLy8gbm90IG9wdGltaXplZCAgaWYgd2lkdGg9MSAhXG4gICAgZm9yIChsZXQgeCBvZiBbMCwgcm9pLndpZHRoIC0gMV0pIHtcbiAgICAgICAgZm9yIChsZXQgeSA9IDA7IHkgPCByb2kuaGVpZ2h0OyB5KyspIHtcbiAgICAgICAgICAgIGxldCB0YXJnZXQgPSAoeSArIHJvaS5taW5ZKSAqIHJvaU1hcC53aWR0aCArIHggKyByb2kubWluWDtcbiAgICAgICAgICAgIGlmICgoeSAtIHJvaS5taW5ZKSA+IDAgJiYgcGl4ZWxzW3RhcmdldF0gPT09IHJvaS5pZCAmJiBwaXhlbHNbdGFyZ2V0IC0gcm9pTWFwLndpZHRoXSAhPT0gcm9pLmlkKSB7XG4gICAgICAgICAgICAgICAgbGV0IHZhbHVlID0gcGl4ZWxzW3RhcmdldCAtIHJvaU1hcC53aWR0aF07XG4gICAgICAgICAgICAgICAgaWYgKHN1cnJvdW5kaW5nLmluZGV4T2YodmFsdWUpID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICBzdXJyb3VuZGluZ1twdHIrK10gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKHJvaU1hcC5oZWlnaHQgLSB5IC0gcm9pLm1pblkpID4gMSAmJiBwaXhlbHNbdGFyZ2V0XSA9PT0gcm9pLmlkICYmIHBpeGVsc1t0YXJnZXQgKyByb2lNYXAud2lkdGhdICE9PSByb2kuaWQpIHtcbiAgICAgICAgICAgICAgICBsZXQgdmFsdWUgPSBwaXhlbHNbdGFyZ2V0ICsgcm9pTWFwLndpZHRoXTtcbiAgICAgICAgICAgICAgICBpZiAoc3Vycm91bmRpbmcuaW5kZXhPZih2YWx1ZSkgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1cnJvdW5kaW5nW3B0cisrXSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoc3Vycm91bmRpbmdbMF0gPT09IHVuZGVmaW5lZCkgcmV0dXJuIFswXTtcbiAgICByZXR1cm4gc3Vycm91bmRpbmc7IC8vIHRoZSBzZWxlY3Rpb24gdGFrZXMgdGhlIHdob2xlIHJlY3RhbmdsZVxufVxuXG5cbi8qXG4gV2UgZ2V0IHRoZSBudW1iZXIgb2YgcGl4ZWxzIG9mIHRoZSBST0kgdGhhdCB0b3VjaCB0aGUgcmVjdGFuZ2xlXG4gVGhpcyBpcyB1c2VmdWwgZm9yIHRoZSBjYWxjdWxhdGlvbiBvZiB0aGUgYm9yZGVyXG4gYmVjYXVzZSB3ZSB3aWxsIGlnbm9yZSB0aG9zZSBzcGVjaWFsIHBpeGVscyBvZiB0aGUgcmVjdGFuZ2xlXG4gYm9yZGVyIHRoYXQgZG9uJ3QgaGF2ZSBuZWlnaGJvdXJncyBhbGwgYXJvdW5kIHRoZW0uXG4gKi9cblxuZnVuY3Rpb24gZ2V0RXh0ZXJuYWwocm9pKSB7XG4gICAgbGV0IHRvdGFsID0gMDtcbiAgICBsZXQgcm9pTWFwID0gcm9pLm1hcDtcbiAgICBsZXQgcGl4ZWxzID0gcm9pTWFwLnBpeGVscztcblxuICAgIGxldCB0b3BCb3R0b20gPSBbMF07XG4gICAgaWYgKHJvaS5oZWlnaHQgPiAxKSB0b3BCb3R0b21bMV0gPSByb2kuaGVpZ2h0IC0gMTtcbiAgICBmb3IgKGxldCB5IG9mIHRvcEJvdHRvbSkge1xuICAgICAgICBmb3IgKGxldCB4ID0gMTsgeCA8IHJvaS53aWR0aCAtIDE7IHgrKykge1xuICAgICAgICAgICAgbGV0IHRhcmdldCA9ICh5ICsgcm9pLm1pblkpICogcm9pTWFwLndpZHRoICsgeCArIHJvaS5taW5YO1xuICAgICAgICAgICAgaWYgKHBpeGVsc1t0YXJnZXRdID09PSByb2kuaWQpIHtcbiAgICAgICAgICAgICAgICB0b3RhbCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgbGV0IGxlZnRSaWdodCA9IFswXTtcbiAgICBpZiAocm9pLndpZHRoID4gMSkgbGVmdFJpZ2h0WzFdID0gcm9pLndpZHRoIC0gMTtcbiAgICBmb3IgKGxldCB4IG9mIGxlZnRSaWdodCkge1xuICAgICAgICBmb3IgKGxldCB5ID0gMDsgeSA8IHJvaS5oZWlnaHQ7IHkrKykge1xuICAgICAgICAgICAgbGV0IHRhcmdldCA9ICh5ICsgcm9pLm1pblkpICogcm9pTWFwLndpZHRoICsgeCArIHJvaS5taW5YO1xuICAgICAgICAgICAgaWYgKHBpeGVsc1t0YXJnZXRdID09PSByb2kuaWQpIHtcbiAgICAgICAgICAgICAgICB0b3RhbCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0b3RhbDtcbn1cblxuLypcbiBXZSB3aWxsIGNhbGN1bGF0ZSB0aGUgbnVtYmVyIG9mIHBpeGVscyB0aGF0IGFyZSBpbnZvbHZlZCBpbiBib3JkZXJcbiBCb3JkZXIgYXJlIGFsbCB0aGUgcGl4ZWxzIHRoYXQgdG91Y2ggYW5vdGhlciBcInpvbmVcIi4gSXQgY291bGQgYmUgZXh0ZXJuYWxcbiBvciBpbnRlcm5hbFxuIEFsbCB0aGUgcGl4ZWxzIHRoYXQgdG91Y2ggdGhlIGJveCBhcmUgcGFydCBvZiB0aGUgYm9yZGVyIGFuZFxuIGFyZSBjYWxjdWxhdGVkIGluIHRoZSBnZXRCb3hQaXhlbHMgcHJvY2VkdXJlXG4gKi9cbmZ1bmN0aW9uIGdldEJvcmRlcihyb2kpIHtcbiAgICBsZXQgdG90YWwgPSAwO1xuICAgIGxldCByb2lNYXAgPSByb2kubWFwO1xuICAgIGxldCBwaXhlbHMgPSByb2lNYXAucGl4ZWxzO1xuXG4gICAgZm9yIChsZXQgeCA9IDE7IHggPCByb2kud2lkdGggLSAxOyB4KyspIHtcbiAgICAgICAgZm9yIChsZXQgeSA9IDE7IHkgPCByb2kuaGVpZ2h0IC0gMTsgeSsrKSB7XG4gICAgICAgICAgICBsZXQgdGFyZ2V0ID0gKHkgKyByb2kubWluWSkgKiByb2lNYXAud2lkdGggKyB4ICsgcm9pLm1pblg7XG4gICAgICAgICAgICBpZiAocGl4ZWxzW3RhcmdldF0gPT09IHJvaS5pZCkge1xuICAgICAgICAgICAgICAgIC8vIGlmIGEgcGl4ZWwgYXJvdW5kIGlzIG5vdCByb2kuaWQgaXQgaXMgYSBib3JkZXJcbiAgICAgICAgICAgICAgICBpZiAoKHBpeGVsc1t0YXJnZXQgLSAxXSAhPT0gcm9pLmlkKSB8fFxuICAgICAgICAgICAgICAgICAgICAocGl4ZWxzW3RhcmdldCArIDFdICE9PSByb2kuaWQpIHx8XG4gICAgICAgICAgICAgICAgICAgIChwaXhlbHNbdGFyZ2V0IC0gcm9pTWFwLndpZHRoXSAhPT0gcm9pLmlkKSB8fFxuICAgICAgICAgICAgICAgICAgICAocGl4ZWxzW3RhcmdldCArIHJvaU1hcC53aWR0aF0gIT09IHJvaS5pZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdG90YWwrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRvdGFsICsgcm9pLmV4dGVybmFsO1xufVxuXG4vKlxuIFdlIHdpbGwgY2FsY3VsYXRlIHRoZSBudW1iZXIgb2YgcGl4ZWxzIHRoYXQgYXJlIGluIHRoZSBleHRlcm5hbCBib3JkZXJcbiBDb250b3VyIGFyZSBhbGwgdGhlIHBpeGVscyB0aGF0IHRvdWNoIGFuIGV4dGVybmFsIFwiem9uZVwiLlxuIEFsbCB0aGUgcGl4ZWxzIHRoYXQgdG91Y2ggdGhlIGJveCBhcmUgcGFydCBvZiB0aGUgYm9yZGVyIGFuZFxuIGFyZSBjYWxjdWxhdGVkIGluIHRoZSBnZXRCb3hQaXhlbHMgcHJvY2VkdXJlXG4gKi9cbmZ1bmN0aW9uIGdldENvbnRvdXIocm9pKSB7XG4gICAgbGV0IHRvdGFsID0gMDtcbiAgICBsZXQgcm9pTWFwID0gcm9pLm1hcDtcbiAgICBsZXQgcGl4ZWxzID0gcm9pTWFwLnBpeGVscztcblxuICAgIGZvciAobGV0IHggPSAxOyB4IDwgcm9pLndpZHRoIC0gMTsgeCsrKSB7XG4gICAgICAgIGZvciAobGV0IHkgPSAxOyB5IDwgcm9pLmhlaWdodCAtIDE7IHkrKykge1xuICAgICAgICAgICAgbGV0IHRhcmdldCA9ICh5ICsgcm9pLm1pblkpICogcm9pTWFwLndpZHRoICsgeCArIHJvaS5taW5YO1xuICAgICAgICAgICAgaWYgKHBpeGVsc1t0YXJnZXRdID09PSByb2kuaWQpIHtcbiAgICAgICAgICAgICAgICAvLyBpZiBhIHBpeGVsIGFyb3VuZCBpcyBub3Qgcm9pLmlkIGl0IGlzIGEgYm9yZGVyXG4gICAgICAgICAgICAgICAgaWYgKChyb2kuc3Vycm91bmQuaW5kZXhPZihwaXhlbHNbdGFyZ2V0IC0gMV0pICE9PSAtMSkgfHxcbiAgICAgICAgICAgICAgICAgICAgKHJvaS5zdXJyb3VuZC5pbmRleE9mKHBpeGVsc1t0YXJnZXQgKyAxXSkgIT09IC0xKSB8fFxuICAgICAgICAgICAgICAgICAgICAocm9pLnN1cnJvdW5kLmluZGV4T2YocGl4ZWxzW3RhcmdldCAtIHJvaU1hcC53aWR0aF0pICE9PSAtMSkgfHxcbiAgICAgICAgICAgICAgICAgICAgKHJvaS5zdXJyb3VuZC5pbmRleE9mKHBpeGVsc1t0YXJnZXQgKyByb2lNYXAud2lkdGhdKSAhPT0gLTEpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRvdGFsKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0b3RhbCArIHJvaS5leHRlcm5hbDtcbn1cblxuLypcbldlIHdpbGwgY2FsY3VsYXRlIGFsbCB0aGUgaWRzIG9mIHRoZSBtYXAgdGhhdCBhcmUgXCJpbnRlcm5hbFwiXG5UaGlzIHdpbGwgYWxsb3cgdG8gZXh0cmFjdCB0aGUgJ3BsYWluJyBpbWFnZVxuICovXG5mdW5jdGlvbiBnZXRJbnRlcm5hbE1hcElEcyhyb2kpIHtcbiAgICBsZXQgaW50ZXJuYWwgPSBbcm9pLmlkXTtcbiAgICBsZXQgcm9pTWFwID0gcm9pLm1hcDtcbiAgICBsZXQgcGl4ZWxzID0gcm9pTWFwLnBpeGVscztcblxuXG5cbiAgICBpZiAocm9pLmhlaWdodCA+IDIpIHtcbiAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCByb2kud2lkdGg7IHgrKykge1xuICAgICAgICAgICAgbGV0IHRhcmdldCA9IChyb2kubWluWSkgKiByb2lNYXAud2lkdGggKyB4ICsgcm9pLm1pblg7XG4gICAgICAgICAgICBpZiAoaW50ZXJuYWwuaW5kZXhPZihwaXhlbHNbdGFyZ2V0XSkgPj0gMCkge1xuICAgICAgICAgICAgICAgIGxldCBpZCA9IHBpeGVsc1t0YXJnZXQgKyByb2lNYXAud2lkdGhdO1xuICAgICAgICAgICAgICAgIGlmICgoaW50ZXJuYWwuaW5kZXhPZihpZCkgPT09IC0xKSAmJiAocm9pLnN1cnJvdW5kLmluZGV4T2YoaWQpID09PSAtMSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaW50ZXJuYWwucHVzaChpZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgbGV0IGFycmF5ID0gbmV3IEFycmF5KDQpO1xuICAgIGZvciAobGV0IHggPSAxOyB4IDwgcm9pLndpZHRoIC0gMTsgeCsrKSB7XG4gICAgICAgIGZvciAobGV0IHkgPSAxOyB5IDwgcm9pLmhlaWdodCAtIDE7IHkrKykge1xuICAgICAgICAgICAgbGV0IHRhcmdldCA9ICh5ICsgcm9pLm1pblkpICogcm9pTWFwLndpZHRoICsgeCArIHJvaS5taW5YO1xuICAgICAgICAgICAgaWYgKGludGVybmFsLmluZGV4T2YocGl4ZWxzW3RhcmdldF0pID49IDApIHtcbiAgICAgICAgICAgICAgICAvLyB3ZSBjaGVjayBpZiBvbmUgb2YgdGhlIG5laWdoYm91ciBpcyBub3QgeWV0IGluXG5cbiAgICAgICAgICAgICAgICBhcnJheVswXSA9IHBpeGVsc1t0YXJnZXQgLSAxXTtcbiAgICAgICAgICAgICAgICBhcnJheVsxXSA9IHBpeGVsc1t0YXJnZXQgKyAxXTtcbiAgICAgICAgICAgICAgICBhcnJheVsyXSA9IHBpeGVsc1t0YXJnZXQgLSByb2lNYXAud2lkdGhdO1xuICAgICAgICAgICAgICAgIGFycmF5WzNdID0gcGl4ZWxzW3RhcmdldCArIHJvaU1hcC53aWR0aF07XG5cbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgaWQgPSBhcnJheVtpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKChpbnRlcm5hbC5pbmRleE9mKGlkKSA9PT0gLTEpICYmIChyb2kuc3Vycm91bmQuaW5kZXhPZihpZCkgPT09IC0xKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJuYWwucHVzaChpZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gaW50ZXJuYWw7XG59XG4iLCJpbXBvcnQgSW1hZ2UgZnJvbSAnLi4vaW1hZ2UnO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjb2xvckRlcHRoKG5ld0NvbG9yRGVwdGggPSA4KSB7XG5cbiAgICB0aGlzLmNoZWNrUHJvY2Vzc2FibGUoJ2NvbG9yRGVwdGgnLCB7XG4gICAgICAgIGJpdERlcHRoOiBbOCwgMTZdXG4gICAgfSk7XG5cbiAgICBpZiAoIX5bOCwxNl0uaW5kZXhPZihuZXdDb2xvckRlcHRoKSkgdGhyb3cgRXJyb3IoJ1lvdSBuZWVkIHRvIHNwZWNpZnkgdGhlIG5ldyBjb2xvckRlcHRoIGFzIDggb3IgMTYnKTtcblxuICAgIGlmICh0aGlzLmJpdERlcHRoID09PSBuZXdDb2xvckRlcHRoKSByZXR1cm4gdGhpcy5jbG9uZSgpO1xuXG4gICAgbGV0IG5ld0ltYWdlID0gSW1hZ2UuY3JlYXRlRnJvbSh0aGlzLCB7Yml0RGVwdGg6IG5ld0NvbG9yRGVwdGh9KTtcblxuICAgIGlmIChuZXdDb2xvckRlcHRoID09PSA4KSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5kYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBuZXdJbWFnZS5kYXRhW2ldID0gdGhpcy5kYXRhW2ldID4+IDg7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbmV3SW1hZ2UuZGF0YVtpXSA9IHRoaXMuZGF0YVtpXSA8PCA4IHwgdGhpcy5kYXRhW2ldO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ld0ltYWdlO1xufVxuIiwiaW1wb3J0IEltYWdlIGZyb20gJy4uL2ltYWdlJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY3JvcCh7XG4gICAgeCA9IDAsXG4gICAgeSA9IDAsXG4gICAgd2lkdGggPSB0aGlzLndpZHRoIC0geCxcbiAgICBoZWlnaHQgPSB0aGlzLmhlaWdodCAtIHlcbiAgICB9ID0ge30pIHtcblxuICAgIGlmICh4ID4gKHRoaXMud2lkdGggLSAxKSB8fCB5ID4gKHRoaXMuaGVpZ2h0IC0gMSkpXG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBjcm9wOiBvcmlnaW4gKHg6JHt4fSwgeToke3l9KSBvdXQgb2YgcmFuZ2UgKCR7dGhpcy53aWR0aCAtIDF9OyAke3RoaXMuaGVpZ2h0IC0gMX0pYCk7XG4gICAgaWYgKHdpZHRoIDw9IDAgfHwgaGVpZ2h0IDw9IDApXG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBjcm9wOiB3aWR0aCBhbmQgaGVpZ2h0ICh3aWR0aDoke3dpZHRofTsgaGVpZ2h0OiR7aGVpZ2h0fSkgbXVzdCBiZSBwb3NpdGl2ZSBudW1iZXJzYCk7XG4gICAgaWYgKHggPCAwIHx8IHkgPCAwKVxuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgY3JvcDogeCBhbmQgeSAoeDoke3h9LCB5OiR7eX0pIG11c3QgYmUgcG9zaXRpdmUgbnVtYmVyc2ApO1xuICAgIGlmICh3aWR0aCA+ICh0aGlzLndpZHRoIC0geCkgfHwgaGVpZ2h0ID4gKHRoaXMuaGVpZ2h0IC0geSkpXG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBjcm9wOiAoeDogJHt4fSwgeToke3l9LCB3aWR0aDoke3dpZHRofSwgaGVpZ2h0OiR7aGVpZ2h0fSkgc2l6ZSBpcyBvdXQgb2YgcmFuZ2VgKTtcblxuICAgIGxldCBuZXdJbWFnZSA9IEltYWdlLmNyZWF0ZUZyb20odGhpcywge3dpZHRoLCBoZWlnaHR9KTtcblxuICAgIGxldCB4V2lkdGggPSB3aWR0aCAqIHRoaXMuY2hhbm5lbHM7XG4gICAgbGV0IHkxID0geSArIGhlaWdodDtcblxuICAgIGxldCBwdHIgPSAwOyAvLyBwb2ludGVyIGZvciBuZXcgYXJyYXlcblxuICAgIGxldCBqTGVmdCA9IHggKiB0aGlzLmNoYW5uZWxzO1xuXG4gICAgZm9yIChsZXQgaSA9IHk7IGkgPCB5MTsgaSsrKSB7XG4gICAgICAgIGxldCBqID0gKGkgKiB0aGlzLndpZHRoICogdGhpcy5jaGFubmVscykgKyBqTGVmdDtcbiAgICAgICAgbGV0IGpMID0gaiArIHhXaWR0aDtcbiAgICAgICAgZm9yICg7IGogPCBqTDsgaisrKSB7XG4gICAgICAgICAgICBuZXdJbWFnZS5kYXRhW3B0cisrXSA9IHRoaXMuZGF0YVtqXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBuZXdJbWFnZTtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGF2ZXJhZ2UobmV3SW1hZ2UpIHtcbiAgICBsZXQgcHRyID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuZGF0YS5sZW5ndGg7IGkgKz0gdGhpcy5jaGFubmVscykge1xuICAgICAgICBuZXdJbWFnZS5kYXRhW3B0cisrXSA9ICh0aGlzLmRhdGFbaV0gKyB0aGlzLmRhdGFbaSArIDFdICsgdGhpcy5kYXRhW2kgKyAyXSkgLyAzO1xuICAgICAgICBpZiAodGhpcy5hbHBoYSkge1xuICAgICAgICAgICAgbmV3SW1hZ2UuZGF0YVtwdHIrK10gPSB0aGlzLmRhdGFbaSArIDNdO1xuICAgICAgICB9XG4gICAgfVxufVxuIiwiaW1wb3J0IEltYWdlIGZyb20gJy4uLy4uL2ltYWdlJztcbmltcG9ydCB7UkdCfSBmcm9tICcuLi8uLi9tb2RlbC9tb2RlbCc7XG5cbmltcG9ydCBsdW1hNzA5IGZyb20gJy4vbHVtYTcwOSc7XG5pbXBvcnQgbHVtYTYwMSBmcm9tICcuL2x1bWE2MDEnO1xuaW1wb3J0IG1pbm1heCBmcm9tICcuL21pbm1heCc7XG5pbXBvcnQgbWF4aW11bSBmcm9tICcuL21heGltdW0nO1xuaW1wb3J0IGF2ZXJhZ2UgZnJvbSAnLi9hdmVyYWdlJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ3JleSh7YWxnb3JpdGhtID0gJ2x1bWE3MDknfSA9IHt9KSB7XG5cbiAgICBpZiAodGhpcy5jb21wb25lbnRzID09PSAxKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsb25lKCk7XG4gICAgfVxuXG4gICAgdGhpcy5jaGVja1Byb2Nlc3NhYmxlKCdncmV5Jywge2NvbG9yTW9kZWw6IFJHQn0pO1xuXG4gICAgbGV0IG5ld0ltYWdlID0gSW1hZ2UuY3JlYXRlRnJvbSh0aGlzLCB7XG4gICAgICAgIGNvbXBvbmVudHM6IDEsXG4gICAgICAgIGNvbG9yTW9kZWw6IG51bGxcbiAgICB9KTtcblxuICAgIHN3aXRjaCAoYWxnb3JpdGhtLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgY2FzZSAnbHVtYTcwOSc6IC8vIHNSR0JcbiAgICAgICAgICAgIGx1bWE3MDkuY2FsbCh0aGlzLCBuZXdJbWFnZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnbHVtYTYwMSc6IC8vIE5UU0NcbiAgICAgICAgICAgIGx1bWE2MDEuY2FsbCh0aGlzLCBuZXdJbWFnZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnbWlubWF4JzogLy8gdXNlZCBpbiBIU0wgY29sb3IgbW9kZWxcbiAgICAgICAgICAgIG1pbm1heC5jYWxsKHRoaXMsIG5ld0ltYWdlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdtYXhpbXVtJzpcbiAgICAgICAgICAgIG1heGltdW0uY2FsbCh0aGlzLCBuZXdJbWFnZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnYXZlcmFnZSc6IC8vIHVzZWQgaW4gSFNJIGNvbG9yIG1vZGVsXG4gICAgICAgICAgICBhdmVyYWdlLmNhbGwodGhpcywgbmV3SW1hZ2UpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIGdyZXkgYWxnb3JpdGhtOiAnICsgYWxnb3JpdGhtKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3SW1hZ2U7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBsdW1hNjAxKG5ld0ltYWdlKSB7XG4gICAgbGV0IHB0ciA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmRhdGEubGVuZ3RoOyBpICs9IHRoaXMuY2hhbm5lbHMpIHtcbiAgICAgICAgbmV3SW1hZ2UuZGF0YVtwdHIrK10gPSB0aGlzLmRhdGFbaV0gKiAwLjI5OSArIHRoaXMuZGF0YVtpICsgMV0gKiAwLjU4NyArIHRoaXMuZGF0YVtpICsgMl0gKiAwLjExNDtcbiAgICAgICAgaWYgKHRoaXMuYWxwaGEpIHtcbiAgICAgICAgICAgIG5ld0ltYWdlLmRhdGFbcHRyKytdID0gdGhpcy5kYXRhW2kgKyAzXTtcbiAgICAgICAgfVxuICAgIH1cbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGx1bWE3MDkobmV3SW1hZ2UpIHtcbiAgICBsZXQgcHRyID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuZGF0YS5sZW5ndGg7IGkgKz0gdGhpcy5jaGFubmVscykge1xuICAgICAgICBuZXdJbWFnZS5kYXRhW3B0cisrXSA9IHRoaXMuZGF0YVtpXSAqIDAuMjEyNiArIHRoaXMuZGF0YVtpICsgMV0gKiAwLjcxNTIgKyB0aGlzLmRhdGFbaSArIDJdICogMC4wNzIyO1xuICAgICAgICBpZiAodGhpcy5hbHBoYSkge1xuICAgICAgICAgICAgbmV3SW1hZ2UuZGF0YVtwdHIrK10gPSB0aGlzLmRhdGFbaSArIDNdO1xuICAgICAgICB9XG4gICAgfVxufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gbWF4aW11bShuZXdJbWFnZSkge1xuICAgIGxldCBwdHIgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5kYXRhLmxlbmd0aDsgaSArPSB0aGlzLmNoYW5uZWxzKSB7XG4gICAgICAgIG5ld0ltYWdlLmRhdGFbcHRyKytdID0gTWF0aC5tYXgodGhpcy5kYXRhW2ldLCB0aGlzLmRhdGFbaSArIDFdLCB0aGlzLmRhdGFbaSArIDJdKTtcbiAgICAgICAgaWYgKHRoaXMuYWxwaGEpIHtcbiAgICAgICAgICAgIG5ld0ltYWdlLmRhdGFbcHRyKytdID0gdGhpcy5kYXRhW2kgKyAzXTtcbiAgICAgICAgfVxuICAgIH1cbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIG1pbm1heChuZXdJbWFnZSkge1xuICAgIGxldCBwdHIgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5kYXRhLmxlbmd0aDsgaSArPSB0aGlzLmNoYW5uZWxzKSB7XG4gICAgICAgIG5ld0ltYWdlLmRhdGFbcHRyKytdID0gKE1hdGgubWF4KHRoaXMuZGF0YVtpXSwgdGhpcy5kYXRhW2kgKyAxXSwgdGhpcy5kYXRhW2kgKyAyXSkgKyBNYXRoLm1pbih0aGlzLmRhdGFbaV0sIHRoaXMuZGF0YVtpICsgMV0sIHRoaXMuZGF0YVtpICsgMl0pKSAvIDI7XG4gICAgICAgIGlmICh0aGlzLmFscGhhKSB7XG4gICAgICAgICAgICBuZXdJbWFnZS5kYXRhW3B0cisrXSA9IHRoaXMuZGF0YVtpICsgM107XG4gICAgICAgIH1cbiAgICB9XG59XG4iLCIvLyBodHRwOi8vd3d3LmVhc3lyZ2IuY29tL2luZGV4LnBocD9YPU1BVEgmSD0xOCN0ZXh0MThcbi8vIGNoZWNrIHJnYlRvSHNsIDogaHR0cHM6Ly9iZ3JpbnMuZ2l0aHViLmlvL1RpbnlDb2xvci9kb2NzL3Rpbnljb2xvci5odG1sXG5cbmltcG9ydCB7UkdCLCBIU0x9IGZyb20gJy4uL21vZGVsL21vZGVsJztcbmltcG9ydCBJbWFnZSBmcm9tICcuLi9pbWFnZSc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGhzdigpIHtcbiAgICB0aGlzLmNoZWNrUHJvY2Vzc2FibGUoJ2hzdicsIHtcbiAgICAgICAgYml0RGVwdGg6IFs4LCAxNl0sXG4gICAgICAgIGFscGhhOiBbMCwxXSxcbiAgICAgICAgY29sb3JNb2RlbDogW1JHQl1cbiAgICB9KTtcblxuICAgIGxldCBuZXdJbWFnZSA9IEltYWdlLmNyZWF0ZUZyb20odGhpcywge1xuICAgICAgICBjb2xvck1vZGVsOkhTTFxuICAgIH0pO1xuXG4gICAgbGV0IHRocmVzaG9sZCA9IE1hdGguZmxvb3IodGhpcy5tYXhWYWx1ZSAvIDIpO1xuICAgIGxldCBwdHIgPSAwO1xuICAgIGxldCBkYXRhID0gdGhpcy5kYXRhO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkgKz0gdGhpcy5jaGFubmVscykge1xuICAgICAgICBsZXQgcmVkID0gZGF0YVtpXTtcbiAgICAgICAgbGV0IGdyZWVuID0gZGF0YVtpICsgMV07XG4gICAgICAgIGxldCBibHVlID0gZGF0YVtpICsgMl07XG5cbiAgICAgICAgbGV0IG1heCA9IE1hdGgubWF4KHJlZCwgZ3JlZW4sIGJsdWUpO1xuICAgICAgICBsZXQgbWluID0gTWF0aC5taW4ocmVkLCBncmVlbiwgYmx1ZSk7XG4gICAgICAgIGxldCBodWUgPSAwO1xuICAgICAgICBsZXQgc2F0dXJhdGlvbiA9IDA7XG4gICAgICAgIGxldCBsdW1pbmFuY2UgPSAobWF4ICsgbWluKSAvIDI7XG4gICAgICAgIGlmIChtYXggIT09IG1pbikge1xuICAgICAgICAgICAgbGV0IGRlbHRhID0gbWF4IC0gbWluO1xuICAgICAgICAgICAgc2F0dXJhdGlvbiA9IGx1bWluYW5jZSA+IHRocmVzaG9sZCA/IGRlbHRhIC8gKDIgLSBtYXggLSBtaW4pIDogZGVsdGEgLyAobWF4ICsgbWluKTtcbiAgICAgICAgICAgIHN3aXRjaCAobWF4KSB7XG4gICAgICAgICAgICAgICAgY2FzZSByZWQ6XG4gICAgICAgICAgICAgICAgICAgIGh1ZSA9IChncmVlbiAtIGJsdWUpIC8gZGVsdGEgKyAoZ3JlZW4gPCBibHVlID8gNiA6IDApO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIGdyZWVuOlxuICAgICAgICAgICAgICAgICAgICBodWUgPSAoYmx1ZSAtIHJlZCkgLyBkZWx0YSArIDI7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgYmx1ZTpcbiAgICAgICAgICAgICAgICAgICAgaHVlID0gKHJlZCAtIGdyZWVuKSAvIGRlbHRhICsgNDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBodWUgLz0gNjtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgbmV3SW1hZ2UuZGF0YVtwdHIrK10gPSBodWUgKiB0aGlzLm1heFZhbHVlO1xuICAgICAgICBuZXdJbWFnZS5kYXRhW3B0cisrXSA9IHNhdHVyYXRpb24gKiB0aGlzLm1heFZhbHVlO1xuICAgICAgICBuZXdJbWFnZS5kYXRhW3B0cisrXSA9IGx1bWluYW5jZTtcbiAgICAgICAgaWYgKHRoaXMuYWxwaGEpIHtcbiAgICAgICAgICAgIG5ld0ltYWdlLmRhdGFbcHRyKytdID0gZGF0YVtpICsgM107XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbmV3SW1hZ2U7XG59XG4iLCIvLyBiYXNlZCBvbiBodHRwczovL2Jncmlucy5naXRodWIuaW8vVGlueUNvbG9yL2RvY3MvdGlueWNvbG9yLmh0bWxcblxuaW1wb3J0IHtSR0IsIEhTVn0gZnJvbSAnLi4vbW9kZWwvbW9kZWwnO1xuaW1wb3J0IEltYWdlIGZyb20gJy4uL2ltYWdlJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gaHN2KCkge1xuICAgIHRoaXMuY2hlY2tQcm9jZXNzYWJsZSgnaHN2Jywge1xuICAgICAgICBiaXREZXB0aDogWzgsIDE2XSxcbiAgICAgICAgYWxwaGE6IFswLDFdLFxuICAgICAgICBjb2xvck1vZGVsOiBbUkdCXVxuICAgIH0pO1xuXG4gICAgbGV0IG5ld0ltYWdlID0gSW1hZ2UuY3JlYXRlRnJvbSh0aGlzLCB7XG4gICAgICAgIGNvbG9yTW9kZWw6IEhTVlxuICAgIH0pO1xuXG4gICAgbGV0IHB0ciA9IDA7XG4gICAgbGV0IGRhdGEgPSB0aGlzLmRhdGE7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSArPSB0aGlzLmNoYW5uZWxzKSB7XG4gICAgICAgIGxldCByZWQgPSBkYXRhW2ldO1xuICAgICAgICBsZXQgZ3JlZW4gPSBkYXRhW2kgKyAxXTtcbiAgICAgICAgbGV0IGJsdWUgPSBkYXRhW2kgKyAyXTtcblxuICAgICAgICBsZXQgbWluID0gTWF0aC5taW4ocmVkLCBncmVlbiwgYmx1ZSk7XG4gICAgICAgIGxldCBtYXggPSBNYXRoLm1heChyZWQsIGdyZWVuLCBibHVlKTtcbiAgICAgICAgbGV0IGRlbHRhID0gbWF4IC0gbWluO1xuICAgICAgICBsZXQgaHVlID0gMDtcbiAgICAgICAgbGV0IHNhdHVyYXRpb24gPSBtYXggPT09IDAgPyAwIDogZGVsdGEgLyBtYXg7XG4gICAgICAgIGxldCB2YWx1ZSA9IG1heDtcblxuICAgICAgICBpZiAobWF4ICE9PSBtaW4pIHtcbiAgICAgICAgICAgIHN3aXRjaCAobWF4KSB7XG4gICAgICAgICAgICAgICAgY2FzZSByZWQ6XG4gICAgICAgICAgICAgICAgICAgIGh1ZSA9IChncmVlbiAtIGJsdWUpIC8gZGVsdGEgKyAoZ3JlZW4gPCBibHVlID8gNiA6IDApO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIGdyZWVuOlxuICAgICAgICAgICAgICAgICAgICBodWUgPSAoYmx1ZSAtIHJlZCkgLyBkZWx0YSArIDI7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgYmx1ZTpcbiAgICAgICAgICAgICAgICAgICAgaHVlID0gKHJlZCAtIGdyZWVuKSAvIGRlbHRhICsgNDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBodWUgLz0gNjtcbiAgICAgICAgfVxuXG4gICAgICAgIG5ld0ltYWdlLmRhdGFbcHRyKytdID0gaHVlICogdGhpcy5tYXhWYWx1ZTtcbiAgICAgICAgbmV3SW1hZ2UuZGF0YVtwdHIrK10gPSBzYXR1cmF0aW9uICogdGhpcy5tYXhWYWx1ZTtcbiAgICAgICAgbmV3SW1hZ2UuZGF0YVtwdHIrK10gPSB2YWx1ZTtcbiAgICAgICAgaWYgKHRoaXMuYWxwaGEpIHtcbiAgICAgICAgICAgIG5ld0ltYWdlLmRhdGFbcHRyKytdID0gZGF0YVtpICsgM107XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbmV3SW1hZ2U7XG59XG4iLCIvKioqXG4gKlxuICogc2VlIGh0dHA6Ly9yc2IuaW5mby5uaWguZ292L2lqL2RldmVsb3Blci9zb3VyY2UvaWovcHJvY2Vzcy9BdXRvVGhyZXNob2xkZXIuamF2YS5odG1sLlxuICogSHVhbmc6IEltcGxlbWVudHMgSHVhbmcncyBmdXp6eSB0aHJlc2hvbGRpbmcgbWV0aG9kOiBIdWFuZywgTC1LICYgV2FuZywgTS1KIEogKDE5OTUpLFxuICogXCJJbWFnZSB0aHJlc2hvbGRpbmcgYnkgbWluaW1pemluZyB0aGUgbWVhc3VyZSBvZiBmdXp6aW5lc3NcIiwgUGF0dGVybiBSZWNvZ25pdGlvbiAyOCgxKTogNDEtNTFcbiAqXG4gKi9cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gaHVhbmcoaGlzdG9ncmFtKSB7XG4gICAgLyogRGV0ZXJtaW5lIHRoZSBmaXJzdCBub24temVybyBiaW4gKi9cbiAgICBsZXQgZmlyc3RfYmluID0gMDtcbiAgICBmb3IgKGxldCBpaCA9IDA7IGloIDwgaGlzdG9ncmFtLmxlbmd0aDsgaWgrKykge1xuICAgICAgICBpZiAoaGlzdG9ncmFtW2loXSAhPT0gMCkge1xuICAgICAgICAgICAgZmlyc3RfYmluID0gaWg7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qIERldGVybWluZSB0aGUgbGFzdCBub24temVybyBiaW4gKi9cbiAgICBsZXQgbGFzdF9iaW4gPSBoaXN0b2dyYW0ubGVuZ3RoIC0gMTtcbiAgICBmb3IgKGxldCBpaCA9IGhpc3RvZ3JhbS5sZW5ndGggLSAxOyBpaCA+PSBmaXJzdF9iaW47IGloLS0pIHtcbiAgICAgICAgaWYgKGhpc3RvZ3JhbVtpaF0gIT09IDApIHtcbiAgICAgICAgICAgIGxhc3RfYmluID0gaWg7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGxldCB0ZXJtID0gMS4wIC8gKGxhc3RfYmluIC0gZmlyc3RfYmluKTtcbiAgICBsZXQgbXVfMCA9IG5ldyBBcnJheShoaXN0b2dyYW0ubGVuZ3RoKTtcbiAgICBsZXQgc3VtX3BpeCA9IDA7XG4gICAgbGV0IG51bV9waXggPSAwO1xuICAgIGZvciAobGV0IGloID0gZmlyc3RfYmluOyBpaCA8IGhpc3RvZ3JhbS5sZW5ndGg7IGloKyspIHtcbiAgICAgICAgc3VtX3BpeCArPSBpaCAqIGhpc3RvZ3JhbVtpaF07XG4gICAgICAgIG51bV9waXggKz0gaGlzdG9ncmFtW2loXTtcbiAgICAgICAgbXVfMFtpaF0gPSBzdW1fcGl4IC8gbnVtX3BpeDtcbiAgICB9XG5cbiAgICBsZXQgbXVfMSA9IG5ldyBBcnJheShoaXN0b2dyYW0ubGVuZ3RoKTtcbiAgICBzdW1fcGl4ID0gbnVtX3BpeCA9IDA7XG4gICAgZm9yIChsZXQgaWggPSBsYXN0X2JpbjsgaWggPiAwOyBpaC0tKSB7XG4gICAgICAgIHN1bV9waXggKz0gaWggKiBoaXN0b2dyYW1baWhdO1xuICAgICAgICBudW1fcGl4ICs9IGhpc3RvZ3JhbVtpaF07XG4gICAgICAgIG11XzFbaWggLSAxXSA9IHN1bV9waXggLyAgbnVtX3BpeDtcbiAgICB9XG5cbiAgICAvKiBEZXRlcm1pbmUgdGhlIHRocmVzaG9sZCB0aGF0IG1pbmltaXplcyB0aGUgZnV6enkgZW50cm9weSovXG4gICAgbGV0IHRocmVzaG9sZCA9IC0xO1xuICAgIGxldCBtaW5fZW50ID0gTnVtYmVyLk1BWF9WQUxVRTtcbiAgICBmb3IgKGxldCBpdCA9IDA7IGl0IDwgaGlzdG9ncmFtLmxlbmd0aDsgaXQrKykge1xuICAgICAgICBsZXQgZW50ID0gMDtcbiAgICAgICAgbGV0IG11X3g7XG4gICAgICAgIGZvciAobGV0IGloID0gMDsgaWggPD0gaXQ7IGloKyspIHtcbiAgICAgICAgICAgIC8qIEVxdWF0aW9uICg0KSBpbiBSZWYuIDEgKi9cbiAgICAgICAgICAgIG11X3ggPSAxIC8gKDEgKyB0ZXJtICogTWF0aC5hYnMoaWggLSBtdV8wW2l0XSkpO1xuICAgICAgICAgICAgaWYgKCEoKG11X3ggIDwgMWUtMDYpIHx8IChtdV94ID4gMC45OTk5OTkpKSkge1xuICAgICAgICAgICAgICAgIC8qIEVxdWF0aW9uICg2KSAmICg4KSBpbiBSZWYuIDEgKi9cbiAgICAgICAgICAgICAgICBlbnQgKz0gaGlzdG9ncmFtW2loXSAqICgtbXVfeCAqIE1hdGgubG9nIChtdV94KSAtICgxIC0gbXVfeCkgKiBNYXRoLmxvZyAoMSAtIG11X3gpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAobGV0IGloID0gaXQgKyAxOyBpaCA8IGhpc3RvZ3JhbS5sZW5ndGg7IGloKyspIHtcbiAgICAgICAgICAgIC8qIEVxdWF0aW9uICg0KSBpbiBSZWYuIDEgKi9cbiAgICAgICAgICAgIG11X3ggPSAxIC8gKDEgKyB0ZXJtICogTWF0aC5hYnMgKGloIC0gbXVfMVtpdF0pKTtcbiAgICAgICAgICAgIGlmICghKChtdV94ICA8IDFlLTA2KSB8fCAobXVfeCA+IDAuOTk5OTk5KSkpIHtcbiAgICAgICAgICAgICAgICAvKiBFcXVhdGlvbiAoNikgJiAoOCkgaW4gUmVmLiAxICovXG4gICAgICAgICAgICAgICAgZW50ICs9IGhpc3RvZ3JhbVtpaF0gKiAoLW11X3ggKiBNYXRoLmxvZyAobXVfeCkgLSAoMSAtIG11X3gpICogTWF0aC5sb2coMSAtIG11X3gpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlbnQgPCBtaW5fZW50KSB7XG4gICAgICAgICAgICBtaW5fZW50ID0gZW50O1xuICAgICAgICAgICAgdGhyZXNob2xkID0gaXQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRocmVzaG9sZDtcbn1cbiIsIi8qKipcbiAqXG4gKiBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZpamkvQXV0b19UaHJlc2hvbGQvYmxvYi9tYXN0ZXIvc3JjL21haW4vamF2YS9maWppL3RocmVzaG9sZC9BdXRvX1RocmVzaG9sZC5qYXZhXG4gKiBJbnRlcm1vZGVzOiBUaGlzIGFzc3VtZXMgYSBiaW1vZGFsIGhpc3RvZ3JhbS4gSW1wbGVtZW50cyB0aGUgdGhyZXNob2xkaW5nIFByZXdpdHQsIEpNUyAmIE1lbmRlbHNvaG4sIE1MICgxOTY2KSxcbiAqIFwiVGhlIGFuYWx5c2lzIG9mIGNlbGwgaW1hZ2VzXCIsIEFubmFscyBvZiB0aGUgTmV3WW9yayBBY2FkZW15IG9mIFNjaWVuY2VzIDEyODogMTAzNS0xMDUzXG4gKlxuICovXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGludGVybW9kZXMoaGlzdG9ncmFtKSB7XG4gICAgbGV0IGlIaXN0byA9IGhpc3RvZ3JhbS5zbGljZSgpO1xuICAgIGxldCBpdGVyID0gMDtcbiAgICB3aGlsZSAoIWJpbW9kYWxUZXN0KGlIaXN0bykpIHtcbiAgICAgICAgLy9zbW9vdGggd2l0aCBhIDMgcG9pbnQgcnVubmluZyBtZWFuIGZpbHRlclxuICAgICAgICBsZXQgcHJldmlvdXMgPSAwLCBjdXJyZW50ID0gMCwgbmV4dCA9IGlIaXN0b1swXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBoaXN0b2dyYW0ubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgICAgICBwcmV2aW91cyA9IGN1cnJlbnQ7XG4gICAgICAgICAgICBjdXJyZW50ID0gbmV4dDtcbiAgICAgICAgICAgIG5leHQgPSBpSGlzdG9baSArIDFdO1xuICAgICAgICAgICAgaUhpc3RvW2ldID0gKHByZXZpb3VzICsgY3VycmVudCArIG5leHQpIC8gMztcbiAgICAgICAgfVxuICAgICAgICBpSGlzdG9baGlzdG9ncmFtLmxlbmd0aCAtIDFdID0gKGN1cnJlbnQgKyBuZXh0KSAvIDM7XG4gICAgICAgIGl0ZXIrKztcbiAgICAgICAgaWYgKGl0ZXIgPiAxMDAwMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnRlcm1vZGVzIFRocmVzaG9sZCBub3QgZm91bmQgYWZ0ZXIgMTAwMDAgaXRlcmF0aW9ucycpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gVGhlIHRocmVzaG9sZCBpcyB0aGUgbWVhbiBiZXR3ZWVuIHRoZSB0d28gcGVha3MuXG4gICAgbGV0IHR0ID0gMDtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IGhpc3RvZ3JhbS5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgaWYgKGlIaXN0b1tpIC0gMV0gPCBpSGlzdG9baV0gJiYgaUhpc3RvW2kgKyAxXSA8IGlIaXN0b1tpXSkge1xuICAgICAgICAgICAgdHQgKz0gaTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gTWF0aC5mbG9vcih0dCAvIDIuMCk7XG59XG5cbmZ1bmN0aW9uIGJpbW9kYWxUZXN0KGlIaXN0bykge1xuICAgIGxldCBiID0gZmFsc2U7XG4gICAgbGV0IG1vZGVzID0gMDtcblxuICAgIGZvciAobGV0IGsgPSAxOyBrIDwgaUhpc3RvLmxlbmd0aCAtIDE7IGsrKykge1xuICAgICAgICBpZiAoaUhpc3RvW2sgLSAxXSA8IGlIaXN0b1trXSAmJiBpSGlzdG9bayArIDFdIDwgaUhpc3RvW2tdKSB7XG4gICAgICAgICAgICBtb2RlcysrO1xuICAgICAgICAgICAgaWYgKG1vZGVzID4gMikge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAobW9kZXMgPT09IDIpIHtcbiAgICAgICAgYiA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBiO1xufVxuIiwiLyoqXG4gKiBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZpamkvQXV0b19UaHJlc2hvbGQvYmxvYi9tYXN0ZXIvc3JjL21haW4vamF2YS9maWppL3RocmVzaG9sZC9BdXRvX1RocmVzaG9sZC5qYXZhXG4gKiBJc29kYXRhOiBSaWRsZXIsIFRXICYgQ2FsdmFyZCwgUyAoMTk3OCksIFwiUGljdHVyZSB0aHJlc2hvbGRpbmcgdXNpbmcgYW4gaXRlcmF0aXZlIHNlbGVjdGlvbiBtZXRob2RcIlxuICogSUVFRSBUcmFuc2FjdGlvbnMgb24gU3lzdGVtcywgTWFuIGFuZCBDeWJlcm5ldGljcyA4OiA2MzAtNjMyLlxuICpcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gaXNvZGF0YShoaXN0b2dyYW0pIHtcblxuICAgIGxldCBsOyAgICAgIC8vdGhlIGF2ZXJhZ2UgZ3JleSB2YWx1ZSBvZiBwaXhlbHMgd2l0aCBpbnRlbnNpdGllcyA8IGdcbiAgICBsZXQgdG90aDsgICAvL3RoZSB0aGUgYXZlcmFnZSBncmV5IHZhbHVlIG9mIHBpeGVscyB3aXRoIGludGVuc2l0aWVzID4gZ1xuICAgIGxldCB0b3RsOyAgIC8vdGhlIHRvdGFsIHRoZSBhdmVyYWdlIGdyZXkgdmFsdWUgb2YgcGl4ZWxzIHdpdGggaW50ZW5zaXRpZXMgPCBnXG4gICAgbGV0IGg7ICAgICAgLy90aGUgYXZlcmFnZSBncmV5IHZhbHVlIG9mIHBpeGVscyB3aXRoIGludGVuc2l0aWVzID4gZ1xuICAgIGxldCBnID0gMDsgIC8vdGhyZXNob2xkIHZhbHVlXG5cbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IGhpc3RvZ3JhbS5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoaGlzdG9ncmFtW2ldID4gMCkge1xuICAgICAgICAgICAgZyA9IGkgKyAxO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBsID0gMDtcbiAgICAgICAgdG90bCA9IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZzsgaSsrKSB7XG4gICAgICAgICAgICB0b3RsID0gdG90bCArIGhpc3RvZ3JhbVtpXTtcbiAgICAgICAgICAgIGwgPSBsICsgKGhpc3RvZ3JhbVtpXSAqIGkpO1xuICAgICAgICB9XG4gICAgICAgIGggPSAwO1xuICAgICAgICB0b3RoID0gMDtcbiAgICAgICAgZm9yIChsZXQgaSA9IGcgKyAxOyBpIDwgaGlzdG9ncmFtLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0b3RoICs9IGhpc3RvZ3JhbVtpXTtcbiAgICAgICAgICAgIGggKz0gKGhpc3RvZ3JhbVtpXSAqIGkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0b3RsID4gMCAmJiB0b3RoID4gMCkge1xuICAgICAgICAgICAgbCAvPSB0b3RsO1xuICAgICAgICAgICAgaCAvPSB0b3RoO1xuICAgICAgICAgICAgaWYgKGcgPT09ICBNYXRoLnJvdW5kKChsICsgaCkgLyAyLjApKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGcrKztcbiAgICAgICAgaWYgKGcgPiBoaXN0b2dyYW0ubGVuZ3RoIC0gMikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaHJlc2hvbGQgbm90IGZvdW5kJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGc7XG59XG5cbiIsIi8qXG4gKiBzZWUgaHR0cDovL3JzYi5pbmZvLm5paC5nb3YvaWovZGV2ZWxvcGVyL3NvdXJjZS9pai9wcm9jZXNzL0F1dG9UaHJlc2hvbGRlci5qYXZhLmh0bWxcbiAqIFRoZSBtZXRob2QgaXMgcHJlc2VudCBpbjogSW1wbGVtZW50cyBMaSdzIE1pbmltdW0gQ3Jvc3MgRW50cm9weSB0aHJlc2hvbGRpbmcgbWV0aG9kXG4gKiBUaGlzIGltcGxlbWVudGF0aW9uIGlzIGJhc2VkIG9uIHRoZSBpdGVyYXRpdmUgdmVyc2lvbiAoUmVmLiAybmQgcmVmZXJlbmNlIGJlbG93KSBvZiB0aGUgYWxnb3JpdGhtLlxuICogIDEpIExpLCBDSCAmIExlZSwgQ0sgKDE5OTMpLCBcIk1pbmltdW0gQ3Jvc3MgXHRFbnRyb3B5IFRocmVzaG9sZGluZ1wiLCBQYXR0ZXJuIFJlY29nbml0aW9uIDI2KDQpOiA2MSA2MjVcbiAqICAyKSBMaSwgQ0ggJiBUYW0sIFBLUyAoMTk5OCksIFwiQW4gSXRlcmF0aXZlIFx0QWxnb3JpdGhtIGZvciBNaW5pbXVtIENyb3NzIEVudHJvcHkgVGhyZXNob2xkaW5nXCIsXG4gKiAgICAgUGF0dGVybiBcdFJlY29nbml0aW9uIExldHRlcnMgMTgoOCk6IDc3MS03NzZcbiAqICAzKSBTZXpnaW4sIE0gJiBTYW5rdXIsIEIgKDIwMDQpLCBcIlN1cnZleSBcdG92ZXIgSW1hZ2UgVGhyZXNob2xkaW5nIFRlY2huaXF1ZXMgYW5kIFF1YW50aXRhdGl2ZSBQZXJmb3JtYW5jZVxuICogICAgIEV2YWx1YXRpb25cIixKb3VybmFsIG9mIEVsZWN0cm9uaWMgSW1hZ2luZyAxMygxKTogMTQ2LTE2NVxuICogQHBhcmFtIGhpc3RvZ3JhbSAtIHRoZSBoaXN0b2dyYW0gb2YgdGhlIGltYWdlXG4gKiAgICAgICAgdG90YWwgLSB0aGUgbnVtYmVyIG9mIHBpeGVscyBpbiB0aGUgaW1hZ2VcbiAqIEByZXR1cm5zIHtudW1iZXJ9IC0gdGhlIHRocmVzaG9sZFxuICovXG5cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gbGkoaGlzdG9ncmFtLCB0b3RhbCkge1xuXG4gICAgbGV0IHRocmVzaG9sZDtcbiAgICBsZXQgc3VtX2JhY2s7IC8qIHN1bSBvZiB0aGUgYmFja2dyb3VuZCBwaXhlbHMgYXQgYSBnaXZlbiB0aHJlc2hvbGQgKi9cbiAgICBsZXQgc3VtX29iajsgIC8qIHN1bSBvZiB0aGUgb2JqZWN0IHBpeGVscyBhdCBhIGdpdmVuIHRocmVzaG9sZCAqL1xuICAgIGxldCBudW1fYmFjazsgLyogbnVtYmVyIG9mIGJhY2tncm91bmQgcGl4ZWxzIGF0IGEgZ2l2ZW4gdGhyZXNob2xkICovXG4gICAgbGV0IG51bV9vYmo7ICAvKiBudW1iZXIgb2Ygb2JqZWN0IHBpeGVscyBhdCBhIGdpdmVuIHRocmVzaG9sZCAqL1xuICAgIGxldCBvbGRfdGhyZXNoO1xuICAgIGxldCBuZXdfdGhyZXNoO1xuICAgIGxldCBtZWFuX2JhY2s7IC8qIG1lYW4gb2YgdGhlIGJhY2tncm91bmQgcGl4ZWxzIGF0IGEgZ2l2ZW4gdGhyZXNob2xkICovXG4gICAgbGV0IG1lYW5fb2JqOyAgLyogbWVhbiBvZiB0aGUgb2JqZWN0IHBpeGVscyBhdCBhIGdpdmVuIHRocmVzaG9sZCAqL1xuICAgIGxldCBtZWFuOyAgLyogbWVhbiBncmF5LWxldmVsIGluIHRoZSBpbWFnZSAqL1xuICAgIGxldCB0b2xlcmFuY2U7IC8qIHRocmVzaG9sZCB0b2xlcmFuY2UgKi9cbiAgICBsZXQgdGVtcDtcbiAgICB0b2xlcmFuY2UgPSAwLjU7XG5cbiAgICAvKiBDYWxjdWxhdGUgdGhlIG1lYW4gZ3JheS1sZXZlbCAqL1xuICAgIG1lYW4gPSAwLjA7XG4gICAgZm9yIChsZXQgaWggPSAwOyBpaCA8IGhpc3RvZ3JhbS5sZW5ndGg7IGloKyspIHtcbiAgICAgICAgbWVhbiArPSBpaCAqIGhpc3RvZ3JhbVtpaF07XG4gICAgfVxuXG4gICAgbWVhbiAvPSB0b3RhbDtcbiAgICAvKiBJbml0aWFsIGVzdGltYXRlICovXG4gICAgbmV3X3RocmVzaCA9IG1lYW47XG5cbiAgICBkbyB7XG4gICAgICAgIG9sZF90aHJlc2ggPSBuZXdfdGhyZXNoO1xuICAgICAgICB0aHJlc2hvbGQgPSAob2xkX3RocmVzaCArIDAuNSl8MDtcdC8qIHJhbmdlICovXG5cbiAgICAgICAgLyogQ2FsY3VsYXRlIHRoZSBtZWFucyBvZiBiYWNrZ3JvdW5kIGFuZCBvYmplY3QgcGl4ZWxzICovXG4gICAgICAgIC8qIEJhY2tncm91bmQgKi9cbiAgICAgICAgc3VtX2JhY2sgPSAwO1xuICAgICAgICBudW1fYmFjayA9IDA7XG5cbiAgICAgICAgZm9yIChsZXQgaWggPSAwOyBpaCA8PSB0aHJlc2hvbGQ7IGloKyspIHtcbiAgICAgICAgICAgIHN1bV9iYWNrICs9IGloICogaGlzdG9ncmFtW2loXTtcbiAgICAgICAgICAgIG51bV9iYWNrICs9IGhpc3RvZ3JhbVtpaF07XG4gICAgICAgIH1cbiAgICAgICAgbWVhbl9iYWNrID0gKG51bV9iYWNrID09PSAwID8gMC4wIDogKHN1bV9iYWNrIC8gbnVtX2JhY2spKTtcblxuICAgICAgICAvKiBPYmplY3QgKi9cbiAgICAgICAgc3VtX29iaiA9IDA7XG4gICAgICAgIG51bV9vYmogPSAwO1xuICAgICAgICBmb3IgKGxldCBpaCA9IHRocmVzaG9sZCArIDE7IGloIDwgaGlzdG9ncmFtLmxlbmd0aDsgaWgrKykge1xuICAgICAgICAgICAgc3VtX29iaiArPSBpaCAqIGhpc3RvZ3JhbVtpaF07XG4gICAgICAgICAgICBudW1fb2JqICs9IGhpc3RvZ3JhbVtpaF07XG4gICAgICAgIH1cbiAgICAgICAgbWVhbl9vYmogPSAobnVtX29iaiA9PT0gMCA/IDAuMCA6IChzdW1fb2JqIC8gbnVtX29iaikpO1xuICAgICAgICB0ZW1wID0gKG1lYW5fYmFjayAtIG1lYW5fb2JqKSAvIChNYXRoLmxvZyhtZWFuX2JhY2spIC0gTWF0aC5sb2cobWVhbl9vYmopKTtcblxuICAgICAgICBpZiAodGVtcCA8IC1OdW1iZXIuRVBTSUxPTikge1xuICAgICAgICAgICAgbmV3X3RocmVzaCA9ICh0ZW1wIC0gMC41KXwwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbmV3X3RocmVzaCA9ICh0ZW1wICsgMC41KXwwO1xuICAgICAgICB9XG4gICAgICAgIC8qICBTdG9wIHRoZSBpdGVyYXRpb25zIHdoZW4gdGhlIGRpZmZlcmVuY2UgYmV0d2VlbiB0aGVcbiAgICAgICAgIG5ldyBhbmQgb2xkIHRocmVzaG9sZCB2YWx1ZXMgaXMgbGVzcyB0aGFuIHRoZSB0b2xlcmFuY2UgKi9cbiAgICB9XG4gICAgd2hpbGUgKE1hdGguYWJzKG5ld190aHJlc2ggLSBvbGRfdGhyZXNoKSA+IHRvbGVyYW5jZSk7XG5cbiAgICByZXR1cm4gdGhyZXNob2xkO1xufVxuXG5cbiIsImltcG9ydCBJbWFnZSBmcm9tICcuLi8uLi9pbWFnZSc7XG5cbmltcG9ydCBodWFuZyBmcm9tICcuL2h1YW5nJztcbmltcG9ydCBpbnRlcm1vZGVzIGZyb20gJy4vaW50ZXJtb2Rlcyc7XG5pbXBvcnQgaXNvZGF0YSBmcm9tICcuL2lzb2RhdGEnO1xuaW1wb3J0IGxpIGZyb20gJy4vbGknO1xuaW1wb3J0IG1heEVudHJvcHkgZnJvbSAnLi9tYXhFbnRyb3B5JztcbmltcG9ydCBtZWFuIGZyb20gJy4vbWVhbic7XG5pbXBvcnQgbWluRXJyb3IgZnJvbSAnLi9taW5FcnJvcic7XG5pbXBvcnQgbWluaW11bSBmcm9tICcuL21pbmltdW0nO1xuaW1wb3J0IG1vbWVudHMgZnJvbSAnLi9tb21lbnRzJztcbmltcG9ydCBvdHN1IGZyb20gJy4vb3RzdSc7XG5pbXBvcnQgcGVyY2VudGlsZSBmcm9tICcuL3BlcmNlbnRpbGUnO1xuaW1wb3J0IHJlbnlpRW50cm9weSBmcm9tICcuL3JlbnlpRW50cm9weS5qcyc7XG5pbXBvcnQgc2hhbmJoYWcgZnJvbSAgJy4vc2hhbmJoYWcnO1xuaW1wb3J0IHRyaWFuZ2xlIGZyb20gJy4vdHJpYW5nbGUnO1xuaW1wb3J0IHllbiBmcm9tICcuL3llbic7XG5pbXBvcnQge2dldFRocmVzaG9sZH0gZnJvbSAnLi4vLi4vLi4vdXRpbC9jb252ZXJ0ZXInO1xuXG4vKlxuIENyZWF0aW9uIG9mIGJpbmFyeSBtYXNrIGlzIGJhc2VkIG9uIHRoZSBkZXRlcm1pbmF0aW9uIG9mIGEgdGhyZXNob2xkXG4gWW91IG1heSBlaXRoZXIgY2hvb3NlIGFtb25nIHRoZSBwcm92aWRlZCBhbGdvcml0aG0gb3IganVzdCBzcGVjaWZ5IGEgdGhyZXNob2xkIHZhbHVlXG4gKi9cblxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBtYXNrKHtcbiAgICBhbGdvcml0aG0gPSAndGhyZXNob2xkJyxcbiAgICB0aHJlc2hvbGQgPSAwLjUsXG4gICAgdXNlQWxwaGEgPSB0cnVlLFxuICAgIGludmVydCA9IGZhbHNlXG4gICAgfSA9IHt9KSB7XG5cbiAgICB0aGlzLmNoZWNrUHJvY2Vzc2FibGUoJ21hc2snLCB7XG4gICAgICAgIGNvbXBvbmVudHM6IDEsXG4gICAgICAgIGJpdERlcHRoOiBbOCwxNl1cbiAgICB9KTtcblxuICAgIGxldCBoaXN0b2dyYW0gPSB0aGlzLmdldEhpc3RvZ3JhbSgpO1xuICAgIHN3aXRjaCAoYWxnb3JpdGhtLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgY2FzZSAndGhyZXNob2xkJzpcbiAgICAgICAgICAgIHRocmVzaG9sZCA9IGdldFRocmVzaG9sZCh0aHJlc2hvbGQsIHRoaXMubWF4VmFsdWUpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2h1YW5nJzpcbiAgICAgICAgICAgIHRocmVzaG9sZCA9IGh1YW5nKGhpc3RvZ3JhbSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnaW50ZXJtb2Rlcyc6XG4gICAgICAgICAgICB0aHJlc2hvbGQgPSBpbnRlcm1vZGVzKGhpc3RvZ3JhbSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnaXNvZGF0YSc6XG4gICAgICAgICAgICB0aHJlc2hvbGQgPSBpc29kYXRhKGhpc3RvZ3JhbSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnbGknOlxuICAgICAgICAgICAgdGhyZXNob2xkID0gbGkoaGlzdG9ncmFtLCB0aGlzLnNpemUpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ21heGVudHJvcHknOlxuICAgICAgICAgICAgdGhyZXNob2xkID0gbWF4RW50cm9weShoaXN0b2dyYW0sIHRoaXMuc2l6ZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnbWVhbic6XG4gICAgICAgICAgICB0aHJlc2hvbGQgPSBtZWFuKGhpc3RvZ3JhbSwgdGhpcy5zaXplKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdtaW5lcnJvcic6XG4gICAgICAgICAgICB0aHJlc2hvbGQgPSBtaW5FcnJvcihoaXN0b2dyYW0sIHRoaXMuc2l6ZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnbWluaW11bSc6XG4gICAgICAgICAgICB0aHJlc2hvbGQgPSBtaW5pbXVtKGhpc3RvZ3JhbSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnbW9tZW50cyc6XG4gICAgICAgICAgICB0aHJlc2hvbGQgPSBtb21lbnRzKGhpc3RvZ3JhbSwgdGhpcy5zaXplKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdvdHN1JzpcbiAgICAgICAgICAgIHRocmVzaG9sZCA9IG90c3UoaGlzdG9ncmFtLCB0aGlzLnNpemUpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3BlcmNlbnRpbGUnOlxuICAgICAgICAgICAgdGhyZXNob2xkID0gcGVyY2VudGlsZShoaXN0b2dyYW0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3JlbnlpZW50cm9weSc6XG4gICAgICAgICAgICB0aHJlc2hvbGQgPSByZW55aUVudHJvcHkoaGlzdG9ncmFtLCB0aGlzLnNpemUpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3NoYW5iaGFnJzpcbiAgICAgICAgICAgIHRocmVzaG9sZCA9IHNoYW5iaGFnKGhpc3RvZ3JhbSwgdGhpcy5zaXplKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICd0cmlhbmdsZSc6XG4gICAgICAgICAgICB0aHJlc2hvbGQgPSB0cmlhbmdsZShoaXN0b2dyYW0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3llbic6XG4gICAgICAgICAgICB0aHJlc2hvbGQgPSB5ZW4oaGlzdG9ncmFtLCB0aGlzLnNpemUpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21hc2sgdHJhbnNmb3JtIHVua25vd24gYWxnb3JpdGhtOiAnICsgYWxnb3JpdGhtKTtcbiAgICB9XG5cbiAgICBsZXQgbmV3SW1hZ2UgPSBuZXcgSW1hZ2UgKHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0LCB7XG4gICAgICAgIGtpbmQ6ICdCSU5BUlknLFxuICAgICAgICBwYXJlbnQ6IHRoaXNcbiAgICB9KTtcblxuICAgIGxldCBwdHIgPSAwO1xuICAgIGlmICh0aGlzLmFscGhhICYmIHVzZUFscGhhKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5kYXRhLmxlbmd0aDsgaSArPSB0aGlzLmNoYW5uZWxzKSB7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSB0aGlzLmRhdGFbaV0gKyAodGhpcy5tYXhWYWx1ZSAtIHRoaXMuZGF0YVtpXSkgKiAodGhpcy5tYXhWYWx1ZSAtIHRoaXMuZGF0YVtpICsgMV0pIC8gdGhpcy5tYXhWYWx1ZTtcbiAgICAgICAgICAgIGlmICgoaW52ZXJ0ICYmIHZhbHVlIDw9IHRocmVzaG9sZCkgfHwgKCFpbnZlcnQgJiYgdmFsdWUgPj0gdGhyZXNob2xkKSkge1xuICAgICAgICAgICAgICAgIG5ld0ltYWdlLnNldEJpdChwdHIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHRyKys7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuZGF0YS5sZW5ndGg7IGkgKz0gdGhpcy5jaGFubmVscykge1xuICAgICAgICAgICAgaWYgKChpbnZlcnQgJiYgdGhpcy5kYXRhW2ldIDw9IHRocmVzaG9sZCkgfHwgKCFpbnZlcnQgJiYgdGhpcy5kYXRhW2ldID49IHRocmVzaG9sZCkpIHtcbiAgICAgICAgICAgICAgICBuZXdJbWFnZS5zZXRCaXQocHRyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHB0cisrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXdJbWFnZTtcbn1cbiIsIi8qXG4gKiBzZWUgaHR0cDovL3JzYi5pbmZvLm5paC5nb3YvaWovZGV2ZWxvcGVyL3NvdXJjZS9pai9wcm9jZXNzL0F1dG9UaHJlc2hvbGRlci5qYXZhLmh0bWxcbiAqIFRoZSBtZXRob2QgaXMgcHJlc2VudCBpbjogSW1wbGVtZW50cyBLYXB1ci1TYWhvby1Xb25nIChNYXhpbXVtIEVudHJvcHkpIHRocmVzaG9sZGluZyBtZXRob2Q6XG4gKiBLYXB1ciwgSk47IFNhaG9vLCBQSyAmIFdvbmcsIEFDSyAoMTk4NSksIFwiQSBOZXcgTWV0aG9kIGZvciBHcmF5LUxldmVsIFBpY3R1cmUgVGhyZXNob2xkaW5nIFVzaW5nIHRoZSBFbnRyb3B5IG9mIHRoZSBIaXN0b2dyYW1cIixcbiAqIEdyYXBoaWNhbCBNb2RlbHMgYW5kIEltYWdlIFByb2Nlc3NpbmcgMjkoMyk6IDI3My0yODVcbiAqIEBwYXJhbSBoaXN0b2dyYW0gLSB0aGUgaGlzdG9ncmFtIG9mIHRoZSBpbWFnZVxuICogICAgICAgIHRvdGFsIC0gdGhlIG51bWJlciBvZiBwaXhlbHMgaW4gdGhlIGltYWdlXG4gKiBAcmV0dXJucyB7bnVtYmVyfSAtIHRoZSB0aHJlc2hvbGRcbiAqL1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBtYXhFbnRyb3B5KGhpc3RvZ3JhbSwgdG90YWwpIHtcbiAgICBsZXQgbm9ybV9oaXN0byA9IG5ldyBBcnJheShoaXN0b2dyYW0ubGVuZ3RoKTsgLy8gbm9ybWFsaXplZCBoaXN0b2dyYW1cbiAgICBmb3IgKGxldCBpaCA9IDA7IGloIDwgaGlzdG9ncmFtLmxlbmd0aDsgaWgrKylcbiAgICAgICAgbm9ybV9oaXN0b1tpaF0gPSBoaXN0b2dyYW1baWhdIC8gdG90YWw7XG5cbiAgICBsZXQgUDEgPSBuZXcgQXJyYXkoaGlzdG9ncmFtLmxlbmd0aCk7IC8vIGN1bXVsYXRpdmUgbm9ybWFsaXplZCBoaXN0b2dyYW1cbiAgICBsZXQgUDIgPSBuZXcgQXJyYXkoaGlzdG9ncmFtLmxlbmd0aCk7XG4gICAgUDFbMF0gPSBub3JtX2hpc3RvWzBdO1xuICAgIFAyWzBdID0gMS4wIC0gUDFbMF07XG5cbiAgICBmb3IgKGxldCBpaCA9IDE7IGloIDwgaGlzdG9ncmFtLmxlbmd0aDsgaWgrKykge1xuICAgICAgICBQMVtpaF0gPSBQMVtpaCAtIDFdICsgbm9ybV9oaXN0b1tpaF07XG4gICAgICAgIFAyW2loXSA9IDEuMCAtIFAxW2loXTtcbiAgICB9XG5cbiAgICAvKiBEZXRlcm1pbmUgdGhlIGZpcnN0IG5vbi16ZXJvIGJpbiAqL1xuICAgIGxldCBmaXJzdF9iaW4gPSAwO1xuICAgIGZvciAobGV0IGloID0gMDsgaWggPCBoaXN0b2dyYW0ubGVuZ3RoOyBpaCsrKSB7XG4gICAgICAgIGlmIChNYXRoLmFicyhQMVtpaF0pID49IE51bWJlci5FUFNJTE9OKSB7XG4gICAgICAgICAgICBmaXJzdF9iaW4gPSBpaDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyogRGV0ZXJtaW5lIHRoZSBsYXN0IG5vbi16ZXJvIGJpbiAqL1xuICAgIGxldCBsYXN0X2JpbiA9IGhpc3RvZ3JhbS5sZW5ndGggLSAxO1xuICAgIGZvciAobGV0IGloID0gaGlzdG9ncmFtLmxlbmd0aCAtIDE7IGloID49IGZpcnN0X2JpbjsgaWgtLSkge1xuICAgICAgICBpZiAoTWF0aC5hYnMoUDJbaWhdKSA+PSBOdW1iZXIuRVBTSUxPTikge1xuICAgICAgICAgICAgbGFzdF9iaW4gPSBpaDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gQ2FsY3VsYXRlIHRoZSB0b3RhbCBlbnRyb3B5IGVhY2ggZ3JheS1sZXZlbFxuICAgIC8vIGFuZCBmaW5kIHRoZSB0aHJlc2hvbGQgdGhhdCBtYXhpbWl6ZXMgaXRcbiAgICBsZXQgdGhyZXNob2xkID0gLTE7XG4gICAgbGV0IHRvdF9lbnQ7ICAvLyB0b3RhbCBlbnRyb3B5XG4gICAgbGV0IG1heF9lbnQgPSBOdW1iZXIuTUlOX1ZBTFVFOyAvLyBtYXggZW50cm9weVxuICAgIGxldCBlbnRfYmFjazsgLy8gZW50cm9weSBvZiB0aGUgYmFja2dyb3VuZCBwaXhlbHMgYXQgYSBnaXZlbiB0aHJlc2hvbGRcbiAgICBsZXQgZW50X29iajsgIC8vIGVudHJvcHkgb2YgdGhlIG9iamVjdCBwaXhlbHMgYXQgYSBnaXZlbiB0aHJlc2hvbGRcblxuICAgIGZvciAobGV0IGl0ID0gZmlyc3RfYmluOyBpdCA8PSBsYXN0X2JpbjsgaXQrKykge1xuICAgICAgICAvKiBFbnRyb3B5IG9mIHRoZSBiYWNrZ3JvdW5kIHBpeGVscyAqL1xuICAgICAgICBlbnRfYmFjayA9IDAuMDtcbiAgICAgICAgZm9yIChsZXQgaWggPSAwOyBpaCA8PSBpdDsgaWgrKykge1xuICAgICAgICAgICAgaWYgKGhpc3RvZ3JhbVtpaF0gIT09IDApIHtcbiAgICAgICAgICAgICAgICBlbnRfYmFjayAtPSAobm9ybV9oaXN0b1tpaF0gLyBQMVtpdF0pICogTWF0aC5sb2cobm9ybV9oaXN0b1tpaF0gLyBQMVtpdF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyogRW50cm9weSBvZiB0aGUgb2JqZWN0IHBpeGVscyAqL1xuICAgICAgICBlbnRfb2JqID0gMC4wO1xuICAgICAgICBmb3IgKGxldCBpaCA9IGl0ICsgMTsgaWggPCBoaXN0b2dyYW0ubGVuZ3RoOyBpaCsrKSB7XG4gICAgICAgICAgICBpZiAoaGlzdG9ncmFtW2loXSAhPT0gMCkge1xuICAgICAgICAgICAgICAgIGVudF9vYmogLT0gKG5vcm1faGlzdG9baWhdIC8gUDJbaXRdKSAqIE1hdGgubG9nKG5vcm1faGlzdG9baWhdIC8gUDJbaXRdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qIFRvdGFsIGVudHJvcHkgKi9cbiAgICAgICAgdG90X2VudCA9IGVudF9iYWNrICsgZW50X29iajtcblxuICAgICAgICBpZiAobWF4X2VudCA8IHRvdF9lbnQpIHtcbiAgICAgICAgICAgIG1heF9lbnQgPSB0b3RfZW50O1xuICAgICAgICAgICAgdGhyZXNob2xkID0gaXQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRocmVzaG9sZDtcbn1cbiIsIi8qXG4gKiBUaGUgbWV0aG9kIGlzIHByZXNlbnQgaW46IFVzZXMgdGhlIFx0bWVhbiBvZiBncmV5IGxldmVscyBhcyB0aGUgdGhyZXNob2xkLiBJdCBpcyBkZXNjcmliZWQgaW46XG4gKiBHbGFzYmV5LCBDQSAoMTk5MyksIFwiQW4gYW5hbHlzaXMgb2YgaGlzdG9ncmFtLWJhc2VkIHRocmVzaG9sZGluZyBhbGdvcml0aG1zXCIsXG4gKiBDVkdJUDogR3JhcGhpY2FsIE1vZGVscyBhbmQgSW1hZ2UgUHJvY2Vzc2luZyA1NTogNTMyLTUzN1xuICogQHBhcmFtIGhpc3RvZ3JhbSAtIHRoZSBoaXN0b2dyYW0gb2YgdGhlIGltYWdlXG4gKiAgICAgICAgdG90YWwgLSB0aGUgbnVtYmVyIG9mIHBpeGVscyBpbiB0aGUgaW1hZ2VcbiAqIEByZXR1cm5zIHtudW1iZXJ9IC0gdGhlIHRocmVzaG9sZFxuICovXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIG1lYW4oaGlzdG9ncmFtLCB0b3RhbCkge1xuICAgIGxldCBzdW0gPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaGlzdG9ncmFtLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHN1bSArPSBpICogaGlzdG9ncmFtW2ldO1xuICAgIH1cbiAgICByZXR1cm4gTWF0aC5mbG9vcihzdW0gLyB0b3RhbCk7XG59XG4iLCIvKlxuICogc2VlIGh0dHA6Ly9yc2IuaW5mby5uaWguZ292L2lqL2RldmVsb3Blci9zb3VyY2UvaWovcHJvY2Vzcy9BdXRvVGhyZXNob2xkZXIuamF2YS5odG1sXG4gKiBUaGUgbWV0aG9kIGlzIHByZXNlbnQgaW46IEFuIFx0aXRlcmF0aXZlIGltcGxlbWVudGF0aW9uIG9mIEtpdHRsZXIgYW5kIElsbGluZ3dvcnRoJ3MgTWluaW11bSBFcnJvclxuICogdGhyZXNob2xkaW5nOktpdHRsZXIsIEogJiBJbGxpbmd3b3J0aCwgSiAoMTk4NiksIFwiTWluaW11bSBlcnJvciB0aHJlc2hvbGRpbmdcIiwgUGF0dGVybiBSZWNvZ25pdGlvbiAxOTogNDEtNDdcbiAqIEBwYXJhbSBoaXN0b2dyYW0gLSB0aGUgaGlzdG9ncmFtIG9mIHRoZSBpbWFnZVxuICogICAgICAgIHRvdGFsIC0gdGhlIG51bWJlciBvZiBwaXhlbHMgaW4gdGhlIGltYWdlXG4gKiBAcmV0dXJucyB7bnVtYmVyfSAtIHRoZSB0aHJlc2hvbGRcbiAqL1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBtaW5FcnJvcihoaXN0b2dyYW0sIHRvdGFsKSB7XG5cbiAgICBsZXQgdGhyZXNob2xkO1xuICAgIGxldCBUcHJldiA9IC0yO1xuICAgIGxldCBtdSwgbnUsIHAsIHEsIHNpZ21hMiwgdGF1MiwgdzAsIHcxLCB3Miwgc3F0ZXJtLCB0ZW1wO1xuXG4gICAgLyogQ2FsY3VsYXRlIHRoZSBtZWFuIGdyYXktbGV2ZWwgKi9cbiAgICBsZXQgbWVhbiA9IDAuMDtcbiAgICBmb3IgKGxldCBpaCA9IDA7IGloIDwgaGlzdG9ncmFtLmxlbmd0aDsgaWgrKykge1xuICAgICAgICBtZWFuICs9IGloICogaGlzdG9ncmFtW2loXTtcbiAgICB9XG5cbiAgICBtZWFuIC89IHRvdGFsO1xuXG4gICAgdGhyZXNob2xkID0gbWVhbjtcblxuICAgIHdoaWxlICh0aHJlc2hvbGQgIT09IFRwcmV2KSB7XG4gICAgICAgIC8vQ2FsY3VsYXRlIHNvbWUgc3RhdGlzdGljcy5cbiAgICAgICAgbGV0IHN1bUExID0gc3VtQShoaXN0b2dyYW0sIHRocmVzaG9sZCk7XG4gICAgICAgIGxldCBzdW1BMiA9IHN1bUEoaGlzdG9ncmFtLCBoaXN0b2dyYW0ubGVuZ3RoIC0gMSk7XG4gICAgICAgIGxldCBzdW1CMSA9IHN1bUIoaGlzdG9ncmFtLCB0aHJlc2hvbGQpO1xuICAgICAgICBsZXQgc3VtQjIgPSBzdW1CKGhpc3RvZ3JhbSwgaGlzdG9ncmFtLmxlbmd0aCAtIDEpO1xuICAgICAgICBsZXQgc3VtQzEgPSBzdW1DKGhpc3RvZ3JhbSwgdGhyZXNob2xkKTtcbiAgICAgICAgbGV0IHN1bUMyID0gc3VtQyhoaXN0b2dyYW0sIGhpc3RvZ3JhbS5sZW5ndGggLSAxKTtcblxuICAgICAgICBtdSA9IHN1bUIxIC8gc3VtQTE7XG4gICAgICAgIG51ID0gKHN1bUIyIC0gc3VtQjEpIC8gKHN1bUEyIC0gc3VtQTEpO1xuICAgICAgICBwID0gc3VtQTEgLyBzdW1BMjtcbiAgICAgICAgcSA9IChzdW1BMiAtIHN1bUExKSAvIHN1bUEyO1xuICAgICAgICBzaWdtYTIgPSBzdW1DMSAvIHN1bUExIC0gKG11ICogbXUpO1xuICAgICAgICB0YXUyID0gKHN1bUMyIC0gc3VtQzEpIC8gKHN1bUEyIC0gc3VtQTEpIC0gKG51ICogbnUpO1xuXG4gICAgICAgIC8vVGhlIHRlcm1zIG9mIHRoZSBxdWFkcmF0aWMgZXF1YXRpb24gdG8gYmUgc29sdmVkLlxuICAgICAgICB3MCA9IDEuMCAvIHNpZ21hMiAtIDEuMCAvIHRhdTI7XG4gICAgICAgIHcxID0gbXUgLyBzaWdtYTIgLSBudSAvIHRhdTI7XG4gICAgICAgIHcyID0gKG11ICogbXUpIC8gc2lnbWEyIC0gKG51ICogbnUpIC8gdGF1MiArIE1hdGgubG9nMTAoKHNpZ21hMiAqIChxICogcSkpIC8gKHRhdTIgKiAocCAqIHApKSk7XG5cbiAgICAgICAgLy9JZiB0aGUgbmV4dCB0aHJlc2hvbGQgd291bGQgYmUgaW1hZ2luYXJ5LCByZXR1cm4gd2l0aCB0aGUgY3VycmVudCBvbmUuXG4gICAgICAgIHNxdGVybSA9ICh3MSAqIHcxKSAtIHcwICogdzI7XG4gICAgICAgIGlmIChzcXRlcm0gPCAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhyZXNob2xkO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9UaGUgdXBkYXRlZCB0aHJlc2hvbGQgaXMgdGhlIGludGVnZXIgcGFydCBvZiB0aGUgc29sdXRpb24gb2YgdGhlIHF1YWRyYXRpYyBlcXVhdGlvbi5cbiAgICAgICAgVHByZXYgPSB0aHJlc2hvbGQ7XG4gICAgICAgIHRlbXAgPSAodzEgKyBNYXRoLnNxcnQoc3F0ZXJtKSkgLyB3MDtcblxuICAgICAgICBpZiAoaXNOYU4odGVtcCkpIHtcbiAgICAgICAgICAgIHRocmVzaG9sZCA9IFRwcmV2O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyZXNob2xkID0gTWF0aC5mbG9vcih0ZW1wKTtcbiAgICAgICAgfVxuXG4gICAgfVxuICAgIHJldHVybiB0aHJlc2hvbGQ7XG59XG5cbi8vYXV4IGZ1bmNcblxuZnVuY3Rpb24gc3VtQSh5LCBqKSB7XG4gICAgbGV0IHggPSAwO1xuICAgIGZvciAobGV0IGkgPSAwO2kgPD0gajsgaSsrKSB7XG4gICAgICAgIHggKz0geVtpXTtcbiAgICB9XG4gICAgcmV0dXJuIHg7XG59XG5cbmZ1bmN0aW9uIHN1bUIoeSwgaikge1xuICAgIGxldCB4ID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8PSBqOyBpKyspIHtcbiAgICAgICAgeCArPSBpICogeVtpXTtcbiAgICB9XG4gICAgcmV0dXJuIHg7XG59XG5cbmZ1bmN0aW9uIHN1bUMoeSwgaikge1xuICAgIGxldCB4ID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8PSBqOyBpKyspIHtcbiAgICAgICAgeCArPSBpICogaSAqIHlbaV07XG4gICAgfVxuICAgIHJldHVybiB4O1xufVxuIiwiLy9zZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZpamkvQXV0b19UaHJlc2hvbGQvYmxvYi9tYXN0ZXIvc3JjL21haW4vamF2YS9maWppL3RocmVzaG9sZC9BdXRvX1RocmVzaG9sZC5qYXZhXG4vLyBKLiBNLiBTLiBQcmV3aXR0IGFuZCBNLiBMLiBNZW5kZWxzb2huLCBcIlRoZSBhbmFseXNpcyBvZiBjZWxsIGltYWdlcyxcIiBpblxuLy8gQW5uYWxzIG9mIHRoZSBOZXcgWW9yayBBY2FkZW15IG9mIFNjaWVuY2VzLCB2b2wuIDEyOCwgcHAuIDEwMzUtMTA1MywgMTk2Ni5cbi8vIHBvcnRlZCB0byBJbWFnZUogcGx1Z2luIGJ5IEcuTGFuZGluaSBmcm9tIEFudHRpIE5pZW1pc3RvJ3MgTWF0bGFiIGNvZGUgKEdQTClcbi8vIE9yaWdpbmFsIE1hdGxhYiBjb2RlIENvcHlyaWdodCAoQykgMjAwNCBBbnR0aSBOaWVtaXN0b1xuLy8gU2VlIGh0dHA6Ly93d3cuY3MudHV0LmZpL35hbnQvaGlzdHRocmVzaC8gZm9yIGFuIGV4Y2VsbGVudCBzbGlkZSBwcmVzZW50YXRpb25cbi8vIGFuZCB0aGUgb3JpZ2luYWwgTWF0bGFiIGNvZGVcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIG1pbmltdW0oaGlzdG9ncmFtKSB7XG4gICAgaWYgKGhpc3RvZ3JhbS5sZW5ndGggPCAyKSB7Ly92YWxpZGF0ZSB0aGF0IHRoZSBoaXN0b2dyYW0gaGFzIGF0IGxlYXN0IHR3byBjb2xvciB2YWx1ZXNcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGxldCBpdGVyYXRpb25zID0gMDsgLy9udW1iZXIgb2YgaXRlcmF0aW9ucyBvZiB0aGUgc21vb3RoaW5nIHByb2Nlc3NcbiAgICBsZXQgdGhyZXNob2xkID0gLTE7XG4gICAgbGV0IG1heCA9IC0xOyAvLyBtYXhpbXVtIGNvbG9yIHZhbHVlIHdpdGggYSBncmVhdGVyIG51bWJlciBvZiBwaXhlbHMgdG8gMFxuICAgIGxldCBoaXN0b2dyYW1Db3B5ID0gbmV3IEFycmF5KGhpc3RvZ3JhbS5sZW5ndGgpOyAvL2EgY29weSBvZiB0aGUgaGlzdG9ncmFtXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBoaXN0b2dyYW0ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaGlzdG9ncmFtQ29weVtpXSA9IGhpc3RvZ3JhbVtpXTtcbiAgICAgICAgaWYgKGhpc3RvZ3JhbVtpXSA+IDApIHtcbiAgICAgICAgICAgIG1heCA9IGk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgd2hpbGUgKCFiaW1vZGFsVGVzdChoaXN0b2dyYW1Db3B5KSkge1xuICAgICAgICBoaXN0b2dyYW1Db3B5ID0gc21vb3RoZWQoaGlzdG9ncmFtQ29weSk7XG4gICAgICAgIGl0ZXJhdGlvbnMrKztcbiAgICAgICAgaWYgKGl0ZXJhdGlvbnMgPiAxMDAwMCkgeyAvL2lmIHRoZXkgb2NjdXIgbW9yZSB0aGFuIDEwMDAwIGl0ZXJhdGlvbnMgaXQgcmV0dXJucyAtMVxuICAgICAgICAgICAgcmV0dXJuIHRocmVzaG9sZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0aHJlc2hvbGQgPSBtaW5pbXVtQmV0d2VlblBlZWtzKGhpc3RvZ3JhbUNvcHksIG1heCk7XG4gICAgcmV0dXJuIHRocmVzaG9sZDtcbn1cbmZ1bmN0aW9uIHNtb290aGVkKGhpc3RvZ3JhbSkgey8vU21vb3RoIHdpdGggYSAzIHBvaW50IHJ1bm5pbmcgbWVhbiBmaWx0ZXJcbiAgICBsZXQgYXVIaXN0b2dyYW0gPSBuZXcgQXJyYXkoaGlzdG9ncmFtLmxlbmd0aCk7IC8vIGEgY29weSBvZiB0aGUgaGlzdG9ncmFtYSBmb3IgdGhlIHNtb290aGluZyBwcm9jZXNzXG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBoaXN0b2dyYW0ubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgIGF1SGlzdG9ncmFtW2ldID0gKGhpc3RvZ3JhbVtpIC0gMV0gKyBoaXN0b2dyYW1baV0gKyBoaXN0b2dyYW1baSArIDFdKSAvIDM7XG4gICAgfVxuICAgIGF1SGlzdG9ncmFtWzBdID0gKGhpc3RvZ3JhbVswXSArIGhpc3RvZ3JhbVsxXSkgLyAzO1xuICAgIGF1SGlzdG9ncmFtW2hpc3RvZ3JhbS5sZW5ndGggLSAxXSA9IChoaXN0b2dyYW1baGlzdG9ncmFtLmxlbmd0aCAtIDJdICsgaGlzdG9ncmFtW2hpc3RvZ3JhbS5sZW5ndGggLSAxXSkgLyAzO1xuICAgIHJldHVybiBhdUhpc3RvZ3JhbTtcbn1cbmZ1bmN0aW9uIG1pbmltdW1CZXR3ZWVuUGVla3MoaGlzdG9ncmFtQmltb2RhbCwgbWF4KSB7XG4gICAgbGV0IHRocmVzaG9sZDtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IG1heDsgaSsrKSB7XG4gICAgICAgIGlmIChoaXN0b2dyYW1CaW1vZGFsW2kgLSAxXSA+IGhpc3RvZ3JhbUJpbW9kYWxbaV0gJiYgaGlzdG9ncmFtQmltb2RhbFtpICsgMV0gPj0gaGlzdG9ncmFtQmltb2RhbFtpXSkge1xuICAgICAgICAgICAgdGhyZXNob2xkID0gaTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aHJlc2hvbGQ7XG59XG5mdW5jdGlvbiBiaW1vZGFsVGVzdChoaXN0b2dyYW0pIHsvL0l0IGlzIHJlc3BvbnNpYmxlIGZvciBkZXRlcm1pbmluZyBpZiBhIGhpc3RvZ3JhbSBpcyBiaW1vZGFsXG4gICAgbGV0IGxlbiA9IGhpc3RvZ3JhbS5sZW5ndGg7XG4gICAgbGV0IGlzQmltb2RhbCA9IGZhbHNlO1xuICAgIGxldCBwZWFrcyA9IDA7XG4gICAgZm9yIChsZXQgayA9IDE7ayA8IGxlbiAtIDE7aysrKSB7XG4gICAgICAgIGlmIChoaXN0b2dyYW1bayAtIDFdIDwgaGlzdG9ncmFtW2tdICYmIGhpc3RvZ3JhbVtrICsgMV0gPCBoaXN0b2dyYW1ba10pIHtcbiAgICAgICAgICAgIHBlYWtzKys7XG4gICAgICAgICAgICBpZiAocGVha3MgPiAyKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAocGVha3MgPT09IDIpXG4gICAgICAgIGlzQmltb2RhbCA9IHRydWU7XG4gICAgcmV0dXJuIGlzQmltb2RhbDtcbn1cbiIsIi8vc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9maWppL0F1dG9fVGhyZXNob2xkL2Jsb2IvbWFzdGVyL3NyYy9tYWluL2phdmEvZmlqaS90aHJlc2hvbGQvQXV0b19UaHJlc2hvbGQuamF2YVxuLy8gVy4gVHNhaSwgXCJNb21lbnQtcHJlc2VydmluZyB0aHJlc2hvbGRpbmc6IGEgbmV3IGFwcHJvYWNoLFwiIENvbXB1dGVyIFZpc2lvbixcbi8vIEdyYXBoaWNzLCBhbmQgSW1hZ2UgUHJvY2Vzc2luZywgdm9sLiAyOSwgcHAuIDM3Ny0zOTMsIDE5ODUuXG4vLyBQb3J0ZWQgdG8gSW1hZ2VKIHBsdWdpbiBieSBHLkxhbmRpbmkgZnJvbSB0aGUgdGhlIG9wZW4gc291cmNlIHByb2plY3QgRk9VUklFUiAwLjhcbi8vIGJ5IE0uIEVtcmUgQ2VsZWJpICwgRGVwYXJ0bWVudCBvZiBDb21wdXRlciBTY2llbmNlLCBMb3Vpc2lhbmEgU3RhdGUgVW5pdmVyc2l0eSBpbiBTaHJldmVwb3J0XG4vLyBTaHJldmVwb3J0LCBMQSA3MTExNSwgVVNBXG4vLyBodHRwOi8vc291cmNlZm9yZ2UubmV0L3Byb2plY3RzL2ZvdXJpZXItaXBhbFxuLy8gaHR0cDovL3d3dy5sc3VzLmVkdS9mYWN1bHR5L35lY2VsZWJpL2ZvdXJpZXIuaHRtXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBtb21lbnRzKGhpc3RvZ3JhbSx0b3RhbCkge1xuLy9tb21lbnRzXG4gICAgbGV0IG0wID0gMS4wO1xuICAgIGxldCBtMSA9IDAuMDtcbiAgICBsZXQgbTIgPSAwLjA7XG4gICAgbGV0IG0zID0gMC4wO1xuICAgIGxldCBzdW0gPSAwLjA7XG4gICAgbGV0IHAwO1xuICAgIGxldCBjZCwgYzAsIGMxLCB6MCwgejE7IC8qIGF1eGlsaWFyeSB2YXJpYWJsZXMgKi9cbiAgICBsZXQgdGhyZXNob2xkID0gLTE7XG4gICAgbGV0IGhpc3RvZ3JhbUxlbmd0aCA9IGhpc3RvZ3JhbS5sZW5ndGg7XG4gICAgbGV0IG5vcm1hbGl6ZWRIaXN0b2dyYW0gPSBuZXcgQXJyYXkoaGlzdG9ncmFtTGVuZ3RoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGhpc3RvZ3JhbUxlbmd0aDsgaSsrKSB7XG4gICAgICAgIG5vcm1hbGl6ZWRIaXN0b2dyYW1baV0gPSBoaXN0b2dyYW1baV0gLyB0b3RhbDtcbiAgICB9XG4gICAgLyogQ2FsY3VsYXRlIHRoZSBmaXJzdCwgc2Vjb25kLCBhbmQgdGhpcmQgb3JkZXIgbW9tZW50cyAqL1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaGlzdG9ncmFtTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbTEgKz0gaSAqIG5vcm1hbGl6ZWRIaXN0b2dyYW1baV07XG4gICAgICAgIG0yICs9IGkgKiBpICogbm9ybWFsaXplZEhpc3RvZ3JhbVtpXTtcbiAgICAgICAgbTMgKz0gaSAqIGkgKiBpICogbm9ybWFsaXplZEhpc3RvZ3JhbVtpXTtcbiAgICB9XG4gICAgLypcbiAgICAgRmlyc3QgNCBtb21lbnRzIG9mIHRoZSBncmF5LWxldmVsIGltYWdlIHNob3VsZCBtYXRjaCB0aGUgZmlyc3QgNCBtb21lbnRzXG4gICAgIG9mIHRoZSB0YXJnZXQgYmluYXJ5IGltYWdlLiBUaGlzIGxlYWRzIHRvIDQgZXF1YWxpdGllcyB3aG9zZSBzb2x1dGlvbnNcbiAgICAgYXJlIGdpdmVuIGluIHRoZSBBcHBlbmRpeCBvZiBSZWYuIDFcbiAgICAgKi9cbiAgICBjZCA9IG0wICogbTIgLSBtMSAqIG0xOyAvL2RldGVybWluYW50IG9mIHRoZSBtYXRyaXogb2YgaGFua2VsIGZvciBtb21lbnRzIDJ4MlxuICAgIGMwID0gKC1tMiAqIG0yICsgbTEgKiBtMykgLyBjZDtcbiAgICBjMSA9IChtMCAqIC1tMyArIG0yICogbTEpIC8gY2Q7XG4vL25ldyB0d28gZ3JheSB2YWx1ZXMgd2hlcmUgejA8ejFcbiAgICB6MCA9IDAuNSAqICgtYzEgLSBNYXRoLnNxcnQgKGMxICogYzEgLSA0LjAgKiBjMCkpO1xuICAgIHoxID0gMC41ICogKC1jMSArIE1hdGguc3FydCAoYzEgKiBjMSAtIDQuMCAqIGMwKSk7XG4gICAgcDAgPSAoejEgLSBtMSkgLyAoejEgLSB6MCk7IC8qIEZyYWN0aW9uIG9mIHRoZSBvYmplY3QgcGl4ZWxzIGluIHRoZSB0YXJnZXQgYmluYXJ5IGltYWdlIChwMHowK3AxejE9bTEpICovXG4vLyBUaGUgdGhyZXNob2xkIGlzIHRoZSBncmF5LWxldmVsIGNsb3Nlc3QgdG8gdGhlIHAwLXRpbGUgb2YgdGhlIG5vcm1hbGl6ZWQgaGlzdG9ncmFtXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBoaXN0b2dyYW1MZW5ndGg7IGkrKykge1xuICAgICAgICBzdW0gKz0gbm9ybWFsaXplZEhpc3RvZ3JhbVtpXTtcbiAgICAgICAgaWYgKHN1bSA+IHAwKSB7XG4gICAgICAgICAgICB0aHJlc2hvbGQgPSBpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRocmVzaG9sZDtcbn1cbmZ1bmN0aW9uIHBhcnRpYWxTdW0oaGlzdG9ncmFtLCBsaW1pdGUpIHsvL2EgcGFydGlhbCBzdW0gaXMgY2FsY3VsYXRlZCBhY2NvcmRpbmcgdG8gdGhlIHZhbHVlIGxpbWl0XG4gICAgbGV0IHN1bSA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPD0gbGltaXRlOyBpKyspIHtcbiAgICAgICAgc3VtICs9IGhpc3RvZ3JhbVtpXTtcbiAgICB9XG4gICAgcmV0dXJuIHN1bTtcbn1cbiIsIi8qKlxuICogVGhlIG1ldGhvZCBpcyBwcmVzZW50IGluOiBPdHN1LCBOICgxOTc5KSwgXCJBIHRocmVzaG9sZCBzZWxlY3Rpb24gbWV0aG9kIGZyb20gZ3JheS1sZXZlbCBoaXN0b2dyYW1zXCIsIElFRUUgVHJhbnMuIFN5cy4sIE1hbi4sIEN5YmVyLiA5OiA2Mi02NlxuICogVGhlIE90c3UgaW1wbGVtZW50YXRpb24gaXMgYmFzZWQgb246IGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL090c3Unc19tZXRob2RcbiAqIEBwYXJhbSBoaXN0b2dyYW0gLSB0aGUgaGlzdG9ncmFtIG9mIHRoZSBpbWFnZVxuICogQHJldHVybnMge251bWJlcn0gLSB0aGUgdGhyZXNob2xkXG4gKi9cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gb3RzdShoaXN0b2dyYW0sIHRvdGFsKSB7XG5cbiAgICBsZXQgc3VtID0gMDsgICAgICAgICAgICAvL1RvdGFsIEludGVuc2l0aWVzIG9mIHRoZSBoaXN0b2dyYW1cbiAgICBsZXQgc3VtQiA9IDA7ICAgICAgICAgICAvL1RvdGFsIGludGVuc2l0aWVzIGluIHRoZSAxLWNsYXNzIGhpc3RvZ3JhbVxuICAgIGxldCB3QiA9IDA7ICAgICAgICAgICAgIC8vVG90YWwgcGl4ZWxzIGluIHRoZSAxLWNsYXNzIGhpc3RvZ3JhbVxuICAgIGxldCB3RiA9IDA7ICAgICAgICAgICAgIC8vVG90YWwgcGl4ZWxzIGluIHRoZSAyLWNsYXNzIGhpc3RvZ3JhbVxuICAgIGxldCBtQjsgICAgICAgICAgICAgICAgIC8vTWVhbiBvZiAxLWNsYXNzIGludGVuc2l0aWVzXG4gICAgbGV0IG1GOyAgICAgICAgICAgICAgICAgLy9NZWFuIG9mIDItY2xhc3MgaW50ZW5zaXRpZXNcbiAgICBsZXQgbWF4ID0gMC4wOyAgICAgICAgICAvL0F1eGlsaWFyeSB2YXJpYWJsZSB0byBzYXZlIHRlbXBvcmFyaWx5IHRoZSBtYXggdmFyaWFuY2VcbiAgICBsZXQgYmV0d2VlbiA9IDAuMDsgICAgICAvL1RvIHNhdmUgdGhlIGN1cnJlbnQgdmFyaWFuY2VcbiAgICBsZXQgdGhyZXNob2xkID0gMC4wO1xuXG5cbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IGhpc3RvZ3JhbS5sZW5ndGg7ICsraSkge1xuICAgICAgICBzdW0gKz0gaSAqIGhpc3RvZ3JhbVtpXTtcbiAgICB9XG5cbiAgICBmb3IgKGxldCBpID0gMTsgaSA8ICBoaXN0b2dyYW0ubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgd0IgKz0gaGlzdG9ncmFtW2ldO1xuXG4gICAgICAgIGlmICh3QiA9PT0gMClcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB3RiA9IHRvdGFsIC0gd0I7XG4gICAgICAgIGlmICh3RiA9PT0gMClcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIHN1bUIgKz0gaSAqIGhpc3RvZ3JhbVtpXTtcbiAgICAgICAgbUIgPSBzdW1CIC8gd0I7XG4gICAgICAgIG1GID0gKHN1bSAtIHN1bUIpIC8gd0Y7XG4gICAgICAgIGJldHdlZW4gPSB3QiAqIHdGICogKG1CIC0gbUYpICogKG1CIC0gbUYpO1xuXG4gICAgICAgIGlmIChiZXR3ZWVuID49IG1heCkge1xuICAgICAgICAgICAgdGhyZXNob2xkID0gaTtcbiAgICAgICAgICAgIG1heCA9IGJldHdlZW47XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRocmVzaG9sZDtcbn1cblxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcGVyY2VudGlsZShoaXN0b2dyYW0pIHtcbiAgICAvLyBTZWUgaHR0cDovL2ltYWdlai5uaWguZ292L2lqL2Rvd25sb2FkL3Rvb2xzL3NvdXJjZS9pai9wcm9jZXNzL0F1dG9UaHJlc2hvbGRlci5qYXZhXG4gICAgLy8gVy4gRG95bGUsIFwiT3BlcmF0aW9uIHVzZWZ1bCBmb3Igc2ltaWxhcml0eS1pbnZhcmlhbnQgcGF0dGVybiByZWNvZ25pdGlvbixcIlxuICAgIC8vIEpvdXJuYWwgb2YgdGhlIEFzc29jaWF0aW9uIGZvciBDb21wdXRpbmcgTWFjaGluZXJ5LCB2b2wuIDkscHAuIDI1OS0yNjcsIDE5NjIuXG4gICAgLy8gcG9ydGVkIHRvIEltYWdlSiBwbHVnaW4gYnkgRy5MYW5kaW5pIGZyb20gQW50dGkgTmllbWlzdG8ncyBNYXRsYWIgY29kZSAoR1BMKVxuICAgIC8vIE9yaWdpbmFsIE1hdGxhYiBjb2RlIENvcHlyaWdodCAoQykgMjAwNCBBbnR0aSBOaWVtaXN0b1xuICAgIC8vIFNlZSBodHRwOi8vd3d3LmNzLnR1dC5maS9+YW50L2hpc3R0aHJlc2gvIGZvciBhbiBleGNlbGxlbnQgc2xpZGUgcHJlc2VudGF0aW9uXG4gICAgLy8gYW5kIHRoZSBvcmlnaW5hbCBNYXRsYWIgY29kZS5cblxuICAgIGxldCB0aHJlc2hvbGQgPSAtMTtcbiAgICBsZXQgcGVyY2VudGlsZSA9IDAuNTsgLy8gZGVmYXVsdCBmcmFjdGlvbiBvZiBmb3JlZ3JvdW5kIHBpeGVsc1xuICAgIGxldCBhdmVjID0gbmV3IEFycmF5KGhpc3RvZ3JhbS5sZW5ndGgpO1xuXG4gICAgbGV0IHRvdGFsID0gcGFydGlhbFN1bShoaXN0b2dyYW0sIGhpc3RvZ3JhbS5sZW5ndGggLSAxKTtcbiAgICBsZXQgdGVtcCA9IDEuMDtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaGlzdG9ncmFtLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGF2ZWNbaV0gPSBNYXRoLmFicygocGFydGlhbFN1bShoaXN0b2dyYW0sIGkpIC8gdG90YWwpIC0gcGVyY2VudGlsZSk7XG4gICAgICAgIGlmIChhdmVjW2ldIDwgdGVtcCkge1xuICAgICAgICAgICAgdGVtcCA9IGF2ZWNbaV07XG4gICAgICAgICAgICB0aHJlc2hvbGQgPSBpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRocmVzaG9sZDtcbn1cblxuZnVuY3Rpb24gcGFydGlhbFN1bShoaXN0b2dyYW0sIGVuZEluZGV4KSB7XG4gICAgbGV0IHggPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDw9IGVuZEluZGV4OyBpKyspIHtcbiAgICAgICAgeCArPSBoaXN0b2dyYW1baV07XG4gICAgfVxuICAgIHJldHVybiB4O1xufVxuIiwiLy8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9maWppL0F1dG9fVGhyZXNob2xkL2Jsb2IvbWFzdGVyL3NyYy9tYWluL2phdmEvZmlqaS90aHJlc2hvbGQvQXV0b19UaHJlc2hvbGQuamF2YVxuLy8gS2FwdXIgSi5OLiwgU2Fob28gUC5LLiwgYW5kIFdvbmcgQS5LLkMuICgxOTg1KSBcIkEgTmV3IE1ldGhvZCBmb3Jcbi8vIEdyYXktTGV2ZWwgUGljdHVyZSBUaHJlc2hvbGRpbmcgVXNpbmcgdGhlIEVudHJvcHkgb2YgdGhlIEhpc3RvZ3JhbVwiXG4vLyBHcmFwaGljYWwgTW9kZWxzIGFuZCBJbWFnZSBQcm9jZXNzaW5nLCAyOSgzKTogMjczLTI4NVxuLy8gTS4gRW1yZSBDZWxlYmlcbi8vIDA2LjE1LjIwMDdcbi8vIFBvcnRlZCB0byBJbWFnZUogcGx1Z2luIGJ5IEcuTGFuZGluaSBmcm9tIEUgQ2VsZWJpJ3MgZm91cmllcl8wLjggcm91dGluZXNcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcmVueWlFbnRyb3B5KGhpc3RvZ3JhbSwgdG90YWwpIHtcbiAgICBsZXQgb3B0X3RocmVzaG9sZDsgLy9PcHRpbWFsIHRocmVzaG9sZFxuICAgIGxldCBmaXJzdF9iaW47IC8vRmlyc3Qgbm9uLXplcm8gYmluXG4gICAgbGV0IGxhc3RfYmluOyAvL2xhc3Qgbm9uLXplcm8gYmluXG5cbiAgICBsZXQgbm9ybV9oaXN0byA9IG5ldyBBcnJheShoaXN0b2dyYW0ubGVuZ3RoKTsgLy9ub3JtYWxpemVkIGhpc3RvZ3JhbVxuICAgIGxldCBQMSA9IG5ldyBBcnJheShoaXN0b2dyYW0ubGVuZ3RoKTsgLy9hY3VtdWxhdGl2ZSBub3JtYWxpemVkIGhpc3RvZ3JhbVxuICAgIGxldCBQMiA9IG5ldyBBcnJheShoaXN0b2dyYW0ubGVuZ3RoKTsgLy9hY3VtdWxhdGl2ZSBub3JtYWxpemVkIGhpc3RvZ3JhbVxuXG4gICAgLy9FbnRyb3B5IFZhcmlhYmxlc1xuICAgIGxldCB0aHJlc2hvbGQxID0gMDtcbiAgICBsZXQgdGhyZXNob2xkMiA9IDA7XG4gICAgbGV0IHRocmVzaG9sZDMgPSAwO1xuICAgIGxldCBtYXhfZW50MSA9IDAuMDtcbiAgICBsZXQgbWF4X2VudDIgPSAwLjA7XG4gICAgbGV0IG1heF9lbnQzID0gMC4wO1xuICAgIGxldCBhbHBoYTIgPSAwLjU7XG4gICAgbGV0IHRlcm0yID0gMS4wIC8gKDEuMCAtIGFscGhhMik7XG4gICAgbGV0IGFscGhhMyA9IDIuMDtcbiAgICBsZXQgdGVybTMgPSAxLjAgLyAoMS4wIC0gYWxwaGEzKTtcblxuICAgIGZvciAobGV0IGloID0gMDsgaWggPCBoaXN0b2dyYW0ubGVuZ3RoOyBpaCsrKVxuICAgICAgICBub3JtX2hpc3RvW2loXSA9IGhpc3RvZ3JhbVtpaF0gLyB0b3RhbDtcblxuICAgIFAxWzBdID0gbm9ybV9oaXN0b1swXTtcbiAgICBQMlswXSA9IDEuMCAtIFAxWzBdO1xuICAgIGZvciAobGV0IGloID0gMTsgaWggPCBoaXN0b2dyYW0ubGVuZ3RoOyBpaCsrKSB7XG4gICAgICAgIFAxW2loXSA9IFAxW2loIC0gMV0gKyBub3JtX2hpc3RvW2loXTtcbiAgICAgICAgUDJbaWhdID0gMS4wIC0gUDFbaWhdO1xuICAgIH1cblxuICAgIC8qIERldGVybWluZSB0aGUgZmlyc3Qgbm9uLXplcm8gYmluICovXG4gICAgZmlyc3RfYmluID0gMDtcbiAgICBmb3IgKGxldCBpaCA9IDA7IGloIDwgaGlzdG9ncmFtLmxlbmd0aDsgaWgrKykge1xuICAgICAgICBpZiAoTWF0aC5hYnMoUDFbaWhdKSA+PSBOdW1iZXIuRVBTSUxPTikge1xuICAgICAgICAgICAgZmlyc3RfYmluID0gaWg7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qIERldGVybWluZSB0aGUgbGFzdCBub24temVybyBiaW4gKi9cbiAgICBsYXN0X2JpbiA9IGhpc3RvZ3JhbS5sZW5ndGggLSAxO1xuICAgIGZvciAobGV0IGloID0gaGlzdG9ncmFtLmxlbmd0aCAtIDE7IGloID49IGZpcnN0X2JpbjsgaWgtLSkge1xuICAgICAgICBpZiAoTWF0aC5hYnMoUDJbaWhdKSA+PSBOdW1iZXIuRVBTSUxPTikge1xuICAgICAgICAgICAgbGFzdF9iaW4gPSBpaDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyogTWF4aW11bSBFbnRyb3B5IFRocmVzaG9sZGluZyAtIEJFR0lOICovXG4gICAgLyogQUxQSEEgPSAxLjAgKi9cbiAgICAvKiBDYWxjdWxhdGUgdGhlIHRvdGFsIGVudHJvcHkgZWFjaCBncmF5LWxldmVsXG4gICAgIGFuZCBmaW5kIHRoZSB0aHJlc2hvbGQgdGhhdCBtYXhpbWl6ZXMgaXRcbiAgICAgKi9cbiAgICBmb3IgKGxldCBpdCA9IGZpcnN0X2JpbjsgaXQgPD0gbGFzdF9iaW47IGl0KyspIHtcbiAgICAgICAgLyogRW50cm9weSBvZiB0aGUgYmFja2dyb3VuZCBwaXhlbHMgKi9cbiAgICAgICAgbGV0IGVudF9iYWNrMSA9IDAuMDtcbiAgICAgICAgbGV0IGVudF9iYWNrMiA9IDAuMDtcbiAgICAgICAgbGV0IGVudF9iYWNrMyA9IDAuMDtcbiAgICAgICAgZm9yIChsZXQgaWggPSAwOyBpaCA8PSBpdDsgaWgrKykge1xuICAgICAgICAgICAgaWYgKGhpc3RvZ3JhbVtpaF0gIT09IDApIHtcbiAgICAgICAgICAgICAgICBlbnRfYmFjazEgLT0gKG5vcm1faGlzdG9baWhdIC8gUDFbaXRdKSAqIE1hdGgubG9nKG5vcm1faGlzdG9baWhdIC8gUDFbaXRdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVudF9iYWNrMiArPSBNYXRoLnNxcnQobm9ybV9oaXN0b1tpaF0gLyBQMVtpdF0pO1xuICAgICAgICAgICAgZW50X2JhY2szICs9IChub3JtX2hpc3RvW2loXSAqIG5vcm1faGlzdG9baWhdKSAvIChQMVtpdF0gKiBQMVtpdF0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLyogRW50cm9weSBvZiB0aGUgb2JqZWN0IHBpeGVscyAqL1xuICAgICAgICBsZXQgZW50X29iajEgPSAwLjA7XG4gICAgICAgIGxldCBlbnRfb2JqMiA9IDAuMDtcbiAgICAgICAgbGV0IGVudF9vYmozID0gMC4wO1xuICAgICAgICBmb3IgKGxldCBpaCA9IGl0ICsgMTsgaWggPCBoaXN0b2dyYW0ubGVuZ3RoOyBpaCsrKSB7XG4gICAgICAgICAgICBpZiAoaGlzdG9ncmFtW2loXSAhPT0gMCkge1xuICAgICAgICAgICAgICAgIGVudF9vYmoxIC09IChub3JtX2hpc3RvW2loXSAvIFAyW2l0XSkgKiBNYXRoLmxvZyhub3JtX2hpc3RvW2loXSAvIFAyW2l0XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbnRfb2JqMiArPSBNYXRoLnNxcnQobm9ybV9oaXN0b1tpaF0gLyBQMltpdF0pO1xuICAgICAgICAgICAgZW50X29iajMgKz0gKG5vcm1faGlzdG9baWhdICogbm9ybV9oaXN0b1tpaF0pIC8gKFAyW2l0XSAqIFAyW2l0XSk7XG4gICAgICAgIH1cblxuICAgICAgICAvKiBUb3RhbCBlbnRyb3B5ICovXG4gICAgICAgIGxldCB0b3RfZW50MSA9IGVudF9iYWNrMSArIGVudF9vYmoxO1xuICAgICAgICBsZXQgdG90X2VudDIgPSB0ZXJtMiAqICgoZW50X2JhY2syICogZW50X29iajIpID4gMC4wID8gTWF0aC5sb2coZW50X2JhY2syICogZW50X29iajIpIDogMC4wKTtcbiAgICAgICAgbGV0IHRvdF9lbnQzID0gdGVybTMgKiAoKGVudF9iYWNrMyAqIGVudF9vYmozKSA+IDAuMCA/IE1hdGgubG9nKGVudF9iYWNrMyAqIGVudF9vYmozKSA6IDAuMCk7XG5cbiAgICAgICAgaWYgKHRvdF9lbnQxID4gbWF4X2VudDEpIHtcbiAgICAgICAgICAgIG1heF9lbnQxID0gdG90X2VudDE7XG4gICAgICAgICAgICB0aHJlc2hvbGQxID0gaXQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodG90X2VudDIgPiBtYXhfZW50Mikge1xuICAgICAgICAgICAgbWF4X2VudDIgPSB0b3RfZW50MjtcbiAgICAgICAgICAgIHRocmVzaG9sZDIgPSBpdDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0b3RfZW50MyA+IG1heF9lbnQzKSB7XG4gICAgICAgICAgICBtYXhfZW50MyA9IHRvdF9lbnQzO1xuICAgICAgICAgICAgdGhyZXNob2xkMyA9IGl0O1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qIEVuZCBNYXhpbXVtIEVudHJvcHkgVGhyZXNob2xkaW5nICovXG5cbiAgICBsZXQgdF9zdGFycyA9IFt0aHJlc2hvbGQxLCB0aHJlc2hvbGQyLCB0aHJlc2hvbGQzXTtcbiAgICB0X3N0YXJzLnNvcnQoKTtcblxuICAgIGxldCBiZXRhcztcblxuICAgIC8qIEFkanVzdCBiZXRhIHZhbHVlcyAqL1xuICAgIGlmIChNYXRoLmFicyh0X3N0YXJzWzBdIC0gdF9zdGFyc1sxXSkgPD0gNSkge1xuICAgICAgICBpZiAoTWF0aC5hYnModF9zdGFyc1sxXSAtIHRfc3RhcnNbMl0pIDw9IDUpIHtcbiAgICAgICAgICAgIGJldGFzID0gWzEsIDIsIDFdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYmV0YXMgPSBbMCwgMSwgM107XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmIChNYXRoLmFicyh0X3N0YXJzWzFdIC0gdF9zdGFyc1syXSkgPD0gNSkge1xuICAgICAgICAgICAgYmV0YXMgPSBbMywgMSwgMF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBiZXRhcyA9IFsxLCAyLCAxXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qIERldGVybWluZSB0aGUgb3B0aW1hbCB0aHJlc2hvbGQgdmFsdWUgKi9cbiAgICBsZXQgb21lZ2EgPSBQMVt0X3N0YXJzWzJdXSAtIFAxW3Rfc3RhcnNbMF1dO1xuICAgIG9wdF90aHJlc2hvbGQgPSBNYXRoLnJvdW5kKHRfc3RhcnNbMF0gKiAoUDFbdF9zdGFyc1swXV0gKyAwLjI1ICogb21lZ2EgKiBiZXRhc1swXSkgKyAwLjI1ICogdF9zdGFyc1sxXSAqIG9tZWdhICogYmV0YXNbMV0gKyB0X3N0YXJzWzJdICogKFAyW3Rfc3RhcnNbMl1dICsgMC4yNSAqIG9tZWdhICogYmV0YXNbMl0pKTtcblxuICAgIHJldHVybiBvcHRfdGhyZXNob2xkO1xufVxuIiwiLy8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9maWppL0F1dG9fVGhyZXNob2xkL2Jsb2IvbWFzdGVyL3NyYy9tYWluL2phdmEvZmlqaS90aHJlc2hvbGQvQXV0b19UaHJlc2hvbGQuamF2YVxuLy8gU2hhbmhiYWcgQS5HLiAoMTk5NCkgXCJVdGlsaXphdGlvbiBvZiBJbmZvcm1hdGlvbiBNZWFzdXJlIGFzIGEgTWVhbnMgb2Zcbi8vIEltYWdlIFRocmVzaG9sZGluZ1wiIEdyYXBoaWNhbCBNb2RlbHMgYW5kIEltYWdlIFByb2Nlc3NpbmcsIDU2KDUpOiA0MTQtNDE5XG4vLyBQb3J0ZWQgdG8gSW1hZ2VKIHBsdWdpbiBieSBHLkxhbmRpbmkgZnJvbSBFIENlbGViaSdzIGZvdXJpZXJfMC44IHJvdXRpbmVzXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHNoYW5iaGFnKGhpc3RvZ3JhbSwgdG90YWwpIHtcbiAgICBsZXQgbm9ybV9oaXN0byA9IG5ldyBBcnJheShoaXN0b2dyYW0ubGVuZ3RoKTsgLy8gbm9ybWFsaXplZCBoaXN0b2dyYW1cbiAgICBmb3IgKGxldCBpaCA9IDA7IGloIDwgaGlzdG9ncmFtLmxlbmd0aDsgaWgrKylcbiAgICAgICAgbm9ybV9oaXN0b1tpaF0gPSBoaXN0b2dyYW1baWhdIC8gdG90YWw7XG5cbiAgICBsZXQgUDEgPSBuZXcgQXJyYXkoaGlzdG9ncmFtLmxlbmd0aCk7IC8vIGN1bXVsYXRpdmUgbm9ybWFsaXplZCBoaXN0b2dyYW1cbiAgICBsZXQgUDIgPSBuZXcgQXJyYXkoaGlzdG9ncmFtLmxlbmd0aCk7XG4gICAgUDFbMF0gPSBub3JtX2hpc3RvWzBdO1xuICAgIFAyWzBdID0gMS4wIC0gUDFbMF07XG4gICAgZm9yIChsZXQgaWggPSAxOyBpaCA8IGhpc3RvZ3JhbS5sZW5ndGg7IGloKyspIHtcbiAgICAgICAgUDFbaWhdID0gUDFbaWggLSAxXSArIG5vcm1faGlzdG9baWhdO1xuICAgICAgICBQMltpaF0gPSAxLjAgLSBQMVtpaF07XG4gICAgfVxuXG4gICAgLyogRGV0ZXJtaW5lIHRoZSBmaXJzdCBub24temVybyBiaW4gKi9cbiAgICBsZXQgZmlyc3RfYmluID0gMDtcbiAgICBmb3IgKGxldCBpaCA9IDA7IGloIDwgaGlzdG9ncmFtLmxlbmd0aDsgaWgrKykge1xuICAgICAgICBpZiAoTWF0aC5hYnMoUDFbaWhdKSA+PSBOdW1iZXIuRVBTSUxPTikge1xuICAgICAgICAgICAgZmlyc3RfYmluID0gaWg7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qIERldGVybWluZSB0aGUgbGFzdCBub24temVybyBiaW4gKi9cbiAgICBsZXQgbGFzdF9iaW4gPSBoaXN0b2dyYW0ubGVuZ3RoIC0gMTtcbiAgICBmb3IgKGxldCBpaCA9IGhpc3RvZ3JhbS5sZW5ndGggLSAxOyBpaCA+PSBmaXJzdF9iaW47IGloLS0pIHtcbiAgICAgICAgaWYgKE1hdGguYWJzKFAyW2loXSkgPj0gTnVtYmVyLkVQU0lMT04pIHtcbiAgICAgICAgICAgIGxhc3RfYmluID0gaWg7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIENhbGN1bGF0ZSB0aGUgdG90YWwgZW50cm9weSBlYWNoIGdyYXktbGV2ZWxcbiAgICAvLyBhbmQgZmluZCB0aGUgdGhyZXNob2xkIHRoYXQgbWF4aW1pemVzIGl0XG4gICAgbGV0IHRocmVzaG9sZCA9IC0xO1xuICAgIGxldCBtaW5fZW50ID0gTnVtYmVyLk1BWF9WQUxVRTsgLy8gbWluIGVudHJvcHlcblxuICAgIGxldCB0ZXJtO1xuICAgIGxldCB0b3RfZW50OyAvLyB0b3RhbCBlbnRyb3B5XG4gICAgbGV0IGVudF9iYWNrOyAvLyBlbnRyb3B5IG9mIHRoZSBiYWNrZ3JvdW5kIHBpeGVscyBhdCBhIGdpdmVuIHRocmVzaG9sZFxuICAgIGxldCBlbnRfb2JqOyAgLy8gZW50cm9weSBvZiB0aGUgb2JqZWN0IHBpeGVscyBhdCBhIGdpdmVuIHRocmVzaG9sZFxuICAgIGZvciAobGV0IGl0ID0gZmlyc3RfYmluOyBpdCA8PSBsYXN0X2JpbjsgaXQrKykge1xuICAgICAgICAvKiBFbnRyb3B5IG9mIHRoZSBiYWNrZ3JvdW5kIHBpeGVscyAqL1xuICAgICAgICBlbnRfYmFjayA9IDAuMDtcbiAgICAgICAgdGVybSA9IDAuNSAvIFAxW2l0XTtcbiAgICAgICAgZm9yIChsZXQgaWggPSAxOyBpaCA8PSBpdDsgaWgrKykgIHtcbiAgICAgICAgICAgIGVudF9iYWNrIC09IG5vcm1faGlzdG9baWhdICogTWF0aC5sb2coMS4wIC0gdGVybSAqIFAxW2loIC0gMV0pO1xuICAgICAgICB9XG4gICAgICAgIGVudF9iYWNrICo9IHRlcm07XG5cbiAgICAgICAgLyogRW50cm9weSBvZiB0aGUgb2JqZWN0IHBpeGVscyAqL1xuICAgICAgICBlbnRfb2JqID0gMC4wO1xuICAgICAgICB0ZXJtID0gMC41IC8gUDJbaXRdO1xuICAgICAgICBmb3IgKGxldCBpaCA9IGl0ICsgMTsgaWggPCBoaXN0b2dyYW0ubGVuZ3RoOyBpaCsrKSB7XG4gICAgICAgICAgICBlbnRfb2JqIC09IG5vcm1faGlzdG9baWhdICogTWF0aC5sb2coMS4wIC0gdGVybSAqIFAyW2loXSk7XG4gICAgICAgIH1cbiAgICAgICAgZW50X29iaiAqPSB0ZXJtO1xuXG4gICAgICAgIC8qIFRvdGFsIGVudHJvcHkgKi9cbiAgICAgICAgdG90X2VudCA9IE1hdGguYWJzKGVudF9iYWNrIC0gZW50X29iaik7XG5cbiAgICAgICAgaWYgKHRvdF9lbnQgPCBtaW5fZW50KSB7XG4gICAgICAgICAgICBtaW5fZW50ID0gdG90X2VudDtcbiAgICAgICAgICAgIHRocmVzaG9sZCA9IGl0O1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aHJlc2hvbGQ7XG59XG4iLCIvLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZpamkvQXV0b19UaHJlc2hvbGQvYmxvYi9tYXN0ZXIvc3JjL21haW4vamF2YS9maWppL3RocmVzaG9sZC9BdXRvX1RocmVzaG9sZC5qYXZhXG4vLyBaYWNrLCBHLiBXLiwgUm9nZXJzLCBXLiBFLiBhbmQgTGF0dCwgUy4gQS4sIDE5NzcsXG4vLyBBdXRvbWF0aWMgTWVhc3VyZW1lbnQgb2YgU2lzdGVyIENocm9tYXRpZCBFeGNoYW5nZSBGcmVxdWVuY3ksXG4vLyBKb3VybmFsIG9mIEhpc3RvY2hlbWlzdHJ5IGFuZCBDeXRvY2hlbWlzdHJ5IDI1ICg3KSwgcHAuIDc0MS03NTNcbi8vXG4vLyAgbW9kaWZpZWQgZnJvbSBKb2hhbm5lcyBTY2hpbmRlbGluIHBsdWdpblxuLy9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHRyaWFuZ2xlKGhpc3RvZ3JhbSkge1xuXG4gICAgLy8gZmluZCBtaW4gYW5kIG1heFxuICAgIGxldCBtaW4gPSAwLCBkbWF4ID0gMCwgbWF4ID0gMCwgbWluMiA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBoaXN0b2dyYW0ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGhpc3RvZ3JhbVtpXSA+IDApIHtcbiAgICAgICAgICAgIG1pbiA9IGk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAobWluID4gMCkgbWluLS07IC8vIGxpbmUgdG8gdGhlIChwPT0wKSBwb2ludCwgbm90IHRvIGhpc3RvZ3JhbVttaW5dXG5cbiAgICAvLyBUaGUgVHJpYW5nbGUgYWxnb3JpdGhtIGNhbm5vdCB0ZWxsIHdoZXRoZXIgdGhlIGRhdGEgaXMgc2tld2VkIHRvIG9uZSBzaWRlIG9yIGFub3RoZXIuXG4gICAgLy8gVGhpcyBjYXVzZXMgYSBwcm9ibGVtIGFzIHRoZXJlIGFyZSAyIHBvc3NpYmxlIHRocmVzaG9sZHMgYmV0d2VlbiB0aGUgbWF4IGFuZCB0aGUgMiBleHRyZW1lc1xuICAgIC8vIG9mIHRoZSBoaXN0b2dyYW0uXG4gICAgLy8gSGVyZSBJIHByb3Bvc2UgdG8gZmluZCBvdXQgdG8gd2hpY2ggc2lkZSBvZiB0aGUgbWF4IHBvaW50IHRoZSBkYXRhIGlzIGZ1cnRoZXN0LCBhbmQgdXNlIHRoYXQgYXNcbiAgICAvLyAgdGhlIG90aGVyIGV4dHJlbWUuXG4gICAgZm9yIChsZXQgaSA9IGhpc3RvZ3JhbS5sZW5ndGggLSAxOyBpID4gMDsgaS0tKSB7XG4gICAgICAgIGlmIChoaXN0b2dyYW1baV0gPiAwKSB7XG4gICAgICAgICAgICBtaW4yID0gaTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChtaW4yIDwgaGlzdG9ncmFtLmxlbmd0aCAtIDEpIG1pbjIrKzsgLy8gbGluZSB0byB0aGUgKHA9PTApIHBvaW50LCBub3QgdG8gZGF0YVttaW5dXG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGhpc3RvZ3JhbS5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoaGlzdG9ncmFtW2ldID4gZG1heCkge1xuICAgICAgICAgICAgbWF4ID0gaTtcbiAgICAgICAgICAgIGRtYXggPSBoaXN0b2dyYW1baV07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBmaW5kIHdoaWNoIGlzIHRoZSBmdXJ0aGVzdCBzaWRlXG4gICAgbGV0IGludmVydGVkID0gZmFsc2U7XG4gICAgaWYgKChtYXggLSBtaW4pIDwgKG1pbjIgLSBtYXgpKSB7XG4gICAgICAgIC8vIHJldmVyc2UgdGhlIGhpc3RvZ3JhbVxuICAgICAgICBpbnZlcnRlZCA9IHRydWU7XG4gICAgICAgIGxldCBsZWZ0ICA9IDA7ICAgICAgICAgICAgICAgICAgICAgIC8vIGluZGV4IG9mIGxlZnRtb3N0IGVsZW1lbnRcbiAgICAgICAgbGV0IHJpZ2h0ID0gaGlzdG9ncmFtLmxlbmd0aCAtIDE7ICAgLy8gaW5kZXggb2YgcmlnaHRtb3N0IGVsZW1lbnRcbiAgICAgICAgd2hpbGUgKGxlZnQgPCByaWdodCkge1xuICAgICAgICAgICAgLy8gZXhjaGFuZ2UgdGhlIGxlZnQgYW5kIHJpZ2h0IGVsZW1lbnRzXG4gICAgICAgICAgICBsZXQgdGVtcCA9IGhpc3RvZ3JhbVtsZWZ0XTtcbiAgICAgICAgICAgIGhpc3RvZ3JhbVtsZWZ0XSAgPSBoaXN0b2dyYW1bcmlnaHRdO1xuICAgICAgICAgICAgaGlzdG9ncmFtW3JpZ2h0XSA9IHRlbXA7XG4gICAgICAgICAgICAvLyBtb3ZlIHRoZSBib3VuZHMgdG93YXJkIHRoZSBjZW50ZXJcbiAgICAgICAgICAgIGxlZnQrKztcbiAgICAgICAgICAgIHJpZ2h0LS07XG4gICAgICAgIH1cbiAgICAgICAgbWluID0gaGlzdG9ncmFtLmxlbmd0aCAtIDEgLSBtaW4yO1xuICAgICAgICBtYXggPSBoaXN0b2dyYW0ubGVuZ3RoIC0gMSAtIG1heDtcbiAgICB9XG5cbiAgICBpZiAobWluID09PSBtYXgpXG4gICAgICAgIHJldHVybiBtaW47XG5cbiAgICAvLyBkZXNjcmliZSBsaW5lIGJ5IG54ICogeCArIG55ICogeSAtIGQgPSAwXG4gICAgbGV0IG54LCBueSwgZDtcbiAgICAvLyBueCBpcyBqdXN0IHRoZSBtYXggZnJlcXVlbmN5IGFzIHRoZSBvdGhlciBwb2ludCBoYXMgZnJlcT0wXG4gICAgbnggPSBoaXN0b2dyYW1bbWF4XTsgICAvLy1taW47IC8vIGRhdGFbbWluXTsgLy8gIGxvd2VzdCB2YWx1ZSBibWluID0gKHA9MCklIGluIHRoZSBpbWFnZVxuICAgIG55ID0gbWluIC0gbWF4O1xuICAgIGQgPSBNYXRoLnNxcnQobnggKiBueCArIG55ICogbnkpO1xuICAgIG54IC89IGQ7XG4gICAgbnkgLz0gZDtcbiAgICBkID0gbnggKiBtaW4gKyBueSAqIGhpc3RvZ3JhbVttaW5dO1xuXG4gICAgLy8gZmluZCBzcGxpdCBwb2ludFxuICAgIGxldCBzcGxpdCA9IG1pbjtcbiAgICBsZXQgc3BsaXREaXN0YW5jZSA9IDA7XG4gICAgZm9yIChsZXQgaSA9IG1pbiArIDE7IGkgPD0gbWF4OyBpKyspIHtcbiAgICAgICAgbGV0IG5ld0Rpc3RhbmNlID0gbnggKiBpICsgbnkgKiBoaXN0b2dyYW1baV0gLSBkO1xuICAgICAgICBpZiAobmV3RGlzdGFuY2UgPiBzcGxpdERpc3RhbmNlKSB7XG4gICAgICAgICAgICBzcGxpdCA9IGk7XG4gICAgICAgICAgICBzcGxpdERpc3RhbmNlID0gbmV3RGlzdGFuY2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3BsaXQtLTtcblxuICAgIGlmIChpbnZlcnRlZCkge1xuICAgICAgICAvLyBUaGUgaGlzdG9ncmFtIG1pZ2h0IGJlIHVzZWQgZm9yIHNvbWV0aGluZyBlbHNlLCBzbyBsZXQncyByZXZlcnNlIGl0IGJhY2tcbiAgICAgICAgbGV0IGxlZnQgID0gMDtcbiAgICAgICAgbGV0IHJpZ2h0ID0gaGlzdG9ncmFtLmxlbmd0aCAtIDE7XG4gICAgICAgIHdoaWxlIChsZWZ0IDwgcmlnaHQpIHtcbiAgICAgICAgICAgIGxldCB0ZW1wID0gaGlzdG9ncmFtW2xlZnRdO1xuICAgICAgICAgICAgaGlzdG9ncmFtW2xlZnRdICA9IGhpc3RvZ3JhbVtyaWdodF07XG4gICAgICAgICAgICBoaXN0b2dyYW1bcmlnaHRdID0gdGVtcDtcbiAgICAgICAgICAgIGxlZnQrKztcbiAgICAgICAgICAgIHJpZ2h0LS07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChoaXN0b2dyYW0ubGVuZ3RoIC0gMSAtIHNwbGl0KTtcbiAgICB9XG4gICAgZWxzZVxuICAgICAgICByZXR1cm4gc3BsaXQ7XG59XG4iLCIvLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZpamkvQXV0b19UaHJlc2hvbGQvYmxvYi9tYXN0ZXIvc3JjL21haW4vamF2YS9maWppL3RocmVzaG9sZC9BdXRvX1RocmVzaG9sZC5qYXZhXG4vLyBJbXBsZW1lbnRzIFllbiAgdGhyZXNob2xkaW5nIG1ldGhvZFxuLy8gMSkgWWVuIEouQy4sIENoYW5nIEYuSi4sIGFuZCBDaGFuZyBTLiAoMTk5NSkgXCJBIE5ldyBDcml0ZXJpb25cbi8vICAgIGZvciBBdXRvbWF0aWMgTXVsdGlsZXZlbCBUaHJlc2hvbGRpbmdcIiBJRUVFIFRyYW5zLiBvbiBJbWFnZVxuLy8gICAgUHJvY2Vzc2luZywgNCgzKTogMzcwLTM3OFxuLy8gMikgU2V6Z2luIE0uIGFuZCBTYW5rdXIgQi4gKDIwMDQpIFwiU3VydmV5IG92ZXIgSW1hZ2UgVGhyZXNob2xkaW5nXG4vLyAgICBUZWNobmlxdWVzIGFuZCBRdWFudGl0YXRpdmUgUGVyZm9ybWFuY2UgRXZhbHVhdGlvblwiIEpvdXJuYWwgb2Zcbi8vICAgIEVsZWN0cm9uaWMgSW1hZ2luZywgMTMoMSk6IDE0Ni0xNjVcbi8vICAgIGh0dHA6Ly9jaXRlc2Vlci5pc3QucHN1LmVkdS9zZXpnaW4wNHN1cnZleS5odG1sXG4vL1xuLy8gTS4gRW1yZSBDZWxlYmlcbi8vIDA2LjE1LjIwMDdcbi8vIFBvcnRlZCB0byBJbWFnZUogcGx1Z2luIGJ5IEcuTGFuZGluaSBmcm9tIEUgQ2VsZWJpJ3MgZm91cmllcl8wLjggcm91dGluZXNcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24geWVuKGhpc3RvZ3JhbSwgdG90YWwpIHtcbiAgICBsZXQgbm9ybV9oaXN0byA9IG5ldyBBcnJheShoaXN0b2dyYW0ubGVuZ3RoKTsgLy8gbm9ybWFsaXplZCBoaXN0b2dyYW1cbiAgICBmb3IgKGxldCBpaCA9IDA7IGloIDwgaGlzdG9ncmFtLmxlbmd0aDsgaWgrKylcbiAgICAgICAgbm9ybV9oaXN0b1tpaF0gPSBoaXN0b2dyYW1baWhdIC8gdG90YWw7XG5cbiAgICBsZXQgUDEgPSBuZXcgQXJyYXkoaGlzdG9ncmFtLmxlbmd0aCk7IC8vIGN1bXVsYXRpdmUgbm9ybWFsaXplZCBoaXN0b2dyYW1cbiAgICBQMVswXSA9IG5vcm1faGlzdG9bMF07XG4gICAgZm9yIChsZXQgaWggPSAxOyBpaCA8IGhpc3RvZ3JhbS5sZW5ndGg7IGloKyspXG4gICAgICAgIFAxW2loXSA9IFAxW2loIC0gMV0gKyBub3JtX2hpc3RvW2loXTtcblxuICAgIGxldCBQMV9zcSA9IG5ldyBBcnJheShoaXN0b2dyYW0ubGVuZ3RoKTtcbiAgICBQMV9zcVswXSA9IG5vcm1faGlzdG9bMF0gKiBub3JtX2hpc3RvWzBdO1xuICAgIGZvciAobGV0IGloID0gMTsgaWggPCBoaXN0b2dyYW0ubGVuZ3RoOyBpaCsrKVxuICAgICAgICBQMV9zcVtpaF0gPSBQMV9zcVtpaCAtIDFdICsgbm9ybV9oaXN0b1tpaF0gKiBub3JtX2hpc3RvW2loXTtcblxuICAgIGxldCBQMl9zcSA9IG5ldyBBcnJheShoaXN0b2dyYW0ubGVuZ3RoKTtcbiAgICBQMl9zcVtoaXN0b2dyYW0ubGVuZ3RoIC0gMV0gPSAwLjA7XG4gICAgZm9yIChsZXQgaWggPSBoaXN0b2dyYW0ubGVuZ3RoIC0gMjsgaWggPj0gMDsgaWgtLSlcbiAgICAgICAgUDJfc3FbaWhdID0gUDJfc3FbaWggKyAxXSArIG5vcm1faGlzdG9baWggKyAxXSAqIG5vcm1faGlzdG9baWggKyAxXTtcblxuICAgIC8qIEZpbmQgdGhlIHRocmVzaG9sZCB0aGF0IG1heGltaXplcyB0aGUgY3JpdGVyaW9uICovXG4gICAgbGV0IHRocmVzaG9sZCA9IC0xO1xuICAgIGxldCBtYXhfY3JpdCA9IE51bWJlci5NSU5fVkFMVUU7XG4gICAgbGV0IGNyaXQ7XG4gICAgZm9yIChsZXQgaXQgPSAwOyBpdCA8IGhpc3RvZ3JhbS5sZW5ndGg7IGl0KyspIHtcbiAgICAgICAgY3JpdCA9IC0xLjAgKiAoKFAxX3NxW2l0XSAqIFAyX3NxW2l0XSkgPiAwLjAgPyBNYXRoLmxvZyhQMV9zcVtpdF0gKiBQMl9zcVtpdF0pIDogMC4wKSArIDIgKiAoKFAxW2l0XSAqICgxLjAgLSBQMVtpdF0pKSA+IDAuMCA/IE1hdGgubG9nKFAxW2l0XSAqICgxLjAgLSBQMVtpdF0pKSA6IDAuMCk7XG4gICAgICAgIGlmIChjcml0ID4gbWF4X2NyaXQpIHtcbiAgICAgICAgICAgIG1heF9jcml0ID0gY3JpdDtcbiAgICAgICAgICAgIHRocmVzaG9sZCA9IGl0O1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aHJlc2hvbGQ7XG59XG4iLCJpbXBvcnQgSW1hZ2UgZnJvbSAnLi4vaW1hZ2UnO1xuaW1wb3J0IGFycmF5IGZyb20gJ25ldy1hcnJheSc7XG5cbmltcG9ydCBjb3B5IGZyb20gJy4uL3V0aWxpdHkvY29weSc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHBhZCh7XG4gICAgc2l6ZSA9IDAsXG4gICAgYWxnb3JpdGhtID0gJ2NvcHknLFxuICAgIGNvbG9yXG4gICAgfSA9IHt9KSB7XG5cbiAgICB0aGlzLmNoZWNrUHJvY2Vzc2FibGUoJ3BhZCcsIHtcbiAgICAgICAgYml0RGVwdGg6IFs4LCAxNl1cbiAgICB9KTtcblxuICAgIGlmIChhbGdvcml0aG0gPT09ICdzZXQnKSB7XG4gICAgICAgIGlmIChjb2xvci5sZW5ndGggIT09IHRoaXMuY2hhbm5lbHMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncGFkOiB0aGUgY29sb3IgYXJyYXkgbXVzdCBoYXZlIHRoZSBzYW1lIGxlbmd0aCBhcyB0aGUgbnVtYmVyIG9mIGNoYW5uZWxzLiBIZXJlOiAnICsgdGhpcy5jaGFubmVscyk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb2xvci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGNvbG9yW2ldID09PSAwKSBjb2xvcltpXSA9IDAuMDAxO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgY29sb3IgPSBhcnJheSh0aGlzLmNoYW5uZWxzLCBudWxsKTtcbiAgICB9XG5cbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoc2l6ZSkpIHtcbiAgICAgICAgc2l6ZSA9IFtzaXplLHNpemVdO1xuICAgIH1cblxuICAgIGxldCBuZXdXaWR0aCA9IHRoaXMud2lkdGggKyBzaXplWzBdICogMjtcbiAgICBsZXQgbmV3SGVpZ2h0ID0gdGhpcy5oZWlnaHQgKyBzaXplWzFdICogMjtcbiAgICBsZXQgY2hhbm5lbHMgPSB0aGlzLmNoYW5uZWxzO1xuXG4gICAgbGV0IG5ld0ltYWdlID0gSW1hZ2UuY3JlYXRlRnJvbSh0aGlzLCB7d2lkdGg6IG5ld1dpZHRoLCBoZWlnaHQ6IG5ld0hlaWdodH0pO1xuXG4gICAgY29weSh0aGlzLCBuZXdJbWFnZSwgc2l6ZVswXSwgc2l6ZVsxXSk7XG5cblxuXG4gICAgZm9yIChsZXQgaSA9IHNpemVbMF07IGkgPCBuZXdXaWR0aCAtIHNpemVbMF07IGkrKykge1xuICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IGNoYW5uZWxzOyBrKyspIHtcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IGNvbG9yW2tdIHx8IG5ld0ltYWdlLmRhdGFbKHNpemVbMV0gKiBuZXdXaWR0aCArIGkpICogY2hhbm5lbHMgKyBrXTtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgc2l6ZVsxXTsgaisrKSB7XG4gICAgICAgICAgICAgICAgbmV3SW1hZ2UuZGF0YVsoaiAqIG5ld1dpZHRoICsgaSkgKiBjaGFubmVscyArIGtdID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YWx1ZSA9IGNvbG9yW2tdIHx8IG5ld0ltYWdlLmRhdGFbKChuZXdIZWlnaHQgLSBzaXplWzFdIC0gMSkgKiBuZXdXaWR0aCArIGkpICogY2hhbm5lbHMgKyBrXTtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSBuZXdIZWlnaHQgLSBzaXplWzFdOyBqIDwgbmV3SGVpZ2h0OyBqKyspIHtcbiAgICAgICAgICAgICAgICBuZXdJbWFnZS5kYXRhWyhqICogbmV3V2lkdGggKyBpKSAqIGNoYW5uZWxzICsga10gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZvciAobGV0IGogPSAwOyBqIDwgbmV3SGVpZ2h0OyBqKyspIHtcbiAgICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCBjaGFubmVsczsgaysrKSB7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSBjb2xvcltrXSB8fCBuZXdJbWFnZS5kYXRhWyhqICogbmV3V2lkdGggKyBzaXplWzBdKSAqIGNoYW5uZWxzICsga107XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNpemVbMF07IGkrKykge1xuICAgICAgICAgICAgICAgIG5ld0ltYWdlLmRhdGFbKGogKiBuZXdXaWR0aCArIGkpICogY2hhbm5lbHMgKyBrXSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFsdWUgPSBjb2xvcltrXSB8fCBuZXdJbWFnZS5kYXRhWyhqICogbmV3V2lkdGggKyBuZXdXaWR0aCAtIHNpemVbMF0gLSAxKSAqIGNoYW5uZWxzICsga107XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gbmV3V2lkdGggLSBzaXplWzBdOyBpIDwgbmV3V2lkdGg7IGkrKykge1xuICAgICAgICAgICAgICAgIG5ld0ltYWdlLmRhdGFbKGogKiBuZXdXaWR0aCArIGkpICogY2hhbm5lbHMgKyBrXSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ld0ltYWdlO1xufVxuIiwiaW1wb3J0IEltYWdlIGZyb20gJy4uL2ltYWdlJztcbmltcG9ydCAqIGFzIEtpbmROYW1lcyBmcm9tICcuLi9raW5kTmFtZXMnO1xuXG4vLyBUaGlzIGlzIGEgdGVtcG9yYXJ5IGNvZGUgdGhhdCBzaG91bGQgYmUgcGxhY2VkIGluIHRoZSBtb3JlIGdlbmVyYXRlIHJlc2l6ZSBtZXRob2Rcbi8vIGl0IG9ubHkgd29ya3MgZm9yIHNjYWxlZCBkb3duICFcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcmVzaXplQmluYXJ5KHNjYWxlID0gMC41LCBvcHRpb25zID0ge30pIHtcbiAgICB0aGlzLmNoZWNrUHJvY2Vzc2FibGUoJ3Jlc2l6ZUJpbmFyeScsIHtcbiAgICAgICAgYml0RGVwdGg6IFsxXVxuICAgIH0pO1xuXG4gICAgbGV0IHdpZHRoID0gTWF0aC5mbG9vcih0aGlzLndpZHRoICogc2NhbGUpO1xuICAgIGxldCBoZWlnaHQgPSBNYXRoLmZsb29yKHRoaXMuaGVpZ2h0ICogc2NhbGUpO1xuICAgIGxldCBzaGlmdFggPSBNYXRoLnJvdW5kKCh0aGlzLndpZHRoIC0gd2lkdGgpIC8gMik7XG4gICAgbGV0IHNoaWZ0WSA9IE1hdGgucm91bmQoKHRoaXMuaGVpZ2h0IC0gaGVpZ2h0KSAvIDIpO1xuXG4gICAgbGV0IG5ld0ltYWdlID0gSW1hZ2UuY3JlYXRlRnJvbSh0aGlzLCB7XG4gICAgICAgIGtpbmQ6IEtpbmROYW1lcy5CSU5BUlksXG4gICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgICAgIHBvc2l0aW9uOiBbc2hpZnRYLCBzaGlmdFldXG4gICAgfSk7XG5cbiAgICBmb3IgKGxldCB4ID0gMDsgeCA8IHRoaXMud2lkdGg7IHgrKykge1xuICAgICAgICBmb3IgKGxldCB5ID0gMDsgeSA8IHRoaXMuaGVpZ2h0OyB5KyspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmdldEJpdFhZKHgseSkpIHtcbiAgICAgICAgICAgICAgICBuZXdJbWFnZS5zZXRCaXRYWShNYXRoLmZsb29yKHggKiBzY2FsZSksIE1hdGguZmxvb3IoeSAqIHNjYWxlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbmV3SW1hZ2U7XG59XG4iLCJpbXBvcnQgSW1hZ2UgZnJvbSAnLi4vaW1hZ2UnO1xuaW1wb3J0IHtSR0J9IGZyb20gJy4uL21vZGVsL21vZGVsJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcmdiYTgoKSB7XG5cbiAgICBsZXQgbmV3SW1hZ2UgPSBuZXcgSW1hZ2UodGhpcy53aWR0aCwgdGhpcy5oZWlnaHQsIHtcbiAgICAgICAga2luZDonUkdCQSdcbiAgICB9KTtcblxuICAgIG5ld0ltYWdlLmRhdGEgPSB0aGlzLmdldFJHQkFEYXRhKCk7XG4gICAgcmV0dXJuIG5ld0ltYWdlO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gbmVhcmVzdE5laWdoYm9yKG5ld0ltYWdlLCBuZXdXaWR0aCwgbmV3SGVpZ2h0KSB7XG4gICAgY29uc3Qgd1JhdGlvID0gdGhpcy53aWR0aCAvIG5ld1dpZHRoO1xuICAgIGNvbnN0IGhSYXRpbyA9IHRoaXMuaGVpZ2h0IC8gbmV3SGVpZ2h0O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmV3V2lkdGg7IGkrKykge1xuICAgICAgICBjb25zdCB3ID0gTWF0aC5mbG9vcigoaSArIDAuNSkgKiB3UmF0aW8pO1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG5ld0hlaWdodDsgaisrKSB7XG4gICAgICAgICAgICBjb25zdCBoID0gTWF0aC5mbG9vcigoaiArIDAuNSkgKiBoUmF0aW8pO1xuICAgICAgICAgICAgZm9yIChsZXQgYyA9IDA7IGMgPCB0aGlzLmNoYW5uZWxzOyBjKyspIHtcbiAgICAgICAgICAgICAgICBuZXdJbWFnZS5zZXRWYWx1ZVhZKGksIGosIGMsIHRoaXMuZ2V0VmFsdWVYWSh3LCBoLCBjKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG4iLCJpbXBvcnQgSW1hZ2UgZnJvbSAnLi4vLi4vaW1hZ2UnO1xuXG5pbXBvcnQgbmVhcmVzdE5laWdoYm9yIGZyb20gJy4vbmVhcmVzdE5laWdoYm9yJztcbmltcG9ydCB7ZmFjdG9yRGltZW5zaW9uc30gZnJvbSAnLi4vLi4vLi4vdXRpbC9jb252ZXJ0ZXInO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBzY2FsZSh7XG4gICAgd2lkdGggPSB0aGlzLndpZHRoLFxuICAgIGhlaWdodCA9IHRoaXMuaGVpZ2h0LFxuICAgIGZhY3RvciA9IDEsXG4gICAgYWxnb3JpdGhtID0gJ25lYXJlc3ROZWlnaGJvcidcbiAgICB9ID0ge30pIHtcblxuICAgIGNvbnN0IHt3aWR0aDogbmV3V2lkdGgsIGhlaWdodDogbmV3SGVpZ2h0fSA9IGZhY3RvckRpbWVuc2lvbnMoZmFjdG9yLCB3aWR0aCwgaGVpZ2h0KTtcblxuICAgIGxldCBuZXdJbWFnZSA9IEltYWdlLmNyZWF0ZUZyb20odGhpcywgeyB3aWR0aDogbmV3V2lkdGgsIGhlaWdodDogbmV3SGVpZ2h0IH0pO1xuXG4gICAgc3dpdGNoIChhbGdvcml0aG0udG9Mb3dlckNhc2UoKSkge1xuICAgICAgICBjYXNlICduZWFyZXN0bmVpZ2hib3InOlxuICAgICAgICBjYXNlICduZWFyZXN0bmVpZ2hib3VyJzpcbiAgICAgICAgICAgIG5lYXJlc3ROZWlnaGJvci5jYWxsKHRoaXMsIG5ld0ltYWdlLCBuZXdXaWR0aCwgbmV3SGVpZ2h0KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBzY2FsZSBhbGdvcml0aG06ICcgKyBhbGdvcml0aG0pO1xuICAgIH1cblxuICAgIHJldHVybiBuZXdJbWFnZTtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNvcHlJbWFnZShmcm9tSW1hZ2UsIHRvSW1hZ2UsIHgsIHkpIHtcbiAgICBsZXQgZnJvbVdpZHRoID0gZnJvbUltYWdlLndpZHRoO1xuICAgIGxldCBmcm9tSGVpZ2h0ID0gZnJvbUltYWdlLmhlaWdodDtcbiAgICBsZXQgdG9XaWR0aCA9IHRvSW1hZ2Uud2lkdGg7XG4gICAgbGV0IHRvSGVpZ2h0ID0gdG9JbWFnZS5oZWlnaHQ7XG4gICAgbGV0IGNoYW5uZWxzID0gZnJvbUltYWdlLmNoYW5uZWxzO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZnJvbVdpZHRoOyBpKyspIHtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBmcm9tSGVpZ2h0OyBqKyspIHtcbiAgICAgICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgY2hhbm5lbHM7IGsrKykge1xuICAgICAgICAgICAgICAgIGxldCBzb3VyY2UgPSAoaiAqIGZyb21XaWR0aCArIGkpICogY2hhbm5lbHMgKyBrO1xuICAgICAgICAgICAgICAgIGxldCB0YXJnZXQgPSAoKHkgKyBqKSAqIHRvV2lkdGggKyB4ICsgaSkgKiBjaGFubmVscyArIGs7XG4gICAgICAgICAgICAgICAgdG9JbWFnZS5kYXRhW3RhcmdldF0gPSBmcm9tSW1hZ2UuZGF0YVtzb3VyY2VdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuIiwiaW1wb3J0IEltYWdlIGZyb20gJy4uL2ltYWdlJztcbmltcG9ydCBuZXdBcnJheSBmcm9tICduZXctYXJyYXknO1xuaW1wb3J0IE1hdHJpeCBmcm9tICcuLi8uLi91dGlsL21hdHJpeCc7XG5cbi8vIFRyeSB0byBtYXRjaCB0aGUgY3VycmVudCBwaWN0dXJlcyB3aXRoIGFub3RoZXIgb25lXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIG1hdGNoKGltYWdlLCB7Ym9yZGVyfSA9IHt9KSB7XG5cblxuICAgIHRoaXMuY2hlY2tQcm9jZXNzYWJsZSgnZ2V0Q2hhbm5lbCcsIHtcbiAgICAgICAgYml0RGVwdGg6IFs4LCAxNl1cbiAgICB9KTtcblxuICAgIGlmICh0aGlzLmJpdERlcHRoICE9PSBpbWFnZS5iaXREZXB0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0JvdGggaW1hZ2VzIG11c3QgaGF2ZSB0aGUgc2FtZSBiaXREZXB0aCcpO1xuICAgIH1cbiAgICBpZiAodGhpcy5jaGFubmVscyAhPT0gaW1hZ2UuY2hhbm5lbHMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdCb3RoIGltYWdlcyBtdXN0IGhhdmUgdGhlIHNhbWUgbnVtYmVyIG9mIGNoYW5uZWxzJyk7XG4gICAgfVxuICAgIGlmICh0aGlzLmNvbG9yTW9kZWwgIT09IGltYWdlLmNvbG9yTW9kZWwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdCb3RoIGltYWdlcyBtdXN0IGhhdmUgdGhlIHNhbWUgY29sb3JNb2RlbCcpO1xuICAgIH1cblxuICAgIC8vIHRoZXJlIGNvdWxkIGJlIG1hbnkgYWxnb3JpdGhtc1xuICAgIGxldCBzaW1pbGFyaXR5TWF0cml4ID0gbmV3IE1hdHJpeChpbWFnZS53aWR0aCwgaW1hZ2UuaGVpZ2h0LCAtSW5maW5pdHkpO1xuXG4gICAgbGV0IGN1cnJlbnRYID0gTWF0aC5mbG9vcihpbWFnZS53aWR0aCAvIDIpO1xuICAgIGxldCBjdXJyZW50WSA9IE1hdGguZmxvb3IoaW1hZ2UuaGVpZ2h0IC8gMik7XG4gICAgbGV0IG1pZGRsZVggPSBjdXJyZW50WDtcbiAgICBsZXQgbWlkZGxlWSA9IGN1cnJlbnRZO1xuICAgIGxldCB0aGVFbmQgPSBmYWxzZTtcblxuICAgIHdoaWxlICghdGhlRW5kKSB7XG4gICAgICAgIGxldCB0b0NhbGN1bGF0ZVBvc2l0aW9ucyA9IHNpbWlsYXJpdHlNYXRyaXgubG9jYWxTZWFyY2goY3VycmVudFgsIGN1cnJlbnRZLCAtSW5maW5pdHkpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRvQ2FsY3VsYXRlUG9zaXRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgcG9zaXRpb24gPSB0b0NhbGN1bGF0ZVBvc2l0aW9uc1tpXTtcbiAgICAgICAgICAgIGxldCBzaW1pbGFyaXR5ID0gdGhpcy5nZXRTaW1pbGFyaXR5KGltYWdlLCB7Ym9yZGVyOiBib3JkZXIsIHNoaWZ0OiBbbWlkZGxlWCAtIHBvc2l0aW9uWzBdLCBtaWRkbGVZIC0gcG9zaXRpb25bMV1dfSk7XG4gICAgICAgICAgICBzaW1pbGFyaXR5TWF0cml4W3Bvc2l0aW9uWzBdXVtwb3NpdGlvblsxXV0gPSBzaW1pbGFyaXR5O1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IG1heCA9IHNpbWlsYXJpdHlNYXRyaXgubG9jYWxNYXgoY3VycmVudFgsIGN1cnJlbnRZKTtcbiAgICAgICAgaWYgKG1heC5wb3NpdGlvblswXSAhPT0gY3VycmVudFggfHwgbWF4LnBvc2l0aW9uWzFdICE9PSBjdXJyZW50WSkge1xuICAgICAgICAgICAgY3VycmVudFggPSBtYXgucG9zaXRpb25bMF07XG4gICAgICAgICAgICBjdXJyZW50WSA9IG1heC5wb3NpdGlvblsxXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoZUVuZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKlxuICAgIGZvciAobGV0IGk9MDsgaTxzaW1pbGFyaXR5TWF0cml4Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBsaW5lPVtdO1xuICAgICAgICBmb3IgKGxldCBqPTA7IGo8c2ltaWxhcml0eU1hdHJpeFtpXS5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgbGluZS5wdXNoKHNpbWlsYXJpdHlNYXRyaXhbaV1bal0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnNvbGUubG9nKGxpbmUuam9pbihcIiBcIikpO1xuICAgIH1cbiAgICBjb25zb2xlLmxvZyhjdXJyZW50WCwgbWlkZGxlWCwgY3VycmVudFksIG1pZGRsZVkpO1xuICAgICovXG5cblxuXG4gICAgcmV0dXJuIFtjdXJyZW50WCAtIG1pZGRsZVgsIGN1cnJlbnRZIC0gbWlkZGxlWV07XG59XG5cbiIsImltcG9ydCBJbWFnZSBmcm9tICcuLi9pbWFnZSc7XG5pbXBvcnQge3ZhbGlkYXRlQ2hhbm5lbH0gZnJvbSAnLi8uLi8uLi91dGlsL2NoYW5uZWwnO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRDaGFubmVsKGNoYW5uZWwpIHtcblxuICAgIHRoaXMuY2hlY2tQcm9jZXNzYWJsZSgnZ2V0Q2hhbm5lbCcsIHtcbiAgICAgICAgYml0RGVwdGg6IFs4LCAxNl1cbiAgICB9KTtcblxuICAgIGNoYW5uZWwgPSB2YWxpZGF0ZUNoYW5uZWwodGhpcyxjaGFubmVsKTtcblxuXG4gICAgbGV0IG5ld0ltYWdlID0gSW1hZ2UuY3JlYXRlRnJvbSh0aGlzLCB7XG4gICAgICAgIGNvbXBvbmVudHM6IDEsXG4gICAgICAgIGFscGhhOiBmYWxzZSxcbiAgICAgICAgY29sb3JNb2RlbDogbnVsbFxuICAgIH0pO1xuICAgIGxldCBwdHIgPSAwO1xuICAgIGZvciAobGV0IGogPSBjaGFubmVsOyBqIDwgdGhpcy5kYXRhLmxlbmd0aDsgaiArPSB0aGlzLmNoYW5uZWxzKSB7XG4gICAgICAgIG5ld0ltYWdlLmRhdGFbcHRyKytdID0gdGhpcy5kYXRhW2pdO1xuICAgIH1cblxuICAgIHJldHVybiBuZXdJbWFnZTtcbn1cbiIsImltcG9ydCBJbWFnZSBmcm9tICcuLi9pbWFnZSc7XG5pbXBvcnQge3ZhbGlkYXRlQ2hhbm5lbH0gZnJvbSAnLi8uLi8uLi91dGlsL2NoYW5uZWwnO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRDb2x1bW4oY29sdW1uLCBjaGFubmVsID0gMCkge1xuXG4gICAgdGhpcy5jaGVja1Byb2Nlc3NhYmxlKCdnZXRDb2x1bW4nLCB7XG4gICAgICAgIGJpdERlcHRoOiBbOCwgMTZdXG4gICAgfSk7XG5cbiAgICB0aGlzLmNoZWNrQ29sdW1uKGNvbHVtbik7XG4gICAgdGhpcy5jaGVja0NoYW5uZWwoY2hhbm5lbCk7XG5cbiAgICBsZXQgYXJyYXkgPSBuZXcgQXJyYXkodGhpcy5oZWlnaHQpO1xuICAgIGxldCBwdHIgPSAwO1xuICAgIGxldCBzdGVwID0gdGhpcy53aWR0aCAqIHRoaXMuY2hhbm5lbHM7XG4gICAgZm9yIChsZXQgaiA9IGNoYW5uZWwgKyBjb2x1bW4gKiB0aGlzLmNoYW5uZWxzOyBqIDwgdGhpcy5kYXRhLmxlbmd0aDsgaiArPSBzdGVwKSB7XG4gICAgICAgIGFycmF5W3B0cisrXSA9IHRoaXMuZGF0YVtqXTtcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5O1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0UGl4ZWxzR3JpZCh7XG4gICAgc2FtcGxpbmcgPSBbMTAsMTBdLFxuICAgIHBhaW50ZWQgPSBmYWxzZSxcbiAgICBtYXNrXG4gICAgfSA9IHt9KSB7XG5cbiAgICB0aGlzLmNoZWNrUHJvY2Vzc2FibGUoJ2dldFBpeGVsc0dyaWQnLCB7XG4gICAgICAgIGJpdERlcHRoOiBbOCwgMTZdLFxuICAgICAgICBjaGFubmVsczogMVxuICAgIH0pO1xuXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHNhbXBsaW5nKSkgc2FtcGxpbmcgPSBbc2FtcGxpbmcsc2FtcGxpbmddO1xuXG4gICAgY29uc3QgeFNhbXBsaW5nID0gc2FtcGxpbmdbMF07XG4gICAgY29uc3QgeVNhbXBsaW5nID0gc2FtcGxpbmdbMV07XG4gICAgY29uc3QgbmJTYW1wbGVzID0geFNhbXBsaW5nICogeVNhbXBsaW5nO1xuXG4gICAgY29uc3QgeHlTID0gbmV3IEFycmF5KG5iU2FtcGxlcyk7XG4gICAgY29uc3QgelMgPSBuZXcgQXJyYXkobmJTYW1wbGVzKTtcblxuICAgIGNvbnN0IHhTdGVwID0gdGhpcy53aWR0aCAvIHhTYW1wbGluZztcbiAgICBjb25zdCB5U3RlcCA9IHRoaXMuaGVpZ2h0IC8geVNhbXBsaW5nO1xuICAgIGxldCBjdXJyZW50WCA9IE1hdGguZmxvb3IoeFN0ZXAgLyAyKTtcblxuICAgIGxldCBwb3NpdGlvbiA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB4U2FtcGxpbmc7IGkrKykge1xuICAgICAgICBsZXQgY3VycmVudFkgPSBNYXRoLmZsb29yKHlTdGVwIC8gMik7XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgeVNhbXBsaW5nOyBqKyspIHtcbiAgICAgICAgICAgIGxldCB4ID0gTWF0aC5yb3VuZChjdXJyZW50WCk7XG4gICAgICAgICAgICBsZXQgeSA9IE1hdGgucm91bmQoY3VycmVudFkpO1xuICAgICAgICAgICAgaWYgKCFtYXNrIHx8IG1hc2suZ2V0Qml0WFkoeCx5KSkge1xuICAgICAgICAgICAgICAgIHh5U1twb3NpdGlvbl0gPSBbeCx5XTtcbiAgICAgICAgICAgICAgICB6U1twb3NpdGlvbl0gPSB0aGlzLmdldFBpeGVsWFkoeCwgeSk7XG4gICAgICAgICAgICAgICAgcG9zaXRpb24rKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1cnJlbnRZICs9IHlTdGVwO1xuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnRYICs9IHhTdGVwO1xuICAgIH1cblxuICAgIC8vIHJlc2l6ZSBhcnJheXMgaWYgbmVlZGVkXG4gICAgeHlTLmxlbmd0aCA9IHBvc2l0aW9uO1xuICAgIHpTLmxlbmd0aCA9IHBvc2l0aW9uO1xuXG4gICAgbGV0IHRvUmV0dXJuID0ge3h5UywgelN9O1xuXG4gICAgaWYgKHBhaW50ZWQpIHtcbiAgICAgICAgdG9SZXR1cm4ucGFpbnRlZCA9IHRoaXMucmdiYTgoKS5wYWludFBpeGVscyh4eVMpO1xuICAgIH1cblxuICAgIHJldHVybiB0b1JldHVybjtcbn1cbiIsImltcG9ydCBJbWFnZSBmcm9tICcuLi9pbWFnZSc7XG5pbXBvcnQge3ZhbGlkYXRlQ2hhbm5lbH0gZnJvbSAnLi8uLi8uLi91dGlsL2NoYW5uZWwnO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRSb3cocm93LCBjaGFubmVsID0gMCkge1xuXG4gICAgdGhpcy5jaGVja1Byb2Nlc3NhYmxlKCdnZXRSb3cnLCB7XG4gICAgICAgIGJpdERlcHRoOiBbOCwgMTZdXG4gICAgfSk7XG5cbiAgICB0aGlzLmNoZWNrUm93KHJvdyk7XG4gICAgdGhpcy5jaGVja0NoYW5uZWwoY2hhbm5lbCk7XG5cblxuICAgIGxldCBhcnJheSA9IG5ldyBBcnJheSh0aGlzLndpZHRoKTtcbiAgICBsZXQgcHRyID0gMDtcbiAgICBsZXQgYmVnaW4gPSByb3cgKiB0aGlzLndpZHRoICogdGhpcy5jaGFubmVscyArIGNoYW5uZWw7XG4gICAgbGV0IGVuZCA9IGJlZ2luICsgdGhpcy53aWR0aCAqIHRoaXMuY2hhbm5lbHM7XG4gICAgZm9yIChsZXQgaiA9IGJlZ2luOyBqIDwgZW5kOyBqICs9IHRoaXMuY2hhbm5lbHMpIHtcbiAgICAgICAgYXJyYXlbcHRyKytdID0gdGhpcy5kYXRhW2pdO1xuICAgIH1cblxuICAgIHJldHVybiBhcnJheTtcbn1cbiIsImltcG9ydCBJbWFnZSBmcm9tICcuLi9pbWFnZSc7XG5pbXBvcnQge3ZhbGlkYXRlQXJyYXlPZkNoYW5uZWxzfSBmcm9tICcuLy4uLy4uL3V0aWwvY2hhbm5lbCc7XG5pbXBvcnQgbmV3QXJyYXkgZnJvbSAnbmV3LWFycmF5JztcblxuLy8gVHJ5IHRvIG1hdGNoIHRoZSBjdXJyZW50IHBpY3R1cmVzIHdpdGggYW5vdGhlciBvbmVcblxuLy8gaWYgbm9ybWFsaXplIHdlIG5vcm1hbGl6ZSBzZXBhcmF0ZWx5IHRoZSAyIGltYWdlc1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRTaW1pbGFyaXR5KGltYWdlLCB7c2hpZnQgPSBbMCwwXSwgYXZlcmFnZSwgY2hhbm5lbHMsIGRlZmF1bHRBbHBoYSwgbm9ybWFsaXplLCBib3JkZXIgPSBbMCwwXX0gPSB7fSkge1xuXG4gICAgdGhpcy5jaGVja1Byb2Nlc3NhYmxlKCdnZXRTaW1pbGFyaXR5Jywge1xuICAgICAgICBiaXREZXB0aDogWzgsIDE2XVxuICAgIH0pO1xuXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGJvcmRlcikpIGJvcmRlciA9IFtib3JkZXIsIGJvcmRlcl07XG4gICAgY2hhbm5lbHMgPSB2YWxpZGF0ZUFycmF5T2ZDaGFubmVscyh0aGlzLCB7Y2hhbm5lbHM6Y2hhbm5lbHMsIGRlZmF1bHRBbHBoYTpkZWZhdWx0QWxwaGF9KTtcblxuICAgIGlmICh0aGlzLmJpdERlcHRoICE9PSBpbWFnZS5iaXREZXB0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0JvdGggaW1hZ2VzIG11c3QgaGF2ZSB0aGUgc2FtZSBiaXREZXB0aCcpO1xuICAgIH1cbiAgICBpZiAodGhpcy5jaGFubmVscyAhPT0gaW1hZ2UuY2hhbm5lbHMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdCb3RoIGltYWdlcyBtdXN0IGhhdmUgdGhlIHNhbWUgbnVtYmVyIG9mIGNoYW5uZWxzJyk7XG4gICAgfVxuICAgIGlmICh0aGlzLmNvbG9yTW9kZWwgIT09IGltYWdlLmNvbG9yTW9kZWwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdCb3RoIGltYWdlcyBtdXN0IGhhdmUgdGhlIHNhbWUgY29sb3JNb2RlbCcpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgYXZlcmFnZSA9PT0gJ3VuZGVmaW5lZCcpIGF2ZXJhZ2UgPSB0cnVlO1xuXG4gICAgLy8gd2UgYWxsb3cgYSBzaGlmdFxuICAgIC8vIHdlIG5lZWQgdG8gZmluZCB0aGUgbWluWCwgbWF4WCwgbWluWSwgbWF4WVxuICAgIGxldCBtaW5YID0gTWF0aC5tYXgoYm9yZGVyWzBdLCAtc2hpZnRbMF0pO1xuICAgIGxldCBtYXhYID0gTWF0aC5taW4odGhpcy53aWR0aCAtIGJvcmRlclswXSwgdGhpcy53aWR0aCAtIHNoaWZ0WzBdKTtcbiAgICBsZXQgbWluWSA9IE1hdGgubWF4KGJvcmRlclsxXSwgLXNoaWZ0WzFdKTtcbiAgICBsZXQgbWF4WSA9IE1hdGgubWluKHRoaXMuaGVpZ2h0IC0gYm9yZGVyWzFdLCB0aGlzLmhlaWdodCAtIHNoaWZ0WzFdKTtcblxuICAgIGxldCByZXN1bHRzID0gbmV3QXJyYXkoY2hhbm5lbHMubGVuZ3RoLDApO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hhbm5lbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IGMgPSBjaGFubmVsc1tpXTtcbiAgICAgICAgbGV0IHN1bVRoaXMgPSBub3JtYWxpemUgPyB0aGlzLnN1bVtjXSA6IE1hdGgubWF4KHRoaXMuc3VtW2NdLCBpbWFnZS5zdW1bY10pO1xuICAgICAgICBsZXQgc3VtSW1hZ2UgPSBub3JtYWxpemUgPyBpbWFnZS5zdW1bY10gOiBNYXRoLm1heCh0aGlzLnN1bVtjXSwgaW1hZ2Uuc3VtW2NdKTtcblxuICAgICAgICBpZiAoc3VtVGhpcyAhPT0gMCAmJiBzdW1JbWFnZSAhPT0gMCkge1xuICAgICAgICAgICAgZm9yIChsZXQgeCA9IG1pblg7IHggPCBtYXhYOyB4KyspIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCB5ID0gbWluWTsgeSA8IG1heFk7IHkrKykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgaW5kZXhUaGlzID0geCAqIHRoaXMubXVsdGlwbGllclggKyB5ICogdGhpcy5tdWx0aXBsaWVyWSArIGM7XG4gICAgICAgICAgICAgICAgICAgIGxldCBpbmRleEltYWdlID0gaW5kZXhUaGlzICsgc2hpZnRbMF0gKiB0aGlzLm11bHRpcGxpZXJYICsgc2hpZnRbMV0gKiB0aGlzLm11bHRpcGxpZXJZO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRzW2ldICs9IE1hdGgubWluKHRoaXMuZGF0YVtpbmRleFRoaXNdIC8gc3VtVGhpcywgaW1hZ2UuZGF0YVtpbmRleEltYWdlXSAvIHN1bUltYWdlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoYXZlcmFnZSkge1xuICAgICAgICByZXR1cm4gcmVzdWx0cy5yZWR1Y2UoKHN1bSwgeCkgPT4gc3VtICsgeCkgLyByZXN1bHRzLmxlbmd0aDtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdHM7XG59XG4iLCJpbXBvcnQgSW1hZ2UgZnJvbSAnLi4vaW1hZ2UnO1xuaW1wb3J0IGFycmF5IGZyb20gJ25ldy1hcnJheSc7XG5cbi8vIHRoaXMgbWV0aG9kIHdpbGwgY2hhbmdlIHRoZSBib3JkZXJcbi8vIHRoYXQgbWF5IG5vdCBiZSBjYWxjdWxhdGVkXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHNldEJvcmRlcih7XG4gICAgc2l6ZSA9IDAsXG4gICAgYWxnb3JpdGhtID0gJ2NvcHknLFxuICAgIGNvbG9yXG4gICAgfSA9IHt9KSB7XG5cbiAgICB0aGlzLmNoZWNrUHJvY2Vzc2FibGUoJ3NldEJvcmRlcicsIHtcbiAgICAgICAgYml0RGVwdGg6IFs4LCAxNiwgMzIsIDY0XVxuICAgIH0pO1xuXG4gICAgaWYgKGFsZ29yaXRobSA9PT0gJ3NldCcpIHtcbiAgICAgICAgaWYgKGNvbG9yLmxlbmd0aCAhPT0gdGhpcy5jaGFubmVscykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzZXRCb3JkZXI6IHRoZSBjb2xvciBhcnJheSBtdXN0IGhhdmUgdGhlIHNhbWUgbGVuZ3RoIGFzIHRoZSBudW1iZXIgb2YgY2hhbm5lbHMuIEhlcmU6ICcgKyB0aGlzLmNoYW5uZWxzKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbG9yLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoY29sb3JbaV0gPT09IDApIGNvbG9yW2ldID0gMC4wMDE7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBjb2xvciA9IGFycmF5KHRoaXMuY2hhbm5lbHMsIG51bGwpO1xuICAgIH1cblxuICAgIGlmICghQXJyYXkuaXNBcnJheShzaXplKSkge1xuICAgICAgICBzaXplID0gW3NpemUsc2l6ZV07XG4gICAgfVxuXG5cbiAgICBsZXQgbGVmdFJpZ2h0U2l6ZSA9IHNpemVbMF07XG4gICAgbGV0IHRvcEJvdHRvbVNpemUgPSBzaXplWzFdO1xuICAgIGxldCBjaGFubmVscyA9IHRoaXMuY2hhbm5lbHM7XG5cblxuXG4gICAgZm9yIChsZXQgaSA9IGxlZnRSaWdodFNpemU7IGkgPCB0aGlzLndpZHRoIC0gbGVmdFJpZ2h0U2l6ZTsgaSsrKSB7XG4gICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgY2hhbm5lbHM7IGsrKykge1xuICAgICAgICAgICAgbGV0IHZhbHVlID0gY29sb3Jba10gfHwgdGhpcy5kYXRhWyhpICsgdGhpcy53aWR0aCAqIHRvcEJvdHRvbVNpemUpICogY2hhbm5lbHMgKyBrXTtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdG9wQm90dG9tU2l6ZTsgaisrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kYXRhWyhqICogdGhpcy53aWR0aCArIGkpICogY2hhbm5lbHMgKyBrXSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFsdWUgPSBjb2xvcltrXSB8fCB0aGlzLmRhdGFbKGkgKyB0aGlzLndpZHRoICogKHRoaXMuaGVpZ2h0IC0gdG9wQm90dG9tU2l6ZSAtIDEpKSAqIGNoYW5uZWxzICsga107XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gdGhpcy5oZWlnaHQgLSB0b3BCb3R0b21TaXplOyBqIDwgdGhpcy5oZWlnaHQ7IGorKykge1xuICAgICAgICAgICAgICAgIHRoaXMuZGF0YVsoaiAqIHRoaXMud2lkdGggKyBpKSAqIGNoYW5uZWxzICsga10gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZvciAobGV0IGogPSAwOyBqIDwgdGhpcy5oZWlnaHQ7IGorKykge1xuICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IGNoYW5uZWxzOyBrKyspIHtcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IGNvbG9yW2tdIHx8IHRoaXMuZGF0YVsoaiAqIHRoaXMud2lkdGggKyBsZWZ0UmlnaHRTaXplKSAqIGNoYW5uZWxzICsga107XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlZnRSaWdodFNpemU7IGkrKykge1xuICAgICAgICAgICAgICAgIHRoaXMuZGF0YVsoaiAqIHRoaXMud2lkdGggKyBpKSAqIGNoYW5uZWxzICsga10gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhbHVlID0gY29sb3Jba10gfHwgdGhpcy5kYXRhWyhqICogdGhpcy53aWR0aCArIHRoaXMud2lkdGggLSBsZWZ0UmlnaHRTaXplIC0gMSkgKiBjaGFubmVscyArIGtdO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMud2lkdGggLSBsZWZ0UmlnaHRTaXplOyBpIDwgdGhpcy53aWR0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kYXRhWyhqICogdGhpcy53aWR0aCArIGkpICogY2hhbm5lbHMgKyBrXSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuIiwiaW1wb3J0IEltYWdlIGZyb20gJy4uL2ltYWdlJztcbmltcG9ydCB7dmFsaWRhdGVDaGFubmVsfSBmcm9tICcuLy4uLy4uL3V0aWwvY2hhbm5lbCc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHNldENoYW5uZWwoY2hhbm5lbCwgaW1hZ2UpIHtcblxuICAgIHRoaXMuY2hlY2tQcm9jZXNzYWJsZSgnc2V0Q2hhbm5lbCcsIHtcbiAgICAgICAgYml0RGVwdGg6IFs4LCAxNl1cbiAgICB9KTtcblxuICAgIGltYWdlLmNoZWNrUHJvY2Vzc2FibGUoJ3NldENoYW5uZWwgKGltYWdlIHBhcmFtZXRlciBjaGVjayknLCB7XG4gICAgICAgIGJpdERlcHRoOiBbdGhpcy5iaXREZXB0aF0sXG4gICAgICAgIGFscGhhOiBbMF0sXG4gICAgICAgIGNvbXBvbmVudHM6IFsxXVxuICAgIH0pO1xuXG4gICAgaWYgKGltYWdlLndpZHRoICE9PSB0aGlzLndpZHRoIHx8IGltYWdlLmhlaWdodCAhPT0gdGhpcy5oZWlnaHQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbWFnZXMgbXVzdCBoYXZlIGV4YWN0bHkgdGhlIHNhbWUgd2lkdGggYW5kIGhlaWdodCcpO1xuICAgIH1cblxuICAgIGNoYW5uZWwgPSB2YWxpZGF0ZUNoYW5uZWwodGhpcyxjaGFubmVsKTtcblxuICAgIGxldCBwdHIgPSBjaGFubmVsO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW1hZ2UuZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLmRhdGFbcHRyXSA9IGltYWdlLmRhdGFbaV07XG4gICAgICAgIHB0ciArPSB0aGlzLmNoYW5uZWxzO1xuICAgIH1cbn1cbiIsImltcG9ydCBJbWFnZSBmcm9tICcuLi9pbWFnZSc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHNwbGl0KHtwcmVzZXJ2ZUFscGhhID0gdHJ1ZX0gPSB7fSkge1xuXG4gICAgdGhpcy5jaGVja1Byb2Nlc3NhYmxlKCdzcGxpdCcsIHtcbiAgICAgICAgYml0RGVwdGg6IFs4LCAxNl1cbiAgICB9KTtcblxuICAgIC8vIHNwbGl0IHdpbGwgYWx3YXlzIHJldHVybiBhbiBhcnJheSBvZiBpbWFnZXNcbiAgICBpZiAodGhpcy5jb21wb25lbnRzID09PSAxKSB7XG4gICAgICAgIHJldHVybiBbdGhpcy5jbG9uZSgpXTtcbiAgICB9XG5cbiAgICBsZXQgaW1hZ2VzID0gW107XG5cbiAgICBsZXQgZGF0YSA9IHRoaXMuZGF0YTtcbiAgICBpZiAodGhpcy5hbHBoYSAmJiBwcmVzZXJ2ZUFscGhhKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jb21wb25lbnRzOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBuZXdJbWFnZSA9IEltYWdlLmNyZWF0ZUZyb20odGhpcywge1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudHM6IDEsXG4gICAgICAgICAgICAgICAgYWxwaGE6IHRydWUsXG4gICAgICAgICAgICAgICAgY29sb3JNb2RlbDogbnVsbFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBsZXQgcHRyID0gMDtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgZGF0YS5sZW5ndGg7IGogKz0gdGhpcy5jaGFubmVscykge1xuICAgICAgICAgICAgICAgIG5ld0ltYWdlLmRhdGFbcHRyKytdID0gZGF0YVtqICsgaV07XG4gICAgICAgICAgICAgICAgbmV3SW1hZ2UuZGF0YVtwdHIrK10gPSBkYXRhW2ogKyB0aGlzLmNvbXBvbmVudHNdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW1hZ2VzLnB1c2gobmV3SW1hZ2UpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmNoYW5uZWxzOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBuZXdJbWFnZSA9IEltYWdlLmNyZWF0ZUZyb20odGhpcywge1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudHM6IDEsXG4gICAgICAgICAgICAgICAgYWxwaGE6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGNvbG9yTW9kZWw6IG51bGxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbGV0IHB0ciA9IDA7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGRhdGEubGVuZ3RoOyBqICs9IHRoaXMuY2hhbm5lbHMpIHtcbiAgICAgICAgICAgICAgICBuZXdJbWFnZS5kYXRhW3B0cisrXSA9IGRhdGFbaiArIGldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW1hZ2VzLnB1c2gobmV3SW1hZ2UpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGltYWdlcztcbn1cbiIsImltcG9ydCB7ZW52fSBmcm9tICcuL2ltYWdlL2Vudmlyb25tZW50JztcblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gcmVxdWlyZSgnLi9pbWFnZS9pbWFnZScpLmRlZmF1bHQ7XG5leHBvcnRzLlN0YWNrID0gcmVxdWlyZSgnLi9zdGFjay9zdGFjaycpLmRlZmF1bHQ7XG5cbmlmIChlbnYgPT09ICdicm93c2VyJykge1xuICAgIGV4cG9ydHMuV29ya2VyID0gcmVxdWlyZSgnLi93b3JrZXIvd29ya2VyJykuZGVmYXVsdDtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGhpc3RvZ3JhbShvcHRpb25zKSB7XG5cbiAgICB0aGlzLmNoZWNrUHJvY2Vzc2FibGUoJ21pbicsIHtcbiAgICAgICAgYml0RGVwdGg6IFs4LCAxNl1cbiAgICB9KTtcblxuICAgIGxldCBoaXN0b2dyYW0gPSB0aGlzWzBdLmdldEhpc3RvZ3JhbShvcHRpb25zKTtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IHNlY29uZEhpc3RvZ3JhbSA9IHRoaXNbaV0uZ2V0SGlzdG9ncmFtKG9wdGlvbnMpO1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGhpc3RvZ3JhbS5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgaGlzdG9ncmFtW2pdICs9IHNlY29uZEhpc3RvZ3JhbVtqXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaGlzdG9ncmFtO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gaGlzdG9ncmFtcyhvcHRpb25zKSB7XG5cbiAgICB0aGlzLmNoZWNrUHJvY2Vzc2FibGUoJ21pbicsIHtcbiAgICAgICAgYml0RGVwdGg6IFs4LCAxNl1cbiAgICB9KTtcblxuICAgIGxldCBoaXN0b2dyYW1zID0gdGhpc1swXS5nZXRIaXN0b2dyYW1zKG9wdGlvbnMpO1xuICAgIGxldCBoaXN0b2dyYW1MZW5ndGggPSBoaXN0b2dyYW1zWzBdLmxlbmd0aDtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IHNlY29uZEhpc3RvZ3JhbXMgPSB0aGlzW2ldLmdldEhpc3RvZ3JhbXMob3B0aW9ucyk7XG4gICAgICAgIGZvciAobGV0IGMgPSAwOyBjIDwgaGlzdG9ncmFtcy5sZW5ndGg7IGMrKykge1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBoaXN0b2dyYW1MZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIGhpc3RvZ3JhbXNbY11bal0gKz0gc2Vjb25kSGlzdG9ncmFtc1tjXVtqXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaGlzdG9ncmFtcztcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIG1heCgpIHtcblxuICAgIHRoaXMuY2hlY2tQcm9jZXNzYWJsZSgnbWluJywge1xuICAgICAgICBiaXREZXB0aDogWzgsIDE2XVxuICAgIH0pO1xuXG4gICAgbGV0IG1heCA9IHRoaXNbMF0ubWF4O1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG1heC5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgbWF4W2pdID0gTWF0aC5tYXgobWF4W2pdLCB0aGlzW2ldLm1heFtqXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1heDtcbn1cbiIsImltcG9ydCBnZXRIaXN0b2dyYW1zIGZyb20gJy4vaGlzdG9ncmFtcyc7XG5pbXBvcnQge21lZGlhbiBhcyBtZWRpYW5Gcm9tSGlzdG9ncmFtfSBmcm9tICcuLi8uLi91dGlsL2hpc3RvZ3JhbSc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIG1lZGlhbigpIHtcblxuICAgIHRoaXMuY2hlY2tQcm9jZXNzYWJsZSgnbWVkaWFuJywge1xuICAgICAgICBiaXREZXB0aDogWzgsIDE2XVxuICAgIH0pO1xuXG5cbiAgICBsZXQgaGlzdG9ncmFtcyA9IHRoaXMuZ2V0SGlzdG9ncmFtcyh7bWF4U2xvdHM6IHRoaXNbMF0ubWF4VmFsdWUgKyAxfSk7XG4gICAgbGV0IHJlc3VsdCA9IG5ldyBBcnJheShoaXN0b2dyYW1zLmxlbmd0aCk7XG4gICAgZm9yIChsZXQgYyA9IDA7IGMgPCBoaXN0b2dyYW1zLmxlbmd0aDsgYysrKSB7XG4gICAgICAgIGxldCBoaXN0b2dyYW0gPSBoaXN0b2dyYW1zW2NdO1xuICAgICAgICByZXN1bHRbY10gPSBtZWRpYW5Gcm9tSGlzdG9ncmFtKGhpc3RvZ3JhbSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBtaW4oKSB7XG4gICAgdGhpcy5jaGVja1Byb2Nlc3NhYmxlKCdtaW4nLCB7XG4gICAgICAgIGJpdERlcHRoOiBbOCwgMTZdXG4gICAgfSk7XG5cbiAgICBsZXQgbWluID0gdGhpc1swXS5taW47XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbWluLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBtaW5bal0gPSBNYXRoLm1pbihtaW5bal0sIHRoaXNbaV0ubWluW2pdKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWluO1xufVxuIiwiaW1wb3J0IG1hdGNoQW5kQ3JvcCBmcm9tICcuL3RyYW5zZm9ybS9tYXRjaEFuZENyb3AnO1xuXG5pbXBvcnQgbWluIGZyb20gJy4vY29tcHV0ZS9taW4nO1xuaW1wb3J0IG1heCBmcm9tICcuL2NvbXB1dGUvbWF4JztcbmltcG9ydCBtZWRpYW4gZnJvbSAnLi9jb21wdXRlL21lZGlhbic7XG5pbXBvcnQgaGlzdG9ncmFtIGZyb20gJy4vY29tcHV0ZS9oaXN0b2dyYW0nO1xuaW1wb3J0IGhpc3RvZ3JhbXMgZnJvbSAnLi9jb21wdXRlL2hpc3RvZ3JhbXMnO1xuXG5pbXBvcnQgYXZlcmFnZSBmcm9tICcuL3V0aWxpdHkvYXZlcmFnZSc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGV4dGVuZChTdGFjaykge1xuICAgIGxldCBpblBsYWNlID0ge2luUGxhY2U6IHRydWV9O1xuICAgIFN0YWNrLmV4dGVuZE1ldGhvZCgnbWF0Y2hBbmRDcm9wJywgbWF0Y2hBbmRDcm9wKTtcblxuICAgIFN0YWNrLmV4dGVuZE1ldGhvZCgnZ2V0TWluJywgbWluKTtcbiAgICBTdGFjay5leHRlbmRNZXRob2QoJ2dldE1heCcsIG1heCk7XG4gICAgU3RhY2suZXh0ZW5kTWV0aG9kKCdnZXRNZWRpYW4nLCBtZWRpYW4pO1xuICAgIFN0YWNrLmV4dGVuZE1ldGhvZCgnZ2V0SGlzdG9ncmFtJywgaGlzdG9ncmFtKTtcbiAgICBTdGFjay5leHRlbmRNZXRob2QoJ2dldEhpc3RvZ3JhbXMnLCBoaXN0b2dyYW1zKTtcblxuICAgIFN0YWNrLmV4dGVuZE1ldGhvZCgnZ2V0QXZlcmFnZScsIGF2ZXJhZ2UpO1xufVxuIiwiaW1wb3J0IGV4dGVuZCBmcm9tICcuL2V4dGVuZCc7XG5pbXBvcnQgSW1hZ2UgZnJvbSAnLi4vaW1hZ2UvaW1hZ2UnO1xuXG5sZXQgY29tcHV0ZWRQcm9wZXJ0eURlc2NyaXB0b3IgPSB7XG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGdldDogdW5kZWZpbmVkXG59O1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBTdGFjayhpbWFnZXMpIHtcbiAgICBsZXQgc3RhY2s7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoaW1hZ2VzKSkge1xuICAgICAgICBzdGFjayA9IG5ldyBBcnJheShpbWFnZXMubGVuZ3RoKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbWFnZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHN0YWNrW2ldID0gaW1hZ2VzW2ldO1xuICAgICAgICB9XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgaW1hZ2VzID09PSAnbnVtYmVyJykge1xuICAgICAgICBzdGFjayA9IG5ldyBBcnJheShpbWFnZXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YWNrID0gW107XG4gICAgfVxuICAgIHN0YWNrLmNvbXB1dGVkID0gbnVsbDtcbiAgICBzdGFjay5fX3Byb3RvX18gPSBTdGFjay5wcm90b3R5cGU7XG4gICAgcmV0dXJuIHN0YWNrO1xufVxuXG5TdGFjay5sb2FkID0gZnVuY3Rpb24gKHVybHMpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5hbGwodXJscy5tYXAoSW1hZ2UubG9hZCkpLnRoZW4oU3RhY2spO1xufTtcblxuU3RhY2suZXh0ZW5kTWV0aG9kID0gZnVuY3Rpb24gZXh0ZW5kTWV0aG9kKG5hbWUsIG1ldGhvZCwge2luUGxhY2UgPSBmYWxzZSwgcmV0dXJuVGhpcyA9IHRydWUsIHBhcnRpYWxBcmdzID0gW119ID0ge30pIHtcbiAgICBpZiAoaW5QbGFjZSkge1xuICAgICAgICBTdGFjay5wcm90b3R5cGVbbmFtZV0gPSBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgICAgICAgLy8gcmVtb3ZlIGNvbXB1dGVkIHByb3BlcnRpZXNcbiAgICAgICAgICAgIHRoaXMuY29tcHV0ZWQgPSBudWxsO1xuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IG1ldGhvZC5hcHBseSh0aGlzLCBbLi4ucGFydGlhbEFyZ3MsIC4uLmFyZ3NdKTtcbiAgICAgICAgICAgIGlmIChyZXR1cm5UaGlzKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBTdGFjay5wcm90b3R5cGVbbmFtZV0gPSBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgICAgICAgcmV0dXJuIG1ldGhvZC5hcHBseSh0aGlzLCBbLi4ucGFydGlhbEFyZ3MsIC4uLmFyZ3NdKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIFN0YWNrO1xufTtcblxuU3RhY2suZXh0ZW5kUHJvcGVydHkgPSBmdW5jdGlvbiBleHRlbmRQcm9wZXJ0eShuYW1lLCBtZXRob2QsIHtwYXJ0aWFsQXJncyA9IFtdfSA9IHt9KSB7XG4gICAgY29tcHV0ZWRQcm9wZXJ0eURlc2NyaXB0b3IuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5jb21wdXRlZCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5jb21wdXRlZCA9IHt9O1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuY29tcHV0ZWQuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbXB1dGVkW25hbWVdO1xuICAgICAgICB9XG4gICAgICAgIGxldCByZXN1bHQgPSBtZXRob2QuYXBwbHkodGhpcywgcGFydGlhbEFyZ3MpO1xuICAgICAgICB0aGlzLmNvbXB1dGVkW25hbWVdID0gcmVzdWx0O1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFN0YWNrLnByb3RvdHlwZSwgbmFtZSwgY29tcHV0ZWRQcm9wZXJ0eURlc2NyaXB0b3IpO1xuICAgIHJldHVybiBTdGFjaztcbn07XG5cblN0YWNrLl9fcHJvdG9fXyA9IEFycmF5O1xuU3RhY2sucHJvdG90eXBlLl9fcHJvdG9fXyA9IEFycmF5LnByb3RvdHlwZTtcblN0YWNrLnByb3RvdHlwZS5tYXAgPSBmdW5jdGlvbiAoY2IsIHRoaXNBcmcpIHtcbiAgICBpZiAodHlwZW9mIGNiICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoY2IgKyAnIGlzIG5vdCBhIGZ1bmN0aW9uJyk7XG4gICAgfVxuICAgIGxldCBuZXdTdGFjayA9IG5ldyBTdGFjayh0aGlzLmxlbmd0aCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIG5ld1N0YWNrW2ldID0gY2IuY2FsbCh0aGlzQXJnLCB0aGlzW2ldLCBpLCB0aGlzKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ld1N0YWNrO1xufTtcblxuLy8gdGhpcyBtZXRob2QgY2hlY2sgaWYgYSBwcm9jZXNzIGNhbiBiZSBhcHBsaWVkIG9uIHRoZSBjdXJyZW50IGltYWdlXG5TdGFjay5wcm90b3R5cGUuY2hlY2tQcm9jZXNzYWJsZSA9IGZ1bmN0aW9uIChwcm9jZXNzTmFtZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgaWYgKHR5cGVvZiBwcm9jZXNzTmFtZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignY2hlY2tQcm9jZXNzYWJsZSByZXF1aXJlcyBhcyBmaXJzdCBwYXJhbWV0ZXIgdGhlIHByb2Nlc3NOYW1lIChhIHN0cmluZyknKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuc2l6ZSA9PT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgcHJvY2VzczogJyArIHByb2Nlc3NOYW1lICsgJyBjYW4gbm90IGJlIGFwcGxpZWQgb24gYW4gZW1wdHkgc3RhY2snKTtcbiAgICB9XG4gICAgdGhpc1swXS5jaGVja1Byb2Nlc3NhYmxlKHByb2Nlc3NOYW1lLCBvcHRpb25zKTtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKChvcHRpb25zLnNhbWVTaXplID09PSB1bmRlZmluZWQgfHwgb3B0aW9ucy5zYW1lU2l6ZSkgJiYgdGhpc1swXS53aWR0aCAhPT0gdGhpc1tpXS53aWR0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIHByb2Nlc3M6ICcgKyBwcm9jZXNzTmFtZSArICcgY2FuIG5vdCBiZSBhcHBsaWVkIGlmIHdpZHRoIGlzIG5vdCBpZGVudGljYWwgaW4gYWxsIGltYWdlcycpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgob3B0aW9ucy5zYW1lU2l6ZSA9PT0gdW5kZWZpbmVkIHx8IG9wdGlvbnMuc2FtZVNpemUpICYmIHRoaXNbMF0uaGVpZ2h0ICE9PSB0aGlzW2ldLmhlaWdodCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIHByb2Nlc3M6ICcgKyBwcm9jZXNzTmFtZSArICcgY2FuIG5vdCBiZSBhcHBsaWVkIGlmIGhlaWdodCBpcyBub3QgaWRlbnRpY2FsIGluIGFsbCBpbWFnZXMnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKG9wdGlvbnMuc2FtZUFscGhhID09PSB1bmRlZmluZWQgfHwgb3B0aW9ucy5zYW1lQWxwaGEpICYmIHRoaXNbMF0uYWxwaGEgIT09IHRoaXNbaV0uYWxwaGEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBwcm9jZXNzOiAnICsgcHJvY2Vzc05hbWUgKyAnIGNhbiBub3QgYmUgYXBwbGllZCBpZiBhbHBoYSBpcyBub3QgaWRlbnRpY2FsIGluIGFsbCBpbWFnZXMnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKG9wdGlvbnMuc2FtZUJpdERlcHRoID09PSB1bmRlZmluZWQgfHwgb3B0aW9ucy5zYW1lQml0RGVwdGgpICYmIHRoaXNbMF0uYml0RGVwdGggIT09IHRoaXNbaV0uYml0RGVwdGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBwcm9jZXNzOiAnICsgcHJvY2Vzc05hbWUgKyAnIGNhbiBub3QgYmUgYXBwbGllZCBpZiBiaXREZXB0aCBpcyBub3QgaWRlbnRpY2FsIGluIGFsbCBpbWFnZXMnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKG9wdGlvbnMuc2FtZUNvbG9yTW9kZWwgPT09IHVuZGVmaW5lZCB8fCBvcHRpb25zLnNhbWVDb2xvck1vZGVsKSAmJiB0aGlzWzBdLmNvbG9yTW9kZWwgIT09IHRoaXNbaV0uY29sb3JNb2RlbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIHByb2Nlc3M6ICcgKyBwcm9jZXNzTmFtZSArICcgY2FuIG5vdCBiZSBhcHBsaWVkIGlmIGNvbG9yTW9kZWwgaXMgbm90IGlkZW50aWNhbCBpbiBhbGwgaW1hZ2VzJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChvcHRpb25zLnNhbWVOdW1iZXJDaGFubmVscyA9PT0gdW5kZWZpbmVkIHx8IG9wdGlvbnMuc2FtZU51bWJlckNoYW5uZWxzKSAmJiB0aGlzWzBdLmNoYW5uZWxzICE9PSB0aGlzW2ldLmNoYW5uZWxzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgcHJvY2VzczogJyArIHByb2Nlc3NOYW1lICsgJyBjYW4gbm90IGJlIGFwcGxpZWQgaWYgY2hhbm5lbHMgaXMgbm90IGlkZW50aWNhbCBpbiBhbGwgaW1hZ2VzJyk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5leHRlbmQoU3RhY2spO1xuIiwiLypcbiBXZSB3aWxsIHRyeSB0byBtb3ZlIGEgc2V0IG9mIGltYWdlcyBpbiBvcmRlciB0byBnZXQgb25seSB0aGUgYmVzdCBjb21tb24gcGFydCBvZiB0aGVtXG4gVGhlIG1hdGNoIGlzIGFsd2F5cyBkb25lIG9uIHRoZSBmaXJzdCBpbWFnZSA/XG4qL1xuaW1wb3J0IFN0YWNrIGZyb20gJy4uL3N0YWNrJztcblxuLy8gaW4gYSBzdGFjayB3ZSBjb21wYXJlIDIgY29uc2VjdXRpdmUgaW1hZ2VzXG4vLyBvciBkaXJlY3RseSB0byBhIHBhcmVudFxuXG4vLyBhbGdvcml0aG06IG1hdGNoVG9QcmV2aW91cyB8fCBtYXRjaFRvRmlyc3RcblxuLy8gSWdub3JpbmcgYm9yZGVyIG1heSBiZSBkYW5nZXJvdXMgISBJcyB0aGVyZSBpcyBhIHNoYXBlIG9uIHRoZSBzaWRlIG9mIHRoZSBpbWFnZSB0aGVyZSB3aWxsIGJlIGFcbi8vIGNvbnRpbnVvdXMgc2hpZnQgaWYgeW91IGlnbm9yZSBib3JkZXIuIEJ5IGRlZmF1bHQgaXQgaXMgYmV0dGVyIHRvIGxlYXZlIGl0IHRvIDAsMFxuLy8gTm93IGlmIHRoZSBiYWNrZ3JvdW5kIGlzIG5vdCBibGFjayB0aGVyZSB3aWxsIGFsc28gYmUgbm8gd2F5IHRvIHNoaWZ0IC4uLlxuLy8gSXQgbWF5IHRoZXJlZm9yZSBiZSBtdWNoIGJldHRlciB0byBtYWtlIGEgYmFja2dyb3VuZCBjb3JyZWN0aW9uIGJlZm9yZSB0cnlpbmcgdG8gbWF0Y2ggYW5kIGNyb3Bcbi8vIFRPRE8gdGhpcyBjb2RlIHNlZW1zIGFsc28gYnVnZ3kgaWYgaXQgaXMgbm90IDAsMFxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBtYXRjaEFuZENyb3Aoe1xuICAgIGFsZ29yaXRobSA9ICdtYXRjaFRvUHJldmlvdXMnLFxuICAgIGlnbm9yZUJvcmRlciA9IFswLDBdXG4gICAgfSA9IHt9XG4pIHtcbiAgICB0aGlzLmNoZWNrUHJvY2Vzc2FibGUoJ21hdGNoQW5kQ3JvcCcsIHtcbiAgICAgICAgYml0RGVwdGg6IFs4LCAxNl1cbiAgICB9KTtcblxuICAgIGxldCBtYXRjaFRvUHJldmlvdXMgPSAoYWxnb3JpdGhtID09PSAnbWF0Y2hUb1ByZXZpb3VzJykgPyB0cnVlIDogZmFsc2U7XG5cbiAgICBsZXQgcGFyZW50ID0gdGhpc1swXTtcbiAgICBsZXQgcmVzdWx0cyA9IFtdO1xuICAgIHJlc3VsdHNbMF0gPSB7XG4gICAgICAgIHBvc2l0aW9uOlswLDBdLFxuICAgICAgICBpbWFnZTogdGhpc1swXVxuICAgIH07XG5cbiAgICBsZXQgcmVsYXRpdmVQb3NpdGlvbiA9IFswLDBdO1xuXG4gICAgLy8gd2UgY2FsY3VsYXRlIHRoZSBiZXN0IHJlbGF0aXZlIHBvc2l0aW9uIHRvIHRoZSBwYXJlbnQgaW1hZ2VcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcblxuICAgICAgICBsZXQgcG9zaXRpb24gPSBwYXJlbnQuZ2V0QmVzdE1hdGNoKHRoaXNbaV0se2JvcmRlcjppZ25vcmVCb3JkZXJ9KTtcblxuICAgICAgICByZXN1bHRzW2ldID0ge1xuICAgICAgICAgICAgcG9zaXRpb246IFtwb3NpdGlvblswXSArIHJlbGF0aXZlUG9zaXRpb25bMF0sIHBvc2l0aW9uWzFdICsgcmVsYXRpdmVQb3NpdGlvblsxXV0sXG4gICAgICAgICAgICBpbWFnZTogdGhpc1tpXVxuICAgICAgICB9O1xuICAgICAgICBpZiAobWF0Y2hUb1ByZXZpb3VzKSB7XG4gICAgICAgICAgICByZWxhdGl2ZVBvc2l0aW9uWzBdICs9IHBvc2l0aW9uWzBdO1xuICAgICAgICAgICAgcmVsYXRpdmVQb3NpdGlvblsxXSArPSBwb3NpdGlvblsxXTtcbiAgICAgICAgICAgIHBhcmVudCA9IHRoaXNbaV07XG4gICAgICAgIH1cblxuXG4gICAgfVxuICAgIC8vIG5vdyB3ZSBjYW4gY2FsY3VsYXRlIHRoZSBjcm9wcGluZyB0aGF0IHdlIG5lZWQgdG8gZG9cblxuICAgIGxldCBsZWZ0U2hpZnQgPSAwO1xuICAgIGxldCByaWdodFNoaWZ0ID0gMDtcbiAgICBsZXQgdG9wU2hpZnQgPSAwO1xuICAgIGxldCBib3R0b21TaGlmdCA9IDA7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlc3VsdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHJlc3VsdHNbaV07XG4gICAgICAgIGlmIChyZXN1bHQucG9zaXRpb25bMF0gPiBsZWZ0U2hpZnQpIGxlZnRTaGlmdCA9IHJlc3VsdC5wb3NpdGlvblswXTtcbiAgICAgICAgaWYgKHJlc3VsdC5wb3NpdGlvblswXSA8IHJpZ2h0U2hpZnQpIHJpZ2h0U2hpZnQgPSByZXN1bHQucG9zaXRpb25bMF07XG4gICAgICAgIGlmIChyZXN1bHQucG9zaXRpb25bMV0gPiB0b3BTaGlmdCkgdG9wU2hpZnQgPSByZXN1bHQucG9zaXRpb25bMV07XG4gICAgICAgIGlmIChyZXN1bHQucG9zaXRpb25bMV0gPCBib3R0b21TaGlmdCkgYm90dG9tU2hpZnQgPSByZXN1bHQucG9zaXRpb25bMV07XG4gICAgfVxuICAgIHJpZ2h0U2hpZnQgKj0gLTE7XG4gICAgYm90dG9tU2hpZnQgKj0gLTE7XG5cblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVzdWx0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgcmVzdWx0ID0gcmVzdWx0c1tpXTtcblxuICAgICAgICAvKlxuICAgICAgICBjb25zb2xlLmxvZyhcIkNST1BcIixcbiAgICAgICAgICAgIGxlZnRTaGlmdCAtIHJlc3VsdC5wb3NpdGlvblswXSxcbiAgICAgICAgICAgIHRvcFNoaWZ0IC0gcmVzdWx0LnBvc2l0aW9uWzFdLFxuICAgICAgICAgICAgcGFyZW50LndpZHRoIC0gcmlnaHRTaGlmdCAtIGxlZnRTaGlmdCxcbiAgICAgICAgICAgIHBhcmVudC5oZWlnaHQgLSBib3R0b21TaGlmdCAtIHRvcFNoaWZ0XG4gICAgICAgIClcbiAgICAgICAgKi9cblxuICAgICAgICByZXN1bHQuY3JvcCA9IHJlc3VsdC5pbWFnZS5jcm9wKHtcbiAgICAgICAgICAgIHg6IGxlZnRTaGlmdCAtIHJlc3VsdC5wb3NpdGlvblswXSxcbiAgICAgICAgICAgIHk6IHRvcFNoaWZ0IC0gcmVzdWx0LnBvc2l0aW9uWzFdLFxuICAgICAgICAgICAgd2lkdGg6cGFyZW50LndpZHRoIC0gcmlnaHRTaGlmdCAtIGxlZnRTaGlmdCxcbiAgICAgICAgICAgIGhlaWdodDpwYXJlbnQuaGVpZ2h0IC0gYm90dG9tU2hpZnQgLSB0b3BTaGlmdFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBmaW5hbGx5IHdlIGNyb3AgYW5kIGNyZWF0ZSBhIG5ldyBhcnJheSBvZiBpbWFnZXNcbiAgICBsZXQgbmV3SW1hZ2VzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZXN1bHRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIG5ld0ltYWdlc1tpXSA9IHJlc3VsdHNbaV0uY3JvcDtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFN0YWNrKG5ld0ltYWdlcyk7XG59XG4iLCJpbXBvcnQgU3RhY2sgZnJvbSAnLi4vc3RhY2snO1xuaW1wb3J0IEltYWdlIGZyb20gJy4uLy4uL2ltYWdlL2ltYWdlJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gYXZlcmFnZSh7fSA9IHt9KSB7XG4gICAgdGhpcy5jaGVja1Byb2Nlc3NhYmxlKCdhdmVyYWdlJywge1xuICAgICAgICBiaXREZXB0aDogWzgsIDE2XVxuICAgIH0pO1xuXG4gICAgbGV0IGRhdGEgPSBuZXcgVWludDMyQXJyYXkodGhpc1swXS5kYXRhLmxlbmd0aCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBjdXJyZW50ID0gdGhpc1tpXTtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB0aGlzWzBdLmRhdGEubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGRhdGFbal0gKz0gY3VycmVudC5kYXRhW2pdO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbGV0IGltYWdlID0gSW1hZ2UuY3JlYXRlRnJvbSh0aGlzWzBdKTtcbiAgICBsZXQgbmV3RGF0YSA9IGltYWdlLmRhdGE7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXNbMF0uZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICBuZXdEYXRhW2ldID0gZGF0YVtpXSAvIHRoaXMubGVuZ3RoO1xuICAgIH1cblxuICAgIHJldHVybiBpbWFnZTtcbn1cbiIsImltcG9ydCAqIGFzIE1vZGVsIGZyb20gJy4uL2ltYWdlL21vZGVsL21vZGVsJztcblxuXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVBcnJheU9mQ2hhbm5lbHMoaW1hZ2UsIHtcbiAgICBjaGFubmVscyxcbiAgICBhbGxvd0FscGhhLCAgLy8gYXJlIHdlIGFsbG93aW5nIHRoZSBzZWxlY3Rpb24gb2YgYW4gYWxwaGEgY2hhbm5lbCA/XG4gICAgZGVmYXVsdEFscGhhIC8vIGlmIG5vIGNoYW5uZWxzIGFyZSBzZWxlY3RlZCBzaG91bGQgd2UgdGFrZSB0aGUgYWxwaGEgY2hhbm5lbCA/XG4gICAgfSA9IHt9KSB7XG5cbiAgICBpZiAodHlwZW9mIGFsbG93QWxwaGEgIT09ICdib29sZWFuJykgYWxsb3dBbHBoYSA9IHRydWU7XG5cbiAgICBpZiAodHlwZW9mIGNoYW5uZWxzID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4gYWxsQ2hhbm5lbHMoaW1hZ2UsIGRlZmF1bHRBbHBoYSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHZhbGlkYXRlQ2hhbm5lbHMoaW1hZ2UsIGNoYW5uZWxzLCBhbGxvd0FscGhhKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGFsbENoYW5uZWxzKGltYWdlLCBkZWZhdWx0QWxwaGEpIHtcbiAgICBsZXQgbGVuZ3RoID0gZGVmYXVsdEFscGhhID8gaW1hZ2UuY2hhbm5lbHMgOiBpbWFnZS5jb21wb25lbnRzO1xuICAgIGxldCBhcnJheSA9IG5ldyBBcnJheShsZW5ndGgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYXJyYXlbaV0gPSBpO1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXk7XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlQ2hhbm5lbHMoaW1hZ2UsIGNoYW5uZWxzLCBhbGxvd0FscGhhKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGNoYW5uZWxzKSkgY2hhbm5lbHMgPSBbY2hhbm5lbHNdO1xuICAgIGZvciAobGV0IGMgPSAwOyBjIDwgY2hhbm5lbHMubGVuZ3RoOyBjKyspIHtcbiAgICAgICAgY2hhbm5lbHNbY10gPSB2YWxpZGF0ZUNoYW5uZWwoaW1hZ2UsY2hhbm5lbHNbY10sIGFsbG93QWxwaGEpO1xuICAgIH1cbiAgICByZXR1cm4gY2hhbm5lbHM7XG59XG5cblxuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlQ2hhbm5lbChpbWFnZSwgY2hhbm5lbCwgYWxsb3dBbHBoYSA9IHRydWUpIHtcbiAgICBpZiAoY2hhbm5lbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCd2YWxpZGF0ZUNoYW5uZWwgOiB0aGUgY2hhbm5lbCBoYXMgdG8gYmUgPj0wIGFuZCA8JyArIGltYWdlLmNoYW5uZWxzKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGNoYW5uZWwgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGlmICgncmdiJy5pbmRleE9mKGNoYW5uZWwpID4gLTEpIHtcbiAgICAgICAgICAgIGlmIChpbWFnZS5jb2xvck1vZGVsICE9PSBNb2RlbC5SR0IpIHRocm93IG5ldyBFcnJvcignZ2V0Q2hhbm5lbCA6IG5vdCBhIFJHQiBpbWFnZScpO1xuICAgICAgICAgICAgc3dpdGNoIChjaGFubmVsKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAncic6XG4gICAgICAgICAgICAgICAgICAgIGNoYW5uZWwgPSAwO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdnJzpcbiAgICAgICAgICAgICAgICAgICAgY2hhbm5lbCA9IDE7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2InOlxuICAgICAgICAgICAgICAgICAgICBjaGFubmVsID0gMjtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY2hhbm5lbCA9PT0gJ2EnKSB7XG4gICAgICAgICAgICBpZiAoIWltYWdlLmFscGhhKSB0aHJvdyBuZXcgRXJyb3IoJ3ZhbGlkYXRlQ2hhbm5lbCA6IHRoZSBpbWFnZSBkb2VzIG5vdCBjb250YWluIGFscGhhIGNoYW5uZWwnKTtcbiAgICAgICAgICAgIGNoYW5uZWwgPSBpbWFnZS5jb21wb25lbnRzO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBjaGFubmVsID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd2YWxpZGF0ZUNoYW5uZWwgOiB1bmRlZmluZWQgY2hhbm5lbDogJyArIGNoYW5uZWwpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNoYW5uZWwgPj0gaW1hZ2UuY2hhbm5lbHMpIHtcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3ZhbGlkYXRlQ2hhbm5lbCA6IHRoZSBjaGFubmVsIGhhcyB0byBiZSA+PTAgYW5kIDwnICsgaW1hZ2UuY2hhbm5lbHMpO1xuICAgIH1cblxuICAgIGlmICghYWxsb3dBbHBoYSAmJiBjaGFubmVsID49IGltYWdlLmNvbXBvbmVudHMpIHtcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3ZhbGlkYXRlQ2hhbm5lbCA6IGFscGhhIGNoYW5uZWwgbWF5IG5vdCBiZSBzZWxlY3RlZCcpO1xuICAgIH1cblxuICAgIHJldHVybiBjaGFubmVsO1xufVxuIiwiLyoqXG4gKiBDb252ZXJ0cyBhIGZhY3RvciB2YWx1ZSB0byBhIG51bWJlciBiZXR3ZWVuIDAgYW5kIDFcbiAqIEBwYXJhbSB2YWx1ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0RmFjdG9yKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgY29uc3QgbGFzdCA9IHZhbHVlW3ZhbHVlLmxlbmd0aCAtIDFdO1xuICAgICAgICB2YWx1ZSA9IHBhcnNlRmxvYXQodmFsdWUpO1xuICAgICAgICBpZiAobGFzdCA9PT0gJyUnKSB7XG4gICAgICAgICAgICB2YWx1ZSAvPSAxMDA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuXG4vKipcbiAqIFdlIGNhbiBzcGVjaWZ5IGEgdGhyZXNob2xkIGFzIFwiMC40XCIsIFwiNDAlXCIgb3IgMTIzXG4gKiBAcGFyYW0gdmFsdWVcbiAqIEBwYXJhbSBtYXhWYWx1ZVxuICogQHJldHVybnMgeyp9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRUaHJlc2hvbGQodmFsdWUsIG1heFZhbHVlKSB7XG4gICAgaWYgKCFtYXhWYWx1ZSkge1xuICAgICAgICB0aHJvdyBFcnJvcignZ2V0VGhyZXNob2xkIDogdGhlIG1heFZhbHVlIHNob3VsZCBiZSBzcGVjaWZpZWQnKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgbGV0IGxhc3QgPSB2YWx1ZVt2YWx1ZS5sZW5ndGggLSAxXTtcbiAgICAgICAgaWYgKGxhc3QgIT09ICclJykge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ2dldFRocmVzaG9sZCA6IGlmIHRoZSB2YWx1ZSBpcyBhIHN0cmluZyBpdCBtdXN0IGZpbmlzaCBieSAlJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhcnNlRmxvYXQodmFsdWUpIC8gMTAwICogbWF4VmFsdWU7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICAgIGlmICh2YWx1ZSA8IDEpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZSAqIG1heFZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBFcnJvcignZ2V0VGhyZXNob2xkIDogdGhlIHZhbHVlIGlzIG5vdCB2YWxpZCcpO1xuICAgIH1cbn1cblxuXG5cbmV4cG9ydCBmdW5jdGlvbiBmYWN0b3JEaW1lbnNpb25zKGZhY3Rvciwgd2lkdGgsIGhlaWdodCkge1xuICAgIGZhY3RvciA9IGdldEZhY3RvcihmYWN0b3IpO1xuICAgIHJldHVybiB7XG4gICAgICAgIHdpZHRoOiBNYXRoLnJvdW5kKGZhY3RvciAqIHdpZHRoKSxcbiAgICAgICAgaGVpZ2h0OiBNYXRoLnJvdW5kKGZhY3RvciAqIGhlaWdodClcbiAgICB9O1xufVxuIiwiZXhwb3J0IGZ1bmN0aW9uIG1lZGlhbihoaXN0b2dyYW0pIHtcbiAgICBsZXQgdG90YWwgPSBoaXN0b2dyYW0ucmVkdWNlKChzdW0sIHgpID0+IHN1bSArIHgpO1xuXG4gICAgaWYgKHRvdGFsIDw9IDApIHJldHVybiB1bmRlZmluZWQ7XG5cbiAgICBsZXQgcG9zaXRpb24gPSAwO1xuICAgIGxldCBjdXJyZW50VG90YWwgPSAwO1xuICAgIGxldCBtaWRkbGUgPSB0b3RhbCAvIDI7XG4gICAgbGV0IHByZXZpb3VzO1xuXG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgaWYgKGhpc3RvZ3JhbVtwb3NpdGlvbl0gPiAwKSB7XG4gICAgICAgICAgICBpZiAocHJldmlvdXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAocHJldmlvdXMgKyBwb3NpdGlvbikgLyAyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VycmVudFRvdGFsICs9IGhpc3RvZ3JhbVtwb3NpdGlvbl07XG4gICAgICAgICAgICBpZiAoY3VycmVudFRvdGFsID4gbWlkZGxlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBvc2l0aW9uO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjdXJyZW50VG90YWwgPT09IG1pZGRsZSkge1xuICAgICAgICAgICAgICAgIHByZXZpb3VzID0gcG9zaXRpb247XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcG9zaXRpb24rKztcbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtZWFuKGhpc3RvZ3JhbSkge1xuICAgIGxldCB0b3RhbCA9IDA7XG4gICAgbGV0IHN1bSA9IDA7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGhpc3RvZ3JhbS5sZW5ndGg7IGkrKykge1xuICAgICAgICB0b3RhbCArPSBoaXN0b2dyYW1baV07XG4gICAgICAgIHN1bSArPSBoaXN0b2dyYW1baV0gKiBpO1xuICAgIH1cblxuICAgIGlmICh0b3RhbCA8PSAwKSByZXR1cm4gdW5kZWZpbmVkO1xuXG4gICAgcmV0dXJuIHN1bSAvIHRvdGFsO1xufVxuXG4iLCJpbXBvcnQgaXNJbnRlZ2VyIGZyb20gJ2lzLWludGVnZXInO1xuXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVLZXJuZWwoa2VybmVsKSB7XG4gICAgbGV0IGtIZWlnaHQsIGtXaWR0aDtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShrZXJuZWwpKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGtlcm5lbFswXSkpIHsgLy8gMkQgYXJyYXlcbiAgICAgICAgICAgIGlmICgoKGtlcm5lbC5sZW5ndGggJiAxKSA9PT0gMCkgfHwgKChrZXJuZWxbMF0ubGVuZ3RoICYgMSkgPT09IDApKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCd2YWxpZGF0ZUtlcm5lbDogS2VybmVsIHJvd3MgYW5kIGNvbHVtbnMgc2hvdWxkIGJlIG9kZCBudW1iZXJzJyk7XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBrSGVpZ2h0ID0gTWF0aC5mbG9vcihrZXJuZWwubGVuZ3RoIC8gMik7XG4gICAgICAgICAgICAgICAga1dpZHRoID0gTWF0aC5mbG9vcihrZXJuZWxbMF0ubGVuZ3RoIC8gMik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZXQga2VybmVsV2lkdGggPSBNYXRoLnNxcnQoa2VybmVsLmxlbmd0aCk7XG4gICAgICAgICAgICBpZiAoaXNJbnRlZ2VyKGtlcm5lbFdpZHRoKSkge1xuICAgICAgICAgICAgICAgIGtXaWR0aCA9IGtIZWlnaHQgPSBNYXRoLmZsb29yKE1hdGguc3FydChrZXJuZWwubGVuZ3RoKSAvIDIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigndmFsaWRhdGVLZXJuZWw6IEtlcm5lbCBhcnJheSBzaG91bGQgYmUgYSBzcXVhcmUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHdlIGNvbnZlcnQgdGhlIGFycmF5IHRvIGEgbWF0cml4XG4gICAgICAgICAgICBsZXQgbmV3S2VybmVsID0gbmV3IEFycmF5KGtXaWR0aCk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtlcm5lbFdpZHRoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBuZXdLZXJuZWxbaV0gPSBuZXcgQXJyYXkoa2VybmVsV2lkdGgpO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwga2VybmVsV2lkdGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBuZXdLZXJuZWxbaV1bal0gPSBrZXJuZWxbaSAqIGtlcm5lbFdpZHRoICsgal07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAga2VybmVsID0gbmV3S2VybmVsO1xuXG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3ZhbGlkYXRlS2VybmVsOiBJbnZhbGlkIEtlcm5lbDogJyArIGtlcm5lbCk7XG4gICAgfVxuICAgIHJldHVybiB7a2VybmVsLCBrV2lkdGgsIGtIZWlnaHR9O1xufVxuIiwiZXhwb3J0IGNvbnN0IERJU0NSRVRFX0xBUExBQ0VfNCA9IFtcbiAgICBbMCwgIDEsIDBdLFxuICAgIFsxLCAtNCwgMV0sXG4gICAgWzAsICAxLCAwXVxuXTtcblxuZXhwb3J0IGNvbnN0IERJU0NSRVRFX0xBUExBQ0VfOCA9IFtcbiAgICBbMSwgIDEsIDFdLFxuICAgIFsxLCAtOCwgMV0sXG4gICAgWzEsICAxLCAxXVxuXTtcblxuZXhwb3J0IGNvbnN0IEdSQURJRU5UX1ggPSBbXG4gICAgWy0xLCAwLCArMV0sXG4gICAgWy0yLCAwLCArMl0sXG4gICAgWy0xLCAwLCArMV1cbl07XG5cbmV4cG9ydCBjb25zdCBHUkFESUVOVF9ZID0gW1xuICAgIFstMSwgLTIsIC0xXSxcbiAgICBbIDAsICAwLCAgMF0sXG4gICAgWysxLCArMiwgKzFdXG5dO1xuXG5leHBvcnQgY29uc3QgU0VDT05EX0RFUklWQVRJVkUgPSBbXG4gICAgWy0xLCAtMiwgIDAsICAyLCAgMV0sXG4gICAgWy0yLCAtNCwgIDAsICA0LCAgMl0sXG4gICAgWyAwLCAgMCwgIDAsICAwLCAgMF0sXG4gICAgWyAxLCAgMiwgIDAsIC0yLCAtMV0sXG4gICAgWyAyLCAgNCwgIDAsIC00LCAtMl1cbl07XG5cbmV4cG9ydCBjb25zdCBTRUNPTkRfREVSSVZBVElWRV9JTlYgPSBbXG4gICAgWyAxLCAgMiwgIDAsIC0yLCAtMV0sXG4gICAgWyAyLCAgNCwgIDAsIC00LCAtMl0sXG4gICAgWyAwLCAgMCwgIDAsICAwLCAgMF0sXG4gICAgWy0yLCAtNCwgIDAsICA0LCAgMl0sXG4gICAgWy0xLCAtMiwgIDAsICAyLCAgMV1cbl07XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBNYXRyaXgod2lkdGgsIGhlaWdodCwgZGVmYXVsdFZhbHVlKSB7XG4gICAgY29uc3QgbWF0cml4ID0gbmV3IEFycmF5KHdpZHRoKTtcbiAgICBmb3IgKGxldCB4ID0gMDsgeCA8IHdpZHRoOyB4KyspIHtcbiAgICAgICAgbWF0cml4W3hdID0gbmV3IEFycmF5KGhlaWdodCk7XG4gICAgfVxuICAgIGlmIChkZWZhdWx0VmFsdWUpIHtcbiAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCB3aWR0aDsgeCsrKSB7XG4gICAgICAgICAgICBmb3IgKGxldCB5ID0gMDsgeSA8IGhlaWdodDsgeSsrKSB7XG4gICAgICAgICAgICAgICAgbWF0cml4W3hdW3ldID0gZGVmYXVsdFZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIG1hdHJpeC53aWR0aCA9IHdpZHRoO1xuICAgIG1hdHJpeC5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgbWF0cml4Ll9fcHJvdG9fXyA9IE1hdHJpeC5wcm90b3R5cGU7XG4gICAgcmV0dXJuIG1hdHJpeDtcbn1cblxuTWF0cml4LnByb3RvdHlwZS5sb2NhbE1pbiA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgbGV0IG1pbiA9IHRoaXNbeF1beV07XG4gICAgbGV0IHBvc2l0aW9uID0gW3gsIHldO1xuICAgIGZvciAobGV0IGkgPSAoTWF0aC5tYXgoMCwgeCAtIDEpKTsgaSA8IE1hdGgubWluKHRoaXMubGVuZ3RoLCB4ICsgMik7IGkrKykge1xuICAgICAgICBmb3IgKGxldCBqID0gKE1hdGgubWF4KDAsIHkgLSAxKSk7IGogPCBNYXRoLm1pbih0aGlzWzBdLmxlbmd0aCwgeSArIDIpOyBqKyspIHtcbiAgICAgICAgICAgIGlmICh0aGlzW2ldW2pdIDwgbWluKSB7XG4gICAgICAgICAgICAgICAgbWluID0gdGhpc1tpXVtqXTtcbiAgICAgICAgICAgICAgICBwb3NpdGlvbiA9IFtpLCBqXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBwb3NpdGlvbjogcG9zaXRpb24sXG4gICAgICAgIHZhbHVlOiBtaW5cbiAgICB9O1xufTtcblxuTWF0cml4LnByb3RvdHlwZS5sb2NhbE1heCA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgbGV0IG1heCA9IHRoaXNbeF1beV07XG4gICAgbGV0IHBvc2l0aW9uID0gW3gsIHldO1xuICAgIGZvciAobGV0IGkgPSAoTWF0aC5tYXgoMCwgeCAtIDEpKTsgaSA8IE1hdGgubWluKHRoaXMubGVuZ3RoLCB4ICsgMik7IGkrKykge1xuICAgICAgICBmb3IgKGxldCBqID0gKE1hdGgubWF4KDAsIHkgLSAxKSk7IGogPCBNYXRoLm1pbih0aGlzWzBdLmxlbmd0aCwgeSArIDIpOyBqKyspIHtcbiAgICAgICAgICAgIGlmICh0aGlzW2ldW2pdID4gbWF4KSB7XG4gICAgICAgICAgICAgICAgbWF4ID0gdGhpc1tpXVtqXTtcbiAgICAgICAgICAgICAgICBwb3NpdGlvbiA9IFtpLCBqXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBwb3NpdGlvbjogcG9zaXRpb24sXG4gICAgICAgIHZhbHVlOiBtYXhcbiAgICB9O1xufTtcblxuTWF0cml4LnByb3RvdHlwZS5sb2NhbFNlYXJjaCA9IGZ1bmN0aW9uICh4LCB5LCB2YWx1ZSkge1xuICAgIGxldCByZXN1bHRzID0gW107XG4gICAgZm9yIChsZXQgaSA9IChNYXRoLm1heCgwLCB4IC0gMSkpOyBpIDwgTWF0aC5taW4odGhpcy5sZW5ndGgsIHggKyAyKTsgaSsrKSB7XG4gICAgICAgIGZvciAobGV0IGogPSAoTWF0aC5tYXgoMCwgeSAtIDEpKTsgaiA8IE1hdGgubWluKHRoaXNbMF0ubGVuZ3RoLCB5ICsgMik7IGorKykge1xuICAgICAgICAgICAgaWYgKHRoaXNbaV1bal0gPT09IHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKFtpLCBqXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdHM7XG59O1xuIiwibGV0IE1hdHJpeCA9IHJlcXVpcmUoJ21sLW1hdHJpeCcpO1xuXG5cbmxldCBjcm9zcyA9IFtcbiAgICBbMCwwLDEsMCwwXSxcbiAgICBbMCwwLDEsMCwwXSxcbiAgICBbMSwxLDEsMSwxXSxcbiAgICBbMCwwLDEsMCwwXSxcbiAgICBbMCwwLDEsMCwwXVxuXTtcblxubGV0IHNtYWxsQ3Jvc3MgPSBbXG4gICAgWzAsMSwwXSxcbiAgICBbMSwxLDFdLFxuICAgIFswLDEsMF1cbl07XG5cblxuXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNoYXBlIHtcbiAgICBjb25zdHJ1Y3Rvcih7a2luZCA9ICdjcm9zcycsIHNoYXBlLCBzaXplLCB3aWR0aCwgaGVpZ2h0LCBmaWxsZWR9ID0ge30pIHtcbiAgICAgICAgaWYgKHNoYXBlKSBraW5kID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAoc2l6ZSkge1xuICAgICAgICAgICAgd2lkdGggPSBzaXplO1xuICAgICAgICAgICAgaGVpZ2h0ID0gc2l6ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKHdpZHRoICYmIDEgIT09IDEpIHx8IChoZWlnaHQgJiYgMSAhPT0gMSkpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKCdTaGFwZTogVGhlIHdpZHRoIGFuZCBoZWlnaHQgaGFzIHRvIGJlIG9kZCBudW1iZXJzLicpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChraW5kKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKGtpbmQpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdjcm9zcyc6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWF0cml4ID0gY3Jvc3M7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3NtYWxsQ3Jvc3MnOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLm1hdHJpeCA9IHNtYWxsQ3Jvc3M7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5oZWlnaHQgPSB0aGlzLm1hdHJpeC5sZW5ndGg7XG4gICAgICAgICAgICB0aGlzLndpZHRoID0gdGhpcy5tYXRyaXhbMF0ubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKCh0aGlzLmhlaWdodCAmIDEgPT09IDApIHx8ICh0aGlzLndpZHRoICYgMSA9PT0gMCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NoYXBlcyBtdXN0IGhhdmUgYW4gb2RkIGhlaWdodCBhbmQgd2lkdGgnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN3aXRjaCAoc2hhcGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdzcXVhcmUnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ3JlY3RhbmdsZSc6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWF0cml4ID0gcmVjdGFuZ2xlKHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdjaXJjbGUnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2VsbGlwc2UnOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLm1hdHJpeCA9IGVsbGlwc2Uod2lkdGgsIGhlaWdodCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3RyaWFuZ2xlJzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXRyaXggPSB0cmlhbmdsZSh3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcblxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cblxuICAgICAgICB0aGlzLmhhbGZIZWlnaHQgPSAodGhpcy5oZWlnaHQgLyAyKSA+PiAwO1xuICAgICAgICB0aGlzLmhhbGZXaWR0aCA9ICh0aGlzLndpZHRoIC8gMikgPj4gMDtcbiAgICB9XG59XG5cblNoYXBlLnByb3RvdHlwZS5nZXRQaXhlbHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgbGV0IG1hdHJpeCA9IHRoaXMubWF0cml4O1xuICAgIGxldCBwaXhlbHMgPSBuZXcgQXJyYXkobWF0cml4LnNpemUpO1xuICAgIGxldCBwb3NpdGlvbiA9IDA7XG4gICAgZm9yIChsZXQgeSA9IDA7IHkgPCBtYXRyaXgubGVuZ3RoOyB5KyspIHtcbiAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCBtYXRyaXhbMF0ubGVuZ3RoOyB4KyspIHtcbiAgICAgICAgICAgIGlmIChtYXRyaXhbeV1beF0pIHtcbiAgICAgICAgICAgICAgICBwaXhlbHNbcG9zaXRpb24rK10gPSBbeCAtIHRoaXMuaGFsZldpZHRoLCB5IC0gdGhpcy5oYWxmSGVpZ2h0XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcGl4ZWxzO1xufTtcblxuXG5cbmZ1bmN0aW9uIHJlY3RhbmdsZSh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgbGV0IG1hdHJpeCA9IE1hdHJpeC56ZXJvcyhoZWlnaHQsIHdpZHRoKTtcbiAgICBmb3IgKGxldCB5ID0gMDsgeSA8IGhlaWdodDsgeSsrKSB7XG4gICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgd2lkdGg7IHgrKykge1xuICAgICAgICAgICAgbWF0cml4W3ldW3hdID0gMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWF0cml4O1xufVxuXG5mdW5jdGlvbiBlbGxpcHNlKHdpZHRoLCBoZWlnaHQpIHtcbiAgICBsZXQgbWF0cml4ID0gTWF0cml4Lnplcm9zKGhlaWdodCwgd2lkdGgpO1xuICAgIGxldCBhID0gTWF0aC5mbG9vcih3aWR0aCAvIDIpO1xuICAgIGxldCBiID0gTWF0aC5mbG9vcihoZWlnaHQgLyAyKTtcbiAgICBmb3IgKGxldCB5ID0gMDsgeSA8IGhlaWdodDsgeSsrKSB7XG4gICAgICAgIGxldCB5cCA9IE1hdGguZmxvb3IoeSAvIDIpO1xuICAgICAgICBsZXQgc2hpZnQgPSBNYXRoLmZsb29yKHdpZHRoIC8gMiAtIE1hdGguc3FydCgoYSAqIGEgKiBiICogYiAtIGEgKiBhICogeXAgKiB5cCkgLyBiICogYikpO1xuICAgICAgICBmb3IgKGxldCB4ID0gc2hpZnQ7IHggPCAod2lkdGggLSBzaGlmdCk7IHgrKykge1xuICAgICAgICAgICAgbWF0cml4W3ldW3hdID0gMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWF0cml4O1xufVxuXG5mdW5jdGlvbiB0cmlhbmdsZSh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgbGV0IG1hdHJpeCA9IE1hdHJpeC56ZXJvcyhoZWlnaHQsIHdpZHRoKTtcbiAgICBmb3IgKGxldCB5ID0gMDsgeSA8IGhlaWdodDsgeSsrKSB7XG4gICAgICAgIGxldCBzaGlmdCA9IE1hdGguZmxvb3IoKDEgLSB5IC8gaGVpZ2h0KSAqIHdpZHRoIC8gMik7XG4gICAgICAgIGZvciAobGV0IHggPSBzaGlmdDsgeCA8ICh3aWR0aCAtIHNoaWZ0KTsgeCsrKSB7XG4gICAgICAgICAgICBtYXRyaXhbeV1beF0gPSAxO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtYXRyaXg7XG59XG4iLCJpbXBvcnQgSW1hZ2UgZnJvbSAnLi4vaW1hZ2UvaW1hZ2UnO1xuaW1wb3J0IGlzQXJyYXkgZnJvbSAnaXMtYXJyYXktdHlwZSc7XG5cbmV4cG9ydCBmdW5jdGlvbiBjaGVja051bWJlckFycmF5KHZhbHVlKSB7XG4gICAgaWYgKCFpc05hTih2YWx1ZSkpIHtcbiAgICAgICAgaWYgKHZhbHVlIDw9IDApIHRocm93IG5ldyBFcnJvcignY2hlY2tOdW1iZXJBcnJheTogdGhlIHZhbHVlIG11c3QgYmUgZ3JlYXRlciB0aGFuIDAnKTtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEltYWdlKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUuZGF0YTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NoZWNrTnVtYmVyQXJyYXk6IHRoZSB2YWx1ZSBzaG91bGQgYmUgZWl0aGVyIGEgbnVtYmVyLCBhcnJheSBvciBJbWFnZScpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG59XG5cbiIsImltcG9ydCBiYWNrZ3JvdW5kIGZyb20gJy4vcHJvY2Vzcy9iYWNrZ3JvdW5kJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZXh0ZW5kKFdvcmtlcikge1xuICAgIFdvcmtlci5leHRlbmRNZXRob2QoJ2JhY2tncm91bmQnLCBiYWNrZ3JvdW5kKTtcbn1cbiIsImltcG9ydCBleHRlbmQgZnJvbSAnZXh0ZW5kJztcbmltcG9ydCBJbWFnZSBmcm9tICcuLi8uLi9pbWFnZS9pbWFnZSc7XG5cbmNvbnN0IGRlZmF1bHRPcHRpb25zID0ge1xuICAgIHJlZ3Jlc3Npb246IHtcbiAgICAgICAga2VybmVsVHlwZTogJ3BvbHlub21pYWwnLFxuICAgICAgICBrZXJuZWxPcHRpb25zOiB7ZGVncmVlOiAyLCBjb25zdGFudDogMX1cbiAgICB9LFxuICAgIHRocmVzaG9sZDogMC4wMixcbiAgICByb2k6IHtcbiAgICAgICAgbWluU3VyZmFjZTogMTAwLFxuICAgICAgICBwb3NpdGl2ZTogZmFsc2VcbiAgICB9LFxuICAgIHNhbXBsaW5nOiAyMCxcbiAgICBpbmNsdWRlOiBbXVxufTtcblxuZnVuY3Rpb24gcnVuKGltYWdlLCBvcHRpb25zLCBvblN0ZXApIHtcbiAgICBvcHRpb25zID0gZXh0ZW5kKHt9LCBkZWZhdWx0T3B0aW9ucywgb3B0aW9ucyk7XG4gICAgY29uc3QgbWFuYWdlciA9IHRoaXMubWFuYWdlcjtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShpbWFnZSkpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKGltYWdlLm1hcChmdW5jdGlvbiAoaW1nKSB7XG4gICAgICAgICAgICBjb25zdCBydW4gPSBydW5PbmNlKG1hbmFnZXIsIGltZywgb3B0aW9ucyk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9uU3RlcCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHJ1bi50aGVuKG9uU3RlcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcnVuO1xuICAgICAgICB9KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHJ1bk9uY2UobWFuYWdlciwgaW1hZ2UsIG9wdGlvbnMpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gcnVuT25jZShtYW5hZ2VyLCBpbWFnZSwgb3B0aW9ucykge1xuICAgIHJldHVybiBtYW5hZ2VyLnBvc3QoJ2RhdGEnLCBbaW1hZ2UsIG9wdGlvbnNdKS50aGVuKGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgICBmb3IgKGxldCBpIGluIHJlc3BvbnNlKSB7XG4gICAgICAgICAgICByZXNwb25zZVtpXSA9IG5ldyBJbWFnZShyZXNwb25zZVtpXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH0pO1xufVxuXG5mdW5jdGlvbiB3b3JrKCkge1xuICAgIHdvcmtlci5vbignZGF0YScsIGZ1bmN0aW9uIChzZW5kLCBpbWFnZSwgb3B0aW9ucykge1xuICAgICAgICBpbWFnZSA9IG5ldyBJSlMoaW1hZ2UpO1xuICAgICAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICAgICAgY29uc3QgdG9UcmFuc2ZlciA9IFtdO1xuXG4gICAgICAgIGNvbnN0IGdyZXkgPSBpbWFnZS5ncmV5KCk7XG5cbiAgICAgICAgY29uc3Qgc29iZWwgPSBncmV5LnNvYmVsRmlsdGVyKCk7XG4gICAgICAgIG1heWJlSW5jbHVkZSgnc29iZWwnLCBzb2JlbCk7XG5cbiAgICAgICAgY29uc3QgbWFzayA9IHNvYmVsLmxldmVsKCkubWFzayh7dGhyZXNob2xkOiBvcHRpb25zLnRocmVzaG9sZH0pO1xuICAgICAgICBtYXliZUluY2x1ZGUoJ21hc2snLCBtYXNrKTtcblxuICAgICAgICBjb25zdCByb2lNYW5hZ2VyID0gc29iZWwuZ2V0Uk9JTWFuYWdlcigpO1xuICAgICAgICByb2lNYW5hZ2VyLnB1dE1hc2sobWFzayk7XG4gICAgICAgIGNvbnN0IHJlYWxNYXNrID0gcm9pTWFuYWdlci5nZXRNYXNrKG9wdGlvbnMucm9pKTtcbiAgICAgICAgbWF5YmVJbmNsdWRlKCdyZWFsTWFzaycsIHJlYWxNYXNrKTtcblxuICAgICAgICBjb25zdCBwaXhlbHMgPSBncmV5LmdldFBpeGVsc0dyaWQoe1xuICAgICAgICAgICAgc2FtcGxpbmc6IG9wdGlvbnMuc2FtcGxpbmcsXG4gICAgICAgICAgICBtYXNrOiByZWFsTWFza1xuICAgICAgICB9KTtcblxuICAgICAgICBjb25zdCBiYWNrZ3JvdW5kID0gaW1hZ2UuZ2V0QmFja2dyb3VuZChwaXhlbHMueHlTLCBwaXhlbHMuelMsIG9wdGlvbnMucmVncmVzc2lvbik7XG4gICAgICAgIG1heWJlSW5jbHVkZSgnYmFja2dyb3VuZCcsIGJhY2tncm91bmQpO1xuXG4gICAgICAgIGNvbnN0IGNvcnJlY3RlZCA9IGltYWdlLnN1YnRyYWN0KGJhY2tncm91bmQpO1xuXG4gICAgICAgIHJlc3VsdC5yZXN1bHQgPSBjb3JyZWN0ZWQ7XG4gICAgICAgIHRvVHJhbnNmZXIucHVzaChjb3JyZWN0ZWQuZGF0YS5idWZmZXIpO1xuICAgICAgICBzZW5kKHJlc3VsdCwgdG9UcmFuc2Zlcik7XG5cbiAgICAgICAgZnVuY3Rpb24gbWF5YmVJbmNsdWRlKG5hbWUsIGltYWdlKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5pbmNsdWRlLmluZGV4T2YobmFtZSkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0W25hbWVdID0gaW1hZ2U7XG4gICAgICAgICAgICAgICAgdG9UcmFuc2Zlci5wdXNoKGltYWdlLmRhdGEuYnVmZmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xufVxuXG5leHBvcnQgZGVmYXVsdCB7cnVuLCB3b3JrfTtcbiIsImltcG9ydCBXb3JrZXJNYW5hZ2VyIGZyb20gJ3dlYi13b3JrZXItbWFuYWdlcic7XG5pbXBvcnQgSW1hZ2UgZnJvbSAnLi4vaW1hZ2UvaW1hZ2UnO1xuaW1wb3J0IGV4dGVuZCBmcm9tICcuL2V4dGVuZCc7XG5cbmNsYXNzIFdvcmtlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuX3VybCA9IG51bGw7XG4gICAgICAgIHRoaXMuX2RlcHMgPSBbbnVsbF07XG4gICAgfVxuICAgIGNoZWNrVXJsKCkge1xuICAgICAgICBpZiAodGhpcy5fdXJsID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ltYWdlIHdvcmtlciBtdXN0IGJlIGluaXRpYWxpemVkIHdpdGggYW4gVVJMJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IHVybCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3VybDtcbiAgICB9XG4gICAgc2V0IHVybCh2YWx1ZSkge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignd29ya2VyIFVSTCBtdXN0IGJlIGEgc3RyaW5nJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fdXJsID0gdmFsdWU7XG4gICAgICAgIHRoaXMuX2RlcHNbMF0gPSB2YWx1ZTtcbiAgICB9XG4gICAgc3RhdGljIGV4dGVuZE1ldGhvZChuYW1lLCBtZXRob2QpIHtcbiAgICAgICAgbGV0IG1hbmFnZXI7XG4gICAgICAgIGxldCB1cmw7XG4gICAgICAgIGxldCBydW5uZXIgPSB7fTtcbiAgICAgICAgZnVuY3Rpb24gcnVuKC4uLmFyZ3MpIHtcbiAgICAgICAgICAgIGlmICghbWFuYWdlcikge1xuICAgICAgICAgICAgICAgIHRoaXMuY2hlY2tVcmwoKTtcbiAgICAgICAgICAgICAgICB1cmwgPSB0aGlzLnVybDtcbiAgICAgICAgICAgICAgICBtYW5hZ2VyID0gbmV3IFdvcmtlck1hbmFnZXIobWV0aG9kLndvcmssIHtkZXBzOiB1cmx9KTtcbiAgICAgICAgICAgICAgICBydW5uZXIubWFuYWdlciA9IG1hbmFnZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWV0aG9kLnJ1bi5jYWxsKHJ1bm5lciwgLi4uYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgcnVuLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKG1hbmFnZXIpIHtcbiAgICAgICAgICAgICAgICBtYW5hZ2VyLnRlcm1pbmF0ZSgpO1xuICAgICAgICAgICAgICAgIG1hbmFnZXIgPSBuZXcgV29ya2VyTWFuYWdlcihtZXRob2Qud29yaywge2RlcHM6IHVybH0pO1xuICAgICAgICAgICAgICAgIHJ1bm5lci5tYW5hZ2VyID0gbWFuYWdlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgV29ya2VyLnByb3RvdHlwZVtuYW1lXSA9IHJ1bjtcbiAgICB9XG59XG5cbmV4dGVuZChXb3JrZXIpO1xuXG5leHBvcnQgZGVmYXVsdCBuZXcgV29ya2VyKCk7XG4iLCIndXNlIHN0cmljdCc7XG5cbmltcG9ydCBJbWFnZSBmcm9tICcuLi8uLi9zcmMnO1xuaW1wb3J0IHtpbWFnZUxpc3QsIGdldEhhc2h9IGZyb20gJy4uL3Rlc3QnO1xuXG53aW5kb3cuaW1hZ2VzID0gaW1hZ2VMaXN0O1xud2luZG93LmdldEhhc2ggPSBnZXRIYXNoO1xuXG5sZXQgcm9vdCA9ICcuLi9pbWcvJztcblxud2luZG93LmxvYWQgPSBmdW5jdGlvbiBsb2FkKG5hbWUpIHtcbiAgICByZXR1cm4gSW1hZ2UubG9hZChyb290ICsgbmFtZSk7XG59O1xuXG52YXIgbGVmdCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdsZWZ0Jyk7XG53aW5kb3cuc2V0TGVmdCA9IGZ1bmN0aW9uIHNldExlZnQoaW1nKSB7XG4gICAgbGVmdC5pbm5lckhUTUwgPSAnJztcbiAgICBsZWZ0LmFwcGVuZENoaWxkKGltZy5nZXRDYW52YXMoKSk7XG59O1xuXG52YXIgcmlnaHQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncmlnaHQnKTtcbndpbmRvdy5zZXRSaWdodCA9IGZ1bmN0aW9uIHNldFJpZ2h0KGltZykge1xuICAgIHJpZ2h0LmlubmVySFRNTCA9ICcnO1xuICAgIHJpZ2h0LmFwcGVuZENoaWxkKGltZy5nZXRDYW52YXMoKSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEltYWdlO1xuIiwibW9kdWxlLmV4cG9ydHM9W1xuICBcIkJXMTF4MTEucG5nXCIsXG4gIFwiQlcxNXgxNS5wbmdcIixcbiAgXCJCVzE1eDE1bm90VHJhbnNwYXJlbnQucG5nXCIsXG4gIFwiQlcxNXgxNXRyYW5zcGFyZW50LnBuZ1wiLFxuICBcIkJXMngyLnBuZ1wiLFxuICBcIkJXM3gzLnBuZ1wiLFxuICBcIkJXNHg0LnBuZ1wiLFxuICBcIkJXNXg1LnBuZ1wiLFxuICBcIkJXN3g3LnBuZ1wiLFxuICBcIkJXR3JpZDV4NS5wbmdcIixcbiAgXCJDb2xvckdyaWQ1eDUucG5nXCIsXG4gIFwiY2F0LWJsdXIuanBnXCIsXG4gIFwiY2F0LXNtYWxsLnBuZ1wiLFxuICBcImNhdC5qcGdcIixcbiAgXCJjZWxscy9jZWxscy5qcGdcIixcbiAgXCJjZWxscy9jb21wbGV4Q2VsbHMucG5nXCIsXG4gIFwiY2VsbHMvZWNvbGkucG5nXCIsXG4gIFwiY2VsbHMvaXNvbGF0ZUNlbGxzLnBuZ1wiLFxuICBcImZvcm1hdC9ncmV5MTYucG5nXCIsXG4gIFwiZm9ybWF0L2dyZXk4LnBuZ1wiLFxuICBcImZvcm1hdC9ncmV5YTE2LnBuZ1wiLFxuICBcImZvcm1hdC9ncmV5YTMyLnBuZ1wiLFxuICBcImZvcm1hdC9yZ2IyNC5wbmdcIixcbiAgXCJmb3JtYXQvcmdiNDgucG5nXCIsXG4gIFwiZm9ybWF0L3JnYmEzMi5wbmdcIixcbiAgXCJmb3JtYXQvcmdiYTY0LnBuZ1wiLFxuICBcImdyZXkxNi5wbmdcIixcbiAgXCJncmV5OC5wbmdcIixcbiAgXCJtb29uL2Nyb3AvQmxvb2RNb29uVGVzdC0xLnBuZ1wiLFxuICBcIm1vb24vY3JvcC9CbG9vZE1vb25UZXN0LTIucG5nXCIsXG4gIFwibW9vbi9jcm9wL0Jsb29kTW9vblRlc3QtMy5wbmdcIixcbiAgXCJtb29uL2Nyb3AvQmxvb2RNb29uVGVzdC00LnBuZ1wiLFxuICBcIm1vb24vY3JvcC9CbG9vZE1vb25UZXN0LTUucG5nXCIsXG4gIFwibW9vbi9jcm9wL0Jsb29kTW9vblRlc3QtNi5wbmdcIixcbiAgXCJtb29uL2Nyb3AvQmxvb2RNb29uVGVzdC03LnBuZ1wiLFxuICBcIm1vb24vY3JvcC9CbG9vZE1vb25UZXN0LTgucG5nXCIsXG4gIFwibW9vbi9ub2Nyb3AvQmxvb2RNb29uVGVzdC0xLnBuZ1wiLFxuICBcIm1vb24vbm9jcm9wL0Jsb29kTW9vblRlc3QtMi5wbmdcIixcbiAgXCJtb29uL25vY3JvcC9CbG9vZE1vb25UZXN0LTMucG5nXCIsXG4gIFwibW9vbi9ub2Nyb3AvQmxvb2RNb29uVGVzdC00LnBuZ1wiLFxuICBcIm1vb24vbm9jcm9wL0Jsb29kTW9vblRlc3QtNS5wbmdcIixcbiAgXCJtb29uL25vY3JvcC9CbG9vZE1vb25UZXN0LTYucG5nXCIsXG4gIFwibW9vbi9ub2Nyb3AvQmxvb2RNb29uVGVzdC03LnBuZ1wiLFxuICBcIm1vb24vbm9jcm9wL0Jsb29kTW9vblRlc3QtOC5wbmdcIixcbiAgXCJyZXNpemUvNXg1YV8xLnBuZ1wiLFxuICBcInJlc2l6ZS81eDVhXzEwLnBuZ1wiLFxuICBcInJlc2l6ZS81eDVhXzEzLnBuZ1wiLFxuICBcInJlc2l6ZS81eDVhXzE4LnBuZ1wiLFxuICBcInJlc2l6ZS81eDVhXzIucG5nXCIsXG4gIFwicmVzaXplLzV4NWFfMy5wbmdcIixcbiAgXCJyZXNpemUvNXg1YV80LnBuZ1wiLFxuICBcInJlc2l6ZS81eDVhXzUucG5nXCIsXG4gIFwicmdiMjRiaXRzLnBuZ1wiLFxuICBcInJnYjMyYml0cy5wbmdcIixcbiAgXCJyZ2I0OGJpdHMucG5nXCIsXG4gIFwicmdiOGJpdHMucG5nXCIsXG4gIFwieHRjLmpwZ1wiXG5dIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKTtcbnZhciBTSEEyNTYgPSByZXF1aXJlKCdzaGEuanMnKS5zaGEyNTY7XG5cbmV4cG9ydHMuaW1hZ2VMaXN0ID0gcmVxdWlyZSgnLi9pbWdMaXN0Lmpzb24nKTtcblxuZXhwb3J0cy5nZXRJbWFnZSA9IGZ1bmN0aW9uIGdldEltYWdlKG5hbWUpIHtcbiAgICByZXR1cm4gcGF0aC5yZXNvbHZlKF9fZGlybmFtZSwgJ2ltZycsIG5hbWUpO1xufTtcblxuZXhwb3J0cy5nZXRIYXNoID0gZnVuY3Rpb24gZ2V0SGFzaChpbWcpIHtcbiAgICBpZiAoIWltZy5sZW5ndGgpIHtcbiAgICAgICAgaW1nID0gaW1nLmRhdGE7XG4gICAgfVxuICAgIHZhciBzaGEgPSBuZXcgU0hBMjU2KCk7XG4gICAgc2hhLnVwZGF0ZShpbWcpO1xuICAgIHJldHVybiBzaGEuZGlnZXN0KCdoZXgnKTtcbn07XG4iXX0=
